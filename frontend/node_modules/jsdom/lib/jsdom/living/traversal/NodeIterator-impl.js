"use strict";
const { hasWeakRefs ***REMOVED*** = require("../../utils");
const { domSymbolTree ***REMOVED*** = require("../helpers/internal-constants");
const { filter, FILTER_ACCEPT ***REMOVED*** = require("./helpers");

exports.implementation = class NodeIteratorImpl {
  constructor(globalObject, args, privateData) {
    this._active = false;
    this.root = privateData.root;
    this.whatToShow = privateData.whatToShow;
    this.filter = privateData.filter;

    this._referenceNode = this.root;
    this._pointerBeforeReferenceNode = true;

    // This is used to deactivate the NodeIterator if there are too many working in a Document at the same time.
    // Without weak references, a JS implementation of NodeIterator will leak, since we can't know when to clean it up.
    // This ensures we force a clean up of those beyond some maximum (specified by the Document).
    if (!hasWeakRefs) {
      this._working = true;
    ***REMOVED***

    this._globalObject = globalObject;
  ***REMOVED***

  get referenceNode() {
    this._throwIfNotWorking();
    return this._referenceNode;
  ***REMOVED***

  get pointerBeforeReferenceNode() {
    this._throwIfNotWorking();
    return this._pointerBeforeReferenceNode;
  ***REMOVED***

  nextNode() {
    this._throwIfNotWorking();
    return this._traverse("next");
  ***REMOVED***

  previousNode() {
    this._throwIfNotWorking();
    return this._traverse("previous");
  ***REMOVED***

  detach() {
    // Intentionally do nothing, per spec.
  ***REMOVED***

  // Called by Documents.
  _preRemovingSteps(toBeRemovedNode) {
    // Second clause is https://github.com/whatwg/dom/issues/496
    if (!toBeRemovedNode.contains(this._referenceNode) || toBeRemovedNode === this.root) {
      return;
    ***REMOVED***

    if (this._pointerBeforeReferenceNode) {
      let next = null;
      let candidateForNext = domSymbolTree.following(toBeRemovedNode, { skipChildren: true ***REMOVED***);
      while (candidateForNext !== null) {
        if (this.root.contains(candidateForNext)) {
          next = candidateForNext;
          break;
        ***REMOVED***
        candidateForNext = domSymbolTree.following(candidateForNext, { skipChildren: true ***REMOVED***);
      ***REMOVED***

      if (next !== null) {
        this._referenceNode = next;
        return;
      ***REMOVED***

      this._pointerBeforeReferenceNode = false;
    ***REMOVED***

    const { previousSibling ***REMOVED*** = toBeRemovedNode;
    this._referenceNode = previousSibling === null ?
                          toBeRemovedNode.parentNode :
                          domSymbolTree.lastInclusiveDescendant(toBeRemovedNode.previousSibling);
  ***REMOVED***

  // Only called by getters and methods that are affected by the pre-removing steps
  _throwIfNotWorking() {
    if (!hasWeakRefs && !this._working) {
      throw Error(`This NodeIterator is no longer working. More than 10 iterators are being used concurrently. ` +
        `Using more than 10 node iterators requires WeakRef support.`);
    ***REMOVED***
  ***REMOVED***

  _traverse(direction) {
    let node = this._referenceNode;
    let beforeNode = this._pointerBeforeReferenceNode;

    while (true) {
      if (direction === "next") {
        if (!beforeNode) {
          node = domSymbolTree.following(node, { root: this.root ***REMOVED***);

          if (!node) {
            return null;
          ***REMOVED***
        ***REMOVED***

        beforeNode = false;
      ***REMOVED*** else if (direction === "previous") {
        if (beforeNode) {
          node = domSymbolTree.preceding(node, { root: this.root ***REMOVED***);

          if (!node) {
            return null;
          ***REMOVED***
        ***REMOVED***

        beforeNode = true;
      ***REMOVED***

      const result = filter(this, node);
      if (result === FILTER_ACCEPT) {
        break;
      ***REMOVED***
    ***REMOVED***

    this._referenceNode = node;
    this._pointerBeforeReferenceNode = beforeNode;
    return node;
  ***REMOVED***
***REMOVED***;
