


import { TokenType as tt***REMOVED*** from "./parser/tokenizer/types";
import isAsyncOperation from "./util/isAsyncOperation";











export default class TokenProcessor {
   __init() {this.resultCode = ""***REMOVED***
  // Array mapping input token index to optional string index position in the
  // output code.
   __init2() {this.resultMappings = new Array(this.tokens.length)***REMOVED***
   __init3() {this.tokenIndex = 0***REMOVED***

  constructor(
     code,
     tokens,
     isFlowEnabled,
     disableESTransforms,
     helperManager,
  ) {;this.code = code;this.tokens = tokens;this.isFlowEnabled = isFlowEnabled;this.disableESTransforms = disableESTransforms;this.helperManager = helperManager;TokenProcessor.prototype.__init.call(this);TokenProcessor.prototype.__init2.call(this);TokenProcessor.prototype.__init3.call(this);***REMOVED***

  /**
   * Snapshot the token state in a way that can be restored later, useful for
   * things like lookahead.
   *
   * resultMappings do not need to be copied since in all use cases, they will
   * be overwritten anyway after restore.
   */
  snapshot() {
    return {
      resultCode: this.resultCode,
      tokenIndex: this.tokenIndex,
    ***REMOVED***;
  ***REMOVED***

  restoreToSnapshot(snapshot) {
    this.resultCode = snapshot.resultCode;
    this.tokenIndex = snapshot.tokenIndex;
  ***REMOVED***

  /**
   * Remove and return the code generated since the snapshot, leaving the
   * current token position in-place. Unlike most TokenProcessor operations,
   * this operation can result in input/output line number mismatches because
   * the removed code may contain newlines, so this operation should be used
   * sparingly.
   */
  dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot) {
    const result = this.resultCode.slice(snapshot.resultCode.length);
    this.resultCode = snapshot.resultCode;
    return result;
  ***REMOVED***

  reset() {
    this.resultCode = "";
    this.resultMappings = new Array(this.tokens.length);
    this.tokenIndex = 0;
  ***REMOVED***

  matchesContextualAtIndex(index, contextualKeyword) {
    return (
      this.matches1AtIndex(index, tt.name) &&
      this.tokens[index].contextualKeyword === contextualKeyword
    );
  ***REMOVED***

  identifierNameAtIndex(index) {
    // TODO: We need to process escapes since technically you can have unicode escapes in variable
    // names.
    return this.identifierNameForToken(this.tokens[index]);
  ***REMOVED***

  identifierNameAtRelativeIndex(relativeIndex) {
    return this.identifierNameForToken(this.tokenAtRelativeIndex(relativeIndex));
  ***REMOVED***

  identifierName() {
    return this.identifierNameForToken(this.currentToken());
  ***REMOVED***

  identifierNameForToken(token) {
    return this.code.slice(token.start, token.end);
  ***REMOVED***

  rawCodeForToken(token) {
    return this.code.slice(token.start, token.end);
  ***REMOVED***

  stringValueAtIndex(index) {
    return this.stringValueForToken(this.tokens[index]);
  ***REMOVED***

  stringValue() {
    return this.stringValueForToken(this.currentToken());
  ***REMOVED***

  stringValueForToken(token) {
    // This is used to identify when two imports are the same and to resolve TypeScript enum keys.
    // Ideally we'd process escapes within the strings, but for now we pretty much take the raw
    // code.
    return this.code.slice(token.start + 1, token.end - 1);
  ***REMOVED***

  matches1AtIndex(index, t1) {
    return this.tokens[index].type === t1;
  ***REMOVED***

  matches2AtIndex(index, t1, t2) {
    return this.tokens[index].type === t1 && this.tokens[index + 1].type === t2;
  ***REMOVED***

  matches3AtIndex(index, t1, t2, t3) {
    return (
      this.tokens[index].type === t1 &&
      this.tokens[index + 1].type === t2 &&
      this.tokens[index + 2].type === t3
    );
  ***REMOVED***

  matches1(t1) {
    return this.tokens[this.tokenIndex].type === t1;
  ***REMOVED***

  matches2(t1, t2) {
    return this.tokens[this.tokenIndex].type === t1 && this.tokens[this.tokenIndex + 1].type === t2;
  ***REMOVED***

  matches3(t1, t2, t3) {
    return (
      this.tokens[this.tokenIndex].type === t1 &&
      this.tokens[this.tokenIndex + 1].type === t2 &&
      this.tokens[this.tokenIndex + 2].type === t3
    );
  ***REMOVED***

  matches4(t1, t2, t3, t4) {
    return (
      this.tokens[this.tokenIndex].type === t1 &&
      this.tokens[this.tokenIndex + 1].type === t2 &&
      this.tokens[this.tokenIndex + 2].type === t3 &&
      this.tokens[this.tokenIndex + 3].type === t4
    );
  ***REMOVED***

  matches5(t1, t2, t3, t4, t5) {
    return (
      this.tokens[this.tokenIndex].type === t1 &&
      this.tokens[this.tokenIndex + 1].type === t2 &&
      this.tokens[this.tokenIndex + 2].type === t3 &&
      this.tokens[this.tokenIndex + 3].type === t4 &&
      this.tokens[this.tokenIndex + 4].type === t5
    );
  ***REMOVED***

  matchesContextual(contextualKeyword) {
    return this.matchesContextualAtIndex(this.tokenIndex, contextualKeyword);
  ***REMOVED***

  matchesContextIdAndLabel(type, contextId) {
    return this.matches1(type) && this.currentToken().contextId === contextId;
  ***REMOVED***

  previousWhitespaceAndComments() {
    let whitespaceAndComments = this.code.slice(
      this.tokenIndex > 0 ? this.tokens[this.tokenIndex - 1].end : 0,
      this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex].start : this.code.length,
    );
    if (this.isFlowEnabled) {
      whitespaceAndComments = whitespaceAndComments.replace(/@flow/g, "");
    ***REMOVED***
    return whitespaceAndComments;
  ***REMOVED***

  replaceToken(newCode) {
    this.resultCode += this.previousWhitespaceAndComments();
    this.appendTokenPrefix();
    this.resultMappings[this.tokenIndex] = this.resultCode.length;
    this.resultCode += newCode;
    this.appendTokenSuffix();
    this.tokenIndex++;
  ***REMOVED***

  replaceTokenTrimmingLeftWhitespace(newCode) {
    this.resultCode += this.previousWhitespaceAndComments().replace(/[^\r\n]/g, "");
    this.appendTokenPrefix();
    this.resultMappings[this.tokenIndex] = this.resultCode.length;
    this.resultCode += newCode;
    this.appendTokenSuffix();
    this.tokenIndex++;
  ***REMOVED***

  removeInitialToken() {
    this.replaceToken("");
  ***REMOVED***

  removeToken() {
    this.replaceTokenTrimmingLeftWhitespace("");
  ***REMOVED***

  /**
   * Remove all code until the next ***REMOVED***, accounting for balanced braces.
   */
  removeBalancedCode() {
    let braceDepth = 0;
    while (!this.isAtEnd()) {
      if (this.matches1(tt.braceL)) {
        braceDepth++;
      ***REMOVED*** else if (this.matches1(tt.braceR)) {
        if (braceDepth === 0) {
          return;
        ***REMOVED***
        braceDepth--;
      ***REMOVED***
      this.removeToken();
    ***REMOVED***
  ***REMOVED***

  copyExpectedToken(tokenType) {
    if (this.tokens[this.tokenIndex].type !== tokenType) {
      throw new Error(`Expected token ${tokenType***REMOVED***`);
    ***REMOVED***
    this.copyToken();
  ***REMOVED***

  copyToken() {
    this.resultCode += this.previousWhitespaceAndComments();
    this.appendTokenPrefix();
    this.resultMappings[this.tokenIndex] = this.resultCode.length;
    this.resultCode += this.code.slice(
      this.tokens[this.tokenIndex].start,
      this.tokens[this.tokenIndex].end,
    );
    this.appendTokenSuffix();
    this.tokenIndex++;
  ***REMOVED***

  copyTokenWithPrefix(prefix) {
    this.resultCode += this.previousWhitespaceAndComments();
    this.appendTokenPrefix();
    this.resultCode += prefix;
    this.resultMappings[this.tokenIndex] = this.resultCode.length;
    this.resultCode += this.code.slice(
      this.tokens[this.tokenIndex].start,
      this.tokens[this.tokenIndex].end,
    );
    this.appendTokenSuffix();
    this.tokenIndex++;
  ***REMOVED***

   appendTokenPrefix() {
    const token = this.currentToken();
    if (token.numNullishCoalesceStarts || token.isOptionalChainStart) {
      token.isAsyncOperation = isAsyncOperation(this);
    ***REMOVED***
    if (this.disableESTransforms) {
      return;
    ***REMOVED***
    if (token.numNullishCoalesceStarts) {
      for (let i = 0; i < token.numNullishCoalesceStarts; i++) {
        if (token.isAsyncOperation) {
          this.resultCode += "await ";
          this.resultCode += this.helperManager.getHelperName("asyncNullishCoalesce");
        ***REMOVED*** else {
          this.resultCode += this.helperManager.getHelperName("nullishCoalesce");
        ***REMOVED***
        this.resultCode += "(";
      ***REMOVED***
    ***REMOVED***
    if (token.isOptionalChainStart) {
      if (token.isAsyncOperation) {
        this.resultCode += "await ";
      ***REMOVED***
      if (this.tokenIndex > 0 && this.tokenAtRelativeIndex(-1).type === tt._delete) {
        if (token.isAsyncOperation) {
          this.resultCode += this.helperManager.getHelperName("asyncOptionalChainDelete");
        ***REMOVED*** else {
          this.resultCode += this.helperManager.getHelperName("optionalChainDelete");
        ***REMOVED***
      ***REMOVED*** else if (token.isAsyncOperation) {
        this.resultCode += this.helperManager.getHelperName("asyncOptionalChain");
      ***REMOVED*** else {
        this.resultCode += this.helperManager.getHelperName("optionalChain");
      ***REMOVED***
      this.resultCode += "([";
    ***REMOVED***
  ***REMOVED***

   appendTokenSuffix() {
    const token = this.currentToken();
    if (token.isOptionalChainEnd && !this.disableESTransforms) {
      this.resultCode += "])";
    ***REMOVED***
    if (token.numNullishCoalesceEnds && !this.disableESTransforms) {
      for (let i = 0; i < token.numNullishCoalesceEnds; i++) {
        this.resultCode += "))";
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  appendCode(code) {
    this.resultCode += code;
  ***REMOVED***

  currentToken() {
    return this.tokens[this.tokenIndex];
  ***REMOVED***

  currentTokenCode() {
    const token = this.currentToken();
    return this.code.slice(token.start, token.end);
  ***REMOVED***

  tokenAtRelativeIndex(relativeIndex) {
    return this.tokens[this.tokenIndex + relativeIndex];
  ***REMOVED***

  currentIndex() {
    return this.tokenIndex;
  ***REMOVED***

  /**
   * Move to the next token. Only suitable in preprocessing steps. When
   * generating new code, you should use copyToken or removeToken.
   */
  nextToken() {
    if (this.tokenIndex === this.tokens.length) {
      throw new Error("Unexpectedly reached end of input.");
    ***REMOVED***
    this.tokenIndex++;
  ***REMOVED***

  previousToken() {
    this.tokenIndex--;
  ***REMOVED***

  finish() {
    if (this.tokenIndex !== this.tokens.length) {
      throw new Error("Tried to finish processing tokens before reaching the end.");
    ***REMOVED***
    this.resultCode += this.previousWhitespaceAndComments();
    return {code: this.resultCode, mappings: this.resultMappings***REMOVED***;
  ***REMOVED***

  isAtEnd() {
    return this.tokenIndex === this.tokens.length;
  ***REMOVED***
***REMOVED***
