"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
const codegen_1 = require("./codegen");
const code_1 = require("./codegen/code");
// TODO refactor to use Set
function toHash(arr) {
    const hash = {***REMOVED***;
    for (const item of arr)
        hash[item] = true;
    return hash;
***REMOVED***
exports.toHash = toHash;
function alwaysValidSchema(it, schema) {
    if (typeof schema == "boolean")
        return schema;
    if (Object.keys(schema).length === 0)
        return true;
    checkUnknownRules(it, schema);
    return !schemaHasRules(schema, it.self.RULES.all);
***REMOVED***
exports.alwaysValidSchema = alwaysValidSchema;
function checkUnknownRules(it, schema = it.schema) {
    const { opts, self ***REMOVED*** = it;
    if (!opts.strictSchema)
        return;
    if (typeof schema === "boolean")
        return;
    const rules = self.RULES.keywords;
    for (const key in schema) {
        if (!rules[key])
            checkStrictMode(it, `unknown keyword: "${key***REMOVED***"`);
    ***REMOVED***
***REMOVED***
exports.checkUnknownRules = checkUnknownRules;
function schemaHasRules(schema, rules) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (rules[key])
            return true;
    return false;
***REMOVED***
exports.schemaHasRules = schemaHasRules;
function schemaHasRulesButRef(schema, RULES) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
            return true;
    return false;
***REMOVED***
exports.schemaHasRulesButRef = schemaHasRulesButRef;
function schemaRefOrVal({ topSchemaRef, schemaPath ***REMOVED***, schema, keyword, $data) {
    if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
            return schema;
        if (typeof schema == "string")
            return (0, codegen_1._) `${schema***REMOVED***`;
    ***REMOVED***
    return (0, codegen_1._) `${topSchemaRef***REMOVED***${schemaPath***REMOVED***${(0, codegen_1.getProperty)(keyword)***REMOVED***`;
***REMOVED***
exports.schemaRefOrVal = schemaRefOrVal;
function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
***REMOVED***
exports.unescapeFragment = unescapeFragment;
function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
***REMOVED***
exports.escapeFragment = escapeFragment;
function escapeJsonPointer(str) {
    if (typeof str == "number")
        return `${str***REMOVED***`;
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
***REMOVED***
exports.escapeJsonPointer = escapeJsonPointer;
function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
***REMOVED***
exports.unescapeJsonPointer = unescapeJsonPointer;
function eachItem(xs, f) {
    if (Array.isArray(xs)) {
        for (const x of xs)
            f(x);
    ***REMOVED***
    else {
        f(xs);
    ***REMOVED***
***REMOVED***
exports.eachItem = eachItem;
function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName, ***REMOVED***) {
    return (gen, from, to, toName) => {
        const res = to === undefined
            ? from
            : to instanceof codegen_1.Name
                ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
                : from instanceof codegen_1.Name
                    ? (mergeToName(gen, to, from), from)
                    : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
    ***REMOVED***;
***REMOVED***
exports.mergeEvaluated = {
    props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to***REMOVED*** !== true && ${from***REMOVED*** !== undefined`, () => {
            gen.if((0, codegen_1._) `${from***REMOVED*** === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._) `${to***REMOVED*** || {***REMOVED***`).code((0, codegen_1._) `Object.assign(${to***REMOVED***, ${from***REMOVED***)`));
        ***REMOVED***),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to***REMOVED*** !== true`, () => {
            if (from === true) {
                gen.assign(to, true);
            ***REMOVED***
            else {
                gen.assign(to, (0, codegen_1._) `${to***REMOVED*** || {***REMOVED***`);
                setEvaluated(gen, to, from);
            ***REMOVED***
        ***REMOVED***),
        mergeValues: (from, to) => (from === true ? true : { ...from, ...to ***REMOVED***),
        resultToName: evaluatedPropsToName,
    ***REMOVED***),
    items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._) `${to***REMOVED*** !== true && ${from***REMOVED*** !== undefined`, () => gen.assign(to, (0, codegen_1._) `${from***REMOVED*** === true ? true : ${to***REMOVED*** > ${from***REMOVED*** ? ${to***REMOVED*** : ${from***REMOVED***`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._) `${to***REMOVED*** !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._) `${to***REMOVED*** > ${from***REMOVED*** ? ${to***REMOVED*** : ${from***REMOVED***`)),
        mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
        resultToName: (gen, items) => gen.var("items", items),
    ***REMOVED***),
***REMOVED***;
function evaluatedPropsToName(gen, ps) {
    if (ps === true)
        return gen.var("props", true);
    const props = gen.var("props", (0, codegen_1._) `{***REMOVED***`);
    if (ps !== undefined)
        setEvaluated(gen, props, ps);
    return props;
***REMOVED***
exports.evaluatedPropsToName = evaluatedPropsToName;
function setEvaluated(gen, props, ps) {
    Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._) `${props***REMOVED***${(0, codegen_1.getProperty)(p)***REMOVED***`, true));
***REMOVED***
exports.setEvaluated = setEvaluated;
const snippets = {***REMOVED***;
function useFunc(gen, f) {
    return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code)),
    ***REMOVED***);
***REMOVED***
exports.useFunc = useFunc;
var Type;
(function (Type) {
    Type[Type["Num"] = 0] = "Num";
    Type[Type["Str"] = 1] = "Str";
***REMOVED***)(Type || (exports.Type = Type = {***REMOVED***));
function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
    // let path
    if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax
            ? isNumber
                ? (0, codegen_1._) `"[" + ${dataProp***REMOVED*** + "]"`
                : (0, codegen_1._) `"['" + ${dataProp***REMOVED*** + "']"`
            : isNumber
                ? (0, codegen_1._) `"/" + ${dataProp***REMOVED***`
                : (0, codegen_1._) `"/" + ${dataProp***REMOVED***.replace(/~/g, "~0").replace(/\\//g, "~1")`; // TODO maybe use global escapePointer
    ***REMOVED***
    return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
***REMOVED***
exports.getErrorPath = getErrorPath;
function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
    if (!mode)
        return;
    msg = `strict mode: ${msg***REMOVED***`;
    if (mode === true)
        throw new Error(msg);
    it.self.logger.warn(msg);
***REMOVED***
exports.checkStrictMode = checkStrictMode;
//# sourceMappingURL=util.js.map