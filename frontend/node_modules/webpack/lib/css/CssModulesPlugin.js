/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { SyncWaterfallHook, SyncHook ***REMOVED*** = require("tapable");
const {
	ConcatSource,
	PrefixSource,
	ReplaceSource,
	CachedSource,
	RawSource
***REMOVED*** = require("webpack-sources");
const Compilation = require("../Compilation");
const CssModule = require("../CssModule");
const { tryRunOrWebpackError ***REMOVED*** = require("../HookWebpackError");
const HotUpdateChunk = require("../HotUpdateChunk");
const {
	CSS_MODULE_TYPE,
	CSS_MODULE_TYPE_GLOBAL,
	CSS_MODULE_TYPE_MODULE,
	CSS_MODULE_TYPE_AUTO
***REMOVED*** = require("../ModuleTypeConstants");
const NormalModule = require("../NormalModule");
const RuntimeGlobals = require("../RuntimeGlobals");
const SelfModuleFactory = require("../SelfModuleFactory");
const Template = require("../Template");
const WebpackError = require("../WebpackError");
const CssIcssExportDependency = require("../dependencies/CssIcssExportDependency");
const CssIcssImportDependency = require("../dependencies/CssIcssImportDependency");
const CssIcssSymbolDependency = require("../dependencies/CssIcssSymbolDependency");
const CssImportDependency = require("../dependencies/CssImportDependency");
const CssLocalIdentifierDependency = require("../dependencies/CssLocalIdentifierDependency");
const CssSelfLocalIdentifierDependency = require("../dependencies/CssSelfLocalIdentifierDependency");
const CssUrlDependency = require("../dependencies/CssUrlDependency");
const StaticExportsDependency = require("../dependencies/StaticExportsDependency");
const JavascriptModulesPlugin = require("../javascript/JavascriptModulesPlugin");
const { compareModulesByIdOrIdentifier ***REMOVED*** = require("../util/comparators");
const createSchemaValidation = require("../util/create-schema-validation");
const createHash = require("../util/createHash");
const { getUndoPath ***REMOVED*** = require("../util/identifier");
const memoize = require("../util/memoize");
const nonNumericOnlyHash = require("../util/nonNumericOnlyHash");
const removeBOM = require("../util/removeBOM");
const CssGenerator = require("./CssGenerator");
const CssParser = require("./CssParser");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../../declarations/WebpackOptions").HashFunction***REMOVED*** HashFunction */
/** @typedef {import("../../declarations/WebpackOptions").OutputNormalized***REMOVED*** OutputOptions */
/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../CodeGenerationResults")***REMOVED*** CodeGenerationResults */
/** @typedef {import("../Compilation").ChunkHashContext***REMOVED*** ChunkHashContext */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../CssModule").Inheritance***REMOVED*** Inheritance */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../Module").BuildInfo***REMOVED*** BuildInfo */
/** @typedef {import("../Template").RuntimeTemplate***REMOVED*** RuntimeTemplate */
/** @typedef {import("../TemplatedPathPlugin").TemplatePath***REMOVED*** TemplatePath */
/** @typedef {import("../util/Hash")***REMOVED*** Hash */
/** @typedef {import("../util/memoize")***REMOVED*** Memoize */

/**
 * @typedef {object***REMOVED*** RenderContext
 * @property {Chunk***REMOVED*** chunk the chunk
 * @property {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @property {CodeGenerationResults***REMOVED*** codeGenerationResults results of code generation
 * @property {RuntimeTemplate***REMOVED*** runtimeTemplate the runtime template
 * @property {string***REMOVED*** uniqueName the unique name
 * @property {string***REMOVED*** undoPath undo path to css file
 * @property {CssModule[]***REMOVED*** modules modules
 */

/**
 * @typedef {object***REMOVED*** ChunkRenderContext
 * @property {Chunk***REMOVED*** chunk the chunk
 * @property {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @property {CodeGenerationResults***REMOVED*** codeGenerationResults results of code generation
 * @property {RuntimeTemplate***REMOVED*** runtimeTemplate the runtime template
 * @property {string***REMOVED*** undoPath undo path to css file
 */

/**
 * @typedef {object***REMOVED*** CompilationHooks
 * @property {SyncWaterfallHook<[Source, Module, ChunkRenderContext]>***REMOVED*** renderModulePackage
 * @property {SyncHook<[Chunk, Hash, ChunkHashContext]>***REMOVED*** chunkHash
 */

const getCssLoadingRuntimeModule = memoize(() =>
	require("./CssLoadingRuntimeModule")
);

/**
 * @param {string***REMOVED*** name name
 * @returns {{ oneOf: [{ $ref: string ***REMOVED***], definitions: import("../../schemas/WebpackOptions.json")["definitions"] ***REMOVED******REMOVED*** schema
 */
const getSchema = name => {
	const { definitions ***REMOVED*** = require("../../schemas/WebpackOptions.json");
	return {
		definitions,
		oneOf: [{ $ref: `#/definitions/${name***REMOVED***` ***REMOVED***]
	***REMOVED***;
***REMOVED***;

const generatorValidationOptions = {
	name: "Css Modules Plugin",
	baseDataPath: "generator"
***REMOVED***;
const validateGeneratorOptions = {
	css: createSchemaValidation(
		require("../../schemas/plugins/css/CssGeneratorOptions.check.js"),
		() => getSchema("CssGeneratorOptions"),
		generatorValidationOptions
	),
	"css/auto": createSchemaValidation(
		require("../../schemas/plugins/css/CssAutoGeneratorOptions.check.js"),
		() => getSchema("CssAutoGeneratorOptions"),
		generatorValidationOptions
	),
	"css/module": createSchemaValidation(
		require("../../schemas/plugins/css/CssModuleGeneratorOptions.check.js"),
		() => getSchema("CssModuleGeneratorOptions"),
		generatorValidationOptions
	),
	"css/global": createSchemaValidation(
		require("../../schemas/plugins/css/CssGlobalGeneratorOptions.check.js"),
		() => getSchema("CssGlobalGeneratorOptions"),
		generatorValidationOptions
	)
***REMOVED***;

const parserValidationOptions = {
	name: "Css Modules Plugin",
	baseDataPath: "parser"
***REMOVED***;
const validateParserOptions = {
	css: createSchemaValidation(
		require("../../schemas/plugins/css/CssParserOptions.check.js"),
		() => getSchema("CssParserOptions"),
		parserValidationOptions
	),
	"css/auto": createSchemaValidation(
		require("../../schemas/plugins/css/CssAutoParserOptions.check.js"),
		() => getSchema("CssAutoParserOptions"),
		parserValidationOptions
	),
	"css/module": createSchemaValidation(
		require("../../schemas/plugins/css/CssModuleParserOptions.check.js"),
		() => getSchema("CssModuleParserOptions"),
		parserValidationOptions
	),
	"css/global": createSchemaValidation(
		require("../../schemas/plugins/css/CssGlobalParserOptions.check.js"),
		() => getSchema("CssGlobalParserOptions"),
		parserValidationOptions
	)
***REMOVED***;

/** @type {WeakMap<Compilation, CompilationHooks>***REMOVED*** */
const compilationHooksMap = new WeakMap();

const PLUGIN_NAME = "CssModulesPlugin";

class CssModulesPlugin {
	/**
	 * @param {Compilation***REMOVED*** compilation the compilation
	 * @returns {CompilationHooks***REMOVED*** the attached hooks
	 */
	static getCompilationHooks(compilation) {
		if (!(compilation instanceof Compilation)) {
			throw new TypeError(
				"The 'compilation' argument must be an instance of Compilation"
			);
		***REMOVED***
		let hooks = compilationHooksMap.get(compilation);
		if (hooks === undefined) {
			hooks = {
				renderModulePackage: new SyncWaterfallHook([
					"source",
					"module",
					"renderContext"
				]),
				chunkHash: new SyncHook(["chunk", "hash", "context"])
			***REMOVED***;
			compilationHooksMap.set(compilation, hooks);
		***REMOVED***
		return hooks;
	***REMOVED***

	constructor() {
		/** @type {WeakMap<Source, { undoPath: string, inheritance: Inheritance, source: CachedSource ***REMOVED***>***REMOVED*** */
		this._moduleFactoryCache = new WeakMap();
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			PLUGIN_NAME,
			(compilation, { normalModuleFactory ***REMOVED***) => {
				const hooks = CssModulesPlugin.getCompilationHooks(compilation);
				const selfFactory = new SelfModuleFactory(compilation.moduleGraph);
				compilation.dependencyFactories.set(
					CssImportDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					CssImportDependency,
					new CssImportDependency.Template()
				);
				compilation.dependencyFactories.set(
					CssUrlDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					CssUrlDependency,
					new CssUrlDependency.Template()
				);
				compilation.dependencyTemplates.set(
					CssLocalIdentifierDependency,
					new CssLocalIdentifierDependency.Template()
				);
				compilation.dependencyFactories.set(
					CssSelfLocalIdentifierDependency,
					selfFactory
				);
				compilation.dependencyTemplates.set(
					CssSelfLocalIdentifierDependency,
					new CssSelfLocalIdentifierDependency.Template()
				);
				compilation.dependencyFactories.set(
					CssIcssImportDependency,
					normalModuleFactory
				);
				compilation.dependencyTemplates.set(
					CssIcssImportDependency,
					new CssIcssImportDependency.Template()
				);
				compilation.dependencyTemplates.set(
					CssIcssExportDependency,
					new CssIcssExportDependency.Template()
				);
				compilation.dependencyTemplates.set(
					CssIcssSymbolDependency,
					new CssIcssSymbolDependency.Template()
				);
				compilation.dependencyTemplates.set(
					StaticExportsDependency,
					new StaticExportsDependency.Template()
				);
				for (const type of [
					CSS_MODULE_TYPE,
					CSS_MODULE_TYPE_GLOBAL,
					CSS_MODULE_TYPE_MODULE,
					CSS_MODULE_TYPE_AUTO
				]) {
					normalModuleFactory.hooks.createParser
						.for(type)
						.tap(PLUGIN_NAME, parserOptions => {
							validateParserOptions[type](parserOptions);
							const { url, import: importOption, namedExports ***REMOVED*** = parserOptions;

							switch (type) {
								case CSS_MODULE_TYPE:
									return new CssParser({
										importOption,
										url,
										namedExports
									***REMOVED***);
								case CSS_MODULE_TYPE_GLOBAL:
									return new CssParser({
										defaultMode: "global",
										importOption,
										url,
										namedExports
									***REMOVED***);
								case CSS_MODULE_TYPE_MODULE:
									return new CssParser({
										defaultMode: "local",
										importOption,
										url,
										namedExports
									***REMOVED***);
								case CSS_MODULE_TYPE_AUTO:
									return new CssParser({
										defaultMode: "auto",
										importOption,
										url,
										namedExports
									***REMOVED***);
							***REMOVED***
						***REMOVED***);
					normalModuleFactory.hooks.createGenerator
						.for(type)
						.tap(PLUGIN_NAME, generatorOptions => {
							validateGeneratorOptions[type](generatorOptions);

							return new CssGenerator(
								generatorOptions,
								compilation.moduleGraph
							);
						***REMOVED***);
					normalModuleFactory.hooks.createModuleClass
						.for(type)
						.tap(PLUGIN_NAME, (createData, resolveData) => {
							if (resolveData.dependencies.length > 0) {
								// When CSS is imported from CSS there is only one dependency
								const dependency = resolveData.dependencies[0];

								if (dependency instanceof CssImportDependency) {
									const parent =
										/** @type {CssModule***REMOVED*** */
										(compilation.moduleGraph.getParentModule(dependency));

									if (parent instanceof CssModule) {
										/** @type {import("../CssModule").Inheritance | undefined***REMOVED*** */
										let inheritance;

										if (
											parent.cssLayer !== undefined ||
											parent.supports ||
											parent.media
										) {
											if (!inheritance) {
												inheritance = [];
											***REMOVED***

											inheritance.push([
												parent.cssLayer,
												parent.supports,
												parent.media
											]);
										***REMOVED***

										if (parent.inheritance) {
											if (!inheritance) {
												inheritance = [];
											***REMOVED***

											inheritance.push(...parent.inheritance);
										***REMOVED***

										return new CssModule({
											...createData,
											cssLayer: dependency.layer,
											supports: dependency.supports,
											media: dependency.media,
											inheritance
										***REMOVED***);
									***REMOVED***

									return new CssModule({
										...createData,
										cssLayer: dependency.layer,
										supports: dependency.supports,
										media: dependency.media
									***REMOVED***);
								***REMOVED***
							***REMOVED***

							return new CssModule(createData);
						***REMOVED***);

					NormalModule.getCompilationHooks(compilation).processResult.tap(
						PLUGIN_NAME,
						(result, module) => {
							if (module.type === type) {
								const [source, ...rest] = result;

								return [removeBOM(source), ...rest];
							***REMOVED***

							return result;
						***REMOVED***
					);
				***REMOVED***

				JavascriptModulesPlugin.getCompilationHooks(
					compilation
				).renderModuleContent.tap(PLUGIN_NAME, (source, module) => {
					if (module instanceof CssModule && module.hot) {
						const cssData = /** @type {BuildInfo***REMOVED*** */ (module.buildInfo).cssData;
						if (!cssData) {
							return source;
						***REMOVED***
						const exports = cssData.exports;
						const stringifiedExports = JSON.stringify(
							JSON.stringify(
								Array.from(exports).reduce((obj, [key, value]) => {
									obj[key] = value;
									return obj;
								***REMOVED***, /** @type {Record<string, string>***REMOVED*** */ ({***REMOVED***))
							)
						);

						const hmrCode = Template.asString([
							"",
							`var __webpack_css_exports__ = ${stringifiedExports***REMOVED***;`,
							"// only invalidate when locals change",
							"if (module.hot.data && module.hot.data.__webpack_css_exports__ && module.hot.data.__webpack_css_exports__ != __webpack_css_exports__) {",
							Template.indent("module.hot.invalidate();"),
							"***REMOVED*** else {",
							Template.indent("module.hot.accept();"),
							"***REMOVED***",
							"module.hot.dispose(function(data) { data.__webpack_css_exports__ = __webpack_css_exports__; ***REMOVED***);"
						]);

						return new ConcatSource(source, "\n", new RawSource(hmrCode));
					***REMOVED***

					return source;
				***REMOVED***);
				const orderedCssModulesPerChunk = new WeakMap();
				compilation.hooks.afterCodeGeneration.tap(PLUGIN_NAME, () => {
					const { chunkGraph ***REMOVED*** = compilation;
					for (const chunk of compilation.chunks) {
						if (CssModulesPlugin.chunkHasCss(chunk, chunkGraph)) {
							orderedCssModulesPerChunk.set(
								chunk,
								this.getOrderedChunkCssModules(chunk, chunkGraph, compilation)
							);
						***REMOVED***
					***REMOVED***
				***REMOVED***);
				compilation.hooks.chunkHash.tap(PLUGIN_NAME, (chunk, hash, context) => {
					hooks.chunkHash.call(chunk, hash, context);
				***REMOVED***);
				compilation.hooks.contentHash.tap(PLUGIN_NAME, chunk => {
					const {
						chunkGraph,
						codeGenerationResults,
						moduleGraph,
						runtimeTemplate,
						outputOptions: {
							hashSalt,
							hashDigest,
							hashDigestLength,
							hashFunction
						***REMOVED***
					***REMOVED*** = compilation;
					const hash = createHash(/** @type {HashFunction***REMOVED*** */ (hashFunction));
					if (hashSalt) hash.update(hashSalt);
					hooks.chunkHash.call(chunk, hash, {
						chunkGraph,
						codeGenerationResults,
						moduleGraph,
						runtimeTemplate
					***REMOVED***);
					const modules = orderedCssModulesPerChunk.get(chunk);
					if (modules) {
						for (const module of modules) {
							hash.update(chunkGraph.getModuleHash(module, chunk.runtime));
						***REMOVED***
					***REMOVED***
					const digest = /** @type {string***REMOVED*** */ (hash.digest(hashDigest));
					chunk.contentHash.css = nonNumericOnlyHash(
						digest,
						/** @type {number***REMOVED*** */
						(hashDigestLength)
					);
				***REMOVED***);
				compilation.hooks.renderManifest.tap(PLUGIN_NAME, (result, options) => {
					const { chunkGraph ***REMOVED*** = compilation;
					const { hash, chunk, codeGenerationResults, runtimeTemplate ***REMOVED*** =
						options;

					if (chunk instanceof HotUpdateChunk) return result;

					/** @type {CssModule[] | undefined***REMOVED*** */
					const modules = orderedCssModulesPerChunk.get(chunk);
					if (modules !== undefined) {
						const { path: filename, info ***REMOVED*** = compilation.getPathWithInfo(
							CssModulesPlugin.getChunkFilenameTemplate(
								chunk,
								compilation.outputOptions
							),
							{
								hash,
								runtime: chunk.runtime,
								chunk,
								contentHashType: "css"
							***REMOVED***
						);
						const undoPath = getUndoPath(
							filename,
							/** @type {string***REMOVED*** */
							(compilation.outputOptions.path),
							false
						);
						result.push({
							render: () =>
								this.renderChunk(
									{
										chunk,
										chunkGraph,
										codeGenerationResults,
										uniqueName:
											/** @type {string***REMOVED*** */
											(compilation.outputOptions.uniqueName),
										undoPath,
										modules,
										runtimeTemplate
									***REMOVED***,
									hooks
								),
							filename,
							info,
							identifier: `css${chunk.id***REMOVED***`,
							hash: chunk.contentHash.css
						***REMOVED***);
					***REMOVED***
					return result;
				***REMOVED***);
				const globalChunkLoading = compilation.outputOptions.chunkLoading;
				/**
				 * @param {Chunk***REMOVED*** chunk the chunk
				 * @returns {boolean***REMOVED*** true, when enabled
				 */
				const isEnabledForChunk = chunk => {
					const options = chunk.getEntryOptions();
					const chunkLoading =
						options && options.chunkLoading !== undefined
							? options.chunkLoading
							: globalChunkLoading;
					return chunkLoading === "jsonp" || chunkLoading === "import";
				***REMOVED***;
				const onceForChunkSet = new WeakSet();
				/**
				 * @param {Chunk***REMOVED*** chunk chunk to check
				 * @param {Set<string>***REMOVED*** set runtime requirements
				 */
				const handler = (chunk, set) => {
					if (onceForChunkSet.has(chunk)) return;
					onceForChunkSet.add(chunk);
					if (!isEnabledForChunk(chunk)) return;

					set.add(RuntimeGlobals.makeNamespaceObject);

					const CssLoadingRuntimeModule = getCssLoadingRuntimeModule();
					compilation.addRuntimeModule(chunk, new CssLoadingRuntimeModule(set));
				***REMOVED***;
				compilation.hooks.runtimeRequirementInTree
					.for(RuntimeGlobals.hasCssModules)
					.tap(PLUGIN_NAME, handler);
				compilation.hooks.runtimeRequirementInTree
					.for(RuntimeGlobals.ensureChunkHandlers)
					.tap(PLUGIN_NAME, (chunk, set, { chunkGraph ***REMOVED***) => {
						if (!isEnabledForChunk(chunk)) return;
						if (
							!chunkGraph.hasModuleInGraph(
								chunk,
								m =>
									m.type === CSS_MODULE_TYPE ||
									m.type === CSS_MODULE_TYPE_GLOBAL ||
									m.type === CSS_MODULE_TYPE_MODULE ||
									m.type === CSS_MODULE_TYPE_AUTO
							)
						) {
							return;
						***REMOVED***

						set.add(RuntimeGlobals.hasOwnProperty);
						set.add(RuntimeGlobals.publicPath);
						set.add(RuntimeGlobals.getChunkCssFilename);
					***REMOVED***);
				compilation.hooks.runtimeRequirementInTree
					.for(RuntimeGlobals.hmrDownloadUpdateHandlers)
					.tap(PLUGIN_NAME, (chunk, set, { chunkGraph ***REMOVED***) => {
						if (!isEnabledForChunk(chunk)) return;
						if (
							!chunkGraph.hasModuleInGraph(
								chunk,
								m =>
									m.type === CSS_MODULE_TYPE ||
									m.type === CSS_MODULE_TYPE_GLOBAL ||
									m.type === CSS_MODULE_TYPE_MODULE ||
									m.type === CSS_MODULE_TYPE_AUTO
							)
						) {
							return;
						***REMOVED***
						set.add(RuntimeGlobals.publicPath);
						set.add(RuntimeGlobals.getChunkCssFilename);
					***REMOVED***);
			***REMOVED***
		);
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk chunk
	 * @param {Iterable<Module>***REMOVED*** modules unordered modules
	 * @param {Compilation***REMOVED*** compilation compilation
	 * @returns {Module[]***REMOVED*** ordered modules
	 */
	getModulesInOrder(chunk, modules, compilation) {
		if (!modules) return [];

		/** @type {Module[]***REMOVED*** */
		const modulesList = [...modules];

		// Get ordered list of modules per chunk group
		// Lists are in reverse order to allow to use Array.pop()
		const modulesByChunkGroup = Array.from(chunk.groupsIterable, chunkGroup => {
			const sortedModules = modulesList
				.map(module => ({
					module,
					index: chunkGroup.getModulePostOrderIndex(module)
				***REMOVED***))
				.filter(item => item.index !== undefined)
				.sort(
					(a, b) =>
						/** @type {number***REMOVED*** */ (b.index) - /** @type {number***REMOVED*** */ (a.index)
				)
				.map(item => item.module);

			return { list: sortedModules, set: new Set(sortedModules) ***REMOVED***;
		***REMOVED***);

		if (modulesByChunkGroup.length === 1)
			return modulesByChunkGroup[0].list.reverse();

		const boundCompareModulesByIdOrIdentifier = compareModulesByIdOrIdentifier(
			compilation.chunkGraph
		);

		/**
		 * @param {{ list: Module[] ***REMOVED******REMOVED*** a a
		 * @param {{ list: Module[] ***REMOVED******REMOVED*** b b
		 * @returns {-1 | 0 | 1***REMOVED*** result
		 */
		const compareModuleLists = ({ list: a ***REMOVED***, { list: b ***REMOVED***) => {
			if (a.length === 0) {
				return b.length === 0 ? 0 : 1;
			***REMOVED***
			if (b.length === 0) return -1;
			return boundCompareModulesByIdOrIdentifier(
				a[a.length - 1],
				b[b.length - 1]
			);
		***REMOVED***;

		modulesByChunkGroup.sort(compareModuleLists);

		/** @type {Module[]***REMOVED*** */
		const finalModules = [];

		for (;;) {
			const failedModules = new Set();
			const list = modulesByChunkGroup[0].list;
			if (list.length === 0) {
				// done, everything empty
				break;
			***REMOVED***
			/** @type {Module***REMOVED*** */
			let selectedModule = list[list.length - 1];
			let hasFailed;
			outer: for (;;) {
				for (const { list, set ***REMOVED*** of modulesByChunkGroup) {
					if (list.length === 0) continue;
					const lastModule = list[list.length - 1];
					if (lastModule === selectedModule) continue;
					if (!set.has(selectedModule)) continue;
					failedModules.add(selectedModule);
					if (failedModules.has(lastModule)) {
						// There is a conflict, try other alternatives
						hasFailed = lastModule;
						continue;
					***REMOVED***
					selectedModule = lastModule;
					hasFailed = false;
					continue outer; // restart
				***REMOVED***
				break;
			***REMOVED***
			if (hasFailed) {
				// There is a not resolve-able conflict with the selectedModule
				// TODO print better warning
				compilation.warnings.push(
					new WebpackError(
						`chunk ${chunk.name || chunk.id***REMOVED***\nConflicting order between ${
							/** @type {Module***REMOVED*** */
							(hasFailed).readableIdentifier(compilation.requestShortener)
						***REMOVED*** and ${selectedModule.readableIdentifier(
							compilation.requestShortener
						)***REMOVED***`
					)
				);
				selectedModule = /** @type {Module***REMOVED*** */ (hasFailed);
			***REMOVED***
			// Insert the selected module into the final modules list
			finalModules.push(selectedModule);
			// Remove the selected module from all lists
			for (const { list, set ***REMOVED*** of modulesByChunkGroup) {
				const lastModule = list[list.length - 1];
				if (lastModule === selectedModule) list.pop();
				else if (hasFailed && set.has(selectedModule)) {
					const idx = list.indexOf(selectedModule);
					if (idx >= 0) list.splice(idx, 1);
				***REMOVED***
			***REMOVED***
			modulesByChunkGroup.sort(compareModuleLists);
		***REMOVED***
		return finalModules;
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk chunk
	 * @param {ChunkGraph***REMOVED*** chunkGraph chunk graph
	 * @param {Compilation***REMOVED*** compilation compilation
	 * @returns {Module[]***REMOVED*** ordered css modules
	 */
	getOrderedChunkCssModules(chunk, chunkGraph, compilation) {
		return [
			...this.getModulesInOrder(
				chunk,
				/** @type {Iterable<Module>***REMOVED*** */
				(
					chunkGraph.getOrderedChunkModulesIterableBySourceType(
						chunk,
						"css-import",
						compareModulesByIdOrIdentifier(chunkGraph)
					)
				),
				compilation
			),
			...this.getModulesInOrder(
				chunk,
				/** @type {Iterable<Module>***REMOVED*** */
				(
					chunkGraph.getOrderedChunkModulesIterableBySourceType(
						chunk,
						"css",
						compareModulesByIdOrIdentifier(chunkGraph)
					)
				),
				compilation
			)
		];
	***REMOVED***

	/**
	 * @param {CssModule***REMOVED*** module css module
	 * @param {ChunkRenderContext***REMOVED*** renderContext options object
	 * @param {CompilationHooks***REMOVED*** hooks hooks
	 * @returns {Source***REMOVED*** css module source
	 */
	renderModule(module, renderContext, hooks) {
		const { codeGenerationResults, chunk, undoPath ***REMOVED*** = renderContext;
		const codeGenResult = codeGenerationResults.get(module, chunk.runtime);
		const moduleSourceContent =
			/** @type {Source***REMOVED*** */
			(
				codeGenResult.sources.get("css") ||
					codeGenResult.sources.get("css-import")
			);
		const cacheEntry = this._moduleFactoryCache.get(moduleSourceContent);

		/** @type {Inheritance***REMOVED*** */
		const inheritance = [[module.cssLayer, module.supports, module.media]];
		if (module.inheritance) {
			inheritance.push(...module.inheritance);
		***REMOVED***

		let source;
		if (
			cacheEntry &&
			cacheEntry.undoPath === undoPath &&
			cacheEntry.inheritance.every(([layer, supports, media], i) => {
				const item = inheritance[i];
				if (Array.isArray(item)) {
					return layer === item[0] && supports === item[1] && media === item[2];
				***REMOVED***
				return false;
			***REMOVED***)
		) {
			source = cacheEntry.source;
		***REMOVED*** else {
			const moduleSourceCode =
				/** @type {string***REMOVED*** */
				(moduleSourceContent.source());
			const publicPathAutoRegex = new RegExp(
				CssUrlDependency.PUBLIC_PATH_AUTO,
				"g"
			);
			/** @type {Source***REMOVED*** */
			let moduleSource = new ReplaceSource(moduleSourceContent);
			let match;
			while ((match = publicPathAutoRegex.exec(moduleSourceCode))) {
				/** @type {ReplaceSource***REMOVED*** */ (moduleSource).replace(
					match.index,
					(match.index += match[0].length - 1),
					undoPath
				);
			***REMOVED***

			for (let i = 0; i < inheritance.length; i++) {
				const layer = inheritance[i][0];
				const supports = inheritance[i][1];
				const media = inheritance[i][2];

				if (media) {
					moduleSource = new ConcatSource(
						`@media ${media***REMOVED*** {\n`,
						new PrefixSource("\t", moduleSource),
						"***REMOVED***\n"
					);
				***REMOVED***

				if (supports) {
					moduleSource = new ConcatSource(
						`@supports (${supports***REMOVED***) {\n`,
						new PrefixSource("\t", moduleSource),
						"***REMOVED***\n"
					);
				***REMOVED***

				// Layer can be anonymous
				if (layer !== undefined && layer !== null) {
					moduleSource = new ConcatSource(
						`@layer${layer ? ` ${layer***REMOVED***` : ""***REMOVED*** {\n`,
						new PrefixSource("\t", moduleSource),
						"***REMOVED***\n"
					);
				***REMOVED***
			***REMOVED***

			if (moduleSource) {
				moduleSource = new ConcatSource(moduleSource, "\n");
			***REMOVED***

			source = new CachedSource(moduleSource);
			this._moduleFactoryCache.set(moduleSourceContent, {
				inheritance,
				undoPath,
				source
			***REMOVED***);
		***REMOVED***

		return tryRunOrWebpackError(
			() => hooks.renderModulePackage.call(source, module, renderContext),
			"CssModulesPlugin.getCompilationHooks().renderModulePackage"
		);
	***REMOVED***

	/**
	 * @param {RenderContext***REMOVED*** renderContext the render context
	 * @param {CompilationHooks***REMOVED*** hooks hooks
	 * @returns {Source***REMOVED*** generated source
	 */
	renderChunk(
		{
			undoPath,
			chunk,
			chunkGraph,
			codeGenerationResults,
			modules,
			runtimeTemplate
		***REMOVED***,
		hooks
	) {
		const source = new ConcatSource();
		for (const module of modules) {
			try {
				const moduleSource = this.renderModule(
					module,
					{
						undoPath,
						chunk,
						chunkGraph,
						codeGenerationResults,
						runtimeTemplate
					***REMOVED***,
					hooks
				);
				source.add(moduleSource);
			***REMOVED*** catch (err) {
				/** @type {Error***REMOVED*** */
				(err).message += `\nduring rendering of css ${module.identifier()***REMOVED***`;
				throw err;
			***REMOVED***
		***REMOVED***
		chunk.rendered = true;
		return source;
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk chunk
	 * @param {OutputOptions***REMOVED*** outputOptions output options
	 * @returns {TemplatePath***REMOVED*** used filename template
	 */
	static getChunkFilenameTemplate(chunk, outputOptions) {
		if (chunk.cssFilenameTemplate) {
			return chunk.cssFilenameTemplate;
		***REMOVED*** else if (chunk.canBeInitial()) {
			return /** @type {TemplatePath***REMOVED*** */ (outputOptions.cssFilename);
		***REMOVED***
		return /** @type {TemplatePath***REMOVED*** */ (outputOptions.cssChunkFilename);
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk chunk
	 * @param {ChunkGraph***REMOVED*** chunkGraph chunk graph
	 * @returns {boolean***REMOVED*** true, when the chunk has css
	 */
	static chunkHasCss(chunk, chunkGraph) {
		return (
			Boolean(chunkGraph.getChunkModulesIterableBySourceType(chunk, "css")) ||
			Boolean(
				chunkGraph.getChunkModulesIterableBySourceType(chunk, "css-import")
			)
		);
	***REMOVED***
***REMOVED***

module.exports = CssModulesPlugin;
