"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.exec = exec;
exports.findPackageJSONDir = findPackageJSONDir;
exports.getPostcssImplementation = getPostcssImplementation;
exports.getPostcssOptions = getPostcssOptions;
exports.loadConfig = loadConfig;
exports.normalizeSourceMap = normalizeSourceMap;
exports.normalizeSourceMapAfterPostcss = normalizeSourceMapAfterPostcss;

var _path = _interopRequireDefault(require("path"));

var _module = _interopRequireDefault(require("module"));

var _full = require("klona/full");

var _cosmiconfig = require("cosmiconfig");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj ***REMOVED***; ***REMOVED***

const parentModule = module;

const stat = (inputFileSystem, filePath) => new Promise((resolve, reject) => {
  inputFileSystem.stat(filePath, (err, stats) => {
    if (err) {
      reject(err);
    ***REMOVED***

    resolve(stats);
  ***REMOVED***);
***REMOVED***);

function exec(code, loaderContext) {
  const {
    resource,
    context
  ***REMOVED*** = loaderContext;
  const module = new _module.default(resource, parentModule); // eslint-disable-next-line no-underscore-dangle

  module.paths = _module.default._nodeModulePaths(context);
  module.filename = resource; // eslint-disable-next-line no-underscore-dangle

  module._compile(code, resource);

  return module.exports;
***REMOVED***

async function loadConfig(loaderContext, config, postcssOptions) {
  const searchPath = typeof config === "string" ? _path.default.resolve(config) : _path.default.dirname(loaderContext.resourcePath);
  let stats;

  try {
    stats = await stat(loaderContext.fs, searchPath);
  ***REMOVED*** catch (errorIgnore) {
    throw new Error(`No PostCSS config found in: ${searchPath***REMOVED***`);
  ***REMOVED***

  const explorer = (0, _cosmiconfig.cosmiconfig)("postcss");
  let result;

  try {
    if (stats.isFile()) {
      result = await explorer.load(searchPath);
    ***REMOVED*** else {
      result = await explorer.search(searchPath);
    ***REMOVED***
  ***REMOVED*** catch (error) {
    throw error;
  ***REMOVED***

  if (!result) {
    return {***REMOVED***;
  ***REMOVED***

  loaderContext.addBuildDependency(result.filepath);
  loaderContext.addDependency(result.filepath);

  if (result.isEmpty) {
    return result;
  ***REMOVED***

  if (typeof result.config === "function") {
    const api = {
      mode: loaderContext.mode,
      file: loaderContext.resourcePath,
      // For complex use
      webpackLoaderContext: loaderContext,
      // Partial compatibility with `postcss-cli`
      env: loaderContext.mode,
      options: postcssOptions || {***REMOVED***
    ***REMOVED***;
    result.config = result.config(api);
  ***REMOVED***

  result = (0, _full.klona)(result);
  return result;
***REMOVED***

function loadPlugin(plugin, options, file) {
  try {
    if (!options || Object.keys(options).length === 0) {
      // eslint-disable-next-line global-require, import/no-dynamic-require
      const loadedPlugin = require(plugin);

      if (loadedPlugin.default) {
        return loadedPlugin.default;
      ***REMOVED***

      return loadedPlugin;
    ***REMOVED*** // eslint-disable-next-line global-require, import/no-dynamic-require


    const loadedPlugin = require(plugin);

    if (loadedPlugin.default) {
      return loadedPlugin.default(options);
    ***REMOVED***

    return loadedPlugin(options);
  ***REMOVED*** catch (error) {
    throw new Error(`Loading PostCSS "${plugin***REMOVED***" plugin failed: ${error.message***REMOVED***\n\n(@${file***REMOVED***)`);
  ***REMOVED***
***REMOVED***

function pluginFactory() {
  const listOfPlugins = new Map();
  return plugins => {
    if (typeof plugins === "undefined") {
      return listOfPlugins;
    ***REMOVED***

    if (Array.isArray(plugins)) {
      for (const plugin of plugins) {
        if (Array.isArray(plugin)) {
          const [name, options] = plugin;
          listOfPlugins.set(name, options);
        ***REMOVED*** else if (plugin && typeof plugin === "function") {
          listOfPlugins.set(plugin);
        ***REMOVED*** else if (plugin && Object.keys(plugin).length === 1 && (typeof plugin[Object.keys(plugin)[0]] === "object" || typeof plugin[Object.keys(plugin)[0]] === "boolean") && plugin[Object.keys(plugin)[0]] !== null) {
          const [name] = Object.keys(plugin);
          const options = plugin[name];

          if (options === false) {
            listOfPlugins.delete(name);
          ***REMOVED*** else {
            listOfPlugins.set(name, options);
          ***REMOVED***
        ***REMOVED*** else if (plugin) {
          listOfPlugins.set(plugin);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else {
      const objectPlugins = Object.entries(plugins);

      for (const [name, options] of objectPlugins) {
        if (options === false) {
          listOfPlugins.delete(name);
        ***REMOVED*** else {
          listOfPlugins.set(name, options);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    return listOfPlugins;
  ***REMOVED***;
***REMOVED***

async function tryRequireThenImport(module) {
  let exports;

  try {
    // eslint-disable-next-line import/no-dynamic-require, global-require
    exports = require(module);
    return exports;
  ***REMOVED*** catch (requireError) {
    let importESM;

    try {
      // eslint-disable-next-line no-new-func
      importESM = new Function("id", "return import(id);");
    ***REMOVED*** catch (e) {
      importESM = null;
    ***REMOVED***

    if (requireError.code === "ERR_REQUIRE_ESM" && importESM) {
      exports = await importESM(module);
      return exports.default;
    ***REMOVED***

    throw requireError;
  ***REMOVED***
***REMOVED***

async function getPostcssOptions(loaderContext, loadedConfig = {***REMOVED***, postcssOptions = {***REMOVED***) {
  const file = loaderContext.resourcePath;
  let normalizedPostcssOptions = postcssOptions;

  if (typeof normalizedPostcssOptions === "function") {
    normalizedPostcssOptions = normalizedPostcssOptions(loaderContext);
  ***REMOVED***

  let plugins = [];

  try {
    const factory = pluginFactory();

    if (loadedConfig.config && loadedConfig.config.plugins) {
      factory(loadedConfig.config.plugins);
    ***REMOVED***

    factory(normalizedPostcssOptions.plugins);
    plugins = [...factory()].map(item => {
      const [plugin, options] = item;

      if (typeof plugin === "string") {
        return loadPlugin(plugin, options, file);
      ***REMOVED***

      return plugin;
    ***REMOVED***);
  ***REMOVED*** catch (error) {
    loaderContext.emitError(error);
  ***REMOVED***

  const processOptionsFromConfig = loadedConfig.config || {***REMOVED***;

  if (processOptionsFromConfig.from) {
    processOptionsFromConfig.from = _path.default.resolve(_path.default.dirname(loadedConfig.filepath), processOptionsFromConfig.from);
  ***REMOVED***

  if (processOptionsFromConfig.to) {
    processOptionsFromConfig.to = _path.default.resolve(_path.default.dirname(loadedConfig.filepath), processOptionsFromConfig.to);
  ***REMOVED*** // No need them for processOptions


  delete processOptionsFromConfig.plugins;
  const processOptionsFromOptions = (0, _full.klona)(normalizedPostcssOptions);

  if (processOptionsFromOptions.from) {
    processOptionsFromOptions.from = _path.default.resolve(loaderContext.rootContext, processOptionsFromOptions.from);
  ***REMOVED***

  if (processOptionsFromOptions.to) {
    processOptionsFromOptions.to = _path.default.resolve(loaderContext.rootContext, processOptionsFromOptions.to);
  ***REMOVED*** // No need them for processOptions


  delete processOptionsFromOptions.config;
  delete processOptionsFromOptions.plugins;
  const processOptions = {
    from: file,
    to: file,
    map: false,
    ...processOptionsFromConfig,
    ...processOptionsFromOptions
  ***REMOVED***;

  if (typeof processOptions.parser === "string") {
    try {
      processOptions.parser = await tryRequireThenImport(processOptions.parser);
    ***REMOVED*** catch (error) {
      loaderContext.emitError(new Error(`Loading PostCSS "${processOptions.parser***REMOVED***" parser failed: ${error.message***REMOVED***\n\n(@${file***REMOVED***)`));
    ***REMOVED***
  ***REMOVED***

  if (typeof processOptions.stringifier === "string") {
    try {
      processOptions.stringifier = await tryRequireThenImport(processOptions.stringifier);
    ***REMOVED*** catch (error) {
      loaderContext.emitError(new Error(`Loading PostCSS "${processOptions.stringifier***REMOVED***" stringifier failed: ${error.message***REMOVED***\n\n(@${file***REMOVED***)`));
    ***REMOVED***
  ***REMOVED***

  if (typeof processOptions.syntax === "string") {
    try {
      processOptions.syntax = await tryRequireThenImport(processOptions.syntax);
    ***REMOVED*** catch (error) {
      loaderContext.emitError(new Error(`Loading PostCSS "${processOptions.syntax***REMOVED***" syntax failed: ${error.message***REMOVED***\n\n(@${file***REMOVED***)`));
    ***REMOVED***
  ***REMOVED***

  if (processOptions.map === true) {
    // https://github.com/postcss/postcss/blob/master/docs/source-maps.md
    processOptions.map = {
      inline: true
    ***REMOVED***;
  ***REMOVED***

  return {
    plugins,
    processOptions
  ***REMOVED***;
***REMOVED***

const IS_NATIVE_WIN32_PATH = /^[a-z]:[/\\]|^\\\\/i;
const ABSOLUTE_SCHEME = /^[a-z0-9+\-.]+:/i;

function getURLType(source) {
  if (source[0] === "/") {
    if (source[1] === "/") {
      return "scheme-relative";
    ***REMOVED***

    return "path-absolute";
  ***REMOVED***

  if (IS_NATIVE_WIN32_PATH.test(source)) {
    return "path-absolute";
  ***REMOVED***

  return ABSOLUTE_SCHEME.test(source) ? "absolute" : "path-relative";
***REMOVED***

function normalizeSourceMap(map, resourceContext) {
  let newMap = map; // Some loader emit source map as string
  // Strip any JSON XSSI avoidance prefix from the string (as documented in the source maps specification), and then parse the string as JSON.

  if (typeof newMap === "string") {
    newMap = JSON.parse(newMap);
  ***REMOVED***

  delete newMap.file;
  const {
    sourceRoot
  ***REMOVED*** = newMap;
  delete newMap.sourceRoot;

  if (newMap.sources) {
    newMap.sources = newMap.sources.map(source => {
      const sourceType = getURLType(source); // Do no touch `scheme-relative` and `absolute` URLs

      if (sourceType === "path-relative" || sourceType === "path-absolute") {
        const absoluteSource = sourceType === "path-relative" && sourceRoot ? _path.default.resolve(sourceRoot, _path.default.normalize(source)) : _path.default.normalize(source);
        return _path.default.relative(resourceContext, absoluteSource);
      ***REMOVED***

      return source;
    ***REMOVED***);
  ***REMOVED***

  return newMap;
***REMOVED***

function normalizeSourceMapAfterPostcss(map, resourceContext) {
  const newMap = map; // result.map.file is an optional property that provides the output filename.
  // Since we don't know the final filename in the webpack build chain yet, it makes no sense to have it.
  // eslint-disable-next-line no-param-reassign

  delete newMap.file; // eslint-disable-next-line no-param-reassign

  newMap.sourceRoot = ""; // eslint-disable-next-line no-param-reassign

  newMap.sources = newMap.sources.map(source => {
    if (source.indexOf("<") === 0) {
      return source;
    ***REMOVED***

    const sourceType = getURLType(source); // Do no touch `scheme-relative`, `path-absolute` and `absolute` types

    if (sourceType === "path-relative") {
      return _path.default.resolve(resourceContext, source);
    ***REMOVED***

    return source;
  ***REMOVED***);
  return newMap;
***REMOVED***

function findPackageJSONDir(cwd, statSync) {
  let dir = cwd;

  for (;;) {
    try {
      if (statSync(_path.default.join(dir, "package.json")).isFile()) {
        break;
      ***REMOVED***
    ***REMOVED*** catch (error) {// Nothing
    ***REMOVED***

    const parent = _path.default.dirname(dir);

    if (dir === parent) {
      dir = null;
      break;
    ***REMOVED***

    dir = parent;
  ***REMOVED***

  return dir;
***REMOVED***

function getPostcssImplementation(loaderContext, implementation) {
  let resolvedImplementation = implementation;

  if (!implementation || typeof implementation === "string") {
    const postcssImplPkg = implementation || "postcss";

    try {
      // eslint-disable-next-line import/no-dynamic-require, global-require
      resolvedImplementation = require(postcssImplPkg);
    ***REMOVED*** catch (error) {
      loaderContext.emitError(error); // eslint-disable-next-line consistent-return

      return;
    ***REMOVED***
  ***REMOVED*** // eslint-disable-next-line consistent-return


  return resolvedImplementation;
***REMOVED***