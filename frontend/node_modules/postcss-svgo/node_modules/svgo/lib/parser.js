'use strict';

/**
 * @typedef {import('./types').XastNode***REMOVED*** XastNode
 * @typedef {import('./types').XastInstruction***REMOVED*** XastInstruction
 * @typedef {import('./types').XastDoctype***REMOVED*** XastDoctype
 * @typedef {import('./types').XastComment***REMOVED*** XastComment
 * @typedef {import('./types').XastRoot***REMOVED*** XastRoot
 * @typedef {import('./types').XastElement***REMOVED*** XastElement
 * @typedef {import('./types').XastCdata***REMOVED*** XastCdata
 * @typedef {import('./types').XastText***REMOVED*** XastText
 * @typedef {import('./types').XastParent***REMOVED*** XastParent
 */

// @ts-ignore sax will be replaced with something else later
const SAX = require('@trysound/sax');
const JSAPI = require('./svgo/jsAPI.js');
const { textElems ***REMOVED*** = require('../plugins/_collections.js');

class SvgoParserError extends Error {
  /**
   * @param message {string***REMOVED***
   * @param line {number***REMOVED***
   * @param column {number***REMOVED***
   * @param source {string***REMOVED***
   * @param file {void | string***REMOVED***
   */
  constructor(message, line, column, source, file) {
    super(message);
    this.name = 'SvgoParserError';
    this.message = `${file || '<input>'***REMOVED***:${line***REMOVED***:${column***REMOVED***: ${message***REMOVED***`;
    this.reason = message;
    this.line = line;
    this.column = column;
    this.source = source;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, SvgoParserError);
    ***REMOVED***
  ***REMOVED***
  toString() {
    const lines = this.source.split(/\r?\n/);
    const startLine = Math.max(this.line - 3, 0);
    const endLine = Math.min(this.line + 2, lines.length);
    const lineNumberWidth = String(endLine).length;
    const startColumn = Math.max(this.column - 54, 0);
    const endColumn = Math.max(this.column + 20, 80);
    const code = lines
      .slice(startLine, endLine)
      .map((line, index) => {
        const lineSlice = line.slice(startColumn, endColumn);
        let ellipsisPrefix = '';
        let ellipsisSuffix = '';
        if (startColumn !== 0) {
          ellipsisPrefix = startColumn > line.length - 1 ? ' ' : '…';
        ***REMOVED***
        if (endColumn < line.length - 1) {
          ellipsisSuffix = '…';
        ***REMOVED***
        const number = startLine + 1 + index;
        const gutter = ` ${number.toString().padStart(lineNumberWidth)***REMOVED*** | `;
        if (number === this.line) {
          const gutterSpacing = gutter.replace(/[^|]/g, ' ');
          const lineSpacing = (
            ellipsisPrefix + line.slice(startColumn, this.column - 1)
          ).replace(/[^\t]/g, ' ');
          const spacing = gutterSpacing + lineSpacing;
          return `>${gutter***REMOVED***${ellipsisPrefix***REMOVED***${lineSlice***REMOVED***${ellipsisSuffix***REMOVED***\n ${spacing***REMOVED***^`;
        ***REMOVED***
        return ` ${gutter***REMOVED***${ellipsisPrefix***REMOVED***${lineSlice***REMOVED***${ellipsisSuffix***REMOVED***`;
      ***REMOVED***)
      .join('\n');
    return `${this.name***REMOVED***: ${this.message***REMOVED***\n\n${code***REMOVED***\n`;
  ***REMOVED***
***REMOVED***

const entityDeclaration = /<!ENTITY\s+(\S+)\s+(?:'([^']+)'|"([^"]+)")\s*>/g;

const config = {
  strict: true,
  trim: false,
  normalize: false,
  lowercase: true,
  xmlns: true,
  position: true,
***REMOVED***;

/**
 * Convert SVG (XML) string to SVG-as-JS object.
 *
 * @type {(data: string, from?: string) => XastRoot***REMOVED***
 */
const parseSvg = (data, from) => {
  const sax = SAX.parser(config.strict, config);
  /**
   * @type {XastRoot***REMOVED***
   */
  const root = new JSAPI({ type: 'root', children: [] ***REMOVED***);
  /**
   * @type {XastParent***REMOVED***
   */
  let current = root;
  /**
   * @type {Array<XastParent>***REMOVED***
   */
  const stack = [root];

  /**
   * @type {<T extends XastNode>(node: T) => T***REMOVED***
   */
  const pushToContent = (node) => {
    const wrapped = new JSAPI(node, current);
    current.children.push(wrapped);
    return wrapped;
  ***REMOVED***;

  /**
   * @type {(doctype: string) => void***REMOVED***
   */
  sax.ondoctype = (doctype) => {
    /**
     * @type {XastDoctype***REMOVED***
     */
    const node = {
      type: 'doctype',
      // TODO parse doctype for name, public and system to match xast
      name: 'svg',
      data: {
        doctype,
      ***REMOVED***,
    ***REMOVED***;
    pushToContent(node);
    const subsetStart = doctype.indexOf('[');
    if (subsetStart >= 0) {
      entityDeclaration.lastIndex = subsetStart;
      let entityMatch = entityDeclaration.exec(data);
      while (entityMatch != null) {
        sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];
        entityMatch = entityDeclaration.exec(data);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;

  /**
   * @type {(data: { name: string, body: string ***REMOVED***) => void***REMOVED***
   */
  sax.onprocessinginstruction = (data) => {
    /**
     * @type {XastInstruction***REMOVED***
     */
    const node = {
      type: 'instruction',
      name: data.name,
      value: data.body,
    ***REMOVED***;
    pushToContent(node);
  ***REMOVED***;

  /**
   * @type {(comment: string) => void***REMOVED***
   */
  sax.oncomment = (comment) => {
    /**
     * @type {XastComment***REMOVED***
     */
    const node = {
      type: 'comment',
      value: comment.trim(),
    ***REMOVED***;
    pushToContent(node);
  ***REMOVED***;

  /**
   * @type {(cdata: string) => void***REMOVED***
   */
  sax.oncdata = (cdata) => {
    /**
     * @type {XastCdata***REMOVED***
     */
    const node = {
      type: 'cdata',
      value: cdata,
    ***REMOVED***;
    pushToContent(node);
  ***REMOVED***;

  /**
   * @type {(data: { name: string, attributes: Record<string, { value: string ***REMOVED***>***REMOVED***) => void***REMOVED***
   */
  sax.onopentag = (data) => {
    /**
     * @type {XastElement***REMOVED***
     */
    let element = {
      type: 'element',
      name: data.name,
      attributes: {***REMOVED***,
      children: [],
    ***REMOVED***;
    for (const [name, attr] of Object.entries(data.attributes)) {
      element.attributes[name] = attr.value;
    ***REMOVED***
    element = pushToContent(element);
    current = element;
    stack.push(element);
  ***REMOVED***;

  /**
   * @type {(text: string) => void***REMOVED***
   */
  sax.ontext = (text) => {
    if (current.type === 'element') {
      // prevent trimming of meaningful whitespace inside textual tags
      if (textElems.includes(current.name)) {
        /**
         * @type {XastText***REMOVED***
         */
        const node = {
          type: 'text',
          value: text,
        ***REMOVED***;
        pushToContent(node);
      ***REMOVED*** else if (/\S/.test(text)) {
        /**
         * @type {XastText***REMOVED***
         */
        const node = {
          type: 'text',
          value: text.trim(),
        ***REMOVED***;
        pushToContent(node);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;

  sax.onclosetag = () => {
    stack.pop();
    current = stack[stack.length - 1];
  ***REMOVED***;

  /**
   * @type {(e: any) => void***REMOVED***
   */
  sax.onerror = (e) => {
    const error = new SvgoParserError(
      e.reason,
      e.line + 1,
      e.column,
      data,
      from
    );
    if (e.message.indexOf('Unexpected end') === -1) {
      throw error;
    ***REMOVED***
  ***REMOVED***;

  sax.write(data).close();
  return root;
***REMOVED***;
exports.parseSvg = parseSvg;
