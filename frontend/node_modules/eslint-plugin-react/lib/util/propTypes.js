/**
 * @fileoverview Common propTypes detection functionality.
 */

'use strict';

const flatMap = require('array.prototype.flatmap');

const annotations = require('./annotations');
const propsUtil = require('./props');
const variableUtil = require('./variable');
const testFlowVersion = require('./version').testFlowVersion;
const propWrapperUtil = require('./propWrapper');
const astUtil = require('./ast');
const isFirstLetterCapitalized = require('./isFirstLetterCapitalized');
const eslintUtil = require('./eslint');

const getFirstTokens = eslintUtil.getFirstTokens;
const getScope = eslintUtil.getScope;
const getSourceCode = eslintUtil.getSourceCode;
const getText = eslintUtil.getText;

/**
 * Check if node is function type.
 * @param {ASTNode***REMOVED*** node
 * @returns {boolean***REMOVED***
 */
function isFunctionType(node) {
  if (!node) return false;
  const nodeType = node.type;
  return nodeType === 'FunctionDeclaration'
    || nodeType === 'FunctionExpression'
    || nodeType === 'ArrowFunctionExpression';
***REMOVED***

/**
 * Checks if we are declaring a props as a generic type in a flow-annotated class.
 *
 * @param {ASTNode***REMOVED*** node  the AST node being checked.
 * @returns {boolean***REMOVED*** True if the node is a class with generic prop types, false if not.
 */
function isSuperTypeParameterPropsDeclaration(node) {
  if (node && (node.type === 'ClassDeclaration' || node.type === 'ClassExpression')) {
    const parameters = propsUtil.getSuperTypeArguments(node);
    if (parameters && parameters.params.length > 0) {
      return true;
    ***REMOVED***
  ***REMOVED***
  return false;
***REMOVED***

/**
 * Iterates through a properties node, like a customized forEach.
 * @param {Object***REMOVED*** context Array of properties to iterate.
 * @param {Object[]***REMOVED*** properties Array of properties to iterate.
 * @param {Function***REMOVED*** fn Function to call on each property, receives property key
    and property value. (key, value) => void
  * @param {Function***REMOVED*** [handleSpreadFn] Function to call on each ObjectTypeSpreadProperty, receives the
    argument
 */
function iterateProperties(context, properties, fn, handleSpreadFn) {
  if (properties && properties.length && typeof fn === 'function') {
    for (let i = 0, j = properties.length; i < j; i++) {
      const node = properties[i];
      const key = astUtil.getKeyValue(context, node);

      if (node.type === 'ObjectTypeSpreadProperty' && typeof handleSpreadFn === 'function') {
        handleSpreadFn(node.argument);
      ***REMOVED***

      const value = node.value;
      fn(key, value, node);
    ***REMOVED***
  ***REMOVED***
***REMOVED***

/**
 * Checks if a node is inside a class body.
 *
 * @param {ASTNode***REMOVED*** node the AST node being checked.
 * @returns {boolean***REMOVED*** True if the node has a ClassBody ancestor, false if not.
 */
function isInsideClassBody(node) {
  let parent = node.parent;
  while (parent) {
    if (parent.type === 'ClassBody') {
      return true;
    ***REMOVED***
    parent = parent.parent;
  ***REMOVED***
  return false;
***REMOVED***

function startWithCapitalizedLetter(node) {
  return (
    node.parent.type === 'VariableDeclarator'
    && !isFirstLetterCapitalized(node.parent.id.name)
  );
***REMOVED***

module.exports = function propTypesInstructions(context, components, utils) {
  // Used to track the type annotations in scope.
  // Necessary because babel's scopes do not track type annotations.
  let stack = null;

  const classExpressions = [];
  const defaults = { customValidators: [] ***REMOVED***;
  const configuration = Object.assign({***REMOVED***, defaults, context.options[0] || {***REMOVED***);
  const customValidators = configuration.customValidators;
  const allowedGenericTypes = new Set(['ComponentProps', 'ComponentPropsWithRef', 'ComponentPropsWithoutRef', 'forwardRef', 'ForwardRefRenderFunction', 'VFC', 'VoidFunctionComponent', 'PropsWithChildren', 'SFC', 'StatelessComponent', 'FunctionComponent', 'FC']);
  const genericTypeParamIndexWherePropsArePresent = {
    ComponentProps: 0,
    ComponentPropsWithRef: 0,
    ComponentPropsWithoutRef: 0,
    ForwardRefRenderFunction: 1,
    forwardRef: 1,
    VoidFunctionComponent: 0,
    VFC: 0,
    PropsWithChildren: 0,
    SFC: 0,
    StatelessComponent: 0,
    FunctionComponent: 0,
    FC: 0,
  ***REMOVED***;
  const genericReactTypesImport = new Set();
  // import { FC as X ***REMOVED*** from 'react' -> localToImportedMap = { x: FC ***REMOVED***
  const localToImportedMap = {***REMOVED***;

  /**
   * Returns the full scope.
   * @returns {Object***REMOVED*** The whole scope.
   */
  function typeScope() {
    return stack[stack.length - 1];
  ***REMOVED***

  /**
   * Gets a node from the scope.
   * @param {string***REMOVED*** key The name of the identifier to access.
   * @returns {ASTNode***REMOVED*** The ASTNode associated with the given identifier.
   */
  function getInTypeScope(key) {
    return stack[stack.length - 1][key];
  ***REMOVED***

  /**
   * Sets the new value in the scope.
   * @param {string***REMOVED*** key The name of the identifier to access
   * @param {ASTNode***REMOVED*** value The new value for the identifier.
   * @returns {ASTNode***REMOVED*** The ASTNode associated with the given identifier.
   */
  function setInTypeScope(key, value) {
    stack[stack.length - 1][key] = value;
    return value;
  ***REMOVED***

  /**
   * Checks if prop should be validated by plugin-react-proptypes
   * @param {string***REMOVED*** validator Name of validator to check.
   * @returns {boolean***REMOVED*** True if validator should be checked by custom validator.
   */
  function hasCustomValidator(validator) {
    return customValidators.indexOf(validator) !== -1;
  ***REMOVED***

  /* eslint-disable no-use-before-define */
  /** @type {TypeDeclarationBuilders***REMOVED*** */
  const typeDeclarationBuilders = {
    GenericTypeAnnotation(annotation, parentName, seen) {
      if (getInTypeScope(annotation.id.name)) {
        return buildTypeAnnotationDeclarationTypes(getInTypeScope(annotation.id.name), parentName, seen);
      ***REMOVED***
      return {***REMOVED***;
    ***REMOVED***,

    ObjectTypeAnnotation(annotation, parentName, seen) {
      let containsUnresolvedObjectTypeSpread = false;
      let containsSpread = false;
      const containsIndexers = !!annotation.indexers && annotation.indexers.length > 0;
      const shapeTypeDefinition = {
        type: 'shape',
        children: {***REMOVED***,
      ***REMOVED***;
      iterateProperties(
        context,
        annotation.properties,
        (childKey, childValue, propNode) => {
          const fullName = [parentName, childKey].join('.');
          if (childKey || childValue) {
            const types = buildTypeAnnotationDeclarationTypes(childValue, fullName, seen);
            types.fullName = fullName;
            types.name = childKey;
            types.node = propNode;
            types.isRequired = !childValue.optional;
            shapeTypeDefinition.children[childKey] = types;
          ***REMOVED***
        ***REMOVED***,
        (spreadNode) => {
          const key = astUtil.getKeyValue(context, spreadNode);
          const types = buildTypeAnnotationDeclarationTypes(spreadNode, key, seen);
          if (!types.children) {
            containsUnresolvedObjectTypeSpread = true;
          ***REMOVED*** else {
            Object.assign(shapeTypeDefinition, types.children);
          ***REMOVED***
          containsSpread = true;
        ***REMOVED***
      );

      // Mark if this shape has spread or an indexer. We will know to consider all props from this shape as having propTypes,
      // but still have the ability to detect unused children of this shape.
      shapeTypeDefinition.containsUnresolvedSpread = containsUnresolvedObjectTypeSpread;
      shapeTypeDefinition.containsIndexers = containsIndexers;
      // Deprecated: containsSpread is not used anymore in the codebase, ensure to keep API backward compatibility
      shapeTypeDefinition.containsSpread = containsSpread;

      return shapeTypeDefinition;
    ***REMOVED***,

    UnionTypeAnnotation(annotation, parentName, seen) {
      /** @type {UnionTypeDefinition***REMOVED*** */
      const unionTypeDefinition = {
        type: 'union',
        children: annotation.types.map((type) => buildTypeAnnotationDeclarationTypes(type, parentName, seen)),
      ***REMOVED***;
      if (unionTypeDefinition.children.length === 0) {
        // no complex type found, simply accept everything
        return {***REMOVED***;
      ***REMOVED***
      return unionTypeDefinition;
    ***REMOVED***,

    ArrayTypeAnnotation(annotation, parentName, seen) {
      const fullName = [parentName, '*'].join('.');
      const child = buildTypeAnnotationDeclarationTypes(annotation.elementType, fullName, seen);
      child.fullName = fullName;
      child.name = '__ANY_KEY__';
      child.node = annotation;
      return {
        type: 'object',
        children: {
          __ANY_KEY__: child,
        ***REMOVED***,
      ***REMOVED***;
    ***REMOVED***,
  ***REMOVED***;
  /* eslint-enable no-use-before-define */

  /**
   * Resolve the type annotation for a given node.
   * Flow annotations are sometimes wrapped in outer `TypeAnnotation`
   * and `NullableTypeAnnotation` nodes which obscure the annotation we're
   * interested in.
   * This method also resolves type aliases where possible.
   *
   * @param {ASTNode***REMOVED*** node The annotation or a node containing the type annotation.
   * @returns {ASTNode***REMOVED*** The resolved type annotation for the node.
   */
  function resolveTypeAnnotation(node) {
    let annotation = (node.left && node.left.typeAnnotation) || node.typeAnnotation || node;
    while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {
      annotation = annotation.typeAnnotation;
    ***REMOVED***
    if (annotation.type === 'GenericTypeAnnotation' && getInTypeScope(annotation.id.name)) {
      return getInTypeScope(annotation.id.name);
    ***REMOVED***
    return annotation;
  ***REMOVED***

  /**
   * Creates the representation of the React props type annotation for the component.
   * The representation is used to verify nested used properties.
   * @param {ASTNode***REMOVED*** annotation Type annotation for the props class property.
   * @param {string***REMOVED*** parentName
   * @param {Set<ASTNode>***REMOVED*** [seen]
   * @return {Object***REMOVED*** The representation of the declaration, empty object means
   *    the property is declared without the need for further analysis.
   */
  function buildTypeAnnotationDeclarationTypes(annotation, parentName, seen) {
    if (typeof seen === 'undefined') {
      // Keeps track of annotations we've already seen to
      // prevent problems with recursive types.
      seen = new Set();
    ***REMOVED***
    if (seen.has(annotation)) {
      // This must be a recursive type annotation, so just accept anything.
      return {***REMOVED***;
    ***REMOVED***
    seen.add(annotation);

    if (annotation.type in typeDeclarationBuilders) {
      return typeDeclarationBuilders[annotation.type](annotation, parentName, seen);
    ***REMOVED***
    return {***REMOVED***;
  ***REMOVED***

  /**
   * Marks all props found inside ObjectTypeAnnotation as declared.
   *
   * Modifies the declaredProperties object
   * @param {ASTNode***REMOVED*** propTypes
   * @param {Object***REMOVED*** declaredPropTypes
   * @returns {boolean***REMOVED*** True if propTypes should be ignored (e.g. when a type can't be resolved, when it is imported)
   */
  function declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes) {
    let ignorePropsValidation = false;

    iterateProperties(context, propTypes.properties, (key, value, propNode) => {
      if (!value) {
        ignorePropsValidation = ignorePropsValidation || propNode.type !== 'ObjectTypeSpreadProperty';
        return;
      ***REMOVED***

      const types = buildTypeAnnotationDeclarationTypes(value, key);
      types.fullName = key;
      types.name = key;
      types.node = propNode;
      types.isRequired = !propNode.optional;
      declaredPropTypes[key] = types;
    ***REMOVED***, (spreadNode) => {
      const key = astUtil.getKeyValue(context, spreadNode);
      const spreadAnnotation = getInTypeScope(key);
      if (!spreadAnnotation) {
        ignorePropsValidation = true;
      ***REMOVED*** else {
        const spreadIgnoreValidation = declarePropTypesForObjectTypeAnnotation(spreadAnnotation, declaredPropTypes);
        ignorePropsValidation = ignorePropsValidation || spreadIgnoreValidation;
      ***REMOVED***
    ***REMOVED***);

    return ignorePropsValidation;
  ***REMOVED***

  /**
   * Marks all props found inside IntersectionTypeAnnotation as declared.
   * Since InterSectionTypeAnnotations can be nested, this handles recursively.
   *
   * Modifies the declaredPropTypes object
   * @param {ASTNode***REMOVED*** propTypes
   * @param {Object***REMOVED*** declaredPropTypes
   * @returns {boolean***REMOVED*** True if propTypes should be ignored (e.g. when a type can't be resolved, when it is imported)
   */
  function declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes) {
    return propTypes.types.some((annotation) => {
      if (annotation.type === 'ObjectTypeAnnotation') {
        return declarePropTypesForObjectTypeAnnotation(annotation, declaredPropTypes);
      ***REMOVED***

      if (annotation.type === 'UnionTypeAnnotation') {
        return true;
      ***REMOVED***

      // Type can't be resolved
      if (!annotation.id) {
        return true;
      ***REMOVED***

      const typeNode = getInTypeScope(annotation.id.name);

      if (!typeNode) {
        return true;
      ***REMOVED***
      if (typeNode.type === 'IntersectionTypeAnnotation') {
        return declarePropTypesForIntersectionTypeAnnotation(typeNode, declaredPropTypes);
      ***REMOVED***

      return declarePropTypesForObjectTypeAnnotation(typeNode, declaredPropTypes);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Resolve node of type Identifier when building declaration types.
   * @param {ASTNode***REMOVED*** node
   * @param {ASTNode***REMOVED*** rootNode
   * @param {Function***REMOVED*** callback called with the resolved value only if resolved.
   */
  function resolveValueForIdentifierNode(node, rootNode, callback) {
    if (
      rootNode
      && node
      && node.type === 'Identifier'
    ) {
      const scope = getScope(context, rootNode);
      const identVariable = scope.variableScope.variables.find(
        (variable) => variable.name === node.name
      );
      if (identVariable) {
        const definition = identVariable.defs[identVariable.defs.length - 1];
        callback(definition.node.init);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  /**
   * Creates the representation of the React propTypes for the component.
   * The representation is used to verify nested used properties.
   * @param {ASTNode***REMOVED*** value Node of the PropTypes for the desired property
   * @param {string***REMOVED*** parentName
   * @param {ASTNode***REMOVED*** rootNode
   * @return {Object***REMOVED*** The representation of the declaration, empty object means
   *    the property is declared without the need for further analysis.
   */
  function buildReactDeclarationTypes(value, parentName, rootNode) {
    if (
      value
      && value.callee
      && value.callee.object
      && hasCustomValidator(value.callee.object.name)
    ) {
      return {***REMOVED***;
    ***REMOVED***

    let identNodeResolved = false;
    // Resolve identifier node for cases where isRequired is set in
    // the variable declaration or not at all.
    // const variableType = PropTypes.shape({ foo: ... ***REMOVED***).isRequired
    // propTypes = {
    //   example: variableType
    // ***REMOVED***
    // --------
    // const variableType = PropTypes.shape({ foo: ... ***REMOVED***)
    // propTypes = {
    //   example: variableType
    // ***REMOVED***
    resolveValueForIdentifierNode(value, rootNode, (newValue) => {
      identNodeResolved = true;
      value = newValue;
    ***REMOVED***);

    if (
      value
      && value.type === 'MemberExpression'
      && value.property
      && value.property.name === 'isRequired'
    ) {
      value = value.object;
    ***REMOVED***

    // Resolve identifier node for cases where isRequired is set in
    // the prop types.
    // const variableType = PropTypes.shape({ foo: ... ***REMOVED***)
    // propTypes = {
    //   example: variableType.isRequired
    // ***REMOVED***
    if (!identNodeResolved) {
      resolveValueForIdentifierNode(value, rootNode, (newValue) => {
        value = newValue;
      ***REMOVED***);
    ***REMOVED***

    // Verify PropTypes that are functions
    if (
      astUtil.isCallExpression(value)
      && value.callee
      && value.callee.property
      && value.callee.property.name
      && value.arguments
      && value.arguments.length > 0
    ) {
      const callName = value.callee.property.name;
      const argument = value.arguments[0];
      switch (callName) {
        case 'shape':
        case 'exact': {
          if (argument.type !== 'ObjectExpression') {
            // Invalid proptype or cannot analyse statically
            return {***REMOVED***;
          ***REMOVED***
          const shapeTypeDefinition = {
            type: callName,
            children: {***REMOVED***,
          ***REMOVED***;
          iterateProperties(context, argument.properties, (childKey, childValue, propNode) => {
            if (childValue) { // skip spread propTypes
              const fullName = [parentName, childKey].join('.');
              const types = buildReactDeclarationTypes(childValue, fullName, rootNode);
              types.fullName = fullName;
              types.name = childKey;
              types.node = propNode;
              shapeTypeDefinition.children[childKey] = types;
            ***REMOVED***
          ***REMOVED***);
          return shapeTypeDefinition;
        ***REMOVED***
        case 'arrayOf':
        case 'objectOf': {
          const fullName = [parentName, '*'].join('.');
          const child = buildReactDeclarationTypes(argument, fullName, rootNode);
          child.fullName = fullName;
          child.name = '__ANY_KEY__';
          child.node = argument;
          return {
            type: 'object',
            children: {
              __ANY_KEY__: child,
            ***REMOVED***,
          ***REMOVED***;
        ***REMOVED***
        case 'oneOfType': {
          if (
            !argument.elements
            || argument.elements.length === 0
          ) {
            // Invalid proptype or cannot analyse statically
            return {***REMOVED***;
          ***REMOVED***

          /** @type {UnionTypeDefinition***REMOVED*** */
          const unionTypeDefinition = {
            type: 'union',
            children: argument.elements.map((element) => buildReactDeclarationTypes(element, parentName, rootNode)),
          ***REMOVED***;
          if (unionTypeDefinition.children.length === 0) {
            // no complex type found, simply accept everything
            return {***REMOVED***;
          ***REMOVED***
          return unionTypeDefinition;
        ***REMOVED***
        default:
          return {***REMOVED***;
      ***REMOVED***
    ***REMOVED***
    // Unknown property or accepts everything (any, object, ...)
    return {***REMOVED***;
  ***REMOVED***

  function isValidReactGenericTypeAnnotation(annotation) {
    if (annotation.typeName) {
      if (annotation.typeName.name) { // if FC<Props>
        const typeName = annotation.typeName.name;
        if (!genericReactTypesImport.has(typeName)) {
          return false;
        ***REMOVED***
      ***REMOVED*** else if (annotation.typeName.right.name) { // if React.FC<Props>
        const right = annotation.typeName.right.name;
        const left = annotation.typeName.left.name;

        if (!genericReactTypesImport.has(left) || !allowedGenericTypes.has(right)) {
          return false;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    return true;
  ***REMOVED***

  /**
   * Returns the left most typeName of a node, e.g: FC<Props>, React.FC<Props>
   * The representation is used to verify nested used properties.
   * @param {ASTNode***REMOVED*** node
   * @return {string | undefined***REMOVED***
   */
  function getLeftMostTypeName(node) {
    if (node.name) return node.name;
    if (node.left) return getLeftMostTypeName(node.left);
  ***REMOVED***

  function getRightMostTypeName(node) {
    if (node.name) return node.name;
    if (node.right) return getRightMostTypeName(node.right);
  ***REMOVED***

  /**
   * Returns true if the node is either a interface or type alias declaration
   * @param {ASTNode***REMOVED*** node
   * @return {boolean***REMOVED***
   */
  function filterInterfaceOrTypeAlias(node) {
    return (
      astUtil.isTSInterfaceDeclaration(node) || astUtil.isTSTypeAliasDeclaration(node)
    );
  ***REMOVED***

  /**
   * Returns true if the interface or type alias declaration node name matches the type-name str
   * @param {ASTNode***REMOVED*** node
   * @param {string***REMOVED*** typeName
   * @return {boolean***REMOVED***
   */
  function filterInterfaceOrAliasByName(node, typeName) {
    return (
      node.id
      && node.id.name === typeName
    ) || (
      node.declaration
      && node.declaration.id
      && node.declaration.id.name === typeName
    );
  ***REMOVED***

  class DeclarePropTypesForTSTypeAnnotation {
    constructor(propTypes, declaredPropTypes, rootNode) {
      this.propTypes = propTypes;
      this.declaredPropTypes = declaredPropTypes;
      this.foundDeclaredPropertiesList = [];
      this.referenceNameMap = new Set();
      this.sourceCode = getSourceCode(context);
      this.shouldIgnorePropTypes = false;
      this.rootNode = rootNode;
      this.visitTSNode(this.propTypes);
      this.endAndStructDeclaredPropTypes();
    ***REMOVED***

    /**
     * The node will be distribute to different function.
     * @param {ASTNode***REMOVED*** node
     */
    visitTSNode(node) {
      if (!node) return;
      if (astUtil.isTSTypeAnnotation(node)) {
        const typeAnnotation = node.typeAnnotation;
        this.visitTSNode(typeAnnotation);
      ***REMOVED*** else if (astUtil.isTSTypeReference(node)) {
        this.searchDeclarationByName(node);
      ***REMOVED*** else if (astUtil.isTSInterfaceHeritage(node)) {
        this.searchDeclarationByName(node);
      ***REMOVED*** else if (astUtil.isTSTypeLiteral(node)) {
        // Check node is an object literal
        if (Array.isArray(node.members)) {
          this.foundDeclaredPropertiesList = this.foundDeclaredPropertiesList.concat(node.members);
        ***REMOVED***
      ***REMOVED*** else if (astUtil.isTSIntersectionType(node)) {
        this.convertIntersectionTypeToPropTypes(node);
      ***REMOVED*** else if (astUtil.isTSParenthesizedType(node)) {
        const typeAnnotation = node.typeAnnotation;
        this.visitTSNode(typeAnnotation);
      ***REMOVED*** else if (astUtil.isTSTypeParameterInstantiation(node)) {
        if (Array.isArray(node.params)) {
          node.params.forEach((x) => this.visitTSNode(x));
        ***REMOVED***
      ***REMOVED*** else {
        this.shouldIgnorePropTypes = true;
      ***REMOVED***
    ***REMOVED***

    /**
     * Search TSInterfaceDeclaration or TSTypeAliasDeclaration,
     * by using TSTypeReference and TSInterfaceHeritage name.
     * @param {ASTNode***REMOVED*** node
     */
    searchDeclarationByName(node) {
      let typeName;
      if (astUtil.isTSTypeReference(node)) {
        typeName = node.typeName.name;
        const leftMostName = getLeftMostTypeName(node.typeName);
        const shouldTraverseTypeParams = genericReactTypesImport.has(leftMostName);
        const nodeTypeArguments = propsUtil.getTypeArguments(node);
        if (shouldTraverseTypeParams && nodeTypeArguments && nodeTypeArguments.length !== 0) {
          // All react Generic types are derived from:
          // type PropsWithChildren<P> = P & { children?: ReactNode | undefined ***REMOVED***
          // So we should construct an optional children prop
          this.shouldSpecifyOptionalChildrenProps = true;

          const rightMostName = getRightMostTypeName(node.typeName);
          if (
            leftMostName === 'React'
            && (
              rightMostName === 'HTMLAttributes'
              || rightMostName === 'HTMLElement'
              || rightMostName === 'HTMLProps'
            )
          ) {
            this.shouldSpecifyClassNameProp = true;
          ***REMOVED***

          const importedName = localToImportedMap[rightMostName];
          const idx = genericTypeParamIndexWherePropsArePresent[
            leftMostName !== rightMostName ? rightMostName : importedName
          ];
          const nextNode = nodeTypeArguments.params[idx];
          this.visitTSNode(nextNode);
          return;
        ***REMOVED***
      ***REMOVED*** else if (astUtil.isTSInterfaceHeritage(node)) {
        if (!node.expression && node.id) {
          typeName = node.id.name;
        ***REMOVED*** else {
          typeName = node.expression.name;
        ***REMOVED***
      ***REMOVED***
      if (!typeName) {
        this.shouldIgnorePropTypes = true;
        return;
      ***REMOVED***
      if (typeName === 'ReturnType') {
        this.convertReturnTypeToPropTypes(node, this.rootNode);
        return;
      ***REMOVED***
      // Prevent recursive inheritance will cause maximum callstack.
      if (this.referenceNameMap.has(typeName)) {
        this.shouldIgnorePropTypes = true;
        return;
      ***REMOVED***
      // Add typeName to Set and consider it as traversed.
      this.referenceNameMap.add(typeName);

      /**
       * From line 577 to line 581, and line 588 to line 590 are trying to handle typescript-eslint-parser
       * Need to be deprecated after remove typescript-eslint-parser support.
       */
      const candidateTypes = this.sourceCode.ast.body.filter((item) => astUtil.isTSTypeDeclaration(item));

      const declarations = flatMap(
        candidateTypes,
        (type) => (
          type.declarations
          || (
            type.declaration
            && type.declaration.declarations
          )
          || type.declaration
        )
      );

      // we tried to find either an interface or a type with the TypeReference name
      const typeDeclaration = declarations.filter((dec) => dec.id.name === typeName);

      const interfaceDeclarations = this.sourceCode.ast.body
        .filter(filterInterfaceOrTypeAlias)
        .filter((item) => filterInterfaceOrAliasByName(item, typeName))
        .map((item) => (item.declaration || item));

      if (typeDeclaration.length !== 0) {
        typeDeclaration.map((t) => t.init || t.typeAnnotation).forEach(this.visitTSNode, this);
      ***REMOVED*** else if (interfaceDeclarations.length !== 0) {
        interfaceDeclarations.forEach(this.traverseDeclaredInterfaceOrTypeAlias, this);
      ***REMOVED*** else {
        this.shouldIgnorePropTypes = true;
      ***REMOVED***
    ***REMOVED***

    /**
     * Traverse TSInterfaceDeclaration and TSTypeAliasDeclaration
     * which retrieve from function searchDeclarationByName;
     * @param {ASTNode***REMOVED*** node
     */
    traverseDeclaredInterfaceOrTypeAlias(node) {
      if (astUtil.isTSInterfaceDeclaration(node)) {
        // Handle TSInterfaceDeclaration interface Props { name: string, id: number***REMOVED***, should put in properties list directly;
        this.foundDeclaredPropertiesList = this.foundDeclaredPropertiesList.concat(node.body.body);
      ***REMOVED***
      // Handle TSTypeAliasDeclaration type Props = {name:string***REMOVED***
      if (astUtil.isTSTypeAliasDeclaration(node)) {
        const typeAnnotation = node.typeAnnotation;
        this.visitTSNode(typeAnnotation);
      ***REMOVED***
      if (Array.isArray(node.extends)) {
        node.extends.forEach((x) => this.visitTSNode(x));
        // This line is trying to handle typescript-eslint-parser
        // typescript-eslint-parser extension is name as heritage
      ***REMOVED*** else if (Array.isArray(node.heritage)) {
        node.heritage.forEach((x) => this.visitTSNode(x));
      ***REMOVED***
    ***REMOVED***

    convertIntersectionTypeToPropTypes(node) {
      if (!node) return;
      if (Array.isArray(node.types)) {
        node.types.forEach((x) => this.visitTSNode(x));
      ***REMOVED*** else {
        this.shouldIgnorePropTypes = true;
      ***REMOVED***
    ***REMOVED***

    convertReturnTypeToPropTypes(node, rootNode) {
      // ReturnType<T> should always have one parameter
      const nodeTypeArguments = propsUtil.getTypeArguments(node);
      if (nodeTypeArguments) {
        if (nodeTypeArguments.params.length === 1) {
          let returnType = nodeTypeArguments.params[0];
          // This line is trying to handle typescript-eslint-parser
          // typescript-eslint-parser TSTypeQuery is wrapped by TSTypeReference
          if (astUtil.isTSTypeReference(returnType)) {
            returnType = returnType.typeName;
          ***REMOVED***
          // Handle ReturnType<typeof mapStateToProps>
          if (astUtil.isTSTypeQuery(returnType)) {
            const returnTypeFunction = flatMap(this.sourceCode.ast.body
              .filter((item) => item.type === 'VariableDeclaration'
                && item.declarations.find((dec) => dec.id.name === returnType.exprName.name)
              ), (type) => type.declarations).map((dec) => dec.init);

            if (Array.isArray(returnTypeFunction)) {
              if (returnTypeFunction.length === 0) {
                // Cannot find identifier in current scope. It might be an exported type.
                this.shouldIgnorePropTypes = true;
                return;
              ***REMOVED***
              returnTypeFunction.forEach((func) => {
                if (isFunctionType(func)) {
                  let res = func.body;
                  if (res.type === 'BlockStatement') {
                    res = astUtil.findReturnStatement(func);
                    if (res) {
                      res = res.argument;
                    ***REMOVED***
                  ***REMOVED***
                  switch (res.type) {
                    case 'ObjectExpression':
                      iterateProperties(context, res.properties, (key, value, propNode) => {
                        if (propNode && astUtil.isCallExpression(propNode.argument)) {
                          const propNodeTypeArguments = propsUtil.getTypeArguments(propNode.argument);
                          if (propNodeTypeArguments) {
                            this.visitTSNode(propNodeTypeArguments);
                          ***REMOVED*** else {
                            // Ignore this CallExpression return value since it doesn't have any typeParameters to let us know it's types.
                            this.shouldIgnorePropTypes = true;
                            return;
                          ***REMOVED***
                        ***REMOVED***
                        if (!value) {
                          this.shouldIgnorePropTypes = true;
                          return;
                        ***REMOVED***
                        const types = buildReactDeclarationTypes(value, key, rootNode);
                        types.fullName = key;
                        types.name = key;
                        types.node = propNode;
                        types.isRequired = propsUtil.isRequiredPropType(value);
                        this.declaredPropTypes[key] = types;
                      ***REMOVED***);
                      break;
                    case 'CallExpression':
                      if (propsUtil.getTypeArguments(res)) {
                        this.visitTSNode(propsUtil.getTypeArguments(res));
                      ***REMOVED*** else {
                        // Ignore this CallExpression return value since it doesn't have any typeParameters to let us know it's types.
                        this.shouldIgnorePropTypes = true;
                      ***REMOVED***
                      break;
                    default:
                  ***REMOVED***
                ***REMOVED***
              ***REMOVED***);
              return;
            ***REMOVED***
          ***REMOVED***
          // Handle ReturnType<()=>returnType>
          if (astUtil.isTSFunctionType(returnType)) {
            if (astUtil.isTSTypeAnnotation(returnType.returnType)) {
              this.visitTSNode(returnType.returnType);
              return;
            ***REMOVED***
            // This line is trying to handle typescript-eslint-parser
            // typescript-eslint-parser TSFunction name returnType as typeAnnotation
            if (astUtil.isTSTypeAnnotation(returnType.typeAnnotation)) {
              this.visitTSNode(returnType.typeAnnotation);
              return;
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      this.shouldIgnorePropTypes = true;
    ***REMOVED***

    endAndStructDeclaredPropTypes() {
      if (this.shouldSpecifyOptionalChildrenProps) {
        this.declaredPropTypes.children = {
          fullName: 'children',
          name: 'children',
          isRequired: false,
        ***REMOVED***;
      ***REMOVED***
      if (this.shouldSpecifyClassNameProp) {
        this.declaredPropTypes.className = {
          fullName: 'className',
          name: 'className',
          isRequired: false,
        ***REMOVED***;
      ***REMOVED***

      this.foundDeclaredPropertiesList.forEach((tsInterfaceBody) => {
        if (tsInterfaceBody && (tsInterfaceBody.type === 'TSPropertySignature' || tsInterfaceBody.type === 'TSMethodSignature')) {
          let accessor = 'name';
          if (tsInterfaceBody.key.type === 'Literal') {
            if (typeof tsInterfaceBody.key.value === 'number') {
              accessor = 'raw';
            ***REMOVED*** else {
              accessor = 'value';
            ***REMOVED***
          ***REMOVED***
          this.declaredPropTypes[tsInterfaceBody.key[accessor]] = {
            fullName: tsInterfaceBody.key[accessor],
            name: tsInterfaceBody.key[accessor],
            node: tsInterfaceBody,
            isRequired: !tsInterfaceBody.optional,
          ***REMOVED***;
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  /**
   * Mark a prop type as declared
   * @param {ASTNode***REMOVED*** node The AST node being checked.
   * @param {ASTNode***REMOVED*** propTypes The AST node containing the proptypes
   * @param {ASTNode***REMOVED*** rootNode
   */
  function markPropTypesAsDeclared(node, propTypes, rootNode) {
    let componentNode = node;
    while (componentNode && !components.get(componentNode)) {
      componentNode = componentNode.parent;
    ***REMOVED***
    const component = components.get(componentNode);
    let declaredPropTypes = (component && component.declaredPropTypes) || {***REMOVED***;
    let ignorePropsValidation = (component && component.ignorePropsValidation) || false;
    switch (propTypes && propTypes.type) {
      case 'ObjectTypeAnnotation':
        ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(propTypes, declaredPropTypes);
        break;
      case 'ObjectExpression':
        iterateProperties(context, propTypes.properties, (key, value, propNode) => {
          if (!value) {
            ignorePropsValidation = true;
            return;
          ***REMOVED***
          const types = buildReactDeclarationTypes(value, key, rootNode);
          types.fullName = key;
          types.name = key;
          types.node = propNode;
          types.isRequired = propsUtil.isRequiredPropType(value);
          declaredPropTypes[key] = types;
        ***REMOVED***);
        break;
      case 'MemberExpression': {
        let curDeclaredPropTypes = declaredPropTypes;
        // Walk the list of properties, until we reach the assignment
        // ie: ClassX.propTypes.a.b.c = ...
        while (
          propTypes
          && propTypes.parent
          && propTypes.parent.type !== 'AssignmentExpression'
          && propTypes.property
          && curDeclaredPropTypes
        ) {
          const propName = propTypes.property.name;
          if (propName in curDeclaredPropTypes) {
            curDeclaredPropTypes = curDeclaredPropTypes[propName].children;
            propTypes = propTypes.parent;
          ***REMOVED*** else {
            // This will crash at runtime because we haven't seen this key before
            // stop this and do not declare it
            propTypes = null;
          ***REMOVED***
        ***REMOVED***
        if (propTypes && propTypes.parent && propTypes.property) {
          if (!(propTypes === propTypes.parent.left && propTypes.parent.left.object)) {
            ignorePropsValidation = true;
            break;
          ***REMOVED***
          const parentProp = getText(context, propTypes.parent.left.object).replace(/^.*\.propTypes\./, '');
          const types = buildReactDeclarationTypes(
            propTypes.parent.right,
            parentProp,
            rootNode
          );

          types.name = propTypes.property.name;
          types.fullName = [parentProp, propTypes.property.name].join('.');
          types.node = propTypes.parent;
          types.isRequired = propsUtil.isRequiredPropType(propTypes.parent.right);
          curDeclaredPropTypes[propTypes.property.name] = types;
        ***REMOVED*** else {
          let isUsedInPropTypes = false;
          let n = propTypes;
          while (n) {
            if (((n.type === 'AssignmentExpression') && propsUtil.isPropTypesDeclaration(n.left))
              || ((n.type === 'ClassProperty' || n.type === 'PropertyDefinition' || n.type === 'Property') && propsUtil.isPropTypesDeclaration(n))) {
              // Found a propType used inside of another propType. This is not considered usage, we'll still validate
              // this component.
              isUsedInPropTypes = true;
              break;
            ***REMOVED***
            n = n.parent;
          ***REMOVED***
          if (!isUsedInPropTypes) {
            ignorePropsValidation = true;
          ***REMOVED***
        ***REMOVED***
        break;
      ***REMOVED***
      case 'Identifier': {
        const firstMatchingVariable = variableUtil.getVariableFromContext(context, node, propTypes.name);
        if (firstMatchingVariable) {
          const defInScope = firstMatchingVariable.defs[firstMatchingVariable.defs.length - 1];
          markPropTypesAsDeclared(node, defInScope.node && defInScope.node.init, rootNode);
          return;
        ***REMOVED***
        ignorePropsValidation = true;
        break;
      ***REMOVED***
      case 'CallExpression': {
        if (
          propWrapperUtil.isPropWrapperFunction(
            context,
            getText(context, propTypes.callee)
          )
          && propTypes.arguments && propTypes.arguments[0]
        ) {
          markPropTypesAsDeclared(node, propTypes.arguments[0], rootNode);
          return;
        ***REMOVED***
        break;
      ***REMOVED***
      case 'IntersectionTypeAnnotation':
        ignorePropsValidation = declarePropTypesForIntersectionTypeAnnotation(propTypes, declaredPropTypes);
        break;
      case 'GenericTypeAnnotation':
        if (propTypes.id.name === '$ReadOnly') {
          const propTypeArguments = propsUtil.getTypeArguments(propTypes);
          ignorePropsValidation = declarePropTypesForObjectTypeAnnotation(
            propTypeArguments.params[0],
            declaredPropTypes
          );
        ***REMOVED*** else {
          ignorePropsValidation = true;
        ***REMOVED***
        break;
      case 'TSTypeReference':
      case 'TSTypeAnnotation': {
        const tsTypeAnnotation = new DeclarePropTypesForTSTypeAnnotation(propTypes, declaredPropTypes, rootNode);
        ignorePropsValidation = tsTypeAnnotation.shouldIgnorePropTypes;
        declaredPropTypes = tsTypeAnnotation.declaredPropTypes;
      ***REMOVED***
        break;
      case null:
        break;
      default:
        ignorePropsValidation = true;
        break;
    ***REMOVED***

    components.set(node, {
      declaredPropTypes,
      ignorePropsValidation,
    ***REMOVED***);
  ***REMOVED***

  /**
   * @param {ASTNode***REMOVED*** node We expect either an ArrowFunctionExpression,
   *   FunctionDeclaration, or FunctionExpression
   * @param {ASTNode***REMOVED*** rootNode
   */
  function markAnnotatedFunctionArgumentsAsDeclared(node, rootNode) {
    if (!node.params || !node.params.length) {
      return;
    ***REMOVED***

    let propTypesArguments = null;
    if (node.parent) {
      propTypesArguments = propsUtil.getTypeArguments(node.parent);
    ***REMOVED***

    if (
      node.parent
      && node.parent.callee
      && propTypesArguments
      && propTypesArguments.params
      && (
        node.parent.callee.name === 'forwardRef' || (
          node.parent.callee.object
          && node.parent.callee.property
          && node.parent.callee.object.name === 'React'
          && node.parent.callee.property.name === 'forwardRef'
        )
      )
    ) {
      const declaredPropTypes = {***REMOVED***;
      const obj = new DeclarePropTypesForTSTypeAnnotation(propTypesArguments.params[1], declaredPropTypes, rootNode);
      components.set(node, {
        declaredPropTypes: obj.declaredPropTypes,
        ignorePropsValidation: obj.shouldIgnorePropTypes,
      ***REMOVED***);
      return;
    ***REMOVED***

    const siblingIdentifier = node.parent && node.parent.id;
    const siblingHasTypeAnnotation = siblingIdentifier && siblingIdentifier.typeAnnotation;
    const isNodeAnnotated = annotations.isAnnotatedFunctionPropsDeclaration(node, context);

    if (!isNodeAnnotated && !siblingHasTypeAnnotation) {
      return;
    ***REMOVED***

    // https://github.com/jsx-eslint/eslint-plugin-react/issues/2784
    if (isInsideClassBody(node) && !astUtil.isFunction(node)) {
      return;
    ***REMOVED***

    // Should ignore function that not return JSXElement
    if (!utils.isReturningJSXOrNull(node) || startWithCapitalizedLetter(node)) {
      return;
    ***REMOVED***

    if (isNodeAnnotated) {
      const param = node.params[0];
      if (param.typeAnnotation && param.typeAnnotation.typeAnnotation && param.typeAnnotation.typeAnnotation.type === 'UnionTypeAnnotation') {
        param.typeAnnotation.typeAnnotation.types.forEach((annotation) => {
          if (annotation.type === 'GenericTypeAnnotation') {
            markPropTypesAsDeclared(node, resolveTypeAnnotation(annotation), rootNode);
          ***REMOVED*** else {
            markPropTypesAsDeclared(node, annotation, rootNode);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED*** else {
        markPropTypesAsDeclared(node, resolveTypeAnnotation(param), rootNode);
      ***REMOVED***
    ***REMOVED*** else {
      // implements what's discussed here: https://github.com/jsx-eslint/eslint-plugin-react/issues/2777#issuecomment-683944481
      const annotation = siblingIdentifier.typeAnnotation.typeAnnotation;

      if (
        annotation
        && annotation.type !== 'TSTypeReference'
        && propsUtil.getTypeArguments(annotation) == null
      ) {
        return;
      ***REMOVED***

      if (!isValidReactGenericTypeAnnotation(annotation)) return;

      markPropTypesAsDeclared(node, resolveTypeAnnotation(siblingIdentifier), rootNode);
    ***REMOVED***
  ***REMOVED***

  /**
   * Resolve the type annotation for a given class declaration node.
   *
   * @param {ASTNode***REMOVED*** node The annotation or a node containing the type annotation.
   * @returns {ASTNode***REMOVED*** The resolved type annotation for the node.
   */
  function resolveSuperParameterPropsType(node) {
    let propsParameterPosition;
    const parameters = propsUtil.getSuperTypeArguments(node);

    try {
      // Flow <=0.52 had 3 required TypedParameters of which the second one is the Props.
      // Flow >=0.53 has 2 optional TypedParameters of which the first one is the Props.
      propsParameterPosition = testFlowVersion(context, '>= 0.53.0') ? 0 : 1;
    ***REMOVED*** catch (e) {
      // In case there is no flow version defined, we can safely assume that when there are 3 Props we are dealing with version <= 0.52
      propsParameterPosition = parameters.params.length <= 2 ? 0 : 1;
    ***REMOVED***

    let annotation = parameters.params[propsParameterPosition];
    while (annotation && (annotation.type === 'TypeAnnotation' || annotation.type === 'NullableTypeAnnotation')) {
      annotation = annotation.typeAnnotation;
    ***REMOVED***

    if (annotation && annotation.type === 'GenericTypeAnnotation' && getInTypeScope(annotation.id.name)) {
      return getInTypeScope(annotation.id.name);
    ***REMOVED***
    return annotation;
  ***REMOVED***

  /**
   * Checks if we are declaring a `props` class property with a flow type annotation.
   * @param {ASTNode***REMOVED*** node The AST node being checked.
   * @returns {boolean***REMOVED*** True if the node is a type annotated props declaration, false if not.
   */
  function isAnnotatedClassPropsDeclaration(node) {
    if (node && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition')) {
      const tokens = getFirstTokens(context, node, 2);
      if (
        node.typeAnnotation && (
          tokens[0].value === 'props'
          || (tokens[1] && tokens[1].value === 'props')
        )
      ) {
        return true;
      ***REMOVED***
    ***REMOVED***
    return false;
  ***REMOVED***

  return {
    ClassExpression(node) {
      // TypeParameterDeclaration need to be added to typeScope in order to handle ClassExpressions.
      // This visitor is executed before TypeParameterDeclaration are scoped, therefore we postpone
      // processing class expressions until when the program exists.
      classExpressions.push(node);
    ***REMOVED***,

    ClassDeclaration(node) {
      if (isSuperTypeParameterPropsDeclaration(node)) {
        markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node), node);
      ***REMOVED***
    ***REMOVED***,

    'ClassProperty, PropertyDefinition'(node) {
      if (isAnnotatedClassPropsDeclaration(node)) {
        markPropTypesAsDeclared(node, resolveTypeAnnotation(node), node);
      ***REMOVED*** else if (propsUtil.isPropTypesDeclaration(node)) {
        markPropTypesAsDeclared(node, node.value, node);
      ***REMOVED***
    ***REMOVED***,

    ObjectExpression(node) {
      // Search for the proptypes declaration
      node.properties.forEach((property) => {
        if (!propsUtil.isPropTypesDeclaration(property)) {
          return;
        ***REMOVED***
        markPropTypesAsDeclared(node, property.value, node);
      ***REMOVED***);
    ***REMOVED***,

    FunctionExpression(node) {
      if (node.parent.type !== 'MethodDefinition') {
        markAnnotatedFunctionArgumentsAsDeclared(node, node);
      ***REMOVED***
    ***REMOVED***,

    ImportDeclaration(node) {
      // parse `import ... from 'react`
      if (node.source.value === 'react') {
        node.specifiers.forEach((specifier) => {
          if (
            // handles import * as X from 'react'
            specifier.type === 'ImportNamespaceSpecifier'
            // handles import React from 'react'
            || specifier.type === 'ImportDefaultSpecifier'
          ) {
            genericReactTypesImport.add(specifier.local.name);
          ***REMOVED***

          // handles import { FC ***REMOVED*** from 'react' or import { FC as X ***REMOVED*** from 'react'
          if (specifier.type === 'ImportSpecifier' && allowedGenericTypes.has(specifier.imported.name)) {
            genericReactTypesImport.add(specifier.local.name);
            localToImportedMap[specifier.local.name] = specifier.imported.name;
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***,

    FunctionDeclaration: markAnnotatedFunctionArgumentsAsDeclared,

    ArrowFunctionExpression: markAnnotatedFunctionArgumentsAsDeclared,

    MemberExpression(node) {
      if (propsUtil.isPropTypesDeclaration(node)) {
        const component = utils.getRelatedComponent(node);
        if (!component) {
          return;
        ***REMOVED***
        try {
          markPropTypesAsDeclared(component.node, node.parent.right || node.parent, node);
        ***REMOVED*** catch (e) {
          if (e.constructor !== RangeError) { throw e; ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***,

    MethodDefinition(node) {
      if (!node.static || node.kind !== 'get' || !propsUtil.isPropTypesDeclaration(node)) {
        return;
      ***REMOVED***

      let i = node.value.body.body.length - 1;
      for (; i >= 0; i--) {
        if (node.value.body.body[i].type === 'ReturnStatement') {
          break;
        ***REMOVED***
      ***REMOVED***

      if (i >= 0) {
        markPropTypesAsDeclared(node, node.value.body.body[i].argument, node);
      ***REMOVED***
    ***REMOVED***,

    TypeAlias(node) {
      setInTypeScope(node.id.name, node.right);
    ***REMOVED***,

    TypeParameterDeclaration(node) {
      const identifier = node.params[0];

      if (identifier.typeAnnotation) {
        setInTypeScope(identifier.name, identifier.typeAnnotation.typeAnnotation);
      ***REMOVED***
    ***REMOVED***,

    Program() {
      stack = [{***REMOVED***];
    ***REMOVED***,

    BlockStatement() {
      stack.push(Object.create(typeScope()));
    ***REMOVED***,

    'BlockStatement:exit'() {
      stack.pop();
    ***REMOVED***,

    'Program:exit'() {
      classExpressions.forEach((node) => {
        if (isSuperTypeParameterPropsDeclaration(node)) {
          markPropTypesAsDeclared(node, resolveSuperParameterPropsType(node), node);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***,
  ***REMOVED***;
***REMOVED***;
