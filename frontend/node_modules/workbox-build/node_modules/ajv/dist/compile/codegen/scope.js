"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
const code_1 = require("./code");
class ValueError extends Error {
    constructor(name) {
        super(`CodeGen: "code" for ${name***REMOVED*** not defined`);
        this.value = name.value;
    ***REMOVED***
***REMOVED***
var UsedValueState;
(function (UsedValueState) {
    UsedValueState[UsedValueState["Started"] = 0] = "Started";
    UsedValueState[UsedValueState["Completed"] = 1] = "Completed";
***REMOVED***)(UsedValueState || (exports.UsedValueState = UsedValueState = {***REMOVED***));
exports.varKinds = {
    const: new code_1.Name("const"),
    let: new code_1.Name("let"),
    var: new code_1.Name("var"),
***REMOVED***;
class Scope {
    constructor({ prefixes, parent ***REMOVED*** = {***REMOVED***) {
        this._names = {***REMOVED***;
        this._prefixes = prefixes;
        this._parent = parent;
    ***REMOVED***
    toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
    ***REMOVED***
    name(prefix) {
        return new code_1.Name(this._newName(prefix));
    ***REMOVED***
    _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix***REMOVED***${ng.index++***REMOVED***`;
    ***REMOVED***
    _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || (this._prefixes && !this._prefixes.has(prefix))) {
            throw new Error(`CodeGen: prefix "${prefix***REMOVED***" is not allowed in this scope`);
        ***REMOVED***
        return (this._names[prefix] = { prefix, index: 0 ***REMOVED***);
    ***REMOVED***
***REMOVED***
exports.Scope = Scope;
class ValueScopeName extends code_1.Name {
    constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
    ***REMOVED***
    setValue(value, { property, itemIndex ***REMOVED***) {
        this.value = value;
        this.scopePath = (0, code_1._) `.${new code_1.Name(property)***REMOVED***[${itemIndex***REMOVED***]`;
    ***REMOVED***
***REMOVED***
exports.ValueScopeName = ValueScopeName;
const line = (0, code_1._) `\n`;
class ValueScope extends Scope {
    constructor(opts) {
        super(opts);
        this._values = {***REMOVED***;
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil ***REMOVED***;
    ***REMOVED***
    get() {
        return this._scope;
    ***REMOVED***
    name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
    ***REMOVED***
    value(nameOrPrefix, value) {
        var _a;
        if (value.ref === undefined)
            throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix ***REMOVED*** = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
            const _name = vs.get(valueKey);
            if (_name)
                return _name;
        ***REMOVED***
        else {
            vs = this._values[prefix] = new Map();
        ***REMOVED***
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex ***REMOVED***);
        return name;
    ***REMOVED***
    getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
            return;
        return vs.get(keyOrRef);
    ***REMOVED***
    scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
            if (name.scopePath === undefined)
                throw new Error(`CodeGen: name "${name***REMOVED***" has no value`);
            return (0, code_1._) `${scopeName***REMOVED***${name.scopePath***REMOVED***`;
        ***REMOVED***);
    ***REMOVED***
    scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
            if (name.value === undefined)
                throw new Error(`CodeGen: name "${name***REMOVED***" has no value`);
            return name.value.code;
        ***REMOVED***, usedValues, getCode);
    ***REMOVED***
    _reduceValues(values, valueCode, usedValues = {***REMOVED***, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
            const vs = values[prefix];
            if (!vs)
                continue;
            const nameSet = (usedValues[prefix] = usedValues[prefix] || new Map());
            vs.forEach((name) => {
                if (nameSet.has(name))
                    return;
                nameSet.set(name, UsedValueState.Started);
                let c = valueCode(name);
                if (c) {
                    const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
                    code = (0, code_1._) `${code***REMOVED***${def***REMOVED*** ${name***REMOVED*** = ${c***REMOVED***;${this.opts._n***REMOVED***`;
                ***REMOVED***
                else if ((c = getCode === null || getCode === void 0 ? void 0 : getCode(name))) {
                    code = (0, code_1._) `${code***REMOVED***${c***REMOVED***${this.opts._n***REMOVED***`;
                ***REMOVED***
                else {
                    throw new ValueError(name);
                ***REMOVED***
                nameSet.set(name, UsedValueState.Completed);
            ***REMOVED***);
        ***REMOVED***
        return code;
    ***REMOVED***
***REMOVED***
exports.ValueScope = ValueScope;
//# sourceMappingURL=scope.js.map