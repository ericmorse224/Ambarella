"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.validate = validate;
exports.enableValidation = enableValidation;
exports.disableValidation = disableValidation;
exports.needValidate = needValidate;
Object.defineProperty(exports, "ValidationError", {
  enumerable: true,
  get: function () {
    return _ValidationError.default;
  ***REMOVED***
***REMOVED***);

var _absolutePath = _interopRequireDefault(require("./keywords/absolutePath"));

var _undefinedAsNull = _interopRequireDefault(require("./keywords/undefinedAsNull"));

var _ValidationError = _interopRequireDefault(require("./ValidationError"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj ***REMOVED***; ***REMOVED***

/**
 * @template T
 * @param fn {(function(): any) | undefined***REMOVED***
 * @returns {function(): T***REMOVED***
 */
const memoize = fn => {
  let cache = false;
  /** @type {T***REMOVED*** */

  let result;
  return () => {
    if (cache) {
      return result;
    ***REMOVED***

    result =
    /** @type {function(): any***REMOVED*** */
    fn();
    cache = true; // Allow to clean up memory for fn
    // and all dependent resources
    // eslint-disable-next-line no-undefined, no-param-reassign

    fn = undefined;
    return result;
  ***REMOVED***;
***REMOVED***;

const getAjv = memoize(() => {
  // Use CommonJS require for ajv libs so TypeScript consumers aren't locked into esModuleInterop (see #110).
  // eslint-disable-next-line global-require
  const Ajv = require("ajv"); // eslint-disable-next-line global-require


  const ajvKeywords = require("ajv-keywords");

  const ajv = new Ajv({
    allErrors: true,
    verbose: true,
    $data: true
  ***REMOVED***);
  ajvKeywords(ajv, ["instanceof", "formatMinimum", "formatMaximum", "patternRequired"]); // Custom keywords

  (0, _absolutePath.default)(ajv);
  (0, _undefinedAsNull.default)(ajv);
  return ajv;
***REMOVED***);
/** @typedef {import("json-schema").JSONSchema4***REMOVED*** JSONSchema4 */

/** @typedef {import("json-schema").JSONSchema6***REMOVED*** JSONSchema6 */

/** @typedef {import("json-schema").JSONSchema7***REMOVED*** JSONSchema7 */

/** @typedef {import("ajv").ErrorObject***REMOVED*** ErrorObject */

/** @typedef {import("ajv").ValidateFunction***REMOVED*** ValidateFunction */

/**
 * @typedef {Object***REMOVED*** Extend
 * @property {number=***REMOVED*** formatMinimum
 * @property {number=***REMOVED*** formatMaximum
 * @property {boolean=***REMOVED*** formatExclusiveMinimum
 * @property {boolean=***REMOVED*** formatExclusiveMaximum
 * @property {string=***REMOVED*** link
 * @property {boolean=***REMOVED*** undefinedAsNull
 */

/** @typedef {(JSONSchema4 | JSONSchema6 | JSONSchema7) & Extend***REMOVED*** Schema */

/** @typedef {ErrorObject & { children?: Array<ErrorObject>***REMOVED******REMOVED*** SchemaUtilErrorObject */

/**
 * @callback PostFormatter
 * @param {string***REMOVED*** formattedError
 * @param {SchemaUtilErrorObject***REMOVED*** error
 * @returns {string***REMOVED***
 */

/**
 * @typedef {Object***REMOVED*** ValidationErrorConfiguration
 * @property {string=***REMOVED*** name
 * @property {string=***REMOVED*** baseDataPath
 * @property {PostFormatter=***REMOVED*** postFormatter
 */

/**
 * @param {SchemaUtilErrorObject***REMOVED*** error
 * @param {number***REMOVED*** idx
 * @returns {SchemaUtilErrorObject***REMOVED***
 */

function applyPrefix(error, idx) {
  // eslint-disable-next-line no-param-reassign
  error.dataPath = `[${idx***REMOVED***]${error.dataPath***REMOVED***`;

  if (error.children) {
    error.children.forEach(err => applyPrefix(err, idx));
  ***REMOVED***

  return error;
***REMOVED***

let skipValidation = false; // We use `process.env.SKIP_VALIDATION` because you can have multiple `schema-utils` with different version,
// so we want to disable it globally, `process.env` doesn't supported by browsers, so we have the local `skipValidation` variables
// Enable validation

function enableValidation() {
  skipValidation = false; // Disable validation for any versions

  if (process && process.env) {
    process.env.SKIP_VALIDATION = "n";
  ***REMOVED***
***REMOVED*** // Disable validation


function disableValidation() {
  skipValidation = true;

  if (process && process.env) {
    process.env.SKIP_VALIDATION = "y";
  ***REMOVED***
***REMOVED*** // Check if we need to confirm


function needValidate() {
  if (skipValidation) {
    return false;
  ***REMOVED***

  if (process && process.env && process.env.SKIP_VALIDATION) {
    const value = process.env.SKIP_VALIDATION.trim();

    if (/^(?:y|yes|true|1|on)$/i.test(value)) {
      return false;
    ***REMOVED***

    if (/^(?:n|no|false|0|off)$/i.test(value)) {
      return true;
    ***REMOVED***
  ***REMOVED***

  return true;
***REMOVED***
/**
 * @param {Schema***REMOVED*** schema
 * @param {Array<object> | object***REMOVED*** options
 * @param {ValidationErrorConfiguration=***REMOVED*** configuration
 * @returns {void***REMOVED***
 */


function validate(schema, options, configuration) {
  if (!needValidate()) {
    return;
  ***REMOVED***

  let errors = [];

  if (Array.isArray(options)) {
    for (let i = 0; i <= options.length - 1; i++) {
      errors.push(...validateObject(schema, options[i]).map(err => applyPrefix(err, i)));
    ***REMOVED***
  ***REMOVED*** else {
    errors = validateObject(schema, options);
  ***REMOVED***

  if (errors.length > 0) {
    throw new _ValidationError.default(errors, schema, configuration);
  ***REMOVED***
***REMOVED***
/** @typedef {WeakMap<Schema, ValidateFunction>***REMOVED*** */


const schemaCache = new WeakMap();
/**
 * @param {Schema***REMOVED*** schema
 * @param {Array<object> | object***REMOVED*** options
 * @returns {Array<SchemaUtilErrorObject>***REMOVED***
 */

function validateObject(schema, options) {
  let compiledSchema = schemaCache.get(schema);

  if (!compiledSchema) {
    compiledSchema = getAjv().compile(schema);
    schemaCache.set(schema, compiledSchema);
  ***REMOVED***

  const valid = compiledSchema(options);
  if (valid) return [];
  return compiledSchema.errors ? filterErrors(compiledSchema.errors) : [];
***REMOVED***
/**
 * @param {Array<ErrorObject>***REMOVED*** errors
 * @returns {Array<SchemaUtilErrorObject>***REMOVED***
 */


function filterErrors(errors) {
  /** @type {Array<SchemaUtilErrorObject>***REMOVED*** */
  let newErrors = [];

  for (const error of
  /** @type {Array<SchemaUtilErrorObject>***REMOVED*** */
  errors) {
    const {
      dataPath
    ***REMOVED*** = error;
    /** @type {Array<SchemaUtilErrorObject>***REMOVED*** */

    let children = [];
    newErrors = newErrors.filter(oldError => {
      if (oldError.dataPath.includes(dataPath)) {
        if (oldError.children) {
          children = children.concat(oldError.children.slice(0));
        ***REMOVED*** // eslint-disable-next-line no-undefined, no-param-reassign


        oldError.children = undefined;
        children.push(oldError);
        return false;
      ***REMOVED***

      return true;
    ***REMOVED***);

    if (children.length) {
      error.children = children;
    ***REMOVED***

    newErrors.push(error);
  ***REMOVED***

  return newErrors;
***REMOVED***