import type {
  AddedKeywordDefinition,
  AnySchema,
  AnySchemaObject,
  KeywordErrorCxt,
  KeywordCxtParams,
***REMOVED*** from "../../types"
import type {SchemaCxt, SchemaObjCxt***REMOVED*** from ".."
import type {InstanceOptions***REMOVED*** from "../../core"
import {boolOrEmptySchema, topBoolOrEmptySchema***REMOVED*** from "./boolSchema"
import {coerceAndCheckDataType, getSchemaTypes***REMOVED*** from "./dataType"
import {shouldUseGroup, shouldUseRule***REMOVED*** from "./applicability"
import {checkDataType, checkDataTypes, reportTypeError, DataType***REMOVED*** from "./dataType"
import {assignDefaults***REMOVED*** from "./defaults"
import {funcKeywordCode, macroKeywordCode, validateKeywordUsage, validSchemaType***REMOVED*** from "./keyword"
import {getSubschema, extendSubschemaData, SubschemaArgs, extendSubschemaMode***REMOVED*** from "./subschema"
import {_, nil, str, or, not, getProperty, Block, Code, Name, CodeGen***REMOVED*** from "../codegen"
import N from "../names"
import {resolveUrl***REMOVED*** from "../resolve"
import {
  schemaRefOrVal,
  schemaHasRulesButRef,
  checkUnknownRules,
  checkStrictMode,
  unescapeJsonPointer,
  mergeEvaluated,
***REMOVED*** from "../util"
import type {JSONType, Rule, RuleGroup***REMOVED*** from "../rules"
import {
  ErrorPaths,
  reportError,
  reportExtraError,
  resetErrorsCount,
  keyword$DataError,
***REMOVED*** from "../errors"

// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
export function validateFunctionCode(it: SchemaCxt): void {
  if (isSchemaObj(it)) {
    checkKeywords(it)
    if (schemaCxtHasRules(it)) {
      topSchemaObjCode(it)
      return
    ***REMOVED***
  ***REMOVED***
  validateFunction(it, () => topBoolOrEmptySchema(it))
***REMOVED***

function validateFunction(
  {gen, validateName, schema, schemaEnv, opts***REMOVED***: SchemaCxt,
  body: Block
): void {
  if (opts.code.es5) {
    gen.func(validateName, _`${N.data***REMOVED***, ${N.valCxt***REMOVED***`, schemaEnv.$async, () => {
      gen.code(_`"use strict"; ${funcSourceUrl(schema, opts)***REMOVED***`)
      destructureValCxtES5(gen, opts)
      gen.code(body)
    ***REMOVED***)
  ***REMOVED*** else {
    gen.func(validateName, _`${N.data***REMOVED***, ${destructureValCxt(opts)***REMOVED***`, schemaEnv.$async, () =>
      gen.code(funcSourceUrl(schema, opts)).code(body)
    )
  ***REMOVED***
***REMOVED***

function destructureValCxt(opts: InstanceOptions): Code {
  return _`{${N.instancePath***REMOVED***="", ${N.parentData***REMOVED***, ${N.parentDataProperty***REMOVED***, ${N.rootData***REMOVED***=${
    N.data
  ***REMOVED***${opts.dynamicRef ? _`, ${N.dynamicAnchors***REMOVED***={***REMOVED***` : nil***REMOVED******REMOVED***={***REMOVED***`
***REMOVED***

function destructureValCxtES5(gen: CodeGen, opts: InstanceOptions): void {
  gen.if(
    N.valCxt,
    () => {
      gen.var(N.instancePath, _`${N.valCxt***REMOVED***.${N.instancePath***REMOVED***`)
      gen.var(N.parentData, _`${N.valCxt***REMOVED***.${N.parentData***REMOVED***`)
      gen.var(N.parentDataProperty, _`${N.valCxt***REMOVED***.${N.parentDataProperty***REMOVED***`)
      gen.var(N.rootData, _`${N.valCxt***REMOVED***.${N.rootData***REMOVED***`)
      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`${N.valCxt***REMOVED***.${N.dynamicAnchors***REMOVED***`)
    ***REMOVED***,
    () => {
      gen.var(N.instancePath, _`""`)
      gen.var(N.parentData, _`undefined`)
      gen.var(N.parentDataProperty, _`undefined`)
      gen.var(N.rootData, N.data)
      if (opts.dynamicRef) gen.var(N.dynamicAnchors, _`{***REMOVED***`)
    ***REMOVED***
  )
***REMOVED***

function topSchemaObjCode(it: SchemaObjCxt): void {
  const {schema, opts, gen***REMOVED*** = it
  validateFunction(it, () => {
    if (opts.$comment && schema.$comment) commentKeyword(it)
    checkNoDefault(it)
    gen.let(N.vErrors, null)
    gen.let(N.errors, 0)
    if (opts.unevaluated) resetEvaluated(it)
    typeAndKeywords(it)
    returnResults(it)
  ***REMOVED***)
  return
***REMOVED***

function resetEvaluated(it: SchemaObjCxt): void {
  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
  const {gen, validateName***REMOVED*** = it
  it.evaluated = gen.const("evaluated", _`${validateName***REMOVED***.evaluated`)
  gen.if(_`${it.evaluated***REMOVED***.dynamicProps`, () => gen.assign(_`${it.evaluated***REMOVED***.props`, _`undefined`))
  gen.if(_`${it.evaluated***REMOVED***.dynamicItems`, () => gen.assign(_`${it.evaluated***REMOVED***.items`, _`undefined`))
***REMOVED***

function funcSourceUrl(schema: AnySchema, opts: InstanceOptions): Code {
  const schId = typeof schema == "object" && schema[opts.schemaId]
  return schId && (opts.code.source || opts.code.process) ? _`/*# sourceURL=${schId***REMOVED*** */` : nil
***REMOVED***

// schema compilation - this function is used recursively to generate code for sub-schemas
function subschemaCode(it: SchemaCxt, valid: Name): void {
  if (isSchemaObj(it)) {
    checkKeywords(it)
    if (schemaCxtHasRules(it)) {
      subSchemaObjCode(it, valid)
      return
    ***REMOVED***
  ***REMOVED***
  boolOrEmptySchema(it, valid)
***REMOVED***

function schemaCxtHasRules({schema, self***REMOVED***: SchemaCxt): boolean {
  if (typeof schema == "boolean") return !schema
  for (const key in schema) if (self.RULES.all[key]) return true
  return false
***REMOVED***

function isSchemaObj(it: SchemaCxt): it is SchemaObjCxt {
  return typeof it.schema != "boolean"
***REMOVED***

function subSchemaObjCode(it: SchemaObjCxt, valid: Name): void {
  const {schema, gen, opts***REMOVED*** = it
  if (opts.$comment && schema.$comment) commentKeyword(it)
  updateContext(it)
  checkAsyncSchema(it)
  const errsCount = gen.const("_errs", N.errors)
  typeAndKeywords(it, errsCount)
  // TODO var
  gen.var(valid, _`${errsCount***REMOVED*** === ${N.errors***REMOVED***`)
***REMOVED***

function checkKeywords(it: SchemaObjCxt): void {
  checkUnknownRules(it)
  checkRefsAndKeywords(it)
***REMOVED***

function typeAndKeywords(it: SchemaObjCxt, errsCount?: Name): void {
  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount)
  const types = getSchemaTypes(it.schema)
  const checkedTypes = coerceAndCheckDataType(it, types)
  schemaKeywords(it, types, !checkedTypes, errsCount)
***REMOVED***

function checkRefsAndKeywords(it: SchemaObjCxt): void {
  const {schema, errSchemaPath, opts, self***REMOVED*** = it
  if (schema.$ref && opts.ignoreKeywordsWithRef && schemaHasRulesButRef(schema, self.RULES)) {
    self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath***REMOVED***"`)
  ***REMOVED***
***REMOVED***

function checkNoDefault(it: SchemaObjCxt): void {
  const {schema, opts***REMOVED*** = it
  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
    checkStrictMode(it, "default is ignored in the schema root")
  ***REMOVED***
***REMOVED***

function updateContext(it: SchemaObjCxt): void {
  const schId = it.schema[it.opts.schemaId]
  if (schId) it.baseId = resolveUrl(it.opts.uriResolver, it.baseId, schId)
***REMOVED***

function checkAsyncSchema(it: SchemaObjCxt): void {
  if (it.schema.$async && !it.schemaEnv.$async) throw new Error("async schema in sync schema")
***REMOVED***

function commentKeyword({gen, schemaEnv, schema, errSchemaPath, opts***REMOVED***: SchemaObjCxt): void {
  const msg = schema.$comment
  if (opts.$comment === true) {
    gen.code(_`${N.self***REMOVED***.logger.log(${msg***REMOVED***)`)
  ***REMOVED*** else if (typeof opts.$comment == "function") {
    const schemaPath = str`${errSchemaPath***REMOVED***/$comment`
    const rootName = gen.scopeValue("root", {ref: schemaEnv.root***REMOVED***)
    gen.code(_`${N.self***REMOVED***.opts.$comment(${msg***REMOVED***, ${schemaPath***REMOVED***, ${rootName***REMOVED***.schema)`)
  ***REMOVED***
***REMOVED***

function returnResults(it: SchemaCxt): void {
  const {gen, schemaEnv, validateName, ValidationError, opts***REMOVED*** = it
  if (schemaEnv.$async) {
    // TODO assign unevaluated
    gen.if(
      _`${N.errors***REMOVED*** === 0`,
      () => gen.return(N.data),
      () => gen.throw(_`new ${ValidationError as Name***REMOVED***(${N.vErrors***REMOVED***)`)
    )
  ***REMOVED*** else {
    gen.assign(_`${validateName***REMOVED***.errors`, N.vErrors)
    if (opts.unevaluated) assignEvaluated(it)
    gen.return(_`${N.errors***REMOVED*** === 0`)
  ***REMOVED***
***REMOVED***

function assignEvaluated({gen, evaluated, props, items***REMOVED***: SchemaCxt): void {
  if (props instanceof Name) gen.assign(_`${evaluated***REMOVED***.props`, props)
  if (items instanceof Name) gen.assign(_`${evaluated***REMOVED***.items`, items)
***REMOVED***

function schemaKeywords(
  it: SchemaObjCxt,
  types: JSONType[],
  typeErrors: boolean,
  errsCount?: Name
): void {
  const {gen, schema, data, allErrors, opts, self***REMOVED*** = it
  const {RULES***REMOVED*** = self
  if (schema.$ref && (opts.ignoreKeywordsWithRef || !schemaHasRulesButRef(schema, RULES))) {
    gen.block(() => keywordCode(it, "$ref", (RULES.all.$ref as Rule).definition)) // TODO typecast
    return
  ***REMOVED***
  if (!opts.jtd) checkStrictTypes(it, types)
  gen.block(() => {
    for (const group of RULES.rules) groupKeywords(group)
    groupKeywords(RULES.post)
  ***REMOVED***)

  function groupKeywords(group: RuleGroup): void {
    if (!shouldUseGroup(schema, group)) return
    if (group.type) {
      gen.if(checkDataType(group.type, data, opts.strictNumbers))
      iterateKeywords(it, group)
      if (types.length === 1 && types[0] === group.type && typeErrors) {
        gen.else()
        reportTypeError(it)
      ***REMOVED***
      gen.endIf()
    ***REMOVED*** else {
      iterateKeywords(it, group)
    ***REMOVED***
    // TODO make it "ok" call?
    if (!allErrors) gen.if(_`${N.errors***REMOVED*** === ${errsCount || 0***REMOVED***`)
  ***REMOVED***
***REMOVED***

function iterateKeywords(it: SchemaObjCxt, group: RuleGroup): void {
  const {
    gen,
    schema,
    opts: {useDefaults***REMOVED***,
  ***REMOVED*** = it
  if (useDefaults) assignDefaults(it, group.type)
  gen.block(() => {
    for (const rule of group.rules) {
      if (shouldUseRule(schema, rule)) {
        keywordCode(it, rule.keyword, rule.definition, group.type)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***)
***REMOVED***

function checkStrictTypes(it: SchemaObjCxt, types: JSONType[]): void {
  if (it.schemaEnv.meta || !it.opts.strictTypes) return
  checkContextTypes(it, types)
  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types)
  checkKeywordTypes(it, it.dataTypes)
***REMOVED***

function checkContextTypes(it: SchemaObjCxt, types: JSONType[]): void {
  if (!types.length) return
  if (!it.dataTypes.length) {
    it.dataTypes = types
    return
  ***REMOVED***
  types.forEach((t) => {
    if (!includesType(it.dataTypes, t)) {
      strictTypesError(it, `type "${t***REMOVED***" not allowed by context "${it.dataTypes.join(",")***REMOVED***"`)
    ***REMOVED***
  ***REMOVED***)
  narrowSchemaTypes(it, types)
***REMOVED***

function checkMultipleTypes(it: SchemaObjCxt, ts: JSONType[]): void {
  if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
    strictTypesError(it, "use allowUnionTypes to allow union type keyword")
  ***REMOVED***
***REMOVED***

function checkKeywordTypes(it: SchemaObjCxt, ts: JSONType[]): void {
  const rules = it.self.RULES.all
  for (const keyword in rules) {
    const rule = rules[keyword]
    if (typeof rule == "object" && shouldUseRule(it.schema, rule)) {
      const {type***REMOVED*** = rule.definition
      if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
        strictTypesError(it, `missing type "${type.join(",")***REMOVED***" for keyword "${keyword***REMOVED***"`)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function hasApplicableType(schTs: JSONType[], kwdT: JSONType): boolean {
  return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"))
***REMOVED***

function includesType(ts: JSONType[], t: JSONType): boolean {
  return ts.includes(t) || (t === "integer" && ts.includes("number"))
***REMOVED***

function narrowSchemaTypes(it: SchemaObjCxt, withTypes: JSONType[]): void {
  const ts: JSONType[] = []
  for (const t of it.dataTypes) {
    if (includesType(withTypes, t)) ts.push(t)
    else if (withTypes.includes("integer") && t === "number") ts.push("integer")
  ***REMOVED***
  it.dataTypes = ts
***REMOVED***

function strictTypesError(it: SchemaObjCxt, msg: string): void {
  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath
  msg += ` at "${schemaPath***REMOVED***" (strictTypes)`
  checkStrictMode(it, msg, it.opts.strictTypes)
***REMOVED***

export class KeywordCxt implements KeywordErrorCxt {
  readonly gen: CodeGen
  readonly allErrors?: boolean
  readonly keyword: string
  readonly data: Name // Name referencing the current level of the data instance
  readonly $data?: string | false
  schema: any // keyword value in the schema
  readonly schemaValue: Code | number | boolean // Code reference to keyword schema value or primitive value
  readonly schemaCode: Code | number | boolean // Code reference to resolved schema value (different if schema is $data)
  readonly schemaType: JSONType[] // allowed type(s) of keyword value in the schema
  readonly parentSchema: AnySchemaObject
  readonly errsCount?: Name // Name reference to the number of validation errors collected before this keyword,
  // requires option trackErrors in keyword definition
  params: KeywordCxtParams // object to pass parameters to error messages from keyword code
  readonly it: SchemaObjCxt // schema compilation context (schema is guaranteed to be an object, not boolean)
  readonly def: AddedKeywordDefinition

  constructor(it: SchemaObjCxt, def: AddedKeywordDefinition, keyword: string) {
    validateKeywordUsage(it, def, keyword)
    this.gen = it.gen
    this.allErrors = it.allErrors
    this.keyword = keyword
    this.data = it.data
    this.schema = it.schema[keyword]
    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data
    this.schemaValue = schemaRefOrVal(it, this.schema, keyword, this.$data)
    this.schemaType = def.schemaType
    this.parentSchema = it.schema
    this.params = {***REMOVED***
    this.it = it
    this.def = def

    if (this.$data) {
      this.schemaCode = it.gen.const("vSchema", getData(this.$data, it))
    ***REMOVED*** else {
      this.schemaCode = this.schemaValue
      if (!validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {
        throw new Error(`${keyword***REMOVED*** value must be ${JSON.stringify(def.schemaType)***REMOVED***`)
      ***REMOVED***
    ***REMOVED***

    if ("code" in def ? def.trackErrors : def.errors !== false) {
      this.errsCount = it.gen.const("_errs", N.errors)
    ***REMOVED***
  ***REMOVED***

  result(condition: Code, successAction?: () => void, failAction?: () => void): void {
    this.failResult(not(condition), successAction, failAction)
  ***REMOVED***

  failResult(condition: Code, successAction?: () => void, failAction?: () => void): void {
    this.gen.if(condition)
    if (failAction) failAction()
    else this.error()
    if (successAction) {
      this.gen.else()
      successAction()
      if (this.allErrors) this.gen.endIf()
    ***REMOVED*** else {
      if (this.allErrors) this.gen.endIf()
      else this.gen.else()
    ***REMOVED***
  ***REMOVED***

  pass(condition: Code, failAction?: () => void): void {
    this.failResult(not(condition), undefined, failAction)
  ***REMOVED***

  fail(condition?: Code): void {
    if (condition === undefined) {
      this.error()
      if (!this.allErrors) this.gen.if(false) // this branch will be removed by gen.optimize
      return
    ***REMOVED***
    this.gen.if(condition)
    this.error()
    if (this.allErrors) this.gen.endIf()
    else this.gen.else()
  ***REMOVED***

  fail$data(condition: Code): void {
    if (!this.$data) return this.fail(condition)
    const {schemaCode***REMOVED*** = this
    this.fail(_`${schemaCode***REMOVED*** !== undefined && (${or(this.invalid$data(), condition)***REMOVED***)`)
  ***REMOVED***

  error(append?: boolean, errorParams?: KeywordCxtParams, errorPaths?: ErrorPaths): void {
    if (errorParams) {
      this.setParams(errorParams)
      this._error(append, errorPaths)
      this.setParams({***REMOVED***)
      return
    ***REMOVED***
    this._error(append, errorPaths)
  ***REMOVED***

  private _error(append?: boolean, errorPaths?: ErrorPaths): void {
    ;(append ? reportExtraError : reportError)(this, this.def.error, errorPaths)
  ***REMOVED***

  $dataError(): void {
    reportError(this, this.def.$dataError || keyword$DataError)
  ***REMOVED***

  reset(): void {
    if (this.errsCount === undefined) throw new Error('add "trackErrors" to keyword definition')
    resetErrorsCount(this.gen, this.errsCount)
  ***REMOVED***

  ok(cond: Code | boolean): void {
    if (!this.allErrors) this.gen.if(cond)
  ***REMOVED***

  setParams(obj: KeywordCxtParams, assign?: true): void {
    if (assign) Object.assign(this.params, obj)
    else this.params = obj
  ***REMOVED***

  block$data(valid: Name, codeBlock: () => void, $dataValid: Code = nil): void {
    this.gen.block(() => {
      this.check$data(valid, $dataValid)
      codeBlock()
    ***REMOVED***)
  ***REMOVED***

  check$data(valid: Name = nil, $dataValid: Code = nil): void {
    if (!this.$data) return
    const {gen, schemaCode, schemaType, def***REMOVED*** = this
    gen.if(or(_`${schemaCode***REMOVED*** === undefined`, $dataValid))
    if (valid !== nil) gen.assign(valid, true)
    if (schemaType.length || def.validateSchema) {
      gen.elseIf(this.invalid$data())
      this.$dataError()
      if (valid !== nil) gen.assign(valid, false)
    ***REMOVED***
    gen.else()
  ***REMOVED***

  invalid$data(): Code {
    const {gen, schemaCode, schemaType, def, it***REMOVED*** = this
    return or(wrong$DataType(), invalid$DataSchema())

    function wrong$DataType(): Code {
      if (schemaType.length) {
        /* istanbul ignore if */
        if (!(schemaCode instanceof Name)) throw new Error("ajv implementation error")
        const st = Array.isArray(schemaType) ? schemaType : [schemaType]
        return _`${checkDataTypes(st, schemaCode, it.opts.strictNumbers, DataType.Wrong)***REMOVED***`
      ***REMOVED***
      return nil
    ***REMOVED***

    function invalid$DataSchema(): Code {
      if (def.validateSchema) {
        const validateSchemaRef = gen.scopeValue("validate$data", {ref: def.validateSchema***REMOVED***) // TODO value.code for standalone
        return _`!${validateSchemaRef***REMOVED***(${schemaCode***REMOVED***)`
      ***REMOVED***
      return nil
    ***REMOVED***
  ***REMOVED***

  subschema(appl: SubschemaArgs, valid: Name): SchemaCxt {
    const subschema = getSubschema(this.it, appl)
    extendSubschemaData(subschema, this.it, appl)
    extendSubschemaMode(subschema, appl)
    const nextContext = {...this.it, ...subschema, items: undefined, props: undefined***REMOVED***
    subschemaCode(nextContext, valid)
    return nextContext
  ***REMOVED***

  mergeEvaluated(schemaCxt: SchemaCxt, toName?: typeof Name): void {
    const {it, gen***REMOVED*** = this
    if (!it.opts.unevaluated) return
    if (it.props !== true && schemaCxt.props !== undefined) {
      it.props = mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)
    ***REMOVED***
    if (it.items !== true && schemaCxt.items !== undefined) {
      it.items = mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)
    ***REMOVED***
  ***REMOVED***

  mergeValidEvaluated(schemaCxt: SchemaCxt, valid: Name): boolean | void {
    const {it, gen***REMOVED*** = this
    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
      gen.if(valid, () => this.mergeEvaluated(schemaCxt, Name))
      return true
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function keywordCode(
  it: SchemaObjCxt,
  keyword: string,
  def: AddedKeywordDefinition,
  ruleType?: JSONType
): void {
  const cxt = new KeywordCxt(it, def, keyword)
  if ("code" in def) {
    def.code(cxt, ruleType)
  ***REMOVED*** else if (cxt.$data && def.validate) {
    funcKeywordCode(cxt, def)
  ***REMOVED*** else if ("macro" in def) {
    macroKeywordCode(cxt, def)
  ***REMOVED*** else if (def.compile || def.validate) {
    funcKeywordCode(cxt, def)
  ***REMOVED***
***REMOVED***

const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/
export function getData(
  $data: string,
  {dataLevel, dataNames, dataPathArr***REMOVED***: SchemaCxt
): Code | number {
  let jsonPointer
  let data: Code
  if ($data === "") return N.rootData
  if ($data[0] === "/") {
    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data***REMOVED***`)
    jsonPointer = $data
    data = N.rootData
  ***REMOVED*** else {
    const matches = RELATIVE_JSON_POINTER.exec($data)
    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data***REMOVED***`)
    const up: number = +matches[1]
    jsonPointer = matches[2]
    if (jsonPointer === "#") {
      if (up >= dataLevel) throw new Error(errorMsg("property/index", up))
      return dataPathArr[dataLevel - up]
    ***REMOVED***
    if (up > dataLevel) throw new Error(errorMsg("data", up))
    data = dataNames[dataLevel - up]
    if (!jsonPointer) return data
  ***REMOVED***

  let expr = data
  const segments = jsonPointer.split("/")
  for (const segment of segments) {
    if (segment) {
      data = _`${data***REMOVED***${getProperty(unescapeJsonPointer(segment))***REMOVED***`
      expr = _`${expr***REMOVED*** && ${data***REMOVED***`
    ***REMOVED***
  ***REMOVED***
  return expr

  function errorMsg(pointerType: string, up: number): string {
    return `Cannot access ${pointerType***REMOVED*** ${up***REMOVED*** levels up, current level is ${dataLevel***REMOVED***`
  ***REMOVED***
***REMOVED***
