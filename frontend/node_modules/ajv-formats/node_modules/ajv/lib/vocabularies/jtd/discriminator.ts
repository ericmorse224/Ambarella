import type {CodeKeywordDefinition, KeywordErrorDefinition***REMOVED*** from "../../types"
import type {KeywordCxt***REMOVED*** from "../../compile/validate"
import {_, not, getProperty, Name***REMOVED*** from "../../compile/codegen"
import {checkMetadata***REMOVED*** from "./metadata"
import {checkNullableObject***REMOVED*** from "./nullable"
import {typeErrorMessage, typeErrorParams, _JTDTypeError***REMOVED*** from "./error"
import {DiscrError, DiscrErrorObj***REMOVED*** from "../discriminator/types"

export type JTDDiscriminatorError =
  | _JTDTypeError<"discriminator", "object", string>
  | DiscrErrorObj<DiscrError.Tag>
  | DiscrErrorObj<DiscrError.Mapping>

const error: KeywordErrorDefinition = {
  message: (cxt) => {
    const {schema, params***REMOVED*** = cxt
    return params.discrError
      ? params.discrError === DiscrError.Tag
        ? `tag "${schema***REMOVED***" must be string`
        : `value of tag "${schema***REMOVED***" must be in mapping`
      : typeErrorMessage(cxt, "object")
  ***REMOVED***,
  params: (cxt) => {
    const {schema, params***REMOVED*** = cxt
    return params.discrError
      ? _`{error: ${params.discrError***REMOVED***, tag: ${schema***REMOVED***, tagValue: ${params.tag***REMOVED******REMOVED***`
      : typeErrorParams(cxt, "object")
  ***REMOVED***,
***REMOVED***

const def: CodeKeywordDefinition = {
  keyword: "discriminator",
  schemaType: "string",
  implements: ["mapping"],
  error,
  code(cxt: KeywordCxt) {
    checkMetadata(cxt)
    const {gen, data, schema, parentSchema***REMOVED*** = cxt
    const [valid, cond] = checkNullableObject(cxt, data)

    gen.if(cond)
    validateDiscriminator()
    gen.elseIf(not(valid))
    cxt.error()
    gen.endIf()
    cxt.ok(valid)

    function validateDiscriminator(): void {
      const tag = gen.const("tag", _`${data***REMOVED***${getProperty(schema)***REMOVED***`)
      gen.if(_`${tag***REMOVED*** === undefined`)
      cxt.error(false, {discrError: DiscrError.Tag, tag***REMOVED***)
      gen.elseIf(_`typeof ${tag***REMOVED*** == "string"`)
      validateMapping(tag)
      gen.else()
      cxt.error(false, {discrError: DiscrError.Tag, tag***REMOVED***, {instancePath: schema***REMOVED***)
      gen.endIf()
    ***REMOVED***

    function validateMapping(tag: Name): void {
      gen.if(false)
      for (const tagValue in parentSchema.mapping) {
        gen.elseIf(_`${tag***REMOVED*** === ${tagValue***REMOVED***`)
        gen.assign(valid, applyTagSchema(tagValue))
      ***REMOVED***
      gen.else()
      cxt.error(
        false,
        {discrError: DiscrError.Mapping, tag***REMOVED***,
        {instancePath: schema, schemaPath: "mapping", parentSchema: true***REMOVED***
      )
      gen.endIf()
    ***REMOVED***

    function applyTagSchema(schemaProp: string): Name {
      const _valid = gen.name("valid")
      cxt.subschema(
        {
          keyword: "mapping",
          schemaProp,
          jtdDiscriminator: schema,
        ***REMOVED***,
        _valid
      )
      return _valid
    ***REMOVED***
  ***REMOVED***,
***REMOVED***

export default def
