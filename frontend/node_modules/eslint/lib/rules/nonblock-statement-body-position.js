/**
 * @fileoverview enforce the location of single-line statements
 * @author Teddy Katz
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const POSITION_SCHEMA = { enum: ["beside", "below", "any"] ***REMOVED***;

module.exports = {
    meta: {
        type: "layout",

        docs: {
            description: "enforce the location of single-line statements",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/nonblock-statement-body-position"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            POSITION_SCHEMA,
            {
                properties: {
                    overrides: {
                        properties: {
                            if: POSITION_SCHEMA,
                            else: POSITION_SCHEMA,
                            while: POSITION_SCHEMA,
                            do: POSITION_SCHEMA,
                            for: POSITION_SCHEMA
                        ***REMOVED***,
                        additionalProperties: false
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],

        messages: {
            expectNoLinebreak: "Expected no linebreak before this statement.",
            expectLinebreak: "Expected a linebreak before this statement."
        ***REMOVED***
    ***REMOVED***,

    create(context) {
        const sourceCode = context.getSourceCode();

        //----------------------------------------------------------------------
        // Helpers
        //----------------------------------------------------------------------

        /**
         * Gets the applicable preference for a particular keyword
         * @param {string***REMOVED*** keywordName The name of a keyword, e.g. 'if'
         * @returns {string***REMOVED*** The applicable option for the keyword, e.g. 'beside'
         */
        function getOption(keywordName) {
            return context.options[1] && context.options[1].overrides && context.options[1].overrides[keywordName] ||
                context.options[0] ||
                "beside";
        ***REMOVED***

        /**
         * Validates the location of a single-line statement
         * @param {ASTNode***REMOVED*** node The single-line statement
         * @param {string***REMOVED*** keywordName The applicable keyword name for the single-line statement
         * @returns {void***REMOVED***
         */
        function validateStatement(node, keywordName) {
            const option = getOption(keywordName);

            if (node.type === "BlockStatement" || option === "any") {
                return;
            ***REMOVED***

            const tokenBefore = sourceCode.getTokenBefore(node);

            if (tokenBefore.loc.end.line === node.loc.start.line && option === "below") {
                context.report({
                    node,
                    messageId: "expectLinebreak",
                    fix: fixer => fixer.insertTextBefore(node, "\n")
                ***REMOVED***);
            ***REMOVED*** else if (tokenBefore.loc.end.line !== node.loc.start.line && option === "beside") {
                context.report({
                    node,
                    messageId: "expectNoLinebreak",
                    fix(fixer) {
                        if (sourceCode.getText().slice(tokenBefore.range[1], node.range[0]).trim()) {
                            return null;
                        ***REMOVED***
                        return fixer.replaceTextRange([tokenBefore.range[1], node.range[0]], " ");
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------

        return {
            IfStatement(node) {
                validateStatement(node.consequent, "if");

                // Check the `else` node, but don't check 'else if' statements.
                if (node.alternate && node.alternate.type !== "IfStatement") {
                    validateStatement(node.alternate, "else");
                ***REMOVED***
            ***REMOVED***,
            WhileStatement: node => validateStatement(node.body, "while"),
            DoWhileStatement: node => validateStatement(node.body, "do"),
            ForStatement: node => validateStatement(node.body, "for"),
            ForInStatement: node => validateStatement(node.body, "for"),
            ForOfStatement: node => validateStatement(node.body, "for")
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
