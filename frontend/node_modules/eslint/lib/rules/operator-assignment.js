/**
 * @fileoverview Rule to replace assignment expressions with operator assignment
 * @author Brandon Mills
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether an operator is commutative and has an operator assignment
 * shorthand form.
 * @param {string***REMOVED*** operator Operator to check.
 * @returns {boolean***REMOVED*** True if the operator is commutative and has a
 *     shorthand form.
 */
function isCommutativeOperatorWithShorthand(operator) {
    return ["*", "&", "^", "|"].includes(operator);
***REMOVED***

/**
 * Checks whether an operator is not commutative and has an operator assignment
 * shorthand form.
 * @param {string***REMOVED*** operator Operator to check.
 * @returns {boolean***REMOVED*** True if the operator is not commutative and has
 *     a shorthand form.
 */
function isNonCommutativeOperatorWithShorthand(operator) {
    return ["+", "-", "/", "%", "<<", ">>", ">>>", "**"].includes(operator);
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/**
 * Determines if the left side of a node can be safely fixed (i.e. if it activates the same getters/setters and)
 * toString calls regardless of whether assignment shorthand is used)
 * @param {ASTNode***REMOVED*** node The node on the left side of the expression
 * @returns {boolean***REMOVED*** `true` if the node can be fixed
 */
function canBeFixed(node) {
    return (
        node.type === "Identifier" ||
        (
            node.type === "MemberExpression" &&
            (node.object.type === "Identifier" || node.object.type === "ThisExpression") &&
            (!node.computed || node.property.type === "Literal")
        )
    );
***REMOVED***

/** @type {import('../shared/types').Rule***REMOVED*** */
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "Require or disallow assignment operator shorthand where possible",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/operator-assignment"
        ***REMOVED***,

        schema: [
            {
                enum: ["always", "never"]
            ***REMOVED***
        ],

        fixable: "code",
        messages: {
            replaced: "Assignment (=) can be replaced with operator assignment ({{operator***REMOVED******REMOVED***).",
            unexpected: "Unexpected operator assignment ({{operator***REMOVED******REMOVED***) shorthand."
        ***REMOVED***
    ***REMOVED***,

    create(context) {

        const sourceCode = context.sourceCode;

        /**
         * Returns the operator token of an AssignmentExpression or BinaryExpression
         * @param {ASTNode***REMOVED*** node An AssignmentExpression or BinaryExpression node
         * @returns {Token***REMOVED*** The operator token in the node
         */
        function getOperatorToken(node) {
            return sourceCode.getFirstTokenBetween(node.left, node.right, token => token.value === node.operator);
        ***REMOVED***

        /**
         * Ensures that an assignment uses the shorthand form where possible.
         * @param {ASTNode***REMOVED*** node An AssignmentExpression node.
         * @returns {void***REMOVED***
         */
        function verify(node) {
            if (node.operator !== "=" || node.right.type !== "BinaryExpression") {
                return;
            ***REMOVED***

            const left = node.left;
            const expr = node.right;
            const operator = expr.operator;

            if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {
                const replacementOperator = `${operator***REMOVED***=`;

                if (astUtils.isSameReference(left, expr.left, true)) {
                    context.report({
                        node,
                        messageId: "replaced",
                        data: { operator: replacementOperator ***REMOVED***,
                        fix(fixer) {
                            if (canBeFixed(left) && canBeFixed(expr.left)) {
                                const equalsToken = getOperatorToken(node);
                                const operatorToken = getOperatorToken(expr);
                                const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);
                                const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);

                                // Check for comments that would be removed.
                                if (sourceCode.commentsExistBetween(equalsToken, operatorToken)) {
                                    return null;
                                ***REMOVED***

                                return fixer.replaceText(node, `${leftText***REMOVED***${replacementOperator***REMOVED***${rightText***REMOVED***`);
                            ***REMOVED***
                            return null;
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED*** else if (astUtils.isSameReference(left, expr.right, true) && isCommutativeOperatorWithShorthand(operator)) {

                    /*
                     * This case can't be fixed safely.
                     * If `a` and `b` both have custom valueOf() behavior, then fixing `a = b * a` to `a *= b` would
                     * change the execution order of the valueOf() functions.
                     */
                    context.report({
                        node,
                        messageId: "replaced",
                        data: { operator: replacementOperator ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Warns if an assignment expression uses operator assignment shorthand.
         * @param {ASTNode***REMOVED*** node An AssignmentExpression node.
         * @returns {void***REMOVED***
         */
        function prohibit(node) {
            if (node.operator !== "=" && !astUtils.isLogicalAssignmentOperator(node.operator)) {
                context.report({
                    node,
                    messageId: "unexpected",
                    data: { operator: node.operator ***REMOVED***,
                    fix(fixer) {
                        if (canBeFixed(node.left)) {
                            const firstToken = sourceCode.getFirstToken(node);
                            const operatorToken = getOperatorToken(node);
                            const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);
                            const newOperator = node.operator.slice(0, -1);
                            let rightText;

                            // Check for comments that would be duplicated.
                            if (sourceCode.commentsExistBetween(firstToken, operatorToken)) {
                                return null;
                            ***REMOVED***

                            // If this change would modify precedence (e.g. `foo *= bar + 1` => `foo = foo * (bar + 1)`), parenthesize the right side.
                            if (
                                astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({ type: "BinaryExpression", operator: newOperator ***REMOVED***) &&
                                !astUtils.isParenthesised(sourceCode, node.right)
                            ) {
                                rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])***REMOVED***(${sourceCode.getText(node.right)***REMOVED***)`;
                            ***REMOVED*** else {
                                const tokenAfterOperator = sourceCode.getTokenAfter(operatorToken, { includeComments: true ***REMOVED***);
                                let rightTextPrefix = "";

                                if (
                                    operatorToken.range[1] === tokenAfterOperator.range[0] &&
                                    !astUtils.canTokensBeAdjacent({ type: "Punctuator", value: newOperator ***REMOVED***, tokenAfterOperator)
                                ) {
                                    rightTextPrefix = " "; // foo+=+bar -> foo= foo+ +bar
                                ***REMOVED***

                                rightText = `${rightTextPrefix***REMOVED***${sourceCode.text.slice(operatorToken.range[1], node.range[1])***REMOVED***`;
                            ***REMOVED***

                            return fixer.replaceText(node, `${leftText***REMOVED***= ${leftText***REMOVED***${newOperator***REMOVED***${rightText***REMOVED***`);
                        ***REMOVED***
                        return null;
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        return {
            AssignmentExpression: context.options[0] !== "never" ? verify : prohibit
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
