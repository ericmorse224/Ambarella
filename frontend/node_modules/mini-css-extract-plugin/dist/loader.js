"use strict";

const path = require("path");
const {
  findModuleById,
  evalModuleCode,
  AUTO_PUBLIC_PATH,
  ABSOLUTE_PUBLIC_PATH,
  BASE_URI,
  SINGLE_DOT_PATH_SEGMENT,
  stringifyRequest,
  stringifyLocal
***REMOVED*** = require("./utils");
const schema = require("./loader-options.json");
const MiniCssExtractPlugin = require("./index");

/** @typedef {import("schema-utils/declarations/validate").Schema***REMOVED*** Schema */
/** @typedef {import("webpack").Compiler***REMOVED*** Compiler */
/** @typedef {import("webpack").Compilation***REMOVED*** Compilation */
/** @typedef {import("webpack").Chunk***REMOVED*** Chunk */
/** @typedef {import("webpack").Module***REMOVED*** Module */
/** @typedef {import("webpack").sources.Source***REMOVED*** Source */
/** @typedef {import("webpack").AssetInfo***REMOVED*** AssetInfo */
/** @typedef {import("webpack").NormalModule***REMOVED*** NormalModule */
/** @typedef {import("./index.js").LoaderOptions***REMOVED*** LoaderOptions */
/** @typedef {{ [key: string]: string | function ***REMOVED******REMOVED*** Locals */

/** @typedef {any***REMOVED*** TODO */

/**
 * @typedef {Object***REMOVED*** Dependency
 * @property {string***REMOVED*** identifier
 * @property {string | null***REMOVED*** context
 * @property {Buffer***REMOVED*** content
 * @property {string***REMOVED*** media
 * @property {string***REMOVED*** [supports]
 * @property {string***REMOVED*** [layer]
 * @property {Buffer***REMOVED*** [sourceMap]
 */

/**
 * @param {string***REMOVED*** content
 * @param {{ loaderContext: import("webpack").LoaderContext<LoaderOptions>, options: LoaderOptions, locals: Locals | undefined ***REMOVED******REMOVED*** context
 * @returns {string***REMOVED***
 */
function hotLoader(content, context) {
  const localsJsonString = JSON.stringify(JSON.stringify(context.locals));
  return `${content***REMOVED***
    if(module.hot) {
      (function() {
        var localsJsonString = ${localsJsonString***REMOVED***;
        // ${Date.now()***REMOVED***
        var cssReload = require(${stringifyRequest(context.loaderContext, path.join(__dirname, "hmr/hotModuleReplacement.js"))***REMOVED***)(module.id, ${JSON.stringify(context.options)***REMOVED***);
        // only invalidate when locals change
        if (
          module.hot.data &&
          module.hot.data.value &&
          module.hot.data.value !== localsJsonString
        ) {
          module.hot.invalidate();
        ***REMOVED*** else {
          module.hot.accept();
        ***REMOVED***
        module.hot.dispose(function(data) {
          data.value = localsJsonString;
          cssReload();
        ***REMOVED***);
      ***REMOVED***)();
    ***REMOVED***
  `;
***REMOVED***

/**
 * @this {import("webpack").LoaderContext<LoaderOptions>***REMOVED***
 * @param {string***REMOVED*** request
 */
function pitch(request) {
  if (this._compiler && this._compiler.options && this._compiler.options.experiments && this._compiler.options.experiments.css && this._module && (this._module.type === "css" || this._module.type === "css/auto" || this._module.type === "css/global" || this._module.type === "css/module")) {
    this.emitWarning(new Error('You can\'t use `experiments.css` (`experiments.futureDefaults` enable built-in CSS support by default) and `mini-css-extract-plugin` together, please set `experiments.css` to `false` or set `{ type: "javascript/auto" ***REMOVED***` for rules with `mini-css-extract-plugin` in your webpack config (now `mini-css-extract-plugin` does nothing).'));
    return;
  ***REMOVED***

  // @ts-ignore
  const options = this.getOptions( /** @type {Schema***REMOVED*** */schema);
  const emit = typeof options.emit !== "undefined" ? options.emit : true;
  const callback = this.async();
  const optionsFromPlugin = /** @type {TODO***REMOVED*** */this[MiniCssExtractPlugin.pluginSymbol];
  if (!optionsFromPlugin) {
    callback(new Error("You forgot to add 'mini-css-extract-plugin' plugin (i.e. `{ plugins: [new MiniCssExtractPlugin()] ***REMOVED***`), please read https://github.com/webpack-contrib/mini-css-extract-plugin#getting-started"));
    return;
  ***REMOVED***
  const {
    webpack
  ***REMOVED*** = /** @type {Compiler***REMOVED*** */this._compiler;

  /**
   * @param {TODO***REMOVED*** originalExports
   * @param {Compilation***REMOVED*** [compilation]
   * @param {{ [name: string]: Source ***REMOVED******REMOVED*** [assets]
   * @param {Map<string, AssetInfo>***REMOVED*** [assetsInfo]
   * @returns {void***REMOVED***
   */
  const handleExports = (originalExports, compilation, assets, assetsInfo) => {
    /** @type {Locals | undefined***REMOVED*** */
    let locals;
    let namedExport;
    const esModule = typeof options.esModule !== "undefined" ? options.esModule : true;

    /**
     * @param {Dependency[] | [null, object][]***REMOVED*** dependencies
     */
    const addDependencies = dependencies => {
      if (!Array.isArray(dependencies) && dependencies != null) {
        throw new Error(`Exported value was not extracted as an array: ${JSON.stringify(dependencies)***REMOVED***`);
      ***REMOVED***
      const identifierCountMap = new Map();
      let lastDep;
      for (const dependency of dependencies) {
        if (!( /** @type {Dependency***REMOVED*** */dependency.identifier) || !emit) {
          // eslint-disable-next-line no-continue
          continue;
        ***REMOVED***
        const count = identifierCountMap.get( /** @type {Dependency***REMOVED*** */dependency.identifier) || 0;
        const CssDependency = MiniCssExtractPlugin.getCssDependency(webpack);

        /** @type {NormalModule***REMOVED*** */
        this._module.addDependency(lastDep = new CssDependency( /** @type {Dependency***REMOVED*** */
        dependency, /** @type {Dependency***REMOVED*** */
        dependency.context, count));
        identifierCountMap.set( /** @type {Dependency***REMOVED*** */
        dependency.identifier, count + 1);
      ***REMOVED***
      if (lastDep && assets) {
        lastDep.assets = assets;
        lastDep.assetsInfo = assetsInfo;
      ***REMOVED***
    ***REMOVED***;
    try {
      // eslint-disable-next-line no-underscore-dangle
      const exports = originalExports.__esModule ? originalExports.default : originalExports;
      namedExport =
      // eslint-disable-next-line no-underscore-dangle
      originalExports.__esModule && (!originalExports.default || !("locals" in originalExports.default));
      if (namedExport) {
        Object.keys(originalExports).forEach(key => {
          if (key !== "default") {
            if (!locals) {
              locals = {***REMOVED***;
            ***REMOVED***

            /** @type {Locals***REMOVED*** */
            locals[key] = originalExports[key];
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED*** else {
        locals = exports && exports.locals;
      ***REMOVED***

      /** @type {Dependency[] | [null, object][]***REMOVED*** */
      let dependencies;
      if (!Array.isArray(exports)) {
        dependencies = [[null, exports]];
      ***REMOVED*** else {
        dependencies = exports.map(([id, content, media, sourceMap, supports, layer]) => {
          let identifier = id;
          let context;
          if (compilation) {
            const module = /** @type {Module***REMOVED*** */
            findModuleById(compilation, id);
            identifier = module.identifier();
            ({
              context
            ***REMOVED*** = module);
          ***REMOVED*** else {
            // TODO check if this context is used somewhere
            context = this.rootContext;
          ***REMOVED***
          return {
            identifier,
            context,
            content: Buffer.from(content),
            media,
            supports,
            layer,
            sourceMap: sourceMap ? Buffer.from(JSON.stringify(sourceMap)) :
            // eslint-disable-next-line no-undefined
            undefined
          ***REMOVED***;
        ***REMOVED***);
      ***REMOVED***
      addDependencies(dependencies);
    ***REMOVED*** catch (e) {
      callback( /** @type {Error***REMOVED*** */e);
      return;
    ***REMOVED***
    const result = function makeResult() {
      const defaultExport = typeof options.defaultExport !== "undefined" ? options.defaultExport : false;
      if (locals) {
        if (namedExport) {
          const identifiers = Array.from(function* generateIdentifiers() {
            let identifierId = 0;
            for (const key of Object.keys(locals)) {
              identifierId += 1;
              yield [`_${identifierId.toString(16)***REMOVED***`, key];
            ***REMOVED***
          ***REMOVED***());
          const localsString = identifiers.map(([id, key]) => `\nvar ${id***REMOVED*** = ${stringifyLocal( /** @type {Locals***REMOVED*** */locals[key])***REMOVED***;`).join("");
          const exportsString = `export { ${identifiers.map(([id, key]) => `${id***REMOVED*** as ${JSON.stringify(key)***REMOVED***`).join(", ")***REMOVED*** ***REMOVED***`;
          return defaultExport ? `${localsString***REMOVED***\n${exportsString***REMOVED***\nexport default { ${identifiers.map(([id, key]) => `${JSON.stringify(key)***REMOVED***: ${id***REMOVED***`).join(", ")***REMOVED*** ***REMOVED***\n` : `${localsString***REMOVED***\n${exportsString***REMOVED***\n`;
        ***REMOVED***
        return `\n${esModule ? "export default" : "module.exports = "***REMOVED*** ${JSON.stringify(locals)***REMOVED***;`;
      ***REMOVED*** else if (esModule) {
        return defaultExport ? "\nexport {***REMOVED***;export default {***REMOVED***;" : "\nexport {***REMOVED***;";
      ***REMOVED***
      return "";
    ***REMOVED***();
    let resultSource = `// extracted by ${MiniCssExtractPlugin.pluginName***REMOVED***`;

    // only attempt hotreloading if the css is actually used for something other than hash values
    resultSource += this.hot && emit ? hotLoader(result, {
      loaderContext: this,
      options,
      locals
    ***REMOVED***) : result;
    callback(null, resultSource);
  ***REMOVED***;
  let {
    publicPath
  ***REMOVED*** = /** @type {Compilation***REMOVED*** */
  this._compilation.outputOptions;
  if (typeof options.publicPath === "string") {
    // eslint-disable-next-line prefer-destructuring
    publicPath = options.publicPath;
  ***REMOVED*** else if (typeof options.publicPath === "function") {
    publicPath = options.publicPath(this.resourcePath, this.rootContext);
  ***REMOVED***
  if (publicPath === "auto") {
    publicPath = AUTO_PUBLIC_PATH;
  ***REMOVED***
  if (typeof optionsFromPlugin.experimentalUseImportModule === "undefined" && typeof this.importModule === "function" || optionsFromPlugin.experimentalUseImportModule) {
    if (!this.importModule) {
      callback(new Error("You are using 'experimentalUseImportModule' but 'this.importModule' is not available in loader context. You need to have at least webpack 5.33.2."));
      return;
    ***REMOVED***
    let publicPathForExtract;
    if (typeof publicPath === "string") {
      const isAbsolutePublicPath = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/.test(publicPath);
      publicPathForExtract = isAbsolutePublicPath ? publicPath : `${ABSOLUTE_PUBLIC_PATH***REMOVED***${publicPath.replace(/\./g, SINGLE_DOT_PATH_SEGMENT)***REMOVED***`;
    ***REMOVED*** else {
      publicPathForExtract = publicPath;
    ***REMOVED***
    this.importModule(`${this.resourcePath***REMOVED***.webpack[javascript/auto]!=!!!${request***REMOVED***`, {
      layer: options.layer,
      publicPath: ( /** @type {string***REMOVED*** */publicPathForExtract),
      baseUri: `${BASE_URI***REMOVED***/`
    ***REMOVED***,
    /**
     * @param {Error | null | undefined***REMOVED*** error
     * @param {object***REMOVED*** exports
     */
    (error, exports) => {
      if (error) {
        callback(error);
        return;
      ***REMOVED***
      handleExports(exports);
    ***REMOVED***);
    return;
  ***REMOVED***
  const loaders = this.loaders.slice(this.loaderIndex + 1);
  this.addDependency(this.resourcePath);
  const childFilename = "*";
  const outputOptions = {
    filename: childFilename,
    publicPath
  ***REMOVED***;
  const childCompiler = /** @type {Compilation***REMOVED*** */
  this._compilation.createChildCompiler(`${MiniCssExtractPlugin.pluginName***REMOVED*** ${request***REMOVED***`, outputOptions);

  // The templates are compiled and executed by NodeJS - similar to server side rendering
  // Unfortunately this causes issues as some loaders require an absolute URL to support ES Modules
  // The following config enables relative URL support for the child compiler
  childCompiler.options.module = {
    ...childCompiler.options.module
  ***REMOVED***;
  childCompiler.options.module.parser = {
    ...childCompiler.options.module.parser
  ***REMOVED***;
  childCompiler.options.module.parser.javascript = {
    ...childCompiler.options.module.parser.javascript,
    url: "relative"
  ***REMOVED***;
  const {
    NodeTemplatePlugin
  ***REMOVED*** = webpack.node;
  const {
    NodeTargetPlugin
  ***REMOVED*** = webpack.node;

  // @ts-ignore
  new NodeTemplatePlugin(outputOptions).apply(childCompiler);
  new NodeTargetPlugin().apply(childCompiler);
  const {
    EntryOptionPlugin
  ***REMOVED*** = webpack;
  const {
    library: {
      EnableLibraryPlugin
    ***REMOVED***
  ***REMOVED*** = webpack;
  new EnableLibraryPlugin("commonjs2").apply(childCompiler);
  EntryOptionPlugin.applyEntryOption(childCompiler, this.context, {
    child: {
      library: {
        type: "commonjs2"
      ***REMOVED***,
      import: [`!!${request***REMOVED***`]
    ***REMOVED***
  ***REMOVED***);
  const {
    LimitChunkCountPlugin
  ***REMOVED*** = webpack.optimize;
  new LimitChunkCountPlugin({
    maxChunks: 1
  ***REMOVED***).apply(childCompiler);
  const {
    NormalModule
  ***REMOVED*** = webpack;
  childCompiler.hooks.thisCompilation.tap(`${MiniCssExtractPlugin.pluginName***REMOVED*** loader`,
  /**
   * @param {Compilation***REMOVED*** compilation
   */
  compilation => {
    const normalModuleHook = NormalModule.getCompilationHooks(compilation).loader;
    normalModuleHook.tap(`${MiniCssExtractPlugin.pluginName***REMOVED*** loader`, (loaderContext, module) => {
      if (module.request === request) {
        // eslint-disable-next-line no-param-reassign
        module.loaders = loaders.map(loader => {
          return {
            type: null,
            loader: loader.path,
            options: loader.options,
            ident: loader.ident
          ***REMOVED***;
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***);

  /** @type {string | Buffer***REMOVED*** */
  let source;
  childCompiler.hooks.compilation.tap(MiniCssExtractPlugin.pluginName,
  /**
   * @param {Compilation***REMOVED*** compilation
   */
  compilation => {
    compilation.hooks.processAssets.tap(MiniCssExtractPlugin.pluginName, () => {
      source = compilation.assets[childFilename] && compilation.assets[childFilename].source();

      // Remove all chunk assets
      compilation.chunks.forEach(chunk => {
        chunk.files.forEach(file => {
          compilation.deleteAsset(file);
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***);
  childCompiler.runAsChild((error, entries, compilation) => {
    if (error) {
      callback(error);
      return;
    ***REMOVED***
    if ( /** @type {Compilation***REMOVED*** */compilation.errors.length > 0) {
      callback( /** @type {Compilation***REMOVED*** */compilation.errors[0]);
      return;
    ***REMOVED***

    /** @type {{ [name: string]: Source ***REMOVED******REMOVED*** */
    const assets = Object.create(null);
    /** @type {Map<string, AssetInfo>***REMOVED*** */
    const assetsInfo = new Map();
    for (const asset of /** @type {Compilation***REMOVED*** */compilation.getAssets()) {
      assets[asset.name] = asset.source;
      assetsInfo.set(asset.name, asset.info);
    ***REMOVED***

    /** @type {Compilation***REMOVED*** */
    compilation.fileDependencies.forEach(dep => {
      this.addDependency(dep);
    ***REMOVED***, this);

    /** @type {Compilation***REMOVED*** */
    compilation.contextDependencies.forEach(dep => {
      this.addContextDependency(dep);
    ***REMOVED***, this);
    if (!source) {
      callback(new Error("Didn't get a result from child compiler"));
      return;
    ***REMOVED***
    let originalExports;
    try {
      originalExports = evalModuleCode(this, source, request);
    ***REMOVED*** catch (e) {
      callback( /** @type {Error***REMOVED*** */e);
      return;
    ***REMOVED***
    handleExports(originalExports, compilation, assets, assetsInfo);
  ***REMOVED***);
***REMOVED***

/**
 * @this {import("webpack").LoaderContext<LoaderOptions>***REMOVED***
 * @param {string***REMOVED*** content
 */
// eslint-disable-next-line consistent-return
function loader(content) {
  if (this._compiler && this._compiler.options && this._compiler.options.experiments && this._compiler.options.experiments.css && this._module && (this._module.type === "css" || this._module.type === "css/auto" || this._module.type === "css/global" || this._module.type === "css/module")) {
    return content;
  ***REMOVED***
***REMOVED***
module.exports = loader;
module.exports.pitch = pitch;
module.exports.hotLoader = hotLoader;