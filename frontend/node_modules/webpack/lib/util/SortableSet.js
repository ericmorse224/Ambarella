/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const NONE = Symbol("not sorted");

/**
 * A subset of Set that offers sorting functionality
 * @template T item type in set
 * @extends {Set<T>***REMOVED***
 */
class SortableSet extends Set {
	/**
	 * Create a new sortable set
	 * @template T
	 * @typedef {(a: T, b: T) => number***REMOVED*** SortFunction
	 * @param {Iterable<T>=***REMOVED*** initialIterable The initial iterable value
	 * @param {SortFunction<T>=***REMOVED*** defaultSort Default sorting function
	 */
	constructor(initialIterable, defaultSort) {
		super(initialIterable);
		/**
		 * @private
		 * @type {undefined | SortFunction<T>***REMOVED***
		 */
		this._sortFn = defaultSort;
		/**
		 * @private
		 * @type {typeof NONE | undefined | ((a: T, b: T) => number)***REMOVED******REMOVED***
		 */
		this._lastActiveSortFn = NONE;
		/**
		 * @private
		 * @template R
		 * @type {Map<(set: SortableSet<T>) => EXPECTED_ANY, EXPECTED_ANY> | undefined***REMOVED***
		 */
		this._cache = undefined;
		/**
		 * @private
		 * @template R
		 * @type {Map<(set: SortableSet<T>) => EXPECTED_ANY, EXPECTED_ANY> | undefined***REMOVED***
		 */
		this._cacheOrderIndependent = undefined;
	***REMOVED***

	/**
	 * @param {T***REMOVED*** value value to add to set
	 * @returns {this***REMOVED*** returns itself
	 */
	add(value) {
		this._lastActiveSortFn = NONE;
		this._invalidateCache();
		this._invalidateOrderedCache();
		super.add(value);
		return this;
	***REMOVED***

	/**
	 * @param {T***REMOVED*** value value to delete
	 * @returns {boolean***REMOVED*** true if value existed in set, false otherwise
	 */
	delete(value) {
		this._invalidateCache();
		this._invalidateOrderedCache();
		return super.delete(value);
	***REMOVED***

	/**
	 * @returns {void***REMOVED***
	 */
	clear() {
		this._invalidateCache();
		this._invalidateOrderedCache();
		return super.clear();
	***REMOVED***

	/**
	 * Sort with a comparer function
	 * @param {SortFunction<T> | undefined***REMOVED*** sortFn Sorting comparer function
	 * @returns {void***REMOVED***
	 */
	sortWith(sortFn) {
		if (this.size <= 1 || sortFn === this._lastActiveSortFn) {
			// already sorted - nothing to do
			return;
		***REMOVED***

		const sortedArray = Array.from(this).sort(sortFn);
		super.clear();
		for (let i = 0; i < sortedArray.length; i += 1) {
			super.add(sortedArray[i]);
		***REMOVED***
		this._lastActiveSortFn = sortFn;
		this._invalidateCache();
	***REMOVED***

	sort() {
		this.sortWith(this._sortFn);
		return this;
	***REMOVED***

	/**
	 * Get data from cache
	 * @template {EXPECTED_ANY***REMOVED*** R
	 * @param {(set: SortableSet<T>) => R***REMOVED*** fn function to calculate value
	 * @returns {R***REMOVED*** returns result of fn(this), cached until set changes
	 */
	getFromCache(fn) {
		if (this._cache === undefined) {
			this._cache = new Map();
		***REMOVED*** else {
			const result = this._cache.get(fn);
			const data = /** @type {R***REMOVED*** */ (result);
			if (data !== undefined) {
				return data;
			***REMOVED***
		***REMOVED***
		const newData = fn(this);
		this._cache.set(fn, newData);
		return newData;
	***REMOVED***

	/**
	 * Get data from cache (ignoring sorting)
	 * @template R
	 * @param {(set: SortableSet<T>) => R***REMOVED*** fn function to calculate value
	 * @returns {R***REMOVED*** returns result of fn(this), cached until set changes
	 */
	getFromUnorderedCache(fn) {
		if (this._cacheOrderIndependent === undefined) {
			this._cacheOrderIndependent = new Map();
		***REMOVED*** else {
			const result = this._cacheOrderIndependent.get(fn);
			const data = /** @type {R***REMOVED*** */ (result);
			if (data !== undefined) {
				return data;
			***REMOVED***
		***REMOVED***
		const newData = fn(this);
		this._cacheOrderIndependent.set(fn, newData);
		return newData;
	***REMOVED***

	/**
	 * @private
	 * @returns {void***REMOVED***
	 */
	_invalidateCache() {
		if (this._cache !== undefined) {
			this._cache.clear();
		***REMOVED***
	***REMOVED***

	/**
	 * @private
	 * @returns {void***REMOVED***
	 */
	_invalidateOrderedCache() {
		if (this._cacheOrderIndependent !== undefined) {
			this._cacheOrderIndependent.clear();
		***REMOVED***
	***REMOVED***

	/**
	 * @returns {T[]***REMOVED*** the raw array
	 */
	toJSON() {
		return Array.from(this);
	***REMOVED***
***REMOVED***

module.exports = SortableSet;
