'use strict';

var inspect = require('object-inspect');

var $TypeError = require('es-errors/type');

/*
* This function traverses the list returning the node corresponding to the given key.
*
* That node is also moved to the head of the list, so that if it's accessed again we don't need to traverse the whole list.
* By doing so, all the recently used nodes can be accessed relatively quickly.
*/
/** @type {import('./list.d.ts').listGetNode***REMOVED*** */
// eslint-disable-next-line consistent-return
var listGetNode = function (list, key, isDelete) {
	/** @type {typeof list | NonNullable<(typeof list)['next']>***REMOVED*** */
	var prev = list;
	/** @type {(typeof list)['next']***REMOVED*** */
	var curr;
	// eslint-disable-next-line eqeqeq
	for (; (curr = prev.next) != null; prev = curr) {
		if (curr.key === key) {
			prev.next = curr.next;
			if (!isDelete) {
				// eslint-disable-next-line no-extra-parens
				curr.next = /** @type {NonNullable<typeof list.next>***REMOVED*** */ (list.next);
				list.next = curr; // eslint-disable-line no-param-reassign
			***REMOVED***
			return curr;
		***REMOVED***
	***REMOVED***
***REMOVED***;

/** @type {import('./list.d.ts').listGet***REMOVED*** */
var listGet = function (objects, key) {
	if (!objects) {
		return void undefined;
	***REMOVED***
	var node = listGetNode(objects, key);
	return node && node.value;
***REMOVED***;
/** @type {import('./list.d.ts').listSet***REMOVED*** */
var listSet = function (objects, key, value) {
	var node = listGetNode(objects, key);
	if (node) {
		node.value = value;
	***REMOVED*** else {
		// Prepend the new node to the beginning of the list
		objects.next = /** @type {import('./list.d.ts').ListNode<typeof value, typeof key>***REMOVED*** */ ({ // eslint-disable-line no-param-reassign, no-extra-parens
			key: key,
			next: objects.next,
			value: value
		***REMOVED***);
	***REMOVED***
***REMOVED***;
/** @type {import('./list.d.ts').listHas***REMOVED*** */
var listHas = function (objects, key) {
	if (!objects) {
		return false;
	***REMOVED***
	return !!listGetNode(objects, key);
***REMOVED***;
/** @type {import('./list.d.ts').listDelete***REMOVED*** */
// eslint-disable-next-line consistent-return
var listDelete = function (objects, key) {
	if (objects) {
		return listGetNode(objects, key, true);
	***REMOVED***
***REMOVED***;

/** @type {import('.')***REMOVED*** */
module.exports = function getSideChannelList() {
	/** @typedef {ReturnType<typeof getSideChannelList>***REMOVED*** Channel */
	/** @typedef {Parameters<Channel['get']>[0]***REMOVED*** K */
	/** @typedef {Parameters<Channel['set']>[1]***REMOVED*** V */

	/** @type {import('./list.d.ts').RootNode<V, K> | undefined***REMOVED*** */ var $o;

	/** @type {Channel***REMOVED*** */
	var channel = {
		assert: function (key) {
			if (!channel.has(key)) {
				throw new $TypeError('Side channel does not contain ' + inspect(key));
			***REMOVED***
		***REMOVED***,
		'delete': function (key) {
			var root = $o && $o.next;
			var deletedNode = listDelete($o, key);
			if (deletedNode && root && root === deletedNode) {
				$o = void undefined;
			***REMOVED***
			return !!deletedNode;
		***REMOVED***,
		get: function (key) {
			return listGet($o, key);
		***REMOVED***,
		has: function (key) {
			return listHas($o, key);
		***REMOVED***,
		set: function (key, value) {
			if (!$o) {
				// Initialize the linked list as an empty node, so that we don't have to special-case handling of the first node: we can always refer to it as (previous node).next, instead of something like (list).head
				$o = {
					next: void undefined
				***REMOVED***;
			***REMOVED***
			// eslint-disable-next-line no-extra-parens
			listSet(/** @type {NonNullable<typeof $o>***REMOVED*** */ ($o), key, value);
		***REMOVED***
	***REMOVED***;
	// @ts-expect-error TODO: figure out why this is erroring
	return channel;
***REMOVED***;
