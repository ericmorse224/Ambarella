'use strict';

const assert = require('assert');
const Events = require('events');
const utils = require('./lib/utils');

/**
 * Create an instance of `Enquirer`.
 *
 * ```js
 * const Enquirer = require('enquirer');
 * const enquirer = new Enquirer();
 * ```
 * @name Enquirer
 * @param {Object***REMOVED*** `options` (optional) Options to use with all prompts.
 * @param {Object***REMOVED*** `answers` (optional) Answers object to initialize with.
 * @api public
 */

class Enquirer extends Events {
  constructor(options, answers) {
    super();
    this.options = utils.merge({***REMOVED***, options);
    this.answers = { ...answers ***REMOVED***;
  ***REMOVED***

  /**
   * Register a custom prompt type.
   *
   * ```js
   * const Enquirer = require('enquirer');
   * const enquirer = new Enquirer();
   * enquirer.register('customType', require('./custom-prompt'));
   * ```
   * @name register()
   * @param {String***REMOVED*** `type`
   * @param {Function|Prompt***REMOVED*** `fn` `Prompt` class, or a function that returns a `Prompt` class.
   * @return {Object***REMOVED*** Returns the Enquirer instance
   * @api public
   */

  register(type, fn) {
    if (utils.isObject(type)) {
      for (let key of Object.keys(type)) this.register(key, type[key]);
      return this;
    ***REMOVED***

    assert.equal(typeof fn, 'function', 'expected a function');
    const name = type.toLowerCase();

    if (fn.prototype instanceof this.Prompt) {
      this.prompts[name] = fn;
    ***REMOVED*** else {
      this.prompts[name] = fn(this.Prompt, this);
    ***REMOVED***

    return this;
  ***REMOVED***

  /**
   * Prompt function that takes a "question" object or array of question objects,
   * and returns an object with responses from the user.
   *
   * ```js
   * const Enquirer = require('enquirer');
   * const enquirer = new Enquirer();
   *
   * const response = await enquirer.prompt({
   *   type: 'input',
   *   name: 'username',
   *   message: 'What is your username?'
   * ***REMOVED***);
   * console.log(response);
   * ```
   * @name prompt()
   * @param {Array|Object***REMOVED*** `questions` Options objects for one or more prompts to run.
   * @return {Promise***REMOVED*** Promise that returns an "answers" object with the user's responses.
   * @api public
   */

  async prompt(questions = []) {
    for (let question of [].concat(questions)) {
      try {
        if (typeof question === 'function') question = await question.call(this);
        await this.ask(utils.merge({***REMOVED***, this.options, question));
      ***REMOVED*** catch (err) {
        return Promise.reject(err);
      ***REMOVED***
    ***REMOVED***
    return this.answers;
  ***REMOVED***

  async ask(question) {
    if (typeof question === 'function') {
      question = await question.call(this);
    ***REMOVED***

    let opts = utils.merge({***REMOVED***, this.options, question);
    let { type, name ***REMOVED*** = question;
    let { set, get ***REMOVED*** = utils;

    if (typeof type === 'function') {
      type = await type.call(this, question, this.answers);
    ***REMOVED***

    if (!type) return this.answers[name];
    if (type === 'number') type = 'numeral';

    assert(this.prompts[type], `Prompt "${type***REMOVED***" is not registered`);

    let prompt = new this.prompts[type](opts);
    let value = get(this.answers, name);

    prompt.state.answers = this.answers;
    prompt.enquirer = this;

    if (name) {
      prompt.on('submit', value => {
        this.emit('answer', name, value, prompt);
        set(this.answers, name, value);
      ***REMOVED***);
    ***REMOVED***

    // bubble events
    let emit = prompt.emit.bind(prompt);
    prompt.emit = (...args) => {
      this.emit.call(this, ...args);
      return emit(...args);
    ***REMOVED***;

    this.emit('prompt', prompt, this);

    if (opts.autofill && value != null) {
      prompt.value = prompt.input = value;

      // if "autofill=show" render the prompt, otherwise stay "silent"
      if (opts.autofill === 'show') {
        await prompt.submit();
      ***REMOVED***
    ***REMOVED*** else {
      value = prompt.value = await prompt.run();
    ***REMOVED***

    return value;
  ***REMOVED***

  /**
   * Use an enquirer plugin.
   *
   * ```js
   * const Enquirer = require('enquirer');
   * const enquirer = new Enquirer();
   * const plugin = enquirer => {
   *   // do stuff to enquire instance
   * ***REMOVED***;
   * enquirer.use(plugin);
   * ```
   * @name use()
   * @param {Function***REMOVED*** `plugin` Plugin function that takes an instance of Enquirer.
   * @return {Object***REMOVED*** Returns the Enquirer instance.
   * @api public
   */

  use(plugin) {
    plugin.call(this, this);
    return this;
  ***REMOVED***

  set Prompt(value) {
    this._Prompt = value;
  ***REMOVED***
  get Prompt() {
    return this._Prompt || this.constructor.Prompt;
  ***REMOVED***

  get prompts() {
    return this.constructor.prompts;
  ***REMOVED***

  static set Prompt(value) {
    this._Prompt = value;
  ***REMOVED***
  static get Prompt() {
    return this._Prompt || require('./lib/prompt');
  ***REMOVED***

  static get prompts() {
    return require('./lib/prompts');
  ***REMOVED***

  static get types() {
    return require('./lib/types');
  ***REMOVED***

  /**
   * Prompt function that takes a "question" object or array of question objects,
   * and returns an object with responses from the user.
   *
   * ```js
   * const { prompt ***REMOVED*** = require('enquirer');
   * const response = await prompt({
   *   type: 'input',
   *   name: 'username',
   *   message: 'What is your username?'
   * ***REMOVED***);
   * console.log(response);
   * ```
   * @name Enquirer#prompt
   * @param {Array|Object***REMOVED*** `questions` Options objects for one or more prompts to run.
   * @return {Promise***REMOVED*** Promise that returns an "answers" object with the user's responses.
   * @api public
   */

  static get prompt() {
    const fn = (questions, ...rest) => {
      let enquirer = new this(...rest);
      let emit = enquirer.emit.bind(enquirer);
      enquirer.emit = (...args) => {
        fn.emit(...args);
        return emit(...args);
      ***REMOVED***;
      return enquirer.prompt(questions);
    ***REMOVED***;
    utils.mixinEmitter(fn, new Events());
    return fn;
  ***REMOVED***
***REMOVED***

utils.mixinEmitter(Enquirer, new Events());
const prompts = Enquirer.prompts;

for (let name of Object.keys(prompts)) {
  let key = name.toLowerCase();

  let run = options => new prompts[name](options).run();
  Enquirer.prompt[key] = run;
  Enquirer[key] = run;

  if (!Enquirer[name]) {
    Reflect.defineProperty(Enquirer, name, { get: () => prompts[name] ***REMOVED***);
  ***REMOVED***
***REMOVED***

const define = name => {
  utils.defineExport(Enquirer, name, () => Enquirer.types[name]);
***REMOVED***;

define('ArrayPrompt');
define('AuthPrompt');
define('BooleanPrompt');
define('NumberPrompt');
define('StringPrompt');

module.exports = Enquirer;
