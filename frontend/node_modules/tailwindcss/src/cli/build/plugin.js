// @ts-check

import path from 'path'
import fs from 'fs'
import postcssrc from 'postcss-load-config'
import { lilconfig ***REMOVED*** from 'lilconfig'
import loadPlugins from 'postcss-load-config/src/plugins' // Little bit scary, looking at private/internal API
import loadOptions from 'postcss-load-config/src/options' // Little bit scary, looking at private/internal API

import tailwind from '../../processTailwindFeatures'
import { loadAutoprefixer, loadCssNano, loadPostcss, loadPostcssImport ***REMOVED*** from './deps'
import { formatNodes, drainStdin, outputFile ***REMOVED*** from './utils'
import { env ***REMOVED*** from '../../lib/sharedState'
import resolveConfig from '../../../resolveConfig.js'
import { createBroadPatternCheck, parseCandidateFiles ***REMOVED*** from '../../lib/content.js'
import { createWatcher ***REMOVED*** from './watching.js'
import fastGlob from 'fast-glob'
import { findAtConfigPath ***REMOVED*** from '../../lib/findAtConfigPath.js'
import log from '../../util/log'
import { loadConfig ***REMOVED*** from '../../lib/load-config'
import getModuleDependencies from '../../lib/getModuleDependencies'

/**
 *
 * @param {string***REMOVED*** [customPostCssPath ]
 * @returns
 */
async function loadPostCssPlugins(customPostCssPath) {
  let config = customPostCssPath
    ? await (async () => {
        let file = path.resolve(customPostCssPath)

        // Implementation, see: https://unpkg.com/browse/postcss-load-config@3.1.0/src/index.js
        // @ts-ignore
        let { config = {***REMOVED*** ***REMOVED*** = await lilconfig('postcss').load(file)
        if (typeof config === 'function') {
          config = config()
        ***REMOVED*** else {
          config = Object.assign({***REMOVED***, config)
        ***REMOVED***

        if (!config.plugins) {
          config.plugins = []
        ***REMOVED***

        return {
          file,
          plugins: loadPlugins(config, file),
          options: loadOptions(config, file),
        ***REMOVED***
      ***REMOVED***)()
    : await postcssrc()

  let configPlugins = config.plugins

  let configPluginTailwindIdx = configPlugins.findIndex((plugin) => {
    if (typeof plugin === 'function' && plugin.name === 'tailwindcss') {
      return true
    ***REMOVED***

    if (typeof plugin === 'object' && plugin !== null && plugin.postcssPlugin === 'tailwindcss') {
      return true
    ***REMOVED***

    return false
  ***REMOVED***)

  let beforePlugins =
    configPluginTailwindIdx === -1 ? [] : configPlugins.slice(0, configPluginTailwindIdx)
  let afterPlugins =
    configPluginTailwindIdx === -1
      ? configPlugins
      : configPlugins.slice(configPluginTailwindIdx + 1)

  return [beforePlugins, afterPlugins, config.options]
***REMOVED***

function loadBuiltinPostcssPlugins() {
  let postcss = loadPostcss()
  let IMPORT_COMMENT = '__TAILWIND_RESTORE_IMPORT__: '
  return [
    [
      (root) => {
        root.walkAtRules('import', (rule) => {
          if (rule.params.slice(1).startsWith('tailwindcss/')) {
            rule.after(postcss.comment({ text: IMPORT_COMMENT + rule.params ***REMOVED***))
            rule.remove()
          ***REMOVED***
        ***REMOVED***)
      ***REMOVED***,
      loadPostcssImport(),
      (root) => {
        root.walkComments((rule) => {
          if (rule.text.startsWith(IMPORT_COMMENT)) {
            rule.after(
              postcss.atRule({
                name: 'import',
                params: rule.text.replace(IMPORT_COMMENT, ''),
              ***REMOVED***)
            )
            rule.remove()
          ***REMOVED***
        ***REMOVED***)
      ***REMOVED***,
    ],
    [],
    {***REMOVED***,
  ]
***REMOVED***

let state = {
  /** @type {any***REMOVED*** */
  context: null,

  /** @type {ReturnType<typeof createWatcher> | null***REMOVED*** */
  watcher: null,

  /** @type {{content: string, extension: string***REMOVED***[]***REMOVED*** */
  changedContent: [],

  /** @type {ReturnType<typeof load> | null***REMOVED*** */
  configBag: null,

  contextDependencies: new Set(),

  /** @type {import('../../lib/content.js').ContentPath[]***REMOVED*** */
  contentPaths: [],

  refreshContentPaths() {
    this.contentPaths = parseCandidateFiles(this.context, this.context?.tailwindConfig)
  ***REMOVED***,

  get config() {
    return this.context.tailwindConfig
  ***REMOVED***,

  get contentPatterns() {
    return {
      all: this.contentPaths.map((contentPath) => contentPath.pattern),
      dynamic: this.contentPaths
        .filter((contentPath) => contentPath.glob !== undefined)
        .map((contentPath) => contentPath.pattern),
    ***REMOVED***
  ***REMOVED***,

  loadConfig(configPath, content) {
    if (this.watcher && configPath) {
      this.refreshConfigDependencies()
    ***REMOVED***

    let config = loadConfig(configPath)
    let dependencies = getModuleDependencies(configPath)
    this.configBag = {
      config,
      dependencies,
      dispose() {
        for (let file of dependencies) {
          delete require.cache[require.resolve(file)]
        ***REMOVED***
      ***REMOVED***,
    ***REMOVED***

    // @ts-ignore
    this.configBag.config = resolveConfig(this.configBag.config, { content: { files: [] ***REMOVED*** ***REMOVED***)

    // Override content files if `--content` has been passed explicitly
    if (content?.length > 0) {
      this.configBag.config.content.files = content
    ***REMOVED***

    return this.configBag.config
  ***REMOVED***,

  refreshConfigDependencies() {
    env.DEBUG && console.time('Module dependencies')
    this.configBag?.dispose()
    env.DEBUG && console.timeEnd('Module dependencies')
  ***REMOVED***,

  readContentPaths() {
    let content = []

    // Resolve globs from the content config
    // TODO: When we make the postcss plugin async-capable this can become async
    let files = fastGlob.sync(this.contentPatterns.all)

    let checkBroadPattern = createBroadPatternCheck(this.contentPatterns.all)

    for (let file of files) {
      checkBroadPattern(file)

      content.push({
        content: fs.readFileSync(path.resolve(file), 'utf8'),
        extension: path.extname(file).slice(1),
      ***REMOVED***)
    ***REMOVED***

    // Resolve raw content in the tailwind config
    let rawContent = this.config.content.files.filter((file) => {
      return file !== null && typeof file === 'object'
    ***REMOVED***)

    for (let { raw: htmlContent, extension = 'html' ***REMOVED*** of rawContent) {
      content.push({ content: htmlContent, extension ***REMOVED***)
    ***REMOVED***

    return content
  ***REMOVED***,

  getContext({ createContext, cliConfigPath, root, result, content ***REMOVED***) {
    env.DEBUG && console.time('Searching for config')
    let configPath = findAtConfigPath(root, result) ?? cliConfigPath
    env.DEBUG && console.timeEnd('Searching for config')

    if (this.context) {
      this.context.changedContent = this.changedContent.splice(0)

      return this.context
    ***REMOVED***

    env.DEBUG && console.time('Loading config')
    let config = this.loadConfig(configPath, content)
    env.DEBUG && console.timeEnd('Loading config')

    env.DEBUG && console.time('Creating context')
    this.context = createContext(config, [])
    Object.assign(this.context, {
      userConfigPath: configPath,
    ***REMOVED***)
    env.DEBUG && console.timeEnd('Creating context')

    env.DEBUG && console.time('Resolving content paths')
    this.refreshContentPaths()
    env.DEBUG && console.timeEnd('Resolving content paths')

    if (this.watcher) {
      env.DEBUG && console.time('Watch new files')
      this.watcher.refreshWatchedFiles()
      env.DEBUG && console.timeEnd('Watch new files')
    ***REMOVED***

    for (let file of this.readContentPaths()) {
      this.context.changedContent.push(file)
    ***REMOVED***

    return this.context
  ***REMOVED***,
***REMOVED***

export async function createProcessor(args, cliConfigPath) {
  let postcss = loadPostcss()

  let input = args['--input']
  let output = args['--output']
  let includePostCss = args['--postcss']
  let customPostCssPath = typeof args['--postcss'] === 'string' ? args['--postcss'] : undefined

  let [beforePlugins, afterPlugins, postcssOptions] = includePostCss
    ? await loadPostCssPlugins(customPostCssPath)
    : loadBuiltinPostcssPlugins()

  if (args['--purge']) {
    log.warn('purge-flag-deprecated', [
      'The `--purge` flag has been deprecated.',
      'Please use `--content` instead.',
    ])

    if (!args['--content']) {
      args['--content'] = args['--purge']
    ***REMOVED***
  ***REMOVED***

  let content = args['--content']?.split(/(?<!{[^***REMOVED***]+),/) ?? []

  let tailwindPlugin = () => {
    return {
      postcssPlugin: 'tailwindcss',
      async Once(root, { result ***REMOVED***) {
        env.DEBUG && console.time('Compiling CSS')
        await tailwind(({ createContext ***REMOVED***) => {
          console.error()
          console.error('Rebuilding...')

          return () => {
            return state.getContext({
              createContext,
              cliConfigPath,
              root,
              result,
              content,
            ***REMOVED***)
          ***REMOVED***
        ***REMOVED***)(root, result)
        env.DEBUG && console.timeEnd('Compiling CSS')
      ***REMOVED***,
    ***REMOVED***
  ***REMOVED***

  tailwindPlugin.postcss = true

  let plugins = [
    ...beforePlugins,
    tailwindPlugin,
    !args['--minify'] && formatNodes,
    ...afterPlugins,
    !args['--no-autoprefixer'] && loadAutoprefixer(),
    args['--minify'] && loadCssNano(),
  ].filter(Boolean)

  /** @type {import('postcss').Processor***REMOVED*** */
  // @ts-ignore
  let processor = postcss(plugins)

  async function readInput() {
    // Piping in data, let's drain the stdin
    if (input === '-') {
      return drainStdin()
    ***REMOVED***

    // Input file has been provided
    if (input) {
      return fs.promises.readFile(path.resolve(input), 'utf8')
    ***REMOVED***

    // No input file provided, fallback to default at-rules
    return '@tailwind base; @tailwind components; @tailwind utilities'
  ***REMOVED***

  async function build() {
    let start = process.hrtime.bigint()

    return readInput()
      .then((css) => processor.process(css, { ...postcssOptions, from: input, to: output ***REMOVED***))
      .then((result) => {
        if (!state.watcher) {
          return result
        ***REMOVED***

        env.DEBUG && console.time('Recording PostCSS dependencies')
        for (let message of result.messages) {
          if (message.type === 'dependency') {
            state.contextDependencies.add(message.file)
          ***REMOVED***
        ***REMOVED***
        env.DEBUG && console.timeEnd('Recording PostCSS dependencies')

        // TODO: This needs to be in a different spot
        env.DEBUG && console.time('Watch new files')
        state.watcher.refreshWatchedFiles()
        env.DEBUG && console.timeEnd('Watch new files')

        return result
      ***REMOVED***)
      .then((result) => {
        if (!output) {
          process.stdout.write(result.css)
          return
        ***REMOVED***

        return Promise.all([
          outputFile(result.opts.to, result.css),
          result.map && outputFile(result.opts.to + '.map', result.map.toString()),
        ])
      ***REMOVED***)
      .then(() => {
        let end = process.hrtime.bigint()
        console.error()
        console.error('Done in', (end - start) / BigInt(1e6) + 'ms.')
      ***REMOVED***)
      .then(
        () => {***REMOVED***,
        (err) => {
          // TODO: If an initial build fails we can't easily pick up any PostCSS dependencies
          // that were collected before the error occurred
          // The result is not stored on the error so we have to store it externally
          // and pull the messages off of it here somehow

          // This results in a less than ideal DX because the watcher will not pick up
          // changes to imported CSS if one of them caused an error during the initial build
          // If you fix it and then save the main CSS file so there's no error
          // The watcher will start watching the imported CSS files and will be
          // resilient to future errors.

          if (state.watcher) {
            console.error(err)
          ***REMOVED*** else {
            return Promise.reject(err)
          ***REMOVED***
        ***REMOVED***
      )
  ***REMOVED***

  /**
   * @param {{file: string, content(): Promise<string>, extension: string***REMOVED***[]***REMOVED*** changes
   */
  async function parseChanges(changes) {
    return Promise.all(
      changes.map(async (change) => ({
        content: await change.content(),
        extension: change.extension,
      ***REMOVED***))
    )
  ***REMOVED***

  if (input !== undefined && input !== '-') {
    state.contextDependencies.add(path.resolve(input))
  ***REMOVED***

  return {
    build,
    watch: async () => {
      state.watcher = createWatcher(args, {
        state,

        /**
         * @param {{file: string, content(): Promise<string>, extension: string***REMOVED***[]***REMOVED*** changes
         */
        async rebuild(changes) {
          let needsNewContext = changes.some((change) => {
            return (
              state.configBag?.dependencies.has(change.file) ||
              state.contextDependencies.has(change.file)
            )
          ***REMOVED***)

          if (needsNewContext) {
            state.context = null
          ***REMOVED*** else {
            for (let change of await parseChanges(changes)) {
              state.changedContent.push(change)
            ***REMOVED***
          ***REMOVED***

          return build()
        ***REMOVED***,
      ***REMOVED***)

      await build()
    ***REMOVED***,
  ***REMOVED***
***REMOVED***
