'use strict';

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String***REMOVED*** input The URI encoded string.
 * @returns {String|Null***REMOVED*** The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  ***REMOVED*** catch (e) {
    return null;
  ***REMOVED***
***REMOVED***

/**
 * Attempts to encode a given input.
 *
 * @param {String***REMOVED*** input The string that needs to be encoded.
 * @returns {String|Null***REMOVED*** The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  ***REMOVED*** catch (e) {
    return null;
  ***REMOVED***
***REMOVED***

/**
 * Simple query string parser.
 *
 * @param {String***REMOVED*** query The query string that needs to be parsed.
 * @returns {Object***REMOVED***
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {***REMOVED***
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  ***REMOVED***

  return result;
***REMOVED***

/**
 * Transform a query string to an object.
 *
 * @param {Object***REMOVED*** obj Object that should be transformed.
 * @param {String***REMOVED*** prefix Optional prefix.
 * @returns {String***REMOVED***
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      ***REMOVED***

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    ***REMOVED***
  ***REMOVED***

  return pairs.length ? prefix + pairs.join('&') : '';
***REMOVED***

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;
