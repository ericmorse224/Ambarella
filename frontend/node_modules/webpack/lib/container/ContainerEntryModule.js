/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra, Zackary Jackson @ScriptedAlchemy, Marais Rossouw @maraisr
*/

"use strict";

const { OriginalSource, RawSource ***REMOVED*** = require("webpack-sources");
const AsyncDependenciesBlock = require("../AsyncDependenciesBlock");
const Module = require("../Module");
const { JS_TYPES ***REMOVED*** = require("../ModuleSourceTypesConstants");
const { JAVASCRIPT_MODULE_TYPE_DYNAMIC ***REMOVED*** = require("../ModuleTypeConstants");
const RuntimeGlobals = require("../RuntimeGlobals");
const Template = require("../Template");
const StaticExportsDependency = require("../dependencies/StaticExportsDependency");
const makeSerializable = require("../util/makeSerializable");
const ContainerExposedDependency = require("./ContainerExposedDependency");

/** @typedef {import("../../declarations/WebpackOptions").WebpackOptionsNormalized***REMOVED*** WebpackOptions */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../ChunkGroup")***REMOVED*** ChunkGroup */
/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("../Module").BuildCallback***REMOVED*** BuildCallback */
/** @typedef {import("../Module").CodeGenerationContext***REMOVED*** CodeGenerationContext */
/** @typedef {import("../Module").CodeGenerationResult***REMOVED*** CodeGenerationResult */
/** @typedef {import("../Module").LibIdentOptions***REMOVED*** LibIdentOptions */
/** @typedef {import("../Module").NeedBuildCallback***REMOVED*** NeedBuildCallback */
/** @typedef {import("../Module").NeedBuildContext***REMOVED*** NeedBuildContext */
/** @typedef {import("../Module").SourceTypes***REMOVED*** SourceTypes */
/** @typedef {import("../RequestShortener")***REMOVED*** RequestShortener */
/** @typedef {import("../ResolverFactory").ResolverWithOptions***REMOVED*** ResolverWithOptions */
/** @typedef {import("../WebpackError")***REMOVED*** WebpackError */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext***REMOVED*** ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext***REMOVED*** ObjectSerializerContext */
/** @typedef {import("../util/Hash")***REMOVED*** Hash */
/** @typedef {import("../util/fs").InputFileSystem***REMOVED*** InputFileSystem */
/** @typedef {import("./ContainerEntryDependency")***REMOVED*** ContainerEntryDependency */

/**
 * @typedef {object***REMOVED*** ExposeOptions
 * @property {string[]***REMOVED*** import requests to exposed modules (last one is exported)
 * @property {string***REMOVED*** name custom chunk name for the exposed module
 */

/** @typedef {[string, ExposeOptions][]***REMOVED*** ExposesList */

class ContainerEntryModule extends Module {
	/**
	 * @param {string***REMOVED*** name container entry name
	 * @param {ExposesList***REMOVED*** exposes list of exposed modules
	 * @param {string***REMOVED*** shareScope name of the share scope
	 */
	constructor(name, exposes, shareScope) {
		super(JAVASCRIPT_MODULE_TYPE_DYNAMIC, null);
		this._name = name;
		this._exposes = exposes;
		this._shareScope = shareScope;
	***REMOVED***

	/**
	 * @returns {SourceTypes***REMOVED*** types available (do not mutate)
	 */
	getSourceTypes() {
		return JS_TYPES;
	***REMOVED***

	/**
	 * @returns {string***REMOVED*** a unique identifier of the module
	 */
	identifier() {
		return `container entry (${this._shareScope***REMOVED***) ${JSON.stringify(
			this._exposes
		)***REMOVED***`;
	***REMOVED***

	/**
	 * @param {RequestShortener***REMOVED*** requestShortener the request shortener
	 * @returns {string***REMOVED*** a user readable identifier of the module
	 */
	readableIdentifier(requestShortener) {
		return "container entry";
	***REMOVED***

	/**
	 * @param {LibIdentOptions***REMOVED*** options options
	 * @returns {string | null***REMOVED*** an identifier for library inclusion
	 */
	libIdent(options) {
		return `${this.layer ? `(${this.layer***REMOVED***)/` : ""***REMOVED***webpack/container/entry/${
			this._name
		***REMOVED***`;
	***REMOVED***

	/**
	 * @param {NeedBuildContext***REMOVED*** context context info
	 * @param {NeedBuildCallback***REMOVED*** callback callback function, returns true, if the module needs a rebuild
	 * @returns {void***REMOVED***
	 */
	needBuild(context, callback) {
		return callback(null, !this.buildMeta);
	***REMOVED***

	/**
	 * @param {WebpackOptions***REMOVED*** options webpack options
	 * @param {Compilation***REMOVED*** compilation the compilation
	 * @param {ResolverWithOptions***REMOVED*** resolver the resolver
	 * @param {InputFileSystem***REMOVED*** fs the file system
	 * @param {BuildCallback***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	build(options, compilation, resolver, fs, callback) {
		this.buildMeta = {***REMOVED***;
		this.buildInfo = {
			strict: true,
			topLevelDeclarations: new Set(["moduleMap", "get", "init"])
		***REMOVED***;
		this.buildMeta.exportsType = "namespace";

		this.clearDependenciesAndBlocks();

		for (const [name, options] of this._exposes) {
			const block = new AsyncDependenciesBlock(
				{
					name: options.name
				***REMOVED***,
				{ name ***REMOVED***,
				options.import[options.import.length - 1]
			);
			let idx = 0;
			for (const request of options.import) {
				const dep = new ContainerExposedDependency(name, request);
				dep.loc = {
					name,
					index: idx++
				***REMOVED***;

				block.addDependency(dep);
			***REMOVED***
			this.addBlock(block);
		***REMOVED***
		this.addDependency(new StaticExportsDependency(["get", "init"], false));

		callback();
	***REMOVED***

	/**
	 * @param {CodeGenerationContext***REMOVED*** context context for code generation
	 * @returns {CodeGenerationResult***REMOVED*** result
	 */
	codeGeneration({ moduleGraph, chunkGraph, runtimeTemplate ***REMOVED***) {
		const sources = new Map();
		const runtimeRequirements = new Set([
			RuntimeGlobals.definePropertyGetters,
			RuntimeGlobals.hasOwnProperty,
			RuntimeGlobals.exports
		]);
		const getters = [];

		for (const block of this.blocks) {
			const { dependencies ***REMOVED*** = block;

			const modules = dependencies.map(dependency => {
				const dep = /** @type {ContainerExposedDependency***REMOVED*** */ (dependency);
				return {
					name: dep.exposedName,
					module: moduleGraph.getModule(dep),
					request: dep.userRequest
				***REMOVED***;
			***REMOVED***);

			let str;

			if (modules.some(m => !m.module)) {
				str = runtimeTemplate.throwMissingModuleErrorBlock({
					request: modules.map(m => m.request).join(", ")
				***REMOVED***);
			***REMOVED*** else {
				str = `return ${runtimeTemplate.blockPromise({
					block,
					message: "",
					chunkGraph,
					runtimeRequirements
				***REMOVED***)***REMOVED***.then(${runtimeTemplate.returningFunction(
					runtimeTemplate.returningFunction(
						`(${modules
							.map(({ module, request ***REMOVED***) =>
								runtimeTemplate.moduleRaw({
									module,
									chunkGraph,
									request,
									weak: false,
									runtimeRequirements
								***REMOVED***)
							)
							.join(", ")***REMOVED***)`
					)
				)***REMOVED***);`;
			***REMOVED***

			getters.push(
				`${JSON.stringify(modules[0].name)***REMOVED***: ${runtimeTemplate.basicFunction(
					"",
					str
				)***REMOVED***`
			);
		***REMOVED***

		const source = Template.asString([
			"var moduleMap = {",
			Template.indent(getters.join(",\n")),
			"***REMOVED***;",
			`var get = ${runtimeTemplate.basicFunction("module, getScope", [
				`${RuntimeGlobals.currentRemoteGetScope***REMOVED*** = getScope;`,
				// reusing the getScope variable to avoid creating a new var (and module is also used later)
				"getScope = (",
				Template.indent([
					`${RuntimeGlobals.hasOwnProperty***REMOVED***(moduleMap, module)`,
					Template.indent([
						"? moduleMap[module]()",
						`: Promise.resolve().then(${runtimeTemplate.basicFunction(
							"",
							"throw new Error('Module \"' + module + '\" does not exist in container.');"
						)***REMOVED***)`
					])
				]),
				");",
				`${RuntimeGlobals.currentRemoteGetScope***REMOVED*** = undefined;`,
				"return getScope;"
			])***REMOVED***;`,
			`var init = ${runtimeTemplate.basicFunction("shareScope, initScope", [
				`if (!${RuntimeGlobals.shareScopeMap***REMOVED***) return;`,
				`var name = ${JSON.stringify(this._shareScope)***REMOVED***`,
				`var oldScope = ${RuntimeGlobals.shareScopeMap***REMOVED***[name];`,
				'if(oldScope && oldScope !== shareScope) throw new Error("Container initialization failed as it has already been initialized with a different share scope");',
				`${RuntimeGlobals.shareScopeMap***REMOVED***[name] = shareScope;`,
				`return ${RuntimeGlobals.initializeSharing***REMOVED***(name, initScope);`
			])***REMOVED***;`,
			"",
			"// This exports getters to disallow modifications",
			`${RuntimeGlobals.definePropertyGetters***REMOVED***(exports, {`,
			Template.indent([
				`get: ${runtimeTemplate.returningFunction("get")***REMOVED***,`,
				`init: ${runtimeTemplate.returningFunction("init")***REMOVED***`
			]),
			"***REMOVED***);"
		]);

		sources.set(
			"javascript",
			this.useSourceMap || this.useSimpleSourceMap
				? new OriginalSource(source, "webpack/container-entry")
				: new RawSource(source)
		);

		return {
			sources,
			runtimeRequirements
		***REMOVED***;
	***REMOVED***

	/**
	 * @param {string=***REMOVED*** type the source type for which the size should be estimated
	 * @returns {number***REMOVED*** the estimated size of the module (must be non-zero)
	 */
	size(type) {
		return 42;
	***REMOVED***

	/**
	 * @param {ObjectSerializerContext***REMOVED*** context context
	 */
	serialize(context) {
		const { write ***REMOVED*** = context;
		write(this._name);
		write(this._exposes);
		write(this._shareScope);
		super.serialize(context);
	***REMOVED***

	/**
	 * @param {ObjectDeserializerContext***REMOVED*** context context
	 * @returns {ContainerEntryModule***REMOVED*** deserialized container entry module
	 */
	static deserialize(context) {
		const { read ***REMOVED*** = context;
		const obj = new ContainerEntryModule(read(), read(), read());
		obj.deserialize(context);
		return obj;
	***REMOVED***
***REMOVED***

makeSerializable(
	ContainerEntryModule,
	"webpack/lib/container/ContainerEntryModule"
);

module.exports = ContainerEntryModule;
