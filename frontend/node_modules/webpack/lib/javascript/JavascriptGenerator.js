/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const util = require("util");
const { RawSource, ReplaceSource ***REMOVED*** = require("webpack-sources");
const Generator = require("../Generator");
const InitFragment = require("../InitFragment");
const { JS_TYPES ***REMOVED*** = require("../ModuleSourceTypesConstants");
const HarmonyCompatibilityDependency = require("../dependencies/HarmonyCompatibilityDependency");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../DependenciesBlock")***REMOVED*** DependenciesBlock */
/** @typedef {import("../Dependency")***REMOVED*** Dependency */
/** @typedef {import("../DependencyTemplate")***REMOVED*** DependencyTemplate */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext***REMOVED*** DependencyTemplateContext */
/** @typedef {import("../DependencyTemplates")***REMOVED*** DependencyTemplates */
/** @typedef {import("../Generator").GenerateContext***REMOVED*** GenerateContext */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../Module").ConcatenationBailoutReasonContext***REMOVED*** ConcatenationBailoutReasonContext */
/** @typedef {import("../Module").SourceTypes***REMOVED*** SourceTypes */
/** @typedef {import("../NormalModule")***REMOVED*** NormalModule */
/** @typedef {import("../RuntimeTemplate")***REMOVED*** RuntimeTemplate */

// TODO: clean up this file
// replace with newer constructs

const deprecatedGetInitFragments = util.deprecate(
	/**
	 * @param {DependencyTemplate***REMOVED*** template template
	 * @param {Dependency***REMOVED*** dependency dependency
	 * @param {DependencyTemplateContext***REMOVED*** templateContext template context
	 * @returns {InitFragment<GenerateContext>[]***REMOVED*** init fragments
	 */
	(template, dependency, templateContext) =>
		/** @type {DependencyTemplate & { getInitFragments: (dependency: Dependency, dependencyTemplateContext: DependencyTemplateContext) => InitFragment<GenerateContext>[] ***REMOVED******REMOVED*** */
		(template).getInitFragments(dependency, templateContext),
	"DependencyTemplate.getInitFragment is deprecated (use apply(dep, source, { initFragments ***REMOVED***) instead)",
	"DEP_WEBPACK_JAVASCRIPT_GENERATOR_GET_INIT_FRAGMENTS"
);

class JavascriptGenerator extends Generator {
	/**
	 * @param {NormalModule***REMOVED*** module fresh module
	 * @returns {SourceTypes***REMOVED*** available types (do not mutate)
	 */
	getTypes(module) {
		return JS_TYPES;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module the module
	 * @param {string=***REMOVED*** type source type
	 * @returns {number***REMOVED*** estimate size of the module
	 */
	getSize(module, type) {
		const originalSource = module.originalSource();
		if (!originalSource) {
			return 39;
		***REMOVED***
		return originalSource.size();
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module module for which the bailout reason should be determined
	 * @param {ConcatenationBailoutReasonContext***REMOVED*** context context
	 * @returns {string | undefined***REMOVED*** reason why this module can't be concatenated, undefined when it can be concatenated
	 */
	getConcatenationBailoutReason(module, context) {
		// Only harmony modules are valid for optimization
		if (
			!module.buildMeta ||
			module.buildMeta.exportsType !== "namespace" ||
			module.presentationalDependencies === undefined ||
			!module.presentationalDependencies.some(
				d => d instanceof HarmonyCompatibilityDependency
			)
		) {
			return "Module is not an ECMAScript module";
		***REMOVED***

		// Some expressions are not compatible with module concatenation
		// because they may produce unexpected results. The plugin bails out
		// if some were detected upfront.
		if (module.buildInfo && module.buildInfo.moduleConcatenationBailout) {
			return `Module uses ${module.buildInfo.moduleConcatenationBailout***REMOVED***`;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module module for which the code should be generated
	 * @param {GenerateContext***REMOVED*** generateContext context for generate
	 * @returns {Source | null***REMOVED*** generated code
	 */
	generate(module, generateContext) {
		const originalSource = module.originalSource();
		if (!originalSource) {
			return new RawSource("throw new Error('No source available');");
		***REMOVED***

		const source = new ReplaceSource(originalSource);
		/** @type {InitFragment<GenerateContext>[]***REMOVED*** */
		const initFragments = [];

		this.sourceModule(module, initFragments, source, generateContext);

		return InitFragment.addToSource(source, initFragments, generateContext);
	***REMOVED***

	/**
	 * @param {Error***REMOVED*** error the error
	 * @param {NormalModule***REMOVED*** module module for which the code should be generated
	 * @param {GenerateContext***REMOVED*** generateContext context for generate
	 * @returns {Source | null***REMOVED*** generated code
	 */
	generateError(error, module, generateContext) {
		return new RawSource(`throw new Error(${JSON.stringify(error.message)***REMOVED***);`);
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the module to generate
	 * @param {InitFragment<GenerateContext>[]***REMOVED*** initFragments mutable list of init fragments
	 * @param {ReplaceSource***REMOVED*** source the current replace source which can be modified
	 * @param {GenerateContext***REMOVED*** generateContext the generateContext
	 * @returns {void***REMOVED***
	 */
	sourceModule(module, initFragments, source, generateContext) {
		for (const dependency of module.dependencies) {
			this.sourceDependency(
				module,
				dependency,
				initFragments,
				source,
				generateContext
			);
		***REMOVED***

		if (module.presentationalDependencies !== undefined) {
			for (const dependency of module.presentationalDependencies) {
				this.sourceDependency(
					module,
					dependency,
					initFragments,
					source,
					generateContext
				);
			***REMOVED***
		***REMOVED***

		for (const childBlock of module.blocks) {
			this.sourceBlock(
				module,
				childBlock,
				initFragments,
				source,
				generateContext
			);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the module to generate
	 * @param {DependenciesBlock***REMOVED*** block the dependencies block which will be processed
	 * @param {InitFragment<GenerateContext>[]***REMOVED*** initFragments mutable list of init fragments
	 * @param {ReplaceSource***REMOVED*** source the current replace source which can be modified
	 * @param {GenerateContext***REMOVED*** generateContext the generateContext
	 * @returns {void***REMOVED***
	 */
	sourceBlock(module, block, initFragments, source, generateContext) {
		for (const dependency of block.dependencies) {
			this.sourceDependency(
				module,
				dependency,
				initFragments,
				source,
				generateContext
			);
		***REMOVED***

		for (const childBlock of block.blocks) {
			this.sourceBlock(
				module,
				childBlock,
				initFragments,
				source,
				generateContext
			);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the current module
	 * @param {Dependency***REMOVED*** dependency the dependency to generate
	 * @param {InitFragment<GenerateContext>[]***REMOVED*** initFragments mutable list of init fragments
	 * @param {ReplaceSource***REMOVED*** source the current replace source which can be modified
	 * @param {GenerateContext***REMOVED*** generateContext the render context
	 * @returns {void***REMOVED***
	 */
	sourceDependency(module, dependency, initFragments, source, generateContext) {
		const constructor =
			/** @type {new (...args: EXPECTED_ANY[]) => Dependency***REMOVED*** */
			(dependency.constructor);
		const template = generateContext.dependencyTemplates.get(constructor);
		if (!template) {
			throw new Error(
				`No template for dependency: ${dependency.constructor.name***REMOVED***`
			);
		***REMOVED***

		/** @type {InitFragment<GenerateContext>[] | undefined***REMOVED*** */
		let chunkInitFragments;

		/** @type {DependencyTemplateContext***REMOVED*** */
		const templateContext = {
			runtimeTemplate: generateContext.runtimeTemplate,
			dependencyTemplates: generateContext.dependencyTemplates,
			moduleGraph: generateContext.moduleGraph,
			chunkGraph: generateContext.chunkGraph,
			module,
			runtime: generateContext.runtime,
			runtimeRequirements: generateContext.runtimeRequirements,
			concatenationScope: generateContext.concatenationScope,
			codeGenerationResults:
				/** @type {NonNullable<GenerateContext["codeGenerationResults"]>***REMOVED*** */
				(generateContext.codeGenerationResults),
			initFragments,
			get chunkInitFragments() {
				if (!chunkInitFragments) {
					const data =
						/** @type {NonNullable<GenerateContext["getData"]>***REMOVED*** */
						(generateContext.getData)();
					chunkInitFragments = data.get("chunkInitFragments");
					if (!chunkInitFragments) {
						chunkInitFragments = [];
						data.set("chunkInitFragments", chunkInitFragments);
					***REMOVED***
				***REMOVED***

				return chunkInitFragments;
			***REMOVED***
		***REMOVED***;

		template.apply(dependency, source, templateContext);

		// TODO remove in webpack 6
		if ("getInitFragments" in template) {
			const fragments = deprecatedGetInitFragments(
				template,
				dependency,
				templateContext
			);

			if (fragments) {
				for (const fragment of fragments) {
					initFragments.push(fragment);
				***REMOVED***
			***REMOVED***
		***REMOVED***
	***REMOVED***
***REMOVED***

module.exports = JavascriptGenerator;
