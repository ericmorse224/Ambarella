/**
 * @fileoverview Prevent problematic leaked values from being rendered
 * @author Mario BeltrÃ¡n
 */

'use strict';

const find = require('es-iterator-helpers/Iterator.prototype.find');
const from = require('es-iterator-helpers/Iterator.from');

const getText = require('../util/eslint').getText;
const docsUrl = require('../util/docsUrl');
const report = require('../util/report');
const variableUtil = require('../util/variable');
const testReactVersion = require('../util/version').testReactVersion;
const isParenthesized = require('../util/ast').isParenthesized;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const messages = {
  noPotentialLeakedRender: 'Potential leaked value that might cause unintentionally rendered values or rendering crashes',
***REMOVED***;

const COERCE_STRATEGY = 'coerce';
const TERNARY_STRATEGY = 'ternary';
const DEFAULT_VALID_STRATEGIES = [TERNARY_STRATEGY, COERCE_STRATEGY];
const COERCE_VALID_LEFT_SIDE_EXPRESSIONS = ['UnaryExpression', 'BinaryExpression', 'CallExpression'];
const TERNARY_INVALID_ALTERNATE_VALUES = [undefined, null, false];

function trimLeftNode(node) {
  // Remove double unary expression (boolean coercion), so we avoid trimming valid negations
  if (node.type === 'UnaryExpression' && node.argument.type === 'UnaryExpression') {
    return trimLeftNode(node.argument.argument);
  ***REMOVED***

  return node;
***REMOVED***

function getIsCoerceValidNestedLogicalExpression(node) {
  if (node.type === 'LogicalExpression') {
    return getIsCoerceValidNestedLogicalExpression(node.left) && getIsCoerceValidNestedLogicalExpression(node.right);
  ***REMOVED***

  return COERCE_VALID_LEFT_SIDE_EXPRESSIONS.some((validExpression) => validExpression === node.type);
***REMOVED***

function extractExpressionBetweenLogicalAnds(node) {
  if (node.type !== 'LogicalExpression') return [node];
  if (node.operator !== '&&') return [node];
  return [].concat(
    extractExpressionBetweenLogicalAnds(node.left),
    extractExpressionBetweenLogicalAnds(node.right)
  );
***REMOVED***

function ruleFixer(context, fixStrategy, fixer, reportedNode, leftNode, rightNode) {
  const rightSideText = getText(context, rightNode);

  if (fixStrategy === COERCE_STRATEGY) {
    const expressions = extractExpressionBetweenLogicalAnds(leftNode);
    const newText = expressions.map((node) => {
      let nodeText = getText(context, node);
      if (isParenthesized(context, node)) {
        nodeText = `(${nodeText***REMOVED***)`;
      ***REMOVED***
      if (node.parent && node.parent.type === 'ConditionalExpression' && node.parent.consequent.value === false) {
        return `${getIsCoerceValidNestedLogicalExpression(node) ? '' : '!'***REMOVED***${nodeText***REMOVED***`;
      ***REMOVED***
      return `${getIsCoerceValidNestedLogicalExpression(node) ? '' : '!!'***REMOVED***${nodeText***REMOVED***`;
    ***REMOVED***).join(' && ');

    if (rightNode.parent && rightNode.parent.type === 'ConditionalExpression' && rightNode.parent.consequent.value === false) {
      const consequentVal = rightNode.parent.consequent.raw || rightNode.parent.consequent.name;
      const alternateVal = rightNode.parent.alternate.raw || rightNode.parent.alternate.name;
      if (rightNode.parent.test && rightNode.parent.test.type === 'LogicalExpression') {
        return fixer.replaceText(reportedNode, `${newText***REMOVED*** ? ${consequentVal***REMOVED*** : ${alternateVal***REMOVED***`);
      ***REMOVED***
      return fixer.replaceText(reportedNode, `${newText***REMOVED*** && ${alternateVal***REMOVED***`);
    ***REMOVED***

    if (rightNode.type === 'ConditionalExpression' || rightNode.type === 'LogicalExpression') {
      return fixer.replaceText(reportedNode, `${newText***REMOVED*** && (${rightSideText***REMOVED***)`);
    ***REMOVED***
    if (rightNode.type === 'JSXElement') {
      const rightSideTextLines = rightSideText.split('\n');
      if (rightSideTextLines.length > 1) {
        const rightSideTextLastLine = rightSideTextLines[rightSideTextLines.length - 1];
        const indentSpacesStart = ' '.repeat(rightSideTextLastLine.search(/\S/));
        const indentSpacesClose = ' '.repeat(rightSideTextLastLine.search(/\S/) - 2);
        return fixer.replaceText(reportedNode, `${newText***REMOVED*** && (\n${indentSpacesStart***REMOVED***${rightSideText***REMOVED***\n${indentSpacesClose***REMOVED***)`);
      ***REMOVED***
    ***REMOVED***
    if (rightNode.type === 'Literal') {
      return null;
    ***REMOVED***
    return fixer.replaceText(reportedNode, `${newText***REMOVED*** && ${rightSideText***REMOVED***`);
  ***REMOVED***

  if (fixStrategy === TERNARY_STRATEGY) {
    let leftSideText = getText(context, trimLeftNode(leftNode));
    if (isParenthesized(context, leftNode)) {
      leftSideText = `(${leftSideText***REMOVED***)`;
    ***REMOVED***
    return fixer.replaceText(reportedNode, `${leftSideText***REMOVED*** ? ${rightSideText***REMOVED*** : null`);
  ***REMOVED***

  throw new TypeError('Invalid value for "validStrategies" option');
***REMOVED***

/** @type {import('eslint').Rule.RuleModule***REMOVED*** */
module.exports = {
  meta: {
    docs: {
      description: 'Disallow problematic leaked values from being rendered',
      category: 'Possible Errors',
      recommended: false,
      url: docsUrl('jsx-no-leaked-render'),
    ***REMOVED***,

    messages,

    fixable: 'code',
    schema: [
      {
        type: 'object',
        properties: {
          validStrategies: {
            type: 'array',
            items: {
              enum: [
                TERNARY_STRATEGY,
                COERCE_STRATEGY,
              ],
            ***REMOVED***,
            uniqueItems: true,
            default: DEFAULT_VALID_STRATEGIES,
          ***REMOVED***,
        ***REMOVED***,
        additionalProperties: false,
      ***REMOVED***,
    ],
  ***REMOVED***,

  create(context) {
    const config = context.options[0] || {***REMOVED***;
    const validStrategies = new Set(config.validStrategies || DEFAULT_VALID_STRATEGIES);
    const fixStrategy = find(from(validStrategies), () => true);

    return {
      'JSXExpressionContainer > LogicalExpression[operator="&&"]'(node) {
        const leftSide = node.left;

        const isCoerceValidLeftSide = COERCE_VALID_LEFT_SIDE_EXPRESSIONS
          .some((validExpression) => validExpression === leftSide.type);
        if (validStrategies.has(COERCE_STRATEGY)) {
          if (isCoerceValidLeftSide || getIsCoerceValidNestedLogicalExpression(leftSide)) {
            return;
          ***REMOVED***
          const leftSideVar = variableUtil.getVariableFromContext(context, node, leftSide.name);
          if (leftSideVar) {
            const leftSideValue = leftSideVar.defs
              && leftSideVar.defs.length
              && leftSideVar.defs[0].node.init
              && leftSideVar.defs[0].node.init.value;
            if (typeof leftSideValue === 'boolean') {
              return;
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***

        if (testReactVersion(context, '>= 18') && leftSide.type === 'Literal' && leftSide.value === '') {
          return;
        ***REMOVED***
        report(context, messages.noPotentialLeakedRender, 'noPotentialLeakedRender', {
          node,
          fix(fixer) {
            return ruleFixer(context, fixStrategy, fixer, node, leftSide, node.right);
          ***REMOVED***,
        ***REMOVED***);
      ***REMOVED***,

      'JSXExpressionContainer > ConditionalExpression'(node) {
        if (validStrategies.has(TERNARY_STRATEGY)) {
          return;
        ***REMOVED***

        const isValidTernaryAlternate = TERNARY_INVALID_ALTERNATE_VALUES.indexOf(node.alternate.value) === -1;
        const isJSXElementAlternate = node.alternate.type === 'JSXElement';
        if (isValidTernaryAlternate || isJSXElementAlternate) {
          return;
        ***REMOVED***

        report(context, messages.noPotentialLeakedRender, 'noPotentialLeakedRender', {
          node,
          fix(fixer) {
            return ruleFixer(context, fixStrategy, fixer, node, node.test, node.consequent);
          ***REMOVED***,
        ***REMOVED***);
      ***REMOVED***,
    ***REMOVED***;
  ***REMOVED***,
***REMOVED***;
