/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const RuntimeGlobals = require("../RuntimeGlobals");
const RuntimeModule = require("../RuntimeModule");
const Template = require("../Template");
const {
	parseVersionRuntimeCode,
	versionLtRuntimeCode,
	rangeToStringRuntimeCode,
	satisfyRuntimeCode
***REMOVED*** = require("../util/semver");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../Chunk").ChunkId***REMOVED*** ChunkId */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../ChunkGraph").ModuleId***REMOVED*** ModuleId */
/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../Module").ReadOnlyRuntimeRequirements***REMOVED*** ReadOnlyRuntimeRequirements */
/** @typedef {import("./ConsumeSharedModule")***REMOVED*** ConsumeSharedModule */

class ConsumeSharedRuntimeModule extends RuntimeModule {
	/**
	 * @param {ReadOnlyRuntimeRequirements***REMOVED*** runtimeRequirements runtime requirements
	 */
	constructor(runtimeRequirements) {
		super("consumes", RuntimeModule.STAGE_ATTACH);
		this._runtimeRequirements = runtimeRequirements;
	***REMOVED***

	/**
	 * @returns {string | null***REMOVED*** runtime code
	 */
	generate() {
		const compilation = /** @type {Compilation***REMOVED*** */ (this.compilation);
		const chunkGraph = /** @type {ChunkGraph***REMOVED*** */ (this.chunkGraph);
		const { runtimeTemplate, codeGenerationResults ***REMOVED*** = compilation;
		/** @type {Record<ChunkId, (string | number)[]>***REMOVED*** */
		const chunkToModuleMapping = {***REMOVED***;
		/** @type {Map<string | number, Source>***REMOVED*** */
		const moduleIdToSourceMapping = new Map();
		/** @type {(string | number)[]***REMOVED*** */
		const initialConsumes = [];
		/**
		 * @param {Iterable<Module>***REMOVED*** modules modules
		 * @param {Chunk***REMOVED*** chunk the chunk
		 * @param {(string | number)[]***REMOVED*** list list of ids
		 */
		const addModules = (modules, chunk, list) => {
			for (const m of modules) {
				const module = m;
				const id = /** @type {ModuleId***REMOVED*** */ (chunkGraph.getModuleId(module));
				list.push(id);
				moduleIdToSourceMapping.set(
					id,
					codeGenerationResults.getSource(
						module,
						chunk.runtime,
						"consume-shared"
					)
				);
			***REMOVED***
		***REMOVED***;
		for (const chunk of /** @type {Chunk***REMOVED*** */ (
			this.chunk
		).getAllReferencedChunks()) {
			const modules = chunkGraph.getChunkModulesIterableBySourceType(
				chunk,
				"consume-shared"
			);
			if (!modules) continue;
			addModules(
				modules,
				chunk,
				(chunkToModuleMapping[/** @type {ChunkId***REMOVED*** */ (chunk.id)] = [])
			);
		***REMOVED***
		for (const chunk of /** @type {Chunk***REMOVED*** */ (
			this.chunk
		).getAllInitialChunks()) {
			const modules = chunkGraph.getChunkModulesIterableBySourceType(
				chunk,
				"consume-shared"
			);
			if (!modules) continue;
			addModules(modules, chunk, initialConsumes);
		***REMOVED***
		if (moduleIdToSourceMapping.size === 0) return null;
		return Template.asString([
			parseVersionRuntimeCode(runtimeTemplate),
			versionLtRuntimeCode(runtimeTemplate),
			rangeToStringRuntimeCode(runtimeTemplate),
			satisfyRuntimeCode(runtimeTemplate),
			`var exists = ${runtimeTemplate.basicFunction("scope, key", [
				`return scope && ${RuntimeGlobals.hasOwnProperty***REMOVED***(scope, key);`
			])***REMOVED***`,
			`var get = ${runtimeTemplate.basicFunction("entry", [
				"entry.loaded = 1;",
				"return entry.get()"
			])***REMOVED***;`,
			`var eagerOnly = ${runtimeTemplate.basicFunction("versions", [
				`return Object.keys(versions).reduce(${runtimeTemplate.basicFunction(
					"filtered, version",
					Template.indent([
						"if (versions[version].eager) {",
						Template.indent(["filtered[version] = versions[version];"]),
						"***REMOVED***",
						"return filtered;"
					])
				)***REMOVED***, {***REMOVED***);`
			])***REMOVED***;`,
			`var findLatestVersion = ${runtimeTemplate.basicFunction(
				"scope, key, eager",
				[
					"var versions = eager ? eagerOnly(scope[key]) : scope[key];",
					`var key = Object.keys(versions).reduce(${runtimeTemplate.basicFunction(
						"a, b",
						["return !a || versionLt(a, b) ? b : a;"]
					)***REMOVED***, 0);`,
					"return key && versions[key];"
				]
			)***REMOVED***;`,
			`var findSatisfyingVersion = ${runtimeTemplate.basicFunction(
				"scope, key, requiredVersion, eager",
				[
					"var versions = eager ? eagerOnly(scope[key]) : scope[key];",
					`var key = Object.keys(versions).reduce(${runtimeTemplate.basicFunction(
						"a, b",
						[
							"if (!satisfy(requiredVersion, b)) return a;",
							"return !a || versionLt(a, b) ? b : a;"
						]
					)***REMOVED***, 0);`,
					"return key && versions[key]"
				]
			)***REMOVED***;`,
			`var findSingletonVersionKey = ${runtimeTemplate.basicFunction(
				"scope, key, eager",
				[
					"var versions = eager ? eagerOnly(scope[key]) : scope[key];",
					`return Object.keys(versions).reduce(${runtimeTemplate.basicFunction(
						"a, b",
						["return !a || (!versions[a].loaded && versionLt(a, b)) ? b : a;"]
					)***REMOVED***, 0);`
				]
			)***REMOVED***;`,
			`var getInvalidSingletonVersionMessage = ${runtimeTemplate.basicFunction(
				"scope, key, version, requiredVersion",
				[
					'return "Unsatisfied version " + version + " from " + (version && scope[key][version].from) + " of shared singleton module " + key + " (required " + rangeToString(requiredVersion) + ")"'
				]
			)***REMOVED***;`,
			`var getInvalidVersionMessage = ${runtimeTemplate.basicFunction(
				"scope, scopeName, key, requiredVersion, eager",
				[
					"var versions = scope[key];",
					'return "No satisfying version (" + rangeToString(requiredVersion) + ")" + (eager ? " for eager consumption" : "") + " of shared module " + key + " found in shared scope " + scopeName + ".\\n" +',
					`\t"Available versions: " + Object.keys(versions).map(${runtimeTemplate.basicFunction(
						"key",
						['return key + " from " + versions[key].from;']
					)***REMOVED***).join(", ");`
				]
			)***REMOVED***;`,
			`var fail = ${runtimeTemplate.basicFunction("msg", [
				"throw new Error(msg);"
			])***REMOVED***`,
			`var failAsNotExist = ${runtimeTemplate.basicFunction("scopeName, key", [
				'return fail("Shared module " + key + " doesn\'t exist in shared scope " + scopeName);'
			])***REMOVED***`,
			`var warn = /*#__PURE__*/ ${
				compilation.outputOptions.ignoreBrowserWarnings
					? runtimeTemplate.basicFunction("", "")
					: runtimeTemplate.basicFunction("msg", [
							'if (typeof console !== "undefined" && console.warn) console.warn(msg);'
						])
			***REMOVED***;`,
			`var init = ${runtimeTemplate.returningFunction(
				Template.asString([
					"function(scopeName, key, eager, c, d) {",
					Template.indent([
						`var promise = ${RuntimeGlobals.initializeSharing***REMOVED***(scopeName);`,
						// if we require eager shared, we expect it to be already loaded before it requested, no need to wait the whole scope loaded.
						"if (promise && promise.then && !eager) { ",
						Template.indent([
							`return promise.then(fn.bind(fn, scopeName, ${RuntimeGlobals.shareScopeMap***REMOVED***[scopeName], key, false, c, d));`
						]),
						"***REMOVED***",
						`return fn(scopeName, ${RuntimeGlobals.shareScopeMap***REMOVED***[scopeName], key, eager, c, d);`
					]),
					"***REMOVED***"
				]),
				"fn"
			)***REMOVED***;`,
			"",
			`var useFallback = ${runtimeTemplate.basicFunction(
				"scopeName, key, fallback",
				["return fallback ? fallback() : failAsNotExist(scopeName, key);"]
			)***REMOVED***`,
			`var load = /*#__PURE__*/ init(${runtimeTemplate.basicFunction(
				"scopeName, scope, key, eager, fallback",
				[
					"if (!exists(scope, key)) return useFallback(scopeName, key, fallback);",
					"return get(findLatestVersion(scope, key, eager));"
				]
			)***REMOVED***);`,
			`var loadVersion = /*#__PURE__*/ init(${runtimeTemplate.basicFunction(
				"scopeName, scope, key, eager, requiredVersion, fallback",
				[
					"if (!exists(scope, key)) return useFallback(scopeName, key, fallback);",
					"var satisfyingVersion = findSatisfyingVersion(scope, key, requiredVersion, eager);",
					"if (satisfyingVersion) return get(satisfyingVersion);",
					"warn(getInvalidVersionMessage(scope, scopeName, key, requiredVersion, eager))",
					"return get(findLatestVersion(scope, key, eager));"
				]
			)***REMOVED***);`,
			`var loadStrictVersion = /*#__PURE__*/ init(${runtimeTemplate.basicFunction(
				"scopeName, scope, key, eager, requiredVersion, fallback",
				[
					"if (!exists(scope, key)) return useFallback(scopeName, key, fallback);",
					"var satisfyingVersion = findSatisfyingVersion(scope, key, requiredVersion, eager);",
					"if (satisfyingVersion) return get(satisfyingVersion);",
					"if (fallback) return fallback();",
					"fail(getInvalidVersionMessage(scope, scopeName, key, requiredVersion, eager));"
				]
			)***REMOVED***);`,
			`var loadSingleton = /*#__PURE__*/ init(${runtimeTemplate.basicFunction(
				"scopeName, scope, key, eager, fallback",
				[
					"if (!exists(scope, key)) return useFallback(scopeName, key, fallback);",
					"var version = findSingletonVersionKey(scope, key, eager);",
					"return get(scope[key][version]);"
				]
			)***REMOVED***);`,
			`var loadSingletonVersion = /*#__PURE__*/ init(${runtimeTemplate.basicFunction(
				"scopeName, scope, key, eager, requiredVersion, fallback",
				[
					"if (!exists(scope, key)) return useFallback(scopeName, key, fallback);",
					"var version = findSingletonVersionKey(scope, key, eager);",
					"if (!satisfy(requiredVersion, version)) {",
					Template.indent([
						"warn(getInvalidSingletonVersionMessage(scope, key, version, requiredVersion));"
					]),
					"***REMOVED***",
					"return get(scope[key][version]);"
				]
			)***REMOVED***);`,
			`var loadStrictSingletonVersion = /*#__PURE__*/ init(${runtimeTemplate.basicFunction(
				"scopeName, scope, key, eager, requiredVersion, fallback",
				[
					"if (!exists(scope, key)) return useFallback(scopeName, key, fallback);",
					"var version = findSingletonVersionKey(scope, key, eager);",
					"if (!satisfy(requiredVersion, version)) {",
					Template.indent([
						"fail(getInvalidSingletonVersionMessage(scope, key, version, requiredVersion));"
					]),
					"***REMOVED***",
					"return get(scope[key][version]);"
				]
			)***REMOVED***);`,
			"var installedModules = {***REMOVED***;",
			"var moduleToHandlerMapping = {",
			Template.indent(
				Array.from(
					moduleIdToSourceMapping,
					([key, source]) => `${JSON.stringify(key)***REMOVED***: ${source.source()***REMOVED***`
				).join(",\n")
			),
			"***REMOVED***;",

			initialConsumes.length > 0
				? Template.asString([
						`var initialConsumes = ${JSON.stringify(initialConsumes)***REMOVED***;`,
						`initialConsumes.forEach(${runtimeTemplate.basicFunction("id", [
							`${
								RuntimeGlobals.moduleFactories
							***REMOVED***[id] = ${runtimeTemplate.basicFunction("module", [
								"// Handle case when module is used sync",
								"installedModules[id] = 0;",
								`delete ${RuntimeGlobals.moduleCache***REMOVED***[id];`,
								"var factory = moduleToHandlerMapping[id]();",
								'if(typeof factory !== "function") throw new Error("Shared module is not available for eager consumption: " + id);',
								"module.exports = factory();"
							])***REMOVED***`
						])***REMOVED***);`
					])
				: "// no consumes in initial chunks",
			this._runtimeRequirements.has(RuntimeGlobals.ensureChunkHandlers)
				? Template.asString([
						`var chunkMapping = ${JSON.stringify(
							chunkToModuleMapping,
							null,
							"\t"
						)***REMOVED***;`,
						"var startedInstallModules = {***REMOVED***;",
						`${
							RuntimeGlobals.ensureChunkHandlers
						***REMOVED***.consumes = ${runtimeTemplate.basicFunction("chunkId, promises", [
							`if(${RuntimeGlobals.hasOwnProperty***REMOVED***(chunkMapping, chunkId)) {`,
							Template.indent([
								`chunkMapping[chunkId].forEach(${runtimeTemplate.basicFunction(
									"id",
									[
										`if(${RuntimeGlobals.hasOwnProperty***REMOVED***(installedModules, id)) return promises.push(installedModules[id]);`,
										"if(!startedInstallModules[id]) {",
										`var onFactory = ${runtimeTemplate.basicFunction(
											"factory",
											[
												"installedModules[id] = 0;",
												`${
													RuntimeGlobals.moduleFactories
												***REMOVED***[id] = ${runtimeTemplate.basicFunction("module", [
													`delete ${RuntimeGlobals.moduleCache***REMOVED***[id];`,
													"module.exports = factory();"
												])***REMOVED***`
											]
										)***REMOVED***;`,
										"startedInstallModules[id] = true;",
										`var onError = ${runtimeTemplate.basicFunction("error", [
											"delete installedModules[id];",
											`${
												RuntimeGlobals.moduleFactories
											***REMOVED***[id] = ${runtimeTemplate.basicFunction("module", [
												`delete ${RuntimeGlobals.moduleCache***REMOVED***[id];`,
												"throw error;"
											])***REMOVED***`
										])***REMOVED***;`,
										"try {",
										Template.indent([
											"var promise = moduleToHandlerMapping[id]();",
											"if(promise.then) {",
											Template.indent(
												"promises.push(installedModules[id] = promise.then(onFactory)['catch'](onError));"
											),
											"***REMOVED*** else onFactory(promise);"
										]),
										"***REMOVED*** catch(e) { onError(e); ***REMOVED***",
										"***REMOVED***"
									]
								)***REMOVED***);`
							]),
							"***REMOVED***"
						])***REMOVED***`
					])
				: "// no chunk loading of consumes"
		]);
	***REMOVED***
***REMOVED***

module.exports = ConsumeSharedRuntimeModule;
