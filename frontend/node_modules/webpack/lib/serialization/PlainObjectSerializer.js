/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/

"use strict";

/** @typedef {import("./ObjectMiddleware").ObjectDeserializerContext***REMOVED*** ObjectDeserializerContext */
/** @typedef {import("./ObjectMiddleware").ObjectSerializerContext***REMOVED*** ObjectSerializerContext */

/** @typedef {EXPECTED_FUNCTION***REMOVED*** CacheAssoc */

/**
 * @template T
 * @typedef {WeakMap<CacheAssoc, ObjectStructure<T>>***REMOVED***
 */
const cache = new WeakMap();

/**
 * @template T
 */
class ObjectStructure {
	constructor() {
		this.keys = undefined;
		this.children = undefined;
	***REMOVED***

	/**
	 * @param {keyof T[]***REMOVED*** keys keys
	 * @returns {keyof T[]***REMOVED*** keys
	 */
	getKeys(keys) {
		if (this.keys === undefined) this.keys = keys;
		return this.keys;
	***REMOVED***

	/**
	 * @param {keyof T***REMOVED*** key key
	 * @returns {ObjectStructure<T>***REMOVED*** object structure
	 */
	key(key) {
		if (this.children === undefined) this.children = new Map();
		const child = this.children.get(key);
		if (child !== undefined) return child;
		const newChild = new ObjectStructure();
		this.children.set(key, newChild);
		return newChild;
	***REMOVED***
***REMOVED***

/**
 * @template T
 * @param {(keyof T)[]***REMOVED*** keys keys
 * @param {CacheAssoc***REMOVED*** cacheAssoc cache assoc fn
 * @returns {(keyof T)[]***REMOVED*** keys
 */
const getCachedKeys = (keys, cacheAssoc) => {
	let root = cache.get(cacheAssoc);
	if (root === undefined) {
		root = new ObjectStructure();
		cache.set(cacheAssoc, root);
	***REMOVED***
	let current = root;
	for (const key of keys) {
		current = current.key(key);
	***REMOVED***
	return current.getKeys(keys);
***REMOVED***;

class PlainObjectSerializer {
	/**
	 * @template {object***REMOVED*** T
	 * @param {T***REMOVED*** obj plain object
	 * @param {ObjectSerializerContext***REMOVED*** context context
	 */
	serialize(obj, context) {
		const keys = /** @type {(keyof T)[]***REMOVED*** */ (Object.keys(obj));
		if (keys.length > 128) {
			// Objects with so many keys are unlikely to share structure
			// with other objects
			context.write(keys);
			for (const key of keys) {
				context.write(obj[key]);
			***REMOVED***
		***REMOVED*** else if (keys.length > 1) {
			context.write(getCachedKeys(keys, context.write));
			for (const key of keys) {
				context.write(obj[key]);
			***REMOVED***
		***REMOVED*** else if (keys.length === 1) {
			const key = keys[0];
			context.write(key);
			context.write(obj[key]);
		***REMOVED*** else {
			context.write(null);
		***REMOVED***
	***REMOVED***

	/**
	 * @template {object***REMOVED*** T
	 * @param {ObjectDeserializerContext***REMOVED*** context context
	 * @returns {T***REMOVED*** plain object
	 */
	deserialize(context) {
		const keys = context.read();
		const obj = /** @type {T***REMOVED*** */ ({***REMOVED***);
		if (Array.isArray(keys)) {
			for (const key of keys) {
				obj[/** @type {keyof T***REMOVED*** */ (key)] = context.read();
			***REMOVED***
		***REMOVED*** else if (keys !== null) {
			obj[/** @type {keyof T***REMOVED*** */ (keys)] = context.read();
		***REMOVED***
		return obj;
	***REMOVED***
***REMOVED***

module.exports = PlainObjectSerializer;
