"use strict";
const stableSortBy = require("lodash/sortBy");
const urlencoded = require("./urlencoded");

exports.implementation = class URLSearchParamsImpl {
  constructor(globalObject, constructorArgs, { doNotStripQMark = false ***REMOVED***) {
    let init = constructorArgs[0];
    this._list = [];
    this._url = null;

    if (!doNotStripQMark && typeof init === "string" && init[0] === "?") {
      init = init.slice(1);
    ***REMOVED***

    if (Array.isArray(init)) {
      for (const pair of init) {
        if (pair.length !== 2) {
          throw new TypeError("Failed to construct 'URLSearchParams': parameter 1 sequence's element does not " +
                              "contain exactly two elements.");
        ***REMOVED***
        this._list.push([pair[0], pair[1]]);
      ***REMOVED***
    ***REMOVED*** else if (typeof init === "object" && Object.getPrototypeOf(init) === null) {
      for (const name of Object.keys(init)) {
        const value = init[name];
        this._list.push([name, value]);
      ***REMOVED***
    ***REMOVED*** else {
      this._list = urlencoded.parseUrlencodedString(init);
    ***REMOVED***
  ***REMOVED***

  _updateSteps() {
    if (this._url !== null) {
      let query = urlencoded.serializeUrlencoded(this._list);
      if (query === "") {
        query = null;
      ***REMOVED***
      this._url._url.query = query;
    ***REMOVED***
  ***REMOVED***

  append(name, value) {
    this._list.push([name, value]);
    this._updateSteps();
  ***REMOVED***

  delete(name) {
    let i = 0;
    while (i < this._list.length) {
      if (this._list[i][0] === name) {
        this._list.splice(i, 1);
      ***REMOVED*** else {
        i++;
      ***REMOVED***
    ***REMOVED***
    this._updateSteps();
  ***REMOVED***

  get(name) {
    for (const tuple of this._list) {
      if (tuple[0] === name) {
        return tuple[1];
      ***REMOVED***
    ***REMOVED***
    return null;
  ***REMOVED***

  getAll(name) {
    const output = [];
    for (const tuple of this._list) {
      if (tuple[0] === name) {
        output.push(tuple[1]);
      ***REMOVED***
    ***REMOVED***
    return output;
  ***REMOVED***

  has(name) {
    for (const tuple of this._list) {
      if (tuple[0] === name) {
        return true;
      ***REMOVED***
    ***REMOVED***
    return false;
  ***REMOVED***

  set(name, value) {
    let found = false;
    let i = 0;
    while (i < this._list.length) {
      if (this._list[i][0] === name) {
        if (found) {
          this._list.splice(i, 1);
        ***REMOVED*** else {
          found = true;
          this._list[i][1] = value;
          i++;
        ***REMOVED***
      ***REMOVED*** else {
        i++;
      ***REMOVED***
    ***REMOVED***
    if (!found) {
      this._list.push([name, value]);
    ***REMOVED***
    this._updateSteps();
  ***REMOVED***

  sort() {
    this._list = stableSortBy(this._list, [0]);
    this._updateSteps();
  ***REMOVED***

  [Symbol.iterator]() {
    return this._list[Symbol.iterator]();
  ***REMOVED***

  toString() {
    return urlencoded.serializeUrlencoded(this._list);
  ***REMOVED***
***REMOVED***;
