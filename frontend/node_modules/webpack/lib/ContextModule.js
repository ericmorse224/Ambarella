/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { OriginalSource, RawSource ***REMOVED*** = require("webpack-sources");
const AsyncDependenciesBlock = require("./AsyncDependenciesBlock");
const { makeWebpackError ***REMOVED*** = require("./HookWebpackError");
const Module = require("./Module");
const { JS_TYPES ***REMOVED*** = require("./ModuleSourceTypesConstants");
const { JAVASCRIPT_MODULE_TYPE_DYNAMIC ***REMOVED*** = require("./ModuleTypeConstants");
const RuntimeGlobals = require("./RuntimeGlobals");
const Template = require("./Template");
const WebpackError = require("./WebpackError");
const {
	compareLocations,
	concatComparators,
	compareSelect,
	keepOriginalOrder,
	compareModulesById
***REMOVED*** = require("./util/comparators");
const {
	contextify,
	parseResource,
	makePathsRelative
***REMOVED*** = require("./util/identifier");
const makeSerializable = require("./util/makeSerializable");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../declarations/WebpackOptions").ResolveOptions***REMOVED*** ResolveOptions */
/** @typedef {import("../declarations/WebpackOptions").WebpackOptionsNormalized***REMOVED*** WebpackOptions */
/** @typedef {import("./Chunk")***REMOVED*** Chunk */
/** @typedef {import("./Chunk").ChunkId***REMOVED*** ChunkId */
/** @typedef {import("./ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("./ChunkGraph").ModuleId***REMOVED*** ModuleId */
/** @typedef {import("./ChunkGroup").RawChunkGroupOptions***REMOVED*** RawChunkGroupOptions */
/** @typedef {import("./Compilation")***REMOVED*** Compilation */
/** @typedef {import("./Dependency")***REMOVED*** Dependency */
/** @typedef {import("./DependencyTemplates")***REMOVED*** DependencyTemplates */
/** @typedef {import("./Generator").SourceTypes***REMOVED*** SourceTypes */
/** @typedef {import("./Module").BuildCallback***REMOVED*** BuildCallback */
/** @typedef {import("./Module").BuildInfo***REMOVED*** BuildInfo */
/** @typedef {import("./Module").BuildMeta***REMOVED*** BuildMeta */
/** @typedef {import("./Module").CodeGenerationContext***REMOVED*** CodeGenerationContext */
/** @typedef {import("./Module").CodeGenerationResult***REMOVED*** CodeGenerationResult */
/** @typedef {import("./Module").LibIdentOptions***REMOVED*** LibIdentOptions */
/** @typedef {import("./Module").NeedBuildCallback***REMOVED*** NeedBuildCallback */
/** @typedef {import("./Module").NeedBuildContext***REMOVED*** NeedBuildContext */
/** @typedef {import("./ModuleGraph")***REMOVED*** ModuleGraph */
/** @typedef {import("./RequestShortener")***REMOVED*** RequestShortener */
/** @typedef {import("./ResolverFactory").ResolverWithOptions***REMOVED*** ResolverWithOptions */
/** @typedef {import("./RuntimeTemplate")***REMOVED*** RuntimeTemplate */
/** @typedef {import("./dependencies/ContextElementDependency")***REMOVED*** ContextElementDependency */
/** @typedef {import("./javascript/JavascriptParser").ImportAttributes***REMOVED*** ImportAttributes */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectDeserializerContext***REMOVED*** ObjectDeserializerContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectSerializerContext***REMOVED*** ObjectSerializerContext */
/** @template T @typedef {import("./util/LazySet")<T>***REMOVED*** LazySet<T> */
/** @typedef {import("./util/fs").InputFileSystem***REMOVED*** InputFileSystem */

/** @typedef {"sync" | "eager" | "weak" | "async-weak" | "lazy" | "lazy-once"***REMOVED*** ContextMode Context mode */

/**
 * @typedef {object***REMOVED*** ContextOptions
 * @property {ContextMode***REMOVED*** mode
 * @property {boolean***REMOVED*** recursive
 * @property {RegExp***REMOVED*** regExp
 * @property {("strict" | boolean)=***REMOVED*** namespaceObject
 * @property {string=***REMOVED*** addon
 * @property {(string | null)=***REMOVED*** chunkName
 * @property {(RegExp | null)=***REMOVED*** include
 * @property {(RegExp | null)=***REMOVED*** exclude
 * @property {RawChunkGroupOptions=***REMOVED*** groupOptions
 * @property {string=***REMOVED*** typePrefix
 * @property {string=***REMOVED*** category
 * @property {(string[][] | null)=***REMOVED*** referencedExports exports referenced from modules (won't be mangled)
 * @property {string=***REMOVED*** layer
 * @property {ImportAttributes=***REMOVED*** attributes
 */

/**
 * @typedef {object***REMOVED*** ContextModuleOptionsExtras
 * @property {false | string | string[]***REMOVED*** resource
 * @property {string=***REMOVED*** resourceQuery
 * @property {string=***REMOVED*** resourceFragment
 * @property {ResolveOptions=***REMOVED*** resolveOptions
 */

/** @typedef {ContextOptions & ContextModuleOptionsExtras***REMOVED*** ContextModuleOptions */

/**
 * @callback ResolveDependenciesCallback
 * @param {Error | null***REMOVED*** err
 * @param {ContextElementDependency[]=***REMOVED*** dependencies
 */

/**
 * @callback ResolveDependencies
 * @param {InputFileSystem***REMOVED*** fs
 * @param {ContextModuleOptions***REMOVED*** options
 * @param {ResolveDependenciesCallback***REMOVED*** callback
 */

/** @typedef {1 | 3 | 7 | 9***REMOVED*** FakeMapType */

/** @typedef {Record<ModuleId, FakeMapType>***REMOVED*** FakeMap */

const SNAPSHOT_OPTIONS = { timestamp: true ***REMOVED***;

class ContextModule extends Module {
	/**
	 * @param {ResolveDependencies***REMOVED*** resolveDependencies function to get dependencies in this context
	 * @param {ContextModuleOptions***REMOVED*** options options object
	 */
	constructor(resolveDependencies, options) {
		if (!options || typeof options.resource === "string") {
			const parsed = parseResource(
				options ? /** @type {string***REMOVED*** */ (options.resource) : ""
			);
			const resource = parsed.path;
			const resourceQuery = (options && options.resourceQuery) || parsed.query;
			const resourceFragment =
				(options && options.resourceFragment) || parsed.fragment;
			const layer = options && options.layer;

			super(JAVASCRIPT_MODULE_TYPE_DYNAMIC, resource, layer);
			/** @type {ContextModuleOptions***REMOVED*** */
			this.options = {
				...options,
				resource,
				resourceQuery,
				resourceFragment
			***REMOVED***;
		***REMOVED*** else {
			super(JAVASCRIPT_MODULE_TYPE_DYNAMIC, undefined, options.layer);
			/** @type {ContextModuleOptions***REMOVED*** */
			this.options = {
				...options,
				resource: options.resource,
				resourceQuery: options.resourceQuery || "",
				resourceFragment: options.resourceFragment || ""
			***REMOVED***;
		***REMOVED***

		// Info from Factory
		/** @type {ResolveDependencies | undefined***REMOVED*** */
		this.resolveDependencies = resolveDependencies;
		if (options && options.resolveOptions !== undefined) {
			this.resolveOptions = options.resolveOptions;
		***REMOVED***

		if (options && typeof options.mode !== "string") {
			throw new Error("options.mode is a required option");
		***REMOVED***

		this._identifier = this._createIdentifier();
		this._forceBuild = true;
	***REMOVED***

	/**
	 * @returns {SourceTypes***REMOVED*** types available (do not mutate)
	 */
	getSourceTypes() {
		return JS_TYPES;
	***REMOVED***

	/**
	 * Assuming this module is in the cache. Update the (cached) module with
	 * the fresh module from the factory. Usually updates internal references
	 * and properties.
	 * @param {Module***REMOVED*** module fresh module
	 * @returns {void***REMOVED***
	 */
	updateCacheModule(module) {
		const m = /** @type {ContextModule***REMOVED*** */ (module);
		this.resolveDependencies = m.resolveDependencies;
		this.options = m.options;
	***REMOVED***

	/**
	 * Assuming this module is in the cache. Remove internal references to allow freeing some memory.
	 */
	cleanupForCache() {
		super.cleanupForCache();
		this.resolveDependencies = undefined;
	***REMOVED***

	/**
	 * @private
	 * @param {RegExp***REMOVED*** regexString RegExp as a string
	 * @param {boolean=***REMOVED*** stripSlash do we need to strip a slsh
	 * @returns {string***REMOVED*** pretty RegExp
	 */
	_prettyRegExp(regexString, stripSlash = true) {
		const str = stripSlash
			? regexString.source + regexString.flags
			: `${regexString***REMOVED***`;
		return str.replace(/!/g, "%21").replace(/\|/g, "%7C");
	***REMOVED***

	_createIdentifier() {
		let identifier =
			this.context ||
			(typeof this.options.resource === "string" ||
			this.options.resource === false
				? `${this.options.resource***REMOVED***`
				: this.options.resource.join("|"));
		if (this.options.resourceQuery) {
			identifier += `|${this.options.resourceQuery***REMOVED***`;
		***REMOVED***
		if (this.options.resourceFragment) {
			identifier += `|${this.options.resourceFragment***REMOVED***`;
		***REMOVED***
		if (this.options.mode) {
			identifier += `|${this.options.mode***REMOVED***`;
		***REMOVED***
		if (!this.options.recursive) {
			identifier += "|nonrecursive";
		***REMOVED***
		if (this.options.addon) {
			identifier += `|${this.options.addon***REMOVED***`;
		***REMOVED***
		if (this.options.regExp) {
			identifier += `|${this._prettyRegExp(this.options.regExp, false)***REMOVED***`;
		***REMOVED***
		if (this.options.include) {
			identifier += `|include: ${this._prettyRegExp(
				this.options.include,
				false
			)***REMOVED***`;
		***REMOVED***
		if (this.options.exclude) {
			identifier += `|exclude: ${this._prettyRegExp(
				this.options.exclude,
				false
			)***REMOVED***`;
		***REMOVED***
		if (this.options.referencedExports) {
			identifier += `|referencedExports: ${JSON.stringify(
				this.options.referencedExports
			)***REMOVED***`;
		***REMOVED***
		if (this.options.chunkName) {
			identifier += `|chunkName: ${this.options.chunkName***REMOVED***`;
		***REMOVED***
		if (this.options.groupOptions) {
			identifier += `|groupOptions: ${JSON.stringify(
				this.options.groupOptions
			)***REMOVED***`;
		***REMOVED***
		if (this.options.namespaceObject === "strict") {
			identifier += "|strict namespace object";
		***REMOVED*** else if (this.options.namespaceObject) {
			identifier += "|namespace object";
		***REMOVED***
		if (this.layer) {
			identifier += `|layer: ${this.layer***REMOVED***`;
		***REMOVED***

		return identifier;
	***REMOVED***

	/**
	 * @returns {string***REMOVED*** a unique identifier of the module
	 */
	identifier() {
		return this._identifier;
	***REMOVED***

	/**
	 * @param {RequestShortener***REMOVED*** requestShortener the request shortener
	 * @returns {string***REMOVED*** a user readable identifier of the module
	 */
	readableIdentifier(requestShortener) {
		let identifier;
		if (this.context) {
			identifier = `${requestShortener.shorten(this.context)***REMOVED***/`;
		***REMOVED*** else if (
			typeof this.options.resource === "string" ||
			this.options.resource === false
		) {
			identifier = `${requestShortener.shorten(`${this.options.resource***REMOVED***`)***REMOVED***/`;
		***REMOVED*** else {
			identifier = this.options.resource
				.map(r => `${requestShortener.shorten(r)***REMOVED***/`)
				.join(" ");
		***REMOVED***
		if (this.options.resourceQuery) {
			identifier += ` ${this.options.resourceQuery***REMOVED***`;
		***REMOVED***
		if (this.options.mode) {
			identifier += ` ${this.options.mode***REMOVED***`;
		***REMOVED***
		if (!this.options.recursive) {
			identifier += " nonrecursive";
		***REMOVED***
		if (this.options.addon) {
			identifier += ` ${requestShortener.shorten(this.options.addon)***REMOVED***`;
		***REMOVED***
		if (this.options.regExp) {
			identifier += ` ${this._prettyRegExp(this.options.regExp)***REMOVED***`;
		***REMOVED***
		if (this.options.include) {
			identifier += ` include: ${this._prettyRegExp(this.options.include)***REMOVED***`;
		***REMOVED***
		if (this.options.exclude) {
			identifier += ` exclude: ${this._prettyRegExp(this.options.exclude)***REMOVED***`;
		***REMOVED***
		if (this.options.referencedExports) {
			identifier += ` referencedExports: ${this.options.referencedExports
				.map(e => e.join("."))
				.join(", ")***REMOVED***`;
		***REMOVED***
		if (this.options.chunkName) {
			identifier += ` chunkName: ${this.options.chunkName***REMOVED***`;
		***REMOVED***
		if (this.options.groupOptions) {
			const groupOptions = this.options.groupOptions;
			for (const key of Object.keys(groupOptions)) {
				identifier += ` ${key***REMOVED***: ${
					groupOptions[/** @type {keyof RawChunkGroupOptions***REMOVED*** */ (key)]
				***REMOVED***`;
			***REMOVED***
		***REMOVED***
		if (this.options.namespaceObject === "strict") {
			identifier += " strict namespace object";
		***REMOVED*** else if (this.options.namespaceObject) {
			identifier += " namespace object";
		***REMOVED***

		return identifier;
	***REMOVED***

	/**
	 * @param {LibIdentOptions***REMOVED*** options options
	 * @returns {string | null***REMOVED*** an identifier for library inclusion
	 */
	libIdent(options) {
		let identifier;

		if (this.context) {
			identifier = contextify(
				options.context,
				this.context,
				options.associatedObjectForCache
			);
		***REMOVED*** else if (typeof this.options.resource === "string") {
			identifier = contextify(
				options.context,
				this.options.resource,
				options.associatedObjectForCache
			);
		***REMOVED*** else if (this.options.resource === false) {
			identifier = "false";
		***REMOVED*** else {
			identifier = this.options.resource
				.map(res =>
					contextify(options.context, res, options.associatedObjectForCache)
				)
				.join(" ");
		***REMOVED***

		if (this.layer) identifier = `(${this.layer***REMOVED***)/${identifier***REMOVED***`;
		if (this.options.mode) {
			identifier += ` ${this.options.mode***REMOVED***`;
		***REMOVED***
		if (this.options.recursive) {
			identifier += " recursive";
		***REMOVED***
		if (this.options.addon) {
			identifier += ` ${contextify(
				options.context,
				this.options.addon,
				options.associatedObjectForCache
			)***REMOVED***`;
		***REMOVED***
		if (this.options.regExp) {
			identifier += ` ${this._prettyRegExp(this.options.regExp)***REMOVED***`;
		***REMOVED***
		if (this.options.include) {
			identifier += ` include: ${this._prettyRegExp(this.options.include)***REMOVED***`;
		***REMOVED***
		if (this.options.exclude) {
			identifier += ` exclude: ${this._prettyRegExp(this.options.exclude)***REMOVED***`;
		***REMOVED***
		if (this.options.referencedExports) {
			identifier += ` referencedExports: ${this.options.referencedExports
				.map(e => e.join("."))
				.join(", ")***REMOVED***`;
		***REMOVED***

		return identifier;
	***REMOVED***

	/**
	 * @returns {void***REMOVED***
	 */
	invalidateBuild() {
		this._forceBuild = true;
	***REMOVED***

	/**
	 * @param {NeedBuildContext***REMOVED*** context context info
	 * @param {NeedBuildCallback***REMOVED*** callback callback function, returns true, if the module needs a rebuild
	 * @returns {void***REMOVED***
	 */
	needBuild({ fileSystemInfo ***REMOVED***, callback) {
		// build if enforced
		if (this._forceBuild) return callback(null, true);

		const buildInfo = /** @type {BuildInfo***REMOVED*** */ (this.buildInfo);

		// always build when we have no snapshot and context
		if (!buildInfo.snapshot)
			return callback(null, Boolean(this.context || this.options.resource));

		fileSystemInfo.checkSnapshotValid(buildInfo.snapshot, (err, valid) => {
			callback(err, !valid);
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {WebpackOptions***REMOVED*** options webpack options
	 * @param {Compilation***REMOVED*** compilation the compilation
	 * @param {ResolverWithOptions***REMOVED*** resolver the resolver
	 * @param {InputFileSystem***REMOVED*** fs the file system
	 * @param {BuildCallback***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	build(options, compilation, resolver, fs, callback) {
		this._forceBuild = false;
		/** @type {BuildMeta***REMOVED*** */
		this.buildMeta = {
			exportsType: "default",
			defaultObject: "redirect-warn"
		***REMOVED***;
		this.buildInfo = {
			snapshot: undefined
		***REMOVED***;
		this.dependencies.length = 0;
		this.blocks.length = 0;
		const startTime = Date.now();
		/** @type {ResolveDependencies***REMOVED*** */
		(this.resolveDependencies)(fs, this.options, (err, dependencies) => {
			if (err) {
				return callback(
					makeWebpackError(err, "ContextModule.resolveDependencies")
				);
			***REMOVED***

			// abort if something failed
			// this will create an empty context
			if (!dependencies) {
				callback();
				return;
			***REMOVED***

			// enhance dependencies with meta info
			for (const dep of dependencies) {
				dep.loc = {
					name: dep.userRequest
				***REMOVED***;
				dep.request = this.options.addon + dep.request;
			***REMOVED***
			dependencies.sort(
				concatComparators(
					compareSelect(a => a.loc, compareLocations),
					keepOriginalOrder(this.dependencies)
				)
			);

			if (this.options.mode === "sync" || this.options.mode === "eager") {
				// if we have an sync or eager context
				// just add all dependencies and continue
				this.dependencies = dependencies;
			***REMOVED*** else if (this.options.mode === "lazy-once") {
				// for the lazy-once mode create a new async dependency block
				// and add that block to this context
				if (dependencies.length > 0) {
					const block = new AsyncDependenciesBlock({
						...this.options.groupOptions,
						name: this.options.chunkName
					***REMOVED***);
					for (const dep of dependencies) {
						block.addDependency(dep);
					***REMOVED***
					this.addBlock(block);
				***REMOVED***
			***REMOVED*** else if (
				this.options.mode === "weak" ||
				this.options.mode === "async-weak"
			) {
				// we mark all dependencies as weak
				for (const dep of dependencies) {
					dep.weak = true;
				***REMOVED***
				this.dependencies = dependencies;
			***REMOVED*** else if (this.options.mode === "lazy") {
				// if we are lazy create a new async dependency block per dependency
				// and add all blocks to this context
				let index = 0;
				for (const dep of dependencies) {
					let chunkName = this.options.chunkName;
					if (chunkName) {
						if (!/\[(index|request)\]/.test(chunkName)) {
							chunkName += "[index]";
						***REMOVED***
						chunkName = chunkName.replace(/\[index\]/g, `${index++***REMOVED***`);
						chunkName = chunkName.replace(
							/\[request\]/g,
							Template.toPath(dep.userRequest)
						);
					***REMOVED***
					const block = new AsyncDependenciesBlock(
						{
							...this.options.groupOptions,
							name: chunkName
						***REMOVED***,
						dep.loc,
						dep.userRequest
					);
					block.addDependency(dep);
					this.addBlock(block);
				***REMOVED***
			***REMOVED*** else {
				callback(
					new WebpackError(`Unsupported mode "${this.options.mode***REMOVED***" in context`)
				);
				return;
			***REMOVED***
			if (!this.context && !this.options.resource) return callback();

			compilation.fileSystemInfo.createSnapshot(
				startTime,
				null,
				this.context
					? [this.context]
					: typeof this.options.resource === "string"
						? [this.options.resource]
						: /** @type {string[]***REMOVED*** */ (this.options.resource),
				null,
				SNAPSHOT_OPTIONS,
				(err, snapshot) => {
					if (err) return callback(err);
					/** @type {BuildInfo***REMOVED*** */
					(this.buildInfo).snapshot = snapshot;
					callback();
				***REMOVED***
			);
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {LazySet<string>***REMOVED*** fileDependencies set where file dependencies are added to
	 * @param {LazySet<string>***REMOVED*** contextDependencies set where context dependencies are added to
	 * @param {LazySet<string>***REMOVED*** missingDependencies set where missing dependencies are added to
	 * @param {LazySet<string>***REMOVED*** buildDependencies set where build dependencies are added to
	 */
	addCacheDependencies(
		fileDependencies,
		contextDependencies,
		missingDependencies,
		buildDependencies
	) {
		if (this.context) {
			contextDependencies.add(this.context);
		***REMOVED*** else if (typeof this.options.resource === "string") {
			contextDependencies.add(this.options.resource);
		***REMOVED*** else if (this.options.resource === false) {
			// Do nothing
		***REMOVED*** else {
			for (const res of this.options.resource) contextDependencies.add(res);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Dependency[]***REMOVED*** dependencies all dependencies
	 * @param {ChunkGraph***REMOVED*** chunkGraph chunk graph
	 * @returns {Map<string, string | number>***REMOVED*** map with user requests
	 */
	getUserRequestMap(dependencies, chunkGraph) {
		const moduleGraph = chunkGraph.moduleGraph;
		// if we filter first we get a new array
		// therefore we don't need to create a clone of dependencies explicitly
		// therefore the order of this is !important!
		const sortedDependencies =
			/** @type {ContextElementDependency[]***REMOVED*** */
			(dependencies)
				.filter(dependency => moduleGraph.getModule(dependency))
				.sort((a, b) => {
					if (a.userRequest === b.userRequest) {
						return 0;
					***REMOVED***
					return a.userRequest < b.userRequest ? -1 : 1;
				***REMOVED***);
		const map = Object.create(null);
		for (const dep of sortedDependencies) {
			const module = /** @type {Module***REMOVED*** */ (moduleGraph.getModule(dep));
			map[dep.userRequest] = chunkGraph.getModuleId(module);
		***REMOVED***
		return map;
	***REMOVED***

	/**
	 * @param {Dependency[]***REMOVED*** dependencies all dependencies
	 * @param {ChunkGraph***REMOVED*** chunkGraph chunk graph
	 * @returns {FakeMap | FakeMapType***REMOVED*** fake map
	 */
	getFakeMap(dependencies, chunkGraph) {
		if (!this.options.namespaceObject) {
			return 9;
		***REMOVED***
		const moduleGraph = chunkGraph.moduleGraph;
		// bitfield
		let hasType = 0;
		const comparator = compareModulesById(chunkGraph);
		// if we filter first we get a new array
		// therefore we don't need to create a clone of dependencies explicitly
		// therefore the order of this is !important!
		const sortedModules = dependencies
			.map(
				dependency => /** @type {Module***REMOVED*** */ (moduleGraph.getModule(dependency))
			)
			.filter(Boolean)
			.sort(comparator);
		/** @type {FakeMap***REMOVED*** */
		const fakeMap = Object.create(null);
		for (const module of sortedModules) {
			const exportsType = module.getExportsType(
				moduleGraph,
				this.options.namespaceObject === "strict"
			);
			const id = /** @type {ModuleId***REMOVED*** */ (chunkGraph.getModuleId(module));
			switch (exportsType) {
				case "namespace":
					fakeMap[id] = 9;
					hasType |= 1;
					break;
				case "dynamic":
					fakeMap[id] = 7;
					hasType |= 2;
					break;
				case "default-only":
					fakeMap[id] = 1;
					hasType |= 4;
					break;
				case "default-with-named":
					fakeMap[id] = 3;
					hasType |= 8;
					break;
				default:
					throw new Error(`Unexpected exports type ${exportsType***REMOVED***`);
			***REMOVED***
		***REMOVED***
		if (hasType === 1) {
			return 9;
		***REMOVED***
		if (hasType === 2) {
			return 7;
		***REMOVED***
		if (hasType === 4) {
			return 1;
		***REMOVED***
		if (hasType === 8) {
			return 3;
		***REMOVED***
		if (hasType === 0) {
			return 9;
		***REMOVED***
		return fakeMap;
	***REMOVED***

	/**
	 * @param {FakeMap | FakeMapType***REMOVED*** fakeMap fake map
	 * @returns {string***REMOVED*** fake map init statement
	 */
	getFakeMapInitStatement(fakeMap) {
		return typeof fakeMap === "object"
			? `var fakeMap = ${JSON.stringify(fakeMap, null, "\t")***REMOVED***;`
			: "";
	***REMOVED***

	/**
	 * @param {FakeMapType***REMOVED*** type type
	 * @param {boolean=***REMOVED*** asyncModule is async module
	 * @returns {string***REMOVED*** return result
	 */
	getReturn(type, asyncModule) {
		if (type === 9) {
			return `${RuntimeGlobals.require***REMOVED***(id)`;
		***REMOVED***
		return `${RuntimeGlobals.createFakeNamespaceObject***REMOVED***(id, ${type***REMOVED***${
			asyncModule ? " | 16" : ""
		***REMOVED***)`;
	***REMOVED***

	/**
	 * @param {FakeMap | FakeMapType***REMOVED*** fakeMap fake map
	 * @param {boolean=***REMOVED*** asyncModule us async module
	 * @param {string=***REMOVED*** fakeMapDataExpression fake map data expression
	 * @returns {string***REMOVED*** module object source
	 */
	getReturnModuleObjectSource(
		fakeMap,
		asyncModule,
		fakeMapDataExpression = "fakeMap[id]"
	) {
		if (typeof fakeMap === "number") {
			return `return ${this.getReturn(fakeMap, asyncModule)***REMOVED***;`;
		***REMOVED***
		return `return ${
			RuntimeGlobals.createFakeNamespaceObject
		***REMOVED***(id, ${fakeMapDataExpression***REMOVED***${asyncModule ? " | 16" : ""***REMOVED***)`;
	***REMOVED***

	/**
	 * @param {Dependency[]***REMOVED*** dependencies dependencies
	 * @param {ModuleId***REMOVED*** id module id
	 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
	 * @returns {string***REMOVED*** source code
	 */
	getSyncSource(dependencies, id, chunkGraph) {
		const map = this.getUserRequestMap(dependencies, chunkGraph);
		const fakeMap = this.getFakeMap(dependencies, chunkGraph);
		const returnModuleObject = this.getReturnModuleObjectSource(fakeMap);

		return `var map = ${JSON.stringify(map, null, "\t")***REMOVED***;
${this.getFakeMapInitStatement(fakeMap)***REMOVED***

function webpackContext(req) {
	var id = webpackContextResolve(req);
	${returnModuleObject***REMOVED***
***REMOVED***
function webpackContextResolve(req) {
	if(!${RuntimeGlobals.hasOwnProperty***REMOVED***(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	***REMOVED***
	return map[req];
***REMOVED***
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
***REMOVED***;
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = ${JSON.stringify(id)***REMOVED***;`;
	***REMOVED***

	/**
	 * @param {Dependency[]***REMOVED*** dependencies dependencies
	 * @param {ModuleId***REMOVED*** id module id
	 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
	 * @returns {string***REMOVED*** source code
	 */
	getWeakSyncSource(dependencies, id, chunkGraph) {
		const map = this.getUserRequestMap(dependencies, chunkGraph);
		const fakeMap = this.getFakeMap(dependencies, chunkGraph);
		const returnModuleObject = this.getReturnModuleObjectSource(fakeMap);

		return `var map = ${JSON.stringify(map, null, "\t")***REMOVED***;
${this.getFakeMapInitStatement(fakeMap)***REMOVED***

function webpackContext(req) {
	var id = webpackContextResolve(req);
	if(!${RuntimeGlobals.moduleFactories***REMOVED***[id]) {
		var e = new Error("Module '" + req + "' ('" + id + "') is not available (weak dependency)");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	***REMOVED***
	${returnModuleObject***REMOVED***
***REMOVED***
function webpackContextResolve(req) {
	if(!${RuntimeGlobals.hasOwnProperty***REMOVED***(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	***REMOVED***
	return map[req];
***REMOVED***
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
***REMOVED***;
webpackContext.resolve = webpackContextResolve;
webpackContext.id = ${JSON.stringify(id)***REMOVED***;
module.exports = webpackContext;`;
	***REMOVED***

	/**
	 * @param {Dependency[]***REMOVED*** dependencies dependencies
	 * @param {ModuleId***REMOVED*** id module id
	 * @param {object***REMOVED*** context context
	 * @param {ChunkGraph***REMOVED*** context.chunkGraph the chunk graph
	 * @param {RuntimeTemplate***REMOVED*** context.runtimeTemplate the chunk graph
	 * @returns {string***REMOVED*** source code
	 */
	getAsyncWeakSource(dependencies, id, { chunkGraph, runtimeTemplate ***REMOVED***) {
		const arrow = runtimeTemplate.supportsArrowFunction();
		const map = this.getUserRequestMap(dependencies, chunkGraph);
		const fakeMap = this.getFakeMap(dependencies, chunkGraph);
		const returnModuleObject = this.getReturnModuleObjectSource(fakeMap, true);

		return `var map = ${JSON.stringify(map, null, "\t")***REMOVED***;
${this.getFakeMapInitStatement(fakeMap)***REMOVED***

function webpackAsyncContext(req) {
	return webpackAsyncContextResolve(req).then(${
		arrow ? "id =>" : "function(id)"
	***REMOVED*** {
		if(!${RuntimeGlobals.moduleFactories***REMOVED***[id]) {
			var e = new Error("Module '" + req + "' ('" + id + "') is not available (weak dependency)");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		***REMOVED***
		${returnModuleObject***REMOVED***
	***REMOVED***);
***REMOVED***
function webpackAsyncContextResolve(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(${arrow ? "() =>" : "function()"***REMOVED*** {
		if(!${RuntimeGlobals.hasOwnProperty***REMOVED***(map, req)) {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		***REMOVED***
		return map[req];
	***REMOVED***);
***REMOVED***
webpackAsyncContext.keys = ${runtimeTemplate.returningFunction(
			"Object.keys(map)"
		)***REMOVED***;
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = ${JSON.stringify(id)***REMOVED***;
module.exports = webpackAsyncContext;`;
	***REMOVED***

	/**
	 * @param {Dependency[]***REMOVED*** dependencies dependencies
	 * @param {ModuleId***REMOVED*** id module id
	 * @param {object***REMOVED*** context context
	 * @param {ChunkGraph***REMOVED*** context.chunkGraph the chunk graph
	 * @param {RuntimeTemplate***REMOVED*** context.runtimeTemplate the chunk graph
	 * @returns {string***REMOVED*** source code
	 */
	getEagerSource(dependencies, id, { chunkGraph, runtimeTemplate ***REMOVED***) {
		const arrow = runtimeTemplate.supportsArrowFunction();
		const map = this.getUserRequestMap(dependencies, chunkGraph);
		const fakeMap = this.getFakeMap(dependencies, chunkGraph);
		const thenFunction =
			fakeMap !== 9
				? `${arrow ? "id =>" : "function(id)"***REMOVED*** {
		${this.getReturnModuleObjectSource(fakeMap, true)***REMOVED***
	***REMOVED***`
				: RuntimeGlobals.require;
		return `var map = ${JSON.stringify(map, null, "\t")***REMOVED***;
${this.getFakeMapInitStatement(fakeMap)***REMOVED***

function webpackAsyncContext(req) {
	return webpackAsyncContextResolve(req).then(${thenFunction***REMOVED***);
***REMOVED***
function webpackAsyncContextResolve(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(${arrow ? "() =>" : "function()"***REMOVED*** {
		if(!${RuntimeGlobals.hasOwnProperty***REMOVED***(map, req)) {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		***REMOVED***
		return map[req];
	***REMOVED***);
***REMOVED***
webpackAsyncContext.keys = ${runtimeTemplate.returningFunction(
			"Object.keys(map)"
		)***REMOVED***;
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = ${JSON.stringify(id)***REMOVED***;
module.exports = webpackAsyncContext;`;
	***REMOVED***

	/**
	 * @param {AsyncDependenciesBlock***REMOVED*** block block
	 * @param {Dependency[]***REMOVED*** dependencies dependencies
	 * @param {ModuleId***REMOVED*** id module id
	 * @param {object***REMOVED*** options options object
	 * @param {RuntimeTemplate***REMOVED*** options.runtimeTemplate the runtime template
	 * @param {ChunkGraph***REMOVED*** options.chunkGraph the chunk graph
	 * @returns {string***REMOVED*** source code
	 */
	getLazyOnceSource(block, dependencies, id, { runtimeTemplate, chunkGraph ***REMOVED***) {
		const promise = runtimeTemplate.blockPromise({
			chunkGraph,
			block,
			message: "lazy-once context",
			runtimeRequirements: new Set()
		***REMOVED***);
		const arrow = runtimeTemplate.supportsArrowFunction();
		const map = this.getUserRequestMap(dependencies, chunkGraph);
		const fakeMap = this.getFakeMap(dependencies, chunkGraph);
		const thenFunction =
			fakeMap !== 9
				? `${arrow ? "id =>" : "function(id)"***REMOVED*** {
		${this.getReturnModuleObjectSource(fakeMap, true)***REMOVED***;
	***REMOVED***`
				: RuntimeGlobals.require;

		return `var map = ${JSON.stringify(map, null, "\t")***REMOVED***;
${this.getFakeMapInitStatement(fakeMap)***REMOVED***

function webpackAsyncContext(req) {
	return webpackAsyncContextResolve(req).then(${thenFunction***REMOVED***);
***REMOVED***
function webpackAsyncContextResolve(req) {
	return ${promise***REMOVED***.then(${arrow ? "() =>" : "function()"***REMOVED*** {
		if(!${RuntimeGlobals.hasOwnProperty***REMOVED***(map, req)) {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		***REMOVED***
		return map[req];
	***REMOVED***);
***REMOVED***
webpackAsyncContext.keys = ${runtimeTemplate.returningFunction(
			"Object.keys(map)"
		)***REMOVED***;
webpackAsyncContext.resolve = webpackAsyncContextResolve;
webpackAsyncContext.id = ${JSON.stringify(id)***REMOVED***;
module.exports = webpackAsyncContext;`;
	***REMOVED***

	/**
	 * @param {AsyncDependenciesBlock[]***REMOVED*** blocks blocks
	 * @param {ModuleId***REMOVED*** id module id
	 * @param {object***REMOVED*** context context
	 * @param {ChunkGraph***REMOVED*** context.chunkGraph the chunk graph
	 * @param {RuntimeTemplate***REMOVED*** context.runtimeTemplate the chunk graph
	 * @returns {string***REMOVED*** source code
	 */
	getLazySource(blocks, id, { chunkGraph, runtimeTemplate ***REMOVED***) {
		const moduleGraph = chunkGraph.moduleGraph;
		const arrow = runtimeTemplate.supportsArrowFunction();
		let hasMultipleOrNoChunks = false;
		let hasNoChunk = true;
		const fakeMap = this.getFakeMap(
			blocks.map(b => b.dependencies[0]),
			chunkGraph
		);
		const hasFakeMap = typeof fakeMap === "object";
		/** @typedef {{userRequest: string, dependency: ContextElementDependency, chunks: undefined | Chunk[], module: Module, block: AsyncDependenciesBlock***REMOVED******REMOVED*** Item */
		/**
		 * @type {Item[]***REMOVED***
		 */
		const items = blocks
			.map(block => {
				const dependency =
					/** @type {ContextElementDependency***REMOVED*** */
					(block.dependencies[0]);
				return {
					dependency,
					module: /** @type {Module***REMOVED*** */ (moduleGraph.getModule(dependency)),
					block,
					userRequest: dependency.userRequest,
					chunks: undefined
				***REMOVED***;
			***REMOVED***)
			.filter(item => item.module);
		for (const item of items) {
			const chunkGroup = chunkGraph.getBlockChunkGroup(item.block);
			const chunks = (chunkGroup && chunkGroup.chunks) || [];
			item.chunks = chunks;
			if (chunks.length > 0) {
				hasNoChunk = false;
			***REMOVED***
			if (chunks.length !== 1) {
				hasMultipleOrNoChunks = true;
			***REMOVED***
		***REMOVED***
		const shortMode = hasNoChunk && !hasFakeMap;
		const sortedItems = items.sort((a, b) => {
			if (a.userRequest === b.userRequest) return 0;
			return a.userRequest < b.userRequest ? -1 : 1;
		***REMOVED***);
		/** @type {Record<string, ModuleId | (ModuleId[] | ChunkId[])>***REMOVED*** */
		const map = Object.create(null);
		for (const item of sortedItems) {
			const moduleId =
				/** @type {ModuleId***REMOVED*** */
				(chunkGraph.getModuleId(item.module));
			if (shortMode) {
				map[item.userRequest] = moduleId;
			***REMOVED*** else {
				/** @type {(ModuleId | ChunkId)[]***REMOVED*** */
				const arrayStart = [moduleId];
				if (hasFakeMap) {
					arrayStart.push(fakeMap[moduleId]);
				***REMOVED***
				map[item.userRequest] = arrayStart.concat(
					/** @type {Chunk[]***REMOVED*** */
					(item.chunks).map(chunk => /** @type {ChunkId***REMOVED*** */ (chunk.id))
				);
			***REMOVED***
		***REMOVED***

		const chunksStartPosition = hasFakeMap ? 2 : 1;
		const requestPrefix = hasNoChunk
			? "Promise.resolve()"
			: hasMultipleOrNoChunks
				? `Promise.all(ids.slice(${chunksStartPosition***REMOVED***).map(${RuntimeGlobals.ensureChunk***REMOVED***))`
				: `${RuntimeGlobals.ensureChunk***REMOVED***(ids[${chunksStartPosition***REMOVED***])`;
		const returnModuleObject = this.getReturnModuleObjectSource(
			fakeMap,
			true,
			shortMode ? "invalid" : "ids[1]"
		);

		const webpackAsyncContext =
			requestPrefix === "Promise.resolve()"
				? `
function webpackAsyncContext(req) {
	return Promise.resolve().then(${arrow ? "() =>" : "function()"***REMOVED*** {
		if(!${RuntimeGlobals.hasOwnProperty***REMOVED***(map, req)) {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		***REMOVED***

		${shortMode ? "var id = map[req];" : "var ids = map[req], id = ids[0];"***REMOVED***
		${returnModuleObject***REMOVED***
	***REMOVED***);
***REMOVED***`
				: `function webpackAsyncContext(req) {
	if(!${RuntimeGlobals.hasOwnProperty***REMOVED***(map, req)) {
		return Promise.resolve().then(${arrow ? "() =>" : "function()"***REMOVED*** {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		***REMOVED***);
	***REMOVED***

	var ids = map[req], id = ids[0];
	return ${requestPrefix***REMOVED***.then(${arrow ? "() =>" : "function()"***REMOVED*** {
		${returnModuleObject***REMOVED***
	***REMOVED***);
***REMOVED***`;

		return `var map = ${JSON.stringify(map, null, "\t")***REMOVED***;
${webpackAsyncContext***REMOVED***
webpackAsyncContext.keys = ${runtimeTemplate.returningFunction(
			"Object.keys(map)"
		)***REMOVED***;
webpackAsyncContext.id = ${JSON.stringify(id)***REMOVED***;
module.exports = webpackAsyncContext;`;
	***REMOVED***

	/**
	 * @param {ModuleId***REMOVED*** id module id
	 * @param {RuntimeTemplate***REMOVED*** runtimeTemplate runtime template
	 * @returns {string***REMOVED*** source for empty async context
	 */
	getSourceForEmptyContext(id, runtimeTemplate) {
		return `function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
***REMOVED***
webpackEmptyContext.keys = ${runtimeTemplate.returningFunction("[]")***REMOVED***;
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = ${JSON.stringify(id)***REMOVED***;
module.exports = webpackEmptyContext;`;
	***REMOVED***

	/**
	 * @param {ModuleId***REMOVED*** id module id
	 * @param {RuntimeTemplate***REMOVED*** runtimeTemplate runtime template
	 * @returns {string***REMOVED*** source for empty async context
	 */
	getSourceForEmptyAsyncContext(id, runtimeTemplate) {
		const arrow = runtimeTemplate.supportsArrowFunction();
		return `function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(${arrow ? "() =>" : "function()"***REMOVED*** {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	***REMOVED***);
***REMOVED***
webpackEmptyAsyncContext.keys = ${runtimeTemplate.returningFunction("[]")***REMOVED***;
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = ${JSON.stringify(id)***REMOVED***;
module.exports = webpackEmptyAsyncContext;`;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** asyncMode module mode
	 * @param {CodeGenerationContext***REMOVED*** context context info
	 * @returns {string***REMOVED*** the source code
	 */
	getSourceString(asyncMode, { runtimeTemplate, chunkGraph ***REMOVED***) {
		const id = /** @type {ModuleId***REMOVED*** */ (chunkGraph.getModuleId(this));
		if (asyncMode === "lazy") {
			if (this.blocks && this.blocks.length > 0) {
				return this.getLazySource(this.blocks, id, {
					runtimeTemplate,
					chunkGraph
				***REMOVED***);
			***REMOVED***
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		***REMOVED***
		if (asyncMode === "eager") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getEagerSource(this.dependencies, id, {
					chunkGraph,
					runtimeTemplate
				***REMOVED***);
			***REMOVED***
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		***REMOVED***
		if (asyncMode === "lazy-once") {
			const block = this.blocks[0];
			if (block) {
				return this.getLazyOnceSource(block, block.dependencies, id, {
					runtimeTemplate,
					chunkGraph
				***REMOVED***);
			***REMOVED***
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		***REMOVED***
		if (asyncMode === "async-weak") {
			if (this.dependencies && this.dependencies.length > 0) {
				return this.getAsyncWeakSource(this.dependencies, id, {
					chunkGraph,
					runtimeTemplate
				***REMOVED***);
			***REMOVED***
			return this.getSourceForEmptyAsyncContext(id, runtimeTemplate);
		***REMOVED***
		if (
			asyncMode === "weak" &&
			this.dependencies &&
			this.dependencies.length > 0
		) {
			return this.getWeakSyncSource(this.dependencies, id, chunkGraph);
		***REMOVED***
		if (this.dependencies && this.dependencies.length > 0) {
			return this.getSyncSource(this.dependencies, id, chunkGraph);
		***REMOVED***
		return this.getSourceForEmptyContext(id, runtimeTemplate);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** sourceString source content
	 * @param {Compilation=***REMOVED*** compilation the compilation
	 * @returns {Source***REMOVED*** generated source
	 */
	getSource(sourceString, compilation) {
		if (this.useSourceMap || this.useSimpleSourceMap) {
			return new OriginalSource(
				sourceString,
				`webpack://${makePathsRelative(
					(compilation && compilation.compiler.context) || "",
					this.identifier(),
					compilation && compilation.compiler.root
				)***REMOVED***`
			);
		***REMOVED***
		return new RawSource(sourceString);
	***REMOVED***

	/**
	 * @param {CodeGenerationContext***REMOVED*** context context for code generation
	 * @returns {CodeGenerationResult***REMOVED*** result
	 */
	codeGeneration(context) {
		const { chunkGraph, compilation ***REMOVED*** = context;
		const sources = new Map();
		sources.set(
			"javascript",
			this.getSource(
				this.getSourceString(this.options.mode, context),
				compilation
			)
		);
		const set = new Set();
		const allDeps =
			this.dependencies.length > 0
				? /** @type {ContextElementDependency[]***REMOVED*** */ (this.dependencies).slice()
				: [];
		for (const block of this.blocks)
			for (const dep of block.dependencies)
				allDeps.push(/** @type {ContextElementDependency***REMOVED*** */ (dep));
		set.add(RuntimeGlobals.module);
		set.add(RuntimeGlobals.hasOwnProperty);
		if (allDeps.length > 0) {
			const asyncMode = this.options.mode;
			set.add(RuntimeGlobals.require);
			if (asyncMode === "weak") {
				set.add(RuntimeGlobals.moduleFactories);
			***REMOVED*** else if (asyncMode === "async-weak") {
				set.add(RuntimeGlobals.moduleFactories);
				set.add(RuntimeGlobals.ensureChunk);
			***REMOVED*** else if (asyncMode === "lazy" || asyncMode === "lazy-once") {
				set.add(RuntimeGlobals.ensureChunk);
			***REMOVED***
			if (this.getFakeMap(allDeps, chunkGraph) !== 9) {
				set.add(RuntimeGlobals.createFakeNamespaceObject);
			***REMOVED***
		***REMOVED***
		return {
			sources,
			runtimeRequirements: set
		***REMOVED***;
	***REMOVED***

	/**
	 * @param {string=***REMOVED*** type the source type for which the size should be estimated
	 * @returns {number***REMOVED*** the estimated size of the module (must be non-zero)
	 */
	size(type) {
		// base penalty
		let size = 160;

		// if we don't have dependencies we stop here.
		for (const dependency of this.dependencies) {
			const element = /** @type {ContextElementDependency***REMOVED*** */ (dependency);
			size += 5 + element.userRequest.length;
		***REMOVED***
		return size;
	***REMOVED***

	/**
	 * @param {ObjectSerializerContext***REMOVED*** context context
	 */
	serialize(context) {
		const { write ***REMOVED*** = context;
		write(this._identifier);
		write(this._forceBuild);
		super.serialize(context);
	***REMOVED***

	/**
	 * @param {ObjectDeserializerContext***REMOVED*** context context
	 */
	deserialize(context) {
		const { read ***REMOVED*** = context;
		this._identifier = read();
		this._forceBuild = read();
		super.deserialize(context);
	***REMOVED***
***REMOVED***

makeSerializable(ContextModule, "webpack/lib/ContextModule");

module.exports = ContextModule;
