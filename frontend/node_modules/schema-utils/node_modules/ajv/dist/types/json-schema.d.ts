type StrictNullChecksWrapper<Name extends string, Type> = undefined extends null ? `strictNullChecks must be true in tsconfig to use ${Name***REMOVED***` : Type;
type UnionToIntersection<U> = (U extends any ? (_: U) => void : never) extends (_: infer I) => void ? I : never;
export type SomeJSONSchema = UncheckedJSONSchemaType<Known, true>;
type UncheckedPartialSchema<T> = Partial<UncheckedJSONSchemaType<T, true>>;
export type PartialSchema<T> = StrictNullChecksWrapper<"PartialSchema", UncheckedPartialSchema<T>>;
type JSONType<T extends string, IsPartial extends boolean> = IsPartial extends true ? T | undefined : T;
interface NumberKeywords {
    minimum?: number;
    maximum?: number;
    exclusiveMinimum?: number;
    exclusiveMaximum?: number;
    multipleOf?: number;
    format?: string;
***REMOVED***
interface StringKeywords {
    minLength?: number;
    maxLength?: number;
    pattern?: string;
    format?: string;
***REMOVED***
type UncheckedJSONSchemaType<T, IsPartial extends boolean> = (// these two unions allow arbitrary unions of types
{
    anyOf: readonly UncheckedJSONSchemaType<T, IsPartial>[];
***REMOVED*** | {
    oneOf: readonly UncheckedJSONSchemaType<T, IsPartial>[];
***REMOVED*** | ({
    type: readonly (T extends number ? JSONType<"number" | "integer", IsPartial> : T extends string ? JSONType<"string", IsPartial> : T extends boolean ? JSONType<"boolean", IsPartial> : never)[];
***REMOVED*** & UnionToIntersection<T extends number ? NumberKeywords : T extends string ? StringKeywords : T extends boolean ? {***REMOVED*** : never>) | ((T extends number ? {
    type: JSONType<"number" | "integer", IsPartial>;
***REMOVED*** & NumberKeywords : T extends string ? {
    type: JSONType<"string", IsPartial>;
***REMOVED*** & StringKeywords : T extends boolean ? {
    type: JSONType<"boolean", IsPartial>;
***REMOVED*** : T extends readonly [any, ...any[]] ? {
    type: JSONType<"array", IsPartial>;
    items: {
        readonly [K in keyof T]-?: UncheckedJSONSchemaType<T[K], false> & Nullable<T[K]>;
    ***REMOVED*** & {
        length: T["length"];
    ***REMOVED***;
    minItems: T["length"];
***REMOVED*** & ({
    maxItems: T["length"];
***REMOVED*** | {
    additionalItems: false;
***REMOVED***) : T extends readonly any[] ? {
    type: JSONType<"array", IsPartial>;
    items: UncheckedJSONSchemaType<T[0], false>;
    contains?: UncheckedPartialSchema<T[0]>;
    minItems?: number;
    maxItems?: number;
    minContains?: number;
    maxContains?: number;
    uniqueItems?: true;
    additionalItems?: never;
***REMOVED*** : T extends Record<string, any> ? {
    type: JSONType<"object", IsPartial>;
    additionalProperties?: boolean | UncheckedJSONSchemaType<T[string], false>;
    unevaluatedProperties?: boolean | UncheckedJSONSchemaType<T[string], false>;
    properties?: IsPartial extends true ? Partial<UncheckedPropertiesSchema<T>> : UncheckedPropertiesSchema<T>;
    patternProperties?: Record<string, UncheckedJSONSchemaType<T[string], false>>;
    propertyNames?: Omit<UncheckedJSONSchemaType<string, false>, "type"> & {
        type?: "string";
    ***REMOVED***;
    dependencies?: {
        [K in keyof T]?: readonly (keyof T)[] | UncheckedPartialSchema<T>;
    ***REMOVED***;
    dependentRequired?: {
        [K in keyof T]?: readonly (keyof T)[];
    ***REMOVED***;
    dependentSchemas?: {
        [K in keyof T]?: UncheckedPartialSchema<T>;
    ***REMOVED***;
    minProperties?: number;
    maxProperties?: number;
***REMOVED*** & (IsPartial extends true ? {
    required: readonly (keyof T)[];
***REMOVED*** : [UncheckedRequiredMembers<T>] extends [never] ? {
    required?: readonly UncheckedRequiredMembers<T>[];
***REMOVED*** : {
    required: readonly UncheckedRequiredMembers<T>[];
***REMOVED***) : T extends null ? {
    type: JSONType<"null", IsPartial>;
    nullable: true;
***REMOVED*** : never) & {
    allOf?: readonly UncheckedPartialSchema<T>[];
    anyOf?: readonly UncheckedPartialSchema<T>[];
    oneOf?: readonly UncheckedPartialSchema<T>[];
    if?: UncheckedPartialSchema<T>;
    then?: UncheckedPartialSchema<T>;
    else?: UncheckedPartialSchema<T>;
    not?: UncheckedPartialSchema<T>;
***REMOVED***)) & {
    [keyword: string]: any;
    $id?: string;
    $ref?: string;
    $defs?: Record<string, UncheckedJSONSchemaType<Known, true>>;
    definitions?: Record<string, UncheckedJSONSchemaType<Known, true>>;
***REMOVED***;
export type JSONSchemaType<T> = StrictNullChecksWrapper<"JSONSchemaType", UncheckedJSONSchemaType<T, false>>;
type Known = {
    [key: string]: Known;
***REMOVED*** | [Known, ...Known[]] | Known[] | number | string | boolean | null;
type UncheckedPropertiesSchema<T> = {
    [K in keyof T]-?: (UncheckedJSONSchemaType<T[K], false> & Nullable<T[K]>) | {
        $ref: string;
    ***REMOVED***;
***REMOVED***;
export type PropertiesSchema<T> = StrictNullChecksWrapper<"PropertiesSchema", UncheckedPropertiesSchema<T>>;
type UncheckedRequiredMembers<T> = {
    [K in keyof T]-?: undefined extends T[K] ? never : K;
***REMOVED***[keyof T];
export type RequiredMembers<T> = StrictNullChecksWrapper<"RequiredMembers", UncheckedRequiredMembers<T>>;
type Nullable<T> = undefined extends T ? {
    nullable: true;
    const?: null;
    enum?: readonly (T | null)[];
    default?: T | null;
***REMOVED*** : {
    nullable?: false;
    const?: T;
    enum?: readonly T[];
    default?: T;
***REMOVED***;
export {***REMOVED***;
