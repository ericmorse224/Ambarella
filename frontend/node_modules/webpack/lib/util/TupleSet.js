/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

/**
 * @template K
 * @template V
 * @typedef {Map<K, InnerMap<K, V> | Set<V>>***REMOVED*** InnerMap
 */

/**
 * @template T
 * @template V
 */
class TupleSet {
	/**
	 * @param {Iterable<[T, V, ...EXPECTED_ANY]>=***REMOVED*** init init
	 */
	constructor(init) {
		/** @type {InnerMap<T, V>***REMOVED*** */
		this._map = new Map();
		this.size = 0;
		if (init) {
			for (const tuple of init) {
				this.add(...tuple);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {[T, V, ...EXPECTED_ANY]***REMOVED*** args tuple
	 * @returns {void***REMOVED***
	 */
	add(...args) {
		let map = this._map;
		for (let i = 0; i < args.length - 2; i++) {
			const arg = args[i];
			const innerMap = map.get(arg);
			if (innerMap === undefined) {
				map.set(arg, (map = new Map()));
			***REMOVED*** else {
				map = /** @type {InnerMap<T, V>***REMOVED*** */ (innerMap);
			***REMOVED***
		***REMOVED***

		const beforeLast = args[args.length - 2];
		let set = /** @type {Set<V>***REMOVED*** */ (map.get(beforeLast));
		if (set === undefined) {
			map.set(beforeLast, (set = new Set()));
		***REMOVED***

		const last = args[args.length - 1];
		this.size -= set.size;
		set.add(last);
		this.size += set.size;
	***REMOVED***

	/**
	 * @param {[T, V, ...EXPECTED_ANY]***REMOVED*** args tuple
	 * @returns {boolean***REMOVED*** true, if the tuple is in the Set
	 */
	has(...args) {
		let map = this._map;
		for (let i = 0; i < args.length - 2; i++) {
			const arg = args[i];
			map = /** @type {InnerMap<T, V>***REMOVED*** */ (map.get(arg));
			if (map === undefined) {
				return false;
			***REMOVED***
		***REMOVED***

		const beforeLast = args[args.length - 2];
		const set = map.get(beforeLast);
		if (set === undefined) {
			return false;
		***REMOVED***

		const last = args[args.length - 1];
		return set.has(last);
	***REMOVED***

	/**
	 * @param {[T, V, ...EXPECTED_ANY]***REMOVED*** args tuple
	 * @returns {void***REMOVED***
	 */
	delete(...args) {
		let map = this._map;
		for (let i = 0; i < args.length - 2; i++) {
			const arg = args[i];
			map = /** @type {InnerMap<T, V>***REMOVED*** */ (map.get(arg));
			if (map === undefined) {
				return;
			***REMOVED***
		***REMOVED***

		const beforeLast = args[args.length - 2];
		const set = map.get(beforeLast);
		if (set === undefined) {
			return;
		***REMOVED***

		const last = args[args.length - 1];
		this.size -= set.size;
		set.delete(last);
		this.size += set.size;
	***REMOVED***

	/**
	 * @returns {Iterator<[T, V, ...EXPECTED_ANY]>***REMOVED*** iterator
	 */
	[Symbol.iterator]() {
		// This is difficult to type because we can have a map inside a map inside a map, etc. where the end is a set (each key is an argument)
		// But in basic use we only have 2 arguments in our methods, so we have `Map<K, Set<V>>`
		/** @type {MapIterator<[T, InnerMap<T, V> | Set<V>]>[]***REMOVED*** */
		const iteratorStack = [];
		/** @type {[T?, V?, ...EXPECTED_ANY]***REMOVED*** */
		const tuple = [];
		/** @type {SetIterator<V> | undefined***REMOVED*** */
		let currentSetIterator;

		/**
		 * @param {MapIterator<[T, InnerMap<T, V> | Set<V>]>***REMOVED*** it iterator
		 * @returns {boolean***REMOVED*** result
		 */
		const next = it => {
			const result = it.next();
			if (result.done) {
				if (iteratorStack.length === 0) return false;
				tuple.pop();
				return next(
					/** @type {MapIterator<[T, InnerMap<T, V> | Set<V>]>***REMOVED*** */
					(iteratorStack.pop())
				);
			***REMOVED***
			const [key, value] = result.value;
			iteratorStack.push(it);
			tuple.push(key);
			if (value instanceof Set) {
				currentSetIterator = value[Symbol.iterator]();
				return true;
			***REMOVED***
			return next(value[Symbol.iterator]());
		***REMOVED***;

		next(this._map[Symbol.iterator]());

		return {
			next() {
				while (currentSetIterator) {
					const result = currentSetIterator.next();
					if (result.done) {
						tuple.pop();
						if (
							!next(
								/** @type {MapIterator<[T, InnerMap<T, V> | Set<V>]>***REMOVED*** */
								(iteratorStack.pop())
							)
						) {
							currentSetIterator = undefined;
						***REMOVED***
					***REMOVED*** else {
						return {
							done: false,
							value:
								/** @type {[T, V, ...EXPECTED_ANY]***REMOVED*** */
								(tuple.concat(result.value))
						***REMOVED***;
					***REMOVED***
				***REMOVED***
				return { done: true, value: undefined ***REMOVED***;
			***REMOVED***
		***REMOVED***;
	***REMOVED***
***REMOVED***

module.exports = TupleSet;
