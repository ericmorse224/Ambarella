'use strict';

var mockProperty = require('mock-property');

module.exports = function (getDescriptors, t) {
	var enumDescriptor = {
		configurable: true,
		enumerable: false,
		value: true,
		writable: false
	***REMOVED***;
	var writableDescriptor = {
		configurable: true,
		enumerable: true,
		value: 42,
		writable: true
	***REMOVED***;

	t.test('works with Object.prototype poisoned setter', { skip: !Object.defineProperty ***REMOVED***, function (st) {
		var key = 'foo';

		var obj = {***REMOVED***;
		obj[key] = 42;

		var expected = {***REMOVED***;
		expected[key] = {
			configurable: true,
			enumerable: true,
			value: 42,
			writable: true
		***REMOVED***;

		st.teardown(mockProperty(Object.prototype, key, { set: function (v) { throw new Error(v); ***REMOVED*** ***REMOVED***));

		var hasOwnNamesBug = false;
		try {
			Object.getOwnPropertyNames(obj);
		***REMOVED*** catch (e) {
			// v8 in node 0.6 - 0.12 has a bug :-(
			hasOwnNamesBug = true;
			st.comment('SKIP: this engine has a bug with Object.getOwnPropertyNames: it can not handle a throwing setter on Object.prototype.');
		***REMOVED***

		if (!hasOwnNamesBug) {
			st.doesNotThrow(function () {
				var result = getDescriptors(obj);
				st.deepEqual(result, expected, 'got expected descriptors');
			***REMOVED***);
		***REMOVED***

		delete Object.prototype[key];
		st.end();
	***REMOVED***);

	t.test('gets all expected non-Symbol descriptors', function (st) {
		var obj = { normal: Infinity ***REMOVED***;
		Object.defineProperty(obj, 'enumerable', enumDescriptor);
		Object.defineProperty(obj, 'writable', writableDescriptor);

		var descriptors = getDescriptors(obj);

		st.deepEqual(descriptors, {
			enumerable: enumDescriptor,
			normal: {
				configurable: true,
				enumerable: true,
				value: Infinity,
				writable: true
			***REMOVED***,
			writable: writableDescriptor
		***REMOVED***);
		st.end();
	***REMOVED***);

	var supportsSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';
	t.test('gets Symbol descriptors too', { skip: !supportsSymbols ***REMOVED***, function (st) {
		var symbol = Symbol('sym');
		var symDescriptor = {
			configurable: false,
			enumerable: true,
			value: [symbol],
			writable: true
		***REMOVED***;
		var obj = { normal: Infinity ***REMOVED***;
		Object.defineProperty(obj, 'enumerable', enumDescriptor);
		Object.defineProperty(obj, 'writable', writableDescriptor);
		Object.defineProperty(obj, 'symbol', symDescriptor);

		var descriptors = getDescriptors(obj);

		st.deepEqual(descriptors, {
			enumerable: enumDescriptor,
			normal: {
				configurable: true,
				enumerable: true,
				value: Infinity,
				writable: true
			***REMOVED***,
			symbol: symDescriptor,
			writable: writableDescriptor
		***REMOVED***);
		st.end();
	***REMOVED***);

	var supportsProxy = typeof Proxy === 'function';
	t.test('Proxies that return an undefined descriptor', { skip: !supportsProxy ***REMOVED***, function (st) {
		var obj = { foo: true ***REMOVED***;
		var fooDescriptor = Object.getOwnPropertyDescriptor(obj, 'foo');

		var proxy = new Proxy(obj, {
			getOwnPropertyDescriptor: function (target, key) {
				return Object.getOwnPropertyDescriptor(target, key);
			***REMOVED***,
			ownKeys: function () {
				return ['foo', 'bar'];
			***REMOVED***
		***REMOVED***);
		st.deepEqual(getDescriptors(proxy), { foo: fooDescriptor ***REMOVED***, 'object has no descriptors');
		st.end();
	***REMOVED***);
***REMOVED***;
