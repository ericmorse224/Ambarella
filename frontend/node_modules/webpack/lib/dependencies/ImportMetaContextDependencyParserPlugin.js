/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Ivan Kopeykin @vankop
*/

"use strict";

const WebpackError = require("../WebpackError");
const {
	evaluateToIdentifier
***REMOVED*** = require("../javascript/JavascriptParserHelpers");
const ImportMetaContextDependency = require("./ImportMetaContextDependency");

/** @typedef {import("estree").Expression***REMOVED*** Expression */
/** @typedef {import("estree").ObjectExpression***REMOVED*** ObjectExpression */
/** @typedef {import("estree").Property***REMOVED*** Property */
/** @typedef {import("estree").Identifier***REMOVED*** Identifier */
/** @typedef {import("estree").SourceLocation***REMOVED*** SourceLocation */
/** @typedef {import("../javascript/JavascriptParser")***REMOVED*** JavascriptParser */
/** @typedef {import("../javascript/JavascriptParser").Range***REMOVED*** Range */
/** @typedef {import("../ContextModule").ContextModuleOptions***REMOVED*** ContextModuleOptions */
/** @typedef {import("../ChunkGroup").RawChunkGroupOptions***REMOVED*** RawChunkGroupOptions */
/** @typedef {import("../Dependency").DependencyLocation***REMOVED*** DependencyLocation */
/** @typedef {import("../javascript/BasicEvaluatedExpression")***REMOVED*** BasicEvaluatedExpression */
/** @typedef {Pick<ContextModuleOptions, 'mode'|'recursive'|'regExp'|'include'|'exclude'|'chunkName'>&{groupOptions: RawChunkGroupOptions, exports?: ContextModuleOptions["referencedExports"]***REMOVED******REMOVED*** ImportMetaContextOptions */

/**
 * @param {Property***REMOVED*** prop property
 * @param {string***REMOVED*** expect except message
 * @returns {WebpackError***REMOVED*** error
 */
function createPropertyParseError(prop, expect) {
	return createError(
		`Parsing import.meta.webpackContext options failed. Unknown value for property ${JSON.stringify(
			/** @type {Identifier***REMOVED*** */
			(prop.key).name
		)***REMOVED***, expected type ${expect***REMOVED***.`,
		/** @type {DependencyLocation***REMOVED*** */
		(prop.value.loc)
	);
***REMOVED***

/**
 * @param {string***REMOVED*** msg message
 * @param {DependencyLocation***REMOVED*** loc location
 * @returns {WebpackError***REMOVED*** error
 */
function createError(msg, loc) {
	const error = new WebpackError(msg);
	error.name = "ImportMetaContextError";
	error.loc = loc;
	return error;
***REMOVED***

const PLUGIN_NAME = "ImportMetaContextDependencyParserPlugin";

module.exports = class ImportMetaContextDependencyParserPlugin {
	/**
	 * @param {JavascriptParser***REMOVED*** parser the parser
	 * @returns {void***REMOVED***
	 */
	apply(parser) {
		parser.hooks.evaluateIdentifier
			.for("import.meta.webpackContext")
			.tap(PLUGIN_NAME, expr =>
				evaluateToIdentifier(
					"import.meta.webpackContext",
					"import.meta",
					() => ["webpackContext"],
					true
				)(expr)
			);
		parser.hooks.call
			.for("import.meta.webpackContext")
			.tap(PLUGIN_NAME, expr => {
				if (expr.arguments.length < 1 || expr.arguments.length > 2) return;
				const [directoryNode, optionsNode] = expr.arguments;
				if (optionsNode && optionsNode.type !== "ObjectExpression") return;
				const requestExpr = parser.evaluateExpression(
					/** @type {Expression***REMOVED*** */ (directoryNode)
				);
				if (!requestExpr.isString()) return;
				const request = /** @type {string***REMOVED*** */ (requestExpr.string);
				const errors = [];
				let regExp = /^\.\/.*$/;
				let recursive = true;
				/** @type {ContextModuleOptions["mode"]***REMOVED*** */
				let mode = "sync";
				/** @type {ContextModuleOptions["include"]***REMOVED*** */
				let include;
				/** @type {ContextModuleOptions["exclude"]***REMOVED*** */
				let exclude;
				/** @type {RawChunkGroupOptions***REMOVED*** */
				const groupOptions = {***REMOVED***;
				/** @type {ContextModuleOptions["chunkName"]***REMOVED*** */
				let chunkName;
				/** @type {ContextModuleOptions["referencedExports"]***REMOVED*** */
				let exports;
				if (optionsNode) {
					for (const prop of /** @type {ObjectExpression***REMOVED*** */ (optionsNode)
						.properties) {
						if (prop.type !== "Property" || prop.key.type !== "Identifier") {
							errors.push(
								createError(
									"Parsing import.meta.webpackContext options failed.",
									/** @type {DependencyLocation***REMOVED*** */
									(optionsNode.loc)
								)
							);
							break;
						***REMOVED***
						switch (prop.key.name) {
							case "regExp": {
								const regExpExpr = parser.evaluateExpression(
									/** @type {Expression***REMOVED*** */ (prop.value)
								);
								if (!regExpExpr.isRegExp()) {
									errors.push(createPropertyParseError(prop, "RegExp"));
								***REMOVED*** else {
									regExp = /** @type {RegExp***REMOVED*** */ (regExpExpr.regExp);
								***REMOVED***
								break;
							***REMOVED***
							case "include": {
								const regExpExpr = parser.evaluateExpression(
									/** @type {Expression***REMOVED*** */ (prop.value)
								);
								if (!regExpExpr.isRegExp()) {
									errors.push(createPropertyParseError(prop, "RegExp"));
								***REMOVED*** else {
									include = regExpExpr.regExp;
								***REMOVED***
								break;
							***REMOVED***
							case "exclude": {
								const regExpExpr = parser.evaluateExpression(
									/** @type {Expression***REMOVED*** */ (prop.value)
								);
								if (!regExpExpr.isRegExp()) {
									errors.push(createPropertyParseError(prop, "RegExp"));
								***REMOVED*** else {
									exclude = regExpExpr.regExp;
								***REMOVED***
								break;
							***REMOVED***
							case "mode": {
								const modeExpr = parser.evaluateExpression(
									/** @type {Expression***REMOVED*** */ (prop.value)
								);
								if (!modeExpr.isString()) {
									errors.push(createPropertyParseError(prop, "string"));
								***REMOVED*** else {
									mode = /** @type {ContextModuleOptions["mode"]***REMOVED*** */ (
										modeExpr.string
									);
								***REMOVED***
								break;
							***REMOVED***
							case "chunkName": {
								const expr = parser.evaluateExpression(
									/** @type {Expression***REMOVED*** */ (prop.value)
								);
								if (!expr.isString()) {
									errors.push(createPropertyParseError(prop, "string"));
								***REMOVED*** else {
									chunkName = expr.string;
								***REMOVED***
								break;
							***REMOVED***
							case "exports": {
								const expr = parser.evaluateExpression(
									/** @type {Expression***REMOVED*** */ (prop.value)
								);
								if (expr.isString()) {
									exports = [[/** @type {string***REMOVED*** */ (expr.string)]];
								***REMOVED*** else if (expr.isArray()) {
									const items =
										/** @type {BasicEvaluatedExpression[]***REMOVED*** */
										(expr.items);
									if (
										items.every(i => {
											if (!i.isArray()) return false;
											const innerItems =
												/** @type {BasicEvaluatedExpression[]***REMOVED*** */ (i.items);
											return innerItems.every(i => i.isString());
										***REMOVED***)
									) {
										exports = [];
										for (const i1 of items) {
											/** @type {string[]***REMOVED*** */
											const export_ = [];
											for (const i2 of /** @type {BasicEvaluatedExpression[]***REMOVED*** */ (
												i1.items
											)) {
												export_.push(/** @type {string***REMOVED*** */ (i2.string));
											***REMOVED***
											exports.push(export_);
										***REMOVED***
									***REMOVED*** else {
										errors.push(
											createPropertyParseError(prop, "string|string[][]")
										);
									***REMOVED***
								***REMOVED*** else {
									errors.push(
										createPropertyParseError(prop, "string|string[][]")
									);
								***REMOVED***
								break;
							***REMOVED***
							case "prefetch": {
								const expr = parser.evaluateExpression(
									/** @type {Expression***REMOVED*** */ (prop.value)
								);
								if (expr.isBoolean()) {
									groupOptions.prefetchOrder = 0;
								***REMOVED*** else if (expr.isNumber()) {
									groupOptions.prefetchOrder = expr.number;
								***REMOVED*** else {
									errors.push(createPropertyParseError(prop, "boolean|number"));
								***REMOVED***
								break;
							***REMOVED***
							case "preload": {
								const expr = parser.evaluateExpression(
									/** @type {Expression***REMOVED*** */ (prop.value)
								);
								if (expr.isBoolean()) {
									groupOptions.preloadOrder = 0;
								***REMOVED*** else if (expr.isNumber()) {
									groupOptions.preloadOrder = expr.number;
								***REMOVED*** else {
									errors.push(createPropertyParseError(prop, "boolean|number"));
								***REMOVED***
								break;
							***REMOVED***
							case "fetchPriority": {
								const expr = parser.evaluateExpression(
									/** @type {Expression***REMOVED*** */ (prop.value)
								);
								if (
									expr.isString() &&
									["high", "low", "auto"].includes(
										/** @type {string***REMOVED*** */ (expr.string)
									)
								) {
									groupOptions.fetchPriority =
										/** @type {RawChunkGroupOptions["fetchPriority"]***REMOVED*** */ (
											expr.string
										);
								***REMOVED*** else {
									errors.push(
										createPropertyParseError(prop, '"high"|"low"|"auto"')
									);
								***REMOVED***
								break;
							***REMOVED***
							case "recursive": {
								const recursiveExpr = parser.evaluateExpression(
									/** @type {Expression***REMOVED*** */ (prop.value)
								);
								if (!recursiveExpr.isBoolean()) {
									errors.push(createPropertyParseError(prop, "boolean"));
								***REMOVED*** else {
									recursive = /** @type {boolean***REMOVED*** */ (recursiveExpr.bool);
								***REMOVED***
								break;
							***REMOVED***
							default:
								errors.push(
									createError(
										`Parsing import.meta.webpackContext options failed. Unknown property ${JSON.stringify(
											prop.key.name
										)***REMOVED***.`,
										/** @type {DependencyLocation***REMOVED*** */ (optionsNode.loc)
									)
								);
						***REMOVED***
					***REMOVED***
				***REMOVED***
				if (errors.length) {
					for (const error of errors) parser.state.current.addError(error);
					return;
				***REMOVED***

				const dep = new ImportMetaContextDependency(
					{
						request,
						include,
						exclude,
						recursive,
						regExp,
						groupOptions,
						chunkName,
						referencedExports: exports,
						mode,
						category: "esm"
					***REMOVED***,
					/** @type {Range***REMOVED*** */ (expr.range)
				);
				dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expr.loc);
				dep.optional = Boolean(parser.scope.inTry);
				parser.state.current.addDependency(dep);
				return true;
			***REMOVED***);
	***REMOVED***
***REMOVED***;
