'use strict';

Object.defineProperty(exports, '__esModule', { value: true ***REMOVED***);

var core = require('@babel/core');
var helperPluginUtils = require('@babel/helper-plugin-utils');

function isNameOrLength(key) {
  if (core.types.isIdentifier(key)) {
    return key.name === "name" || key.name === "length";
  ***REMOVED***
  if (core.types.isStringLiteral(key)) {
    return key.value === "name" || key.value === "length";
  ***REMOVED***
  return false;
***REMOVED***
function isStaticFieldWithValue(node) {
  return (core.types.isClassProperty(node) || core.types.isClassPrivateProperty(node)) && node.static && !!node.value;
***REMOVED***
const hasReferenceVisitor = {
  ReferencedIdentifier(path, state) {
    if (path.node.name === state.name) {
      state.ref();
      path.stop();
    ***REMOVED***
  ***REMOVED***,
  Scope(path, {
    name
  ***REMOVED***) {
    if (path.scope.hasOwnBinding(name)) {
      path.skip();
    ***REMOVED***
  ***REMOVED***
***REMOVED***;
function isReferenceOrThis(node, name) {
  return core.types.isThisExpression(node) || name && core.types.isIdentifier(node, {
    name
  ***REMOVED***);
***REMOVED***
const hasReferenceOrThisVisitor = {
  "ThisExpression|ReferencedIdentifier"(path, state) {
    if (isReferenceOrThis(path.node, state.name)) {
      state.ref();
      path.stop();
    ***REMOVED***
  ***REMOVED***,
  FunctionParent(path, state) {
    if (path.isArrowFunctionExpression()) return;
    if (state.name && !path.scope.hasOwnBinding(state.name)) {
      path.traverse(hasReferenceVisitor, state);
    ***REMOVED***
    path.skip();
    if (path.isMethod()) {
      if (path.requeueComputedKeyAndDecorators) {
        path.requeueComputedKeyAndDecorators();
      ***REMOVED*** else {
        require("@babel/traverse").NodePath.prototype.requeueComputedKeyAndDecorators.call(path);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***;
function getPotentiallyBuggyFieldsIndexes(path) {
  var _path$node$id;
  const buggyPublicStaticFieldsIndexes = [];
  let classReferenced = false;
  const className = (_path$node$id = path.node.id) == null ? void 0 : _path$node$id.name;
  const hasReferenceState = {
    name: className,
    ref: () => classReferenced = true
  ***REMOVED***;
  if (className) {
    for (const el of path.get("body.body")) {
      if (el.node.computed) {
        el.get("key").traverse(hasReferenceVisitor, hasReferenceState);
        if (classReferenced) break;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  let nextPotentiallyBuggy = false;
  const {
    body
  ***REMOVED*** = path.node.body;
  for (let i = 0; i < body.length; i++) {
    const node = body[i];
    if (!nextPotentiallyBuggy) {
      if (core.types.isStaticBlock(node)) {
        classReferenced = true;
        nextPotentiallyBuggy = true;
      ***REMOVED*** else if (isStaticFieldWithValue(node)) {
        if (!classReferenced) {
          if (isReferenceOrThis(node.value, className)) {
            classReferenced = true;
          ***REMOVED*** else {
            path.get(`body.body.${i***REMOVED***.value`).traverse(hasReferenceOrThisVisitor, hasReferenceState);
          ***REMOVED***
        ***REMOVED***
        if (classReferenced) {
          nextPotentiallyBuggy = !path.scope.isPure(node.value);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    if (core.types.isClassProperty(node, {
      static: true
    ***REMOVED***) && (nextPotentiallyBuggy || node.computed || isNameOrLength(node.key))) {
      buggyPublicStaticFieldsIndexes.push(i);
    ***REMOVED***
  ***REMOVED***
  return buggyPublicStaticFieldsIndexes;
***REMOVED***
function getNameOrLengthStaticFieldsIndexes(path) {
  const indexes = [];
  const {
    body
  ***REMOVED*** = path.node.body;
  for (let i = 0; i < body.length; i++) {
    const node = body[i];
    if (core.types.isClassProperty(node, {
      static: true,
      computed: false
    ***REMOVED***) && isNameOrLength(node.key)) {
      indexes.push(i);
    ***REMOVED***
  ***REMOVED***
  return indexes;
***REMOVED***
function toRanges(nums) {
  const ranges = [];
  if (nums.length === 0) return ranges;
  let start = nums[0];
  let end = start + 1;
  for (let i = 1; i < nums.length; i++) {
    if (nums[i] <= nums[i - 1]) {
      throw new Error("Internal Babel error: nums must be in ascending order");
    ***REMOVED***
    if (nums[i] === end) {
      end++;
    ***REMOVED*** else {
      ranges.push([start, end]);
      start = nums[i];
      end = start + 1;
    ***REMOVED***
  ***REMOVED***
  ranges.push([start, end]);
  return ranges;
***REMOVED***

function buildFieldsReplacement(fields, scope, file) {
  return core.types.staticBlock(fields.map(field => {
    const key = field.computed || !core.types.isIdentifier(field.key) ? field.key : core.types.stringLiteral(field.key.name);
    return core.types.expressionStatement(core.types.callExpression(file.addHelper("defineProperty"), [core.types.thisExpression(), key, field.value || scope.buildUndefinedNode()]));
  ***REMOVED***));
***REMOVED***
var index = helperPluginUtils.declare(api => {
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  const setPublicClassFields = api.assumption("setPublicClassFields");
  return {
    name: "bugfix-v8-static-class-fields-redefine-readonly",
    visitor: {
      Class(path) {
        const ranges = toRanges(setPublicClassFields ? getNameOrLengthStaticFieldsIndexes(path) : getPotentiallyBuggyFieldsIndexes(path));
        for (let i = ranges.length - 1; i >= 0; i--) {
          const [start, end] = ranges[i];
          const startPath = path.get("body.body")[start];
          startPath.replaceWith(buildFieldsReplacement(path.node.body.body.slice(start, end), path.scope, this.file));
          for (let j = end - 1; j > start; j--) {
            path.get("body.body")[j].remove();
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;
***REMOVED***);

exports.default = index;
//# sourceMappingURL=index.js.map
