/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const makeSerializable = require("./util/makeSerializable");

/** @typedef {import("./AsyncDependenciesBlock")***REMOVED*** AsyncDependenciesBlock */
/** @typedef {import("./ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("./ChunkGroup")***REMOVED*** ChunkGroup */
/** @typedef {import("./Dependency")***REMOVED*** Dependency */
/** @typedef {import("./Dependency").UpdateHashContext***REMOVED*** UpdateHashContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectDeserializerContext***REMOVED*** ObjectDeserializerContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectSerializerContext***REMOVED*** ObjectSerializerContext */
/** @typedef {import("./util/Hash")***REMOVED*** Hash */

/** @typedef {(d: Dependency) => boolean***REMOVED*** DependencyFilterFunction */

/**
 * DependenciesBlock is the base class for all Module classes in webpack. It describes a
 * "block" of dependencies which are pointers to other DependenciesBlock instances. For example
 * when a Module has a CommonJs require statement, the DependencyBlock for the CommonJs module
 * would be added as a dependency to the Module. DependenciesBlock is inherited by two types of classes:
 * Module subclasses and AsyncDependenciesBlock subclasses. The only difference between the two is that
 * AsyncDependenciesBlock subclasses are used for code-splitting (async boundary) and Module subclasses are not.
 */
class DependenciesBlock {
	constructor() {
		/** @type {Dependency[]***REMOVED*** */
		this.dependencies = [];
		/** @type {AsyncDependenciesBlock[]***REMOVED*** */
		this.blocks = [];
		/** @type {DependenciesBlock | undefined***REMOVED*** */
		this.parent = undefined;
	***REMOVED***

	getRootBlock() {
		/** @type {DependenciesBlock***REMOVED*** */
		let current = this;
		while (current.parent) current = current.parent;
		return current;
	***REMOVED***

	/**
	 * Adds a DependencyBlock to DependencyBlock relationship.
	 * This is used for when a Module has a AsyncDependencyBlock tie (for code-splitting)
	 * @param {AsyncDependenciesBlock***REMOVED*** block block being added
	 * @returns {void***REMOVED***
	 */
	addBlock(block) {
		this.blocks.push(block);
		block.parent = this;
	***REMOVED***

	/**
	 * @param {Dependency***REMOVED*** dependency dependency being tied to block.
	 * This is an "edge" pointing to another "node" on module graph.
	 * @returns {void***REMOVED***
	 */
	addDependency(dependency) {
		this.dependencies.push(dependency);
	***REMOVED***

	/**
	 * @param {Dependency***REMOVED*** dependency dependency being removed
	 * @returns {void***REMOVED***
	 */
	removeDependency(dependency) {
		const idx = this.dependencies.indexOf(dependency);
		if (idx >= 0) {
			this.dependencies.splice(idx, 1);
		***REMOVED***
	***REMOVED***

	/**
	 * Removes all dependencies and blocks
	 * @returns {void***REMOVED***
	 */
	clearDependenciesAndBlocks() {
		this.dependencies.length = 0;
		this.blocks.length = 0;
	***REMOVED***

	/**
	 * @param {Hash***REMOVED*** hash the hash used to track dependencies
	 * @param {UpdateHashContext***REMOVED*** context context
	 * @returns {void***REMOVED***
	 */
	updateHash(hash, context) {
		for (const dep of this.dependencies) {
			dep.updateHash(hash, context);
		***REMOVED***
		for (const block of this.blocks) {
			block.updateHash(hash, context);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ObjectSerializerContext***REMOVED*** context context
	 */
	serialize({ write ***REMOVED***) {
		write(this.dependencies);
		write(this.blocks);
	***REMOVED***

	/**
	 * @param {ObjectDeserializerContext***REMOVED*** context context
	 */
	deserialize({ read ***REMOVED***) {
		this.dependencies = read();
		this.blocks = read();
		for (const block of this.blocks) {
			block.parent = this;
		***REMOVED***
	***REMOVED***
***REMOVED***

makeSerializable(DependenciesBlock, "webpack/lib/DependenciesBlock");

module.exports = DependenciesBlock;
