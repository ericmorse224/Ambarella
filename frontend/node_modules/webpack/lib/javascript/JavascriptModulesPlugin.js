/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const eslintScope = require("eslint-scope");
const { SyncWaterfallHook, SyncHook, SyncBailHook ***REMOVED*** = require("tapable");
const vm = require("vm");
const {
	ConcatSource,
	OriginalSource,
	PrefixSource,
	RawSource,
	CachedSource,
	ReplaceSource
***REMOVED*** = require("webpack-sources");
const Compilation = require("../Compilation");
const { tryRunOrWebpackError ***REMOVED*** = require("../HookWebpackError");
const HotUpdateChunk = require("../HotUpdateChunk");
const InitFragment = require("../InitFragment");
const {
	JAVASCRIPT_MODULE_TYPE_AUTO,
	JAVASCRIPT_MODULE_TYPE_DYNAMIC,
	JAVASCRIPT_MODULE_TYPE_ESM,
	WEBPACK_MODULE_TYPE_RUNTIME
***REMOVED*** = require("../ModuleTypeConstants");
const NormalModule = require("../NormalModule");
const RuntimeGlobals = require("../RuntimeGlobals");
const Template = require("../Template");
const { last, someInIterable ***REMOVED*** = require("../util/IterableHelpers");
const StringXor = require("../util/StringXor");
const { compareModulesByIdOrIdentifier ***REMOVED*** = require("../util/comparators");
const {
	getPathInAst,
	getAllReferences,
	RESERVED_NAMES,
	findNewName,
	addScopeSymbols,
	getUsedNamesInScopeInfo
***REMOVED*** = require("../util/concatenate");
const createHash = require("../util/createHash");
const nonNumericOnlyHash = require("../util/nonNumericOnlyHash");
const removeBOM = require("../util/removeBOM");
const { intersectRuntime ***REMOVED*** = require("../util/runtime");
const JavascriptGenerator = require("./JavascriptGenerator");
const JavascriptParser = require("./JavascriptParser");

/** @typedef {import("eslint-scope").Reference***REMOVED*** Reference */
/** @typedef {import("eslint-scope").Scope***REMOVED*** Scope */
/** @typedef {import("eslint-scope").Variable***REMOVED*** Variable */
/** @typedef {import("estree").Program***REMOVED*** Program */
/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../../declarations/WebpackOptions").HashFunction***REMOVED*** HashFunction */
/** @typedef {import("../../declarations/WebpackOptions").Output***REMOVED*** OutputOptions */
/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../CodeGenerationResults")***REMOVED*** CodeGenerationResults */
/** @typedef {import("../Compilation").ChunkHashContext***REMOVED*** ChunkHashContext */
/** @typedef {import("../Compilation").ExecuteModuleObject***REMOVED*** ExecuteModuleObject */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../DependencyTemplates")***REMOVED*** DependencyTemplates */
/** @typedef {import("../Entrypoint")***REMOVED*** Entrypoint */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../Module").BuildInfo***REMOVED*** BuildInfo */
/** @typedef {import("../ModuleGraph")***REMOVED*** ModuleGraph */
/** @typedef {import("../RuntimeTemplate")***REMOVED*** RuntimeTemplate */
/** @typedef {import("../TemplatedPathPlugin").TemplatePath***REMOVED*** TemplatePath */
/** @typedef {import("../WebpackError")***REMOVED*** WebpackError */
/** @typedef {import("../javascript/JavascriptParser").Range***REMOVED*** Range */
/** @typedef {import("../util/Hash")***REMOVED*** Hash */

/**
 * @param {Chunk***REMOVED*** chunk a chunk
 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @returns {boolean***REMOVED*** true, when a JS file is needed for this chunk
 */
const chunkHasJs = (chunk, chunkGraph) => {
	if (chunkGraph.getNumberOfEntryModules(chunk) > 0) return true;

	return Boolean(
		chunkGraph.getChunkModulesIterableBySourceType(chunk, "javascript")
	);
***REMOVED***;

/**
 * @param {Chunk***REMOVED*** chunk a chunk
 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @returns {boolean***REMOVED*** true, when a JS file is needed for this chunk
 */
const chunkHasRuntimeOrJs = (chunk, chunkGraph) => {
	if (
		chunkGraph.getChunkModulesIterableBySourceType(
			chunk,
			WEBPACK_MODULE_TYPE_RUNTIME
		)
	)
		return true;

	return Boolean(
		chunkGraph.getChunkModulesIterableBySourceType(chunk, "javascript")
	);
***REMOVED***;

/**
 * @param {Module***REMOVED*** module a module
 * @param {string***REMOVED*** code the code
 * @returns {string***REMOVED*** generated code for the stack
 */
const printGeneratedCodeForStack = (module, code) => {
	const lines = code.split("\n");
	const n = `${lines.length***REMOVED***`.length;
	return `\n\nGenerated code for ${module.identifier()***REMOVED***\n${lines
		.map(
			/**
			 * @param {string***REMOVED*** line the line
			 * @param {number***REMOVED*** i the index
			 * @param {string[]***REMOVED*** lines the lines
			 * @returns {string***REMOVED*** the line with line number
			 */
			(line, i, lines) => {
				const iStr = `${i + 1***REMOVED***`;
				return `${" ".repeat(n - iStr.length)***REMOVED***${iStr***REMOVED*** | ${line***REMOVED***`;
			***REMOVED***
		)
		.join("\n")***REMOVED***`;
***REMOVED***;

/**
 * @typedef {object***REMOVED*** RenderContext
 * @property {Chunk***REMOVED*** chunk the chunk
 * @property {DependencyTemplates***REMOVED*** dependencyTemplates the dependency templates
 * @property {RuntimeTemplate***REMOVED*** runtimeTemplate the runtime template
 * @property {ModuleGraph***REMOVED*** moduleGraph the module graph
 * @property {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @property {CodeGenerationResults***REMOVED*** codeGenerationResults results of code generation
 * @property {boolean | undefined***REMOVED*** strictMode rendering in strict context
 */

/**
 * @typedef {object***REMOVED*** MainRenderContext
 * @property {Chunk***REMOVED*** chunk the chunk
 * @property {DependencyTemplates***REMOVED*** dependencyTemplates the dependency templates
 * @property {RuntimeTemplate***REMOVED*** runtimeTemplate the runtime template
 * @property {ModuleGraph***REMOVED*** moduleGraph the module graph
 * @property {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @property {CodeGenerationResults***REMOVED*** codeGenerationResults results of code generation
 * @property {string***REMOVED*** hash hash to be used for render call
 * @property {boolean | undefined***REMOVED*** strictMode rendering in strict context
 */

/**
 * @typedef {object***REMOVED*** ChunkRenderContext
 * @property {Chunk***REMOVED*** chunk the chunk
 * @property {DependencyTemplates***REMOVED*** dependencyTemplates the dependency templates
 * @property {RuntimeTemplate***REMOVED*** runtimeTemplate the runtime template
 * @property {ModuleGraph***REMOVED*** moduleGraph the module graph
 * @property {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @property {CodeGenerationResults***REMOVED*** codeGenerationResults results of code generation
 * @property {InitFragment<ChunkRenderContext>[]***REMOVED*** chunkInitFragments init fragments for the chunk
 * @property {boolean | undefined***REMOVED*** strictMode rendering in strict context
 */

/**
 * @typedef {object***REMOVED*** RenderBootstrapContext
 * @property {Chunk***REMOVED*** chunk the chunk
 * @property {CodeGenerationResults***REMOVED*** codeGenerationResults results of code generation
 * @property {RuntimeTemplate***REMOVED*** runtimeTemplate the runtime template
 * @property {ModuleGraph***REMOVED*** moduleGraph the module graph
 * @property {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @property {string***REMOVED*** hash hash to be used for render call
 */

/** @typedef {RenderContext & { inlined: boolean ***REMOVED******REMOVED*** StartupRenderContext */

/**
 * @typedef {object***REMOVED*** CompilationHooks
 * @property {SyncWaterfallHook<[Source, Module, ChunkRenderContext]>***REMOVED*** renderModuleContent
 * @property {SyncWaterfallHook<[Source, Module, ChunkRenderContext]>***REMOVED*** renderModuleContainer
 * @property {SyncWaterfallHook<[Source, Module, ChunkRenderContext]>***REMOVED*** renderModulePackage
 * @property {SyncWaterfallHook<[Source, RenderContext]>***REMOVED*** renderChunk
 * @property {SyncWaterfallHook<[Source, RenderContext]>***REMOVED*** renderMain
 * @property {SyncWaterfallHook<[Source, RenderContext]>***REMOVED*** renderContent
 * @property {SyncWaterfallHook<[Source, RenderContext]>***REMOVED*** render
 * @property {SyncWaterfallHook<[Source, Module, StartupRenderContext]>***REMOVED*** renderStartup
 * @property {SyncWaterfallHook<[string, RenderBootstrapContext]>***REMOVED*** renderRequire
 * @property {SyncBailHook<[Module, RenderBootstrapContext], string | void>***REMOVED*** inlineInRuntimeBailout
 * @property {SyncBailHook<[Module, RenderContext], string | void>***REMOVED*** embedInRuntimeBailout
 * @property {SyncBailHook<[RenderContext], string | void>***REMOVED*** strictRuntimeBailout
 * @property {SyncHook<[Chunk, Hash, ChunkHashContext]>***REMOVED*** chunkHash
 * @property {SyncBailHook<[Chunk, RenderContext], boolean | void>***REMOVED*** useSourceMap
 */

/** @type {WeakMap<Compilation, CompilationHooks>***REMOVED*** */
const compilationHooksMap = new WeakMap();

const PLUGIN_NAME = "JavascriptModulesPlugin";

/** @typedef {{ header: string[], beforeStartup: string[], startup: string[], afterStartup: string[], allowInlineStartup: boolean ***REMOVED******REMOVED*** Bootstrap */

class JavascriptModulesPlugin {
	/**
	 * @param {Compilation***REMOVED*** compilation the compilation
	 * @returns {CompilationHooks***REMOVED*** the attached hooks
	 */
	static getCompilationHooks(compilation) {
		if (!(compilation instanceof Compilation)) {
			throw new TypeError(
				"The 'compilation' argument must be an instance of Compilation"
			);
		***REMOVED***
		let hooks = compilationHooksMap.get(compilation);
		if (hooks === undefined) {
			hooks = {
				renderModuleContent: new SyncWaterfallHook([
					"source",
					"module",
					"renderContext"
				]),
				renderModuleContainer: new SyncWaterfallHook([
					"source",
					"module",
					"renderContext"
				]),
				renderModulePackage: new SyncWaterfallHook([
					"source",
					"module",
					"renderContext"
				]),
				render: new SyncWaterfallHook(["source", "renderContext"]),
				renderContent: new SyncWaterfallHook(["source", "renderContext"]),
				renderStartup: new SyncWaterfallHook([
					"source",
					"module",
					"startupRenderContext"
				]),
				renderChunk: new SyncWaterfallHook(["source", "renderContext"]),
				renderMain: new SyncWaterfallHook(["source", "renderContext"]),
				renderRequire: new SyncWaterfallHook(["code", "renderContext"]),
				inlineInRuntimeBailout: new SyncBailHook(["module", "renderContext"]),
				embedInRuntimeBailout: new SyncBailHook(["module", "renderContext"]),
				strictRuntimeBailout: new SyncBailHook(["renderContext"]),
				chunkHash: new SyncHook(["chunk", "hash", "context"]),
				useSourceMap: new SyncBailHook(["chunk", "renderContext"])
			***REMOVED***;
			compilationHooksMap.set(compilation, hooks);
		***REMOVED***
		return hooks;
	***REMOVED***

	constructor(options = {***REMOVED***) {
		this.options = options;
		/** @type {WeakMap<Source, { source: Source, needModule:boolean, needExports: boolean, needRequire: boolean, needThisAsExports: boolean, needStrict: boolean | undefined ***REMOVED***>***REMOVED*** */
		this._moduleFactoryCache = new WeakMap();
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			PLUGIN_NAME,
			(compilation, { normalModuleFactory ***REMOVED***) => {
				const hooks = JavascriptModulesPlugin.getCompilationHooks(compilation);

				for (const type of [
					JAVASCRIPT_MODULE_TYPE_AUTO,
					JAVASCRIPT_MODULE_TYPE_DYNAMIC,
					JAVASCRIPT_MODULE_TYPE_ESM
				]) {
					normalModuleFactory.hooks.createParser
						.for(type)
						.tap(PLUGIN_NAME, _options => {
							switch (type) {
								case JAVASCRIPT_MODULE_TYPE_AUTO: {
									return new JavascriptParser("auto");
								***REMOVED***
								case JAVASCRIPT_MODULE_TYPE_DYNAMIC: {
									return new JavascriptParser("script");
								***REMOVED***
								case JAVASCRIPT_MODULE_TYPE_ESM: {
									return new JavascriptParser("module");
								***REMOVED***
							***REMOVED***
						***REMOVED***);
					normalModuleFactory.hooks.createGenerator
						.for(type)
						.tap(PLUGIN_NAME, () => new JavascriptGenerator());

					NormalModule.getCompilationHooks(compilation).processResult.tap(
						PLUGIN_NAME,
						(result, module) => {
							if (module.type === type) {
								const [source, ...rest] = result;

								return [removeBOM(source), ...rest];
							***REMOVED***

							return result;
						***REMOVED***
					);
				***REMOVED***

				compilation.hooks.renderManifest.tap(PLUGIN_NAME, (result, options) => {
					const {
						hash,
						chunk,
						chunkGraph,
						moduleGraph,
						runtimeTemplate,
						dependencyTemplates,
						outputOptions,
						codeGenerationResults
					***REMOVED*** = options;

					const hotUpdateChunk = chunk instanceof HotUpdateChunk ? chunk : null;
					const filenameTemplate =
						JavascriptModulesPlugin.getChunkFilenameTemplate(
							chunk,
							outputOptions
						);

					let render;

					if (hotUpdateChunk) {
						render = () =>
							this.renderChunk(
								{
									chunk,
									dependencyTemplates,
									runtimeTemplate,
									moduleGraph,
									chunkGraph,
									codeGenerationResults,
									strictMode: runtimeTemplate.isModule()
								***REMOVED***,
								hooks
							);
					***REMOVED*** else if (chunk.hasRuntime()) {
						if (!chunkHasRuntimeOrJs(chunk, chunkGraph)) {
							return result;
						***REMOVED***

						render = () =>
							this.renderMain(
								{
									hash,
									chunk,
									dependencyTemplates,
									runtimeTemplate,
									moduleGraph,
									chunkGraph,
									codeGenerationResults,
									strictMode: runtimeTemplate.isModule()
								***REMOVED***,
								hooks,
								compilation
							);
					***REMOVED*** else {
						if (!chunkHasJs(chunk, chunkGraph)) {
							return result;
						***REMOVED***

						render = () =>
							this.renderChunk(
								{
									chunk,
									dependencyTemplates,
									runtimeTemplate,
									moduleGraph,
									chunkGraph,
									codeGenerationResults,
									strictMode: runtimeTemplate.isModule()
								***REMOVED***,
								hooks
							);
					***REMOVED***

					result.push({
						render,
						filenameTemplate,
						pathOptions: {
							hash,
							runtime: chunk.runtime,
							chunk,
							contentHashType: "javascript"
						***REMOVED***,
						info: {
							javascriptModule: compilation.runtimeTemplate.isModule()
						***REMOVED***,
						identifier: hotUpdateChunk
							? `hotupdatechunk${chunk.id***REMOVED***`
							: `chunk${chunk.id***REMOVED***`,
						hash: chunk.contentHash.javascript
					***REMOVED***);

					return result;
				***REMOVED***);
				compilation.hooks.chunkHash.tap(PLUGIN_NAME, (chunk, hash, context) => {
					hooks.chunkHash.call(chunk, hash, context);
					if (chunk.hasRuntime()) {
						this.updateHashWithBootstrap(
							hash,
							{
								hash: "0000",
								chunk,
								codeGenerationResults: context.codeGenerationResults,
								chunkGraph: context.chunkGraph,
								moduleGraph: context.moduleGraph,
								runtimeTemplate: context.runtimeTemplate
							***REMOVED***,
							hooks
						);
					***REMOVED***
				***REMOVED***);
				compilation.hooks.contentHash.tap(PLUGIN_NAME, chunk => {
					const {
						chunkGraph,
						codeGenerationResults,
						moduleGraph,
						runtimeTemplate,
						outputOptions: {
							hashSalt,
							hashDigest,
							hashDigestLength,
							hashFunction
						***REMOVED***
					***REMOVED*** = compilation;
					const hash = createHash(/** @type {HashFunction***REMOVED*** */ (hashFunction));
					if (hashSalt) hash.update(hashSalt);
					if (chunk.hasRuntime()) {
						this.updateHashWithBootstrap(
							hash,
							{
								hash: "0000",
								chunk,
								codeGenerationResults,
								chunkGraph: compilation.chunkGraph,
								moduleGraph: compilation.moduleGraph,
								runtimeTemplate: compilation.runtimeTemplate
							***REMOVED***,
							hooks
						);
					***REMOVED*** else {
						hash.update(`${chunk.id***REMOVED*** `);
						hash.update(chunk.ids ? chunk.ids.join(",") : "");
					***REMOVED***
					hooks.chunkHash.call(chunk, hash, {
						chunkGraph,
						codeGenerationResults,
						moduleGraph,
						runtimeTemplate
					***REMOVED***);
					const modules = chunkGraph.getChunkModulesIterableBySourceType(
						chunk,
						"javascript"
					);
					if (modules) {
						const xor = new StringXor();
						for (const m of modules) {
							xor.add(chunkGraph.getModuleHash(m, chunk.runtime));
						***REMOVED***
						xor.updateHash(hash);
					***REMOVED***
					const runtimeModules = chunkGraph.getChunkModulesIterableBySourceType(
						chunk,
						WEBPACK_MODULE_TYPE_RUNTIME
					);
					if (runtimeModules) {
						const xor = new StringXor();
						for (const m of runtimeModules) {
							xor.add(chunkGraph.getModuleHash(m, chunk.runtime));
						***REMOVED***
						xor.updateHash(hash);
					***REMOVED***
					const digest = /** @type {string***REMOVED*** */ (hash.digest(hashDigest));
					chunk.contentHash.javascript = nonNumericOnlyHash(
						digest,
						/** @type {number***REMOVED*** */
						(hashDigestLength)
					);
				***REMOVED***);
				compilation.hooks.additionalTreeRuntimeRequirements.tap(
					PLUGIN_NAME,
					(chunk, set, { chunkGraph ***REMOVED***) => {
						if (
							!set.has(RuntimeGlobals.startupNoDefault) &&
							chunkGraph.hasChunkEntryDependentChunks(chunk)
						) {
							set.add(RuntimeGlobals.onChunksLoaded);
							set.add(RuntimeGlobals.exports);
							set.add(RuntimeGlobals.require);
						***REMOVED***
					***REMOVED***
				);
				compilation.hooks.executeModule.tap(PLUGIN_NAME, (options, context) => {
					const source = options.codeGenerationResult.sources.get("javascript");
					if (source === undefined) return;
					const { module ***REMOVED*** = options;
					const code = source.source();

					const fn = vm.runInThisContext(
						`(function(${module.moduleArgument***REMOVED***, ${module.exportsArgument***REMOVED***, ${RuntimeGlobals.require***REMOVED***) {\n${code***REMOVED***\n/**/***REMOVED***)`,
						{
							filename: module.identifier(),
							lineOffset: -1
						***REMOVED***
					);

					const moduleObject =
						/** @type {ExecuteModuleObject***REMOVED*** */
						(options.moduleObject);

					try {
						fn.call(
							moduleObject.exports,
							moduleObject,
							moduleObject.exports,
							context.__webpack_require__
						);
					***REMOVED*** catch (err) {
						/** @type {Error***REMOVED*** */
						(err).stack += printGeneratedCodeForStack(
							options.module,
							/** @type {string***REMOVED*** */ (code)
						);
						throw err;
					***REMOVED***
				***REMOVED***);
				compilation.hooks.executeModule.tap(PLUGIN_NAME, (options, context) => {
					const source = options.codeGenerationResult.sources.get("runtime");
					if (source === undefined) return;
					let code = source.source();
					if (typeof code !== "string") code = code.toString();

					const fn = vm.runInThisContext(
						`(function(${RuntimeGlobals.require***REMOVED***) {\n${code***REMOVED***\n/**/***REMOVED***)`,
						{
							filename: options.module.identifier(),
							lineOffset: -1
						***REMOVED***
					);
					try {
						// eslint-disable-next-line no-useless-call
						fn.call(null, context.__webpack_require__);
					***REMOVED*** catch (err) {
						/** @type {Error***REMOVED*** */
						(err).stack += printGeneratedCodeForStack(options.module, code);
						throw err;
					***REMOVED***
				***REMOVED***);
			***REMOVED***
		);
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk chunk
	 * @param {OutputOptions***REMOVED*** outputOptions output options
	 * @returns {TemplatePath***REMOVED*** used filename template
	 */
	static getChunkFilenameTemplate(chunk, outputOptions) {
		if (chunk.filenameTemplate) {
			return chunk.filenameTemplate;
		***REMOVED*** else if (chunk instanceof HotUpdateChunk) {
			return /** @type {TemplatePath***REMOVED*** */ (outputOptions.hotUpdateChunkFilename);
		***REMOVED*** else if (chunk.canBeInitial()) {
			return /** @type {TemplatePath***REMOVED*** */ (outputOptions.filename);
		***REMOVED***
		return /** @type {TemplatePath***REMOVED*** */ (outputOptions.chunkFilename);
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the rendered module
	 * @param {ChunkRenderContext***REMOVED*** renderContext options object
	 * @param {CompilationHooks***REMOVED*** hooks hooks
	 * @param {boolean***REMOVED*** factory true: renders as factory method, false: pure module content
	 * @returns {Source | null***REMOVED*** the newly generated source from rendering
	 */
	renderModule(module, renderContext, hooks, factory) {
		const {
			chunk,
			chunkGraph,
			runtimeTemplate,
			codeGenerationResults,
			strictMode
		***REMOVED*** = renderContext;
		try {
			const codeGenResult = codeGenerationResults.get(module, chunk.runtime);
			const moduleSource = codeGenResult.sources.get("javascript");
			if (!moduleSource) return null;
			if (codeGenResult.data !== undefined) {
				const chunkInitFragments = codeGenResult.data.get("chunkInitFragments");
				if (chunkInitFragments) {
					for (const i of chunkInitFragments)
						renderContext.chunkInitFragments.push(i);
				***REMOVED***
			***REMOVED***
			const moduleSourcePostContent = tryRunOrWebpackError(
				() =>
					hooks.renderModuleContent.call(moduleSource, module, renderContext),
				"JavascriptModulesPlugin.getCompilationHooks().renderModuleContent"
			);
			let moduleSourcePostContainer;
			if (factory) {
				const runtimeRequirements = chunkGraph.getModuleRuntimeRequirements(
					module,
					chunk.runtime
				);
				const needModule = runtimeRequirements.has(RuntimeGlobals.module);
				const needExports = runtimeRequirements.has(RuntimeGlobals.exports);
				const needRequire =
					runtimeRequirements.has(RuntimeGlobals.require) ||
					runtimeRequirements.has(RuntimeGlobals.requireScope);
				const needThisAsExports = runtimeRequirements.has(
					RuntimeGlobals.thisAsExports
				);
				const needStrict =
					/** @type {BuildInfo***REMOVED*** */
					(module.buildInfo).strict && !strictMode;
				const cacheEntry = this._moduleFactoryCache.get(
					moduleSourcePostContent
				);
				let source;
				if (
					cacheEntry &&
					cacheEntry.needModule === needModule &&
					cacheEntry.needExports === needExports &&
					cacheEntry.needRequire === needRequire &&
					cacheEntry.needThisAsExports === needThisAsExports &&
					cacheEntry.needStrict === needStrict
				) {
					source = cacheEntry.source;
				***REMOVED*** else {
					const factorySource = new ConcatSource();
					const args = [];
					if (needExports || needRequire || needModule)
						args.push(
							needModule
								? module.moduleArgument
								: `__unused_webpack_${module.moduleArgument***REMOVED***`
						);
					if (needExports || needRequire)
						args.push(
							needExports
								? module.exportsArgument
								: `__unused_webpack_${module.exportsArgument***REMOVED***`
						);
					if (needRequire) args.push(RuntimeGlobals.require);
					if (!needThisAsExports && runtimeTemplate.supportsArrowFunction()) {
						factorySource.add(`/***/ ((${args.join(", ")***REMOVED***) => {\n\n`);
					***REMOVED*** else {
						factorySource.add(`/***/ (function(${args.join(", ")***REMOVED***) {\n\n`);
					***REMOVED***
					if (needStrict) {
						factorySource.add('"use strict";\n');
					***REMOVED***
					factorySource.add(moduleSourcePostContent);
					factorySource.add("\n\n/***/ ***REMOVED***)");
					source = new CachedSource(factorySource);
					this._moduleFactoryCache.set(moduleSourcePostContent, {
						source,
						needModule,
						needExports,
						needRequire,
						needThisAsExports,
						needStrict
					***REMOVED***);
				***REMOVED***
				moduleSourcePostContainer = tryRunOrWebpackError(
					() => hooks.renderModuleContainer.call(source, module, renderContext),
					"JavascriptModulesPlugin.getCompilationHooks().renderModuleContainer"
				);
			***REMOVED*** else {
				moduleSourcePostContainer = moduleSourcePostContent;
			***REMOVED***
			return tryRunOrWebpackError(
				() =>
					hooks.renderModulePackage.call(
						moduleSourcePostContainer,
						module,
						renderContext
					),
				"JavascriptModulesPlugin.getCompilationHooks().renderModulePackage"
			);
		***REMOVED*** catch (err) {
			/** @type {WebpackError***REMOVED*** */
			(err).module = module;
			throw err;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {RenderContext***REMOVED*** renderContext the render context
	 * @param {CompilationHooks***REMOVED*** hooks hooks
	 * @returns {Source***REMOVED*** the rendered source
	 */
	renderChunk(renderContext, hooks) {
		const { chunk, chunkGraph ***REMOVED*** = renderContext;
		const modules = chunkGraph.getOrderedChunkModulesIterableBySourceType(
			chunk,
			"javascript",
			compareModulesByIdOrIdentifier(chunkGraph)
		);
		const allModules = modules ? Array.from(modules) : [];
		let strictHeader;
		let allStrict = renderContext.strictMode;
		if (
			!allStrict &&
			allModules.every(m => /** @type {BuildInfo***REMOVED*** */ (m.buildInfo).strict)
		) {
			const strictBailout = hooks.strictRuntimeBailout.call(renderContext);
			strictHeader = strictBailout
				? `// runtime can't be in strict mode because ${strictBailout***REMOVED***.\n`
				: '"use strict";\n';
			if (!strictBailout) allStrict = true;
		***REMOVED***
		/** @type {ChunkRenderContext***REMOVED*** */
		const chunkRenderContext = {
			...renderContext,
			chunkInitFragments: [],
			strictMode: allStrict
		***REMOVED***;
		const moduleSources =
			Template.renderChunkModules(chunkRenderContext, allModules, module =>
				this.renderModule(module, chunkRenderContext, hooks, true)
			) || new RawSource("{***REMOVED***");
		let source = tryRunOrWebpackError(
			() => hooks.renderChunk.call(moduleSources, chunkRenderContext),
			"JavascriptModulesPlugin.getCompilationHooks().renderChunk"
		);
		source = tryRunOrWebpackError(
			() => hooks.renderContent.call(source, chunkRenderContext),
			"JavascriptModulesPlugin.getCompilationHooks().renderContent"
		);
		if (!source) {
			throw new Error(
				"JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().renderContent plugins should return something"
			);
		***REMOVED***
		source = InitFragment.addToSource(
			source,
			chunkRenderContext.chunkInitFragments,
			chunkRenderContext
		);
		source = tryRunOrWebpackError(
			() => hooks.render.call(source, chunkRenderContext),
			"JavascriptModulesPlugin.getCompilationHooks().render"
		);
		if (!source) {
			throw new Error(
				"JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().render plugins should return something"
			);
		***REMOVED***
		chunk.rendered = true;
		return strictHeader
			? new ConcatSource(strictHeader, source, ";")
			: renderContext.runtimeTemplate.isModule()
				? source
				: new ConcatSource(source, ";");
	***REMOVED***

	/**
	 * @param {MainRenderContext***REMOVED*** renderContext options object
	 * @param {CompilationHooks***REMOVED*** hooks hooks
	 * @param {Compilation***REMOVED*** compilation the compilation
	 * @returns {Source***REMOVED*** the newly generated source from rendering
	 */
	renderMain(renderContext, hooks, compilation) {
		const { chunk, chunkGraph, runtimeTemplate ***REMOVED*** = renderContext;

		const runtimeRequirements = chunkGraph.getTreeRuntimeRequirements(chunk);
		const iife = runtimeTemplate.isIIFE();

		const bootstrap = this.renderBootstrap(renderContext, hooks);
		const useSourceMap = hooks.useSourceMap.call(chunk, renderContext);

		const allModules = Array.from(
			chunkGraph.getOrderedChunkModulesIterableBySourceType(
				chunk,
				"javascript",
				compareModulesByIdOrIdentifier(chunkGraph)
			) || []
		);

		const hasEntryModules = chunkGraph.getNumberOfEntryModules(chunk) > 0;
		/** @type {Set<Module> | undefined***REMOVED*** */
		let inlinedModules;
		if (bootstrap.allowInlineStartup && hasEntryModules) {
			inlinedModules = new Set(chunkGraph.getChunkEntryModulesIterable(chunk));
		***REMOVED***

		const source = new ConcatSource();
		let prefix;
		if (iife) {
			if (runtimeTemplate.supportsArrowFunction()) {
				source.add("/******/ (() => { // webpackBootstrap\n");
			***REMOVED*** else {
				source.add("/******/ (function() { // webpackBootstrap\n");
			***REMOVED***
			prefix = "/******/ \t";
		***REMOVED*** else {
			prefix = "/******/ ";
		***REMOVED***
		let allStrict = renderContext.strictMode;
		if (
			!allStrict &&
			allModules.every(m => /** @type {BuildInfo***REMOVED*** */ (m.buildInfo).strict)
		) {
			const strictBailout = hooks.strictRuntimeBailout.call(renderContext);
			if (strictBailout) {
				source.add(
					`${
						prefix
					***REMOVED***// runtime can't be in strict mode because ${strictBailout***REMOVED***.\n`
				);
			***REMOVED*** else {
				allStrict = true;
				source.add(`${prefix***REMOVED***"use strict";\n`);
			***REMOVED***
		***REMOVED***

		/** @type {ChunkRenderContext***REMOVED*** */
		const chunkRenderContext = {
			...renderContext,
			chunkInitFragments: [],
			strictMode: allStrict
		***REMOVED***;

		const chunkModules = Template.renderChunkModules(
			chunkRenderContext,
			inlinedModules
				? allModules.filter(
						m => !(/** @type {Set<Module>***REMOVED*** */ (inlinedModules).has(m))
					)
				: allModules,
			module => this.renderModule(module, chunkRenderContext, hooks, true),
			prefix
		);
		if (
			chunkModules ||
			runtimeRequirements.has(RuntimeGlobals.moduleFactories) ||
			runtimeRequirements.has(RuntimeGlobals.moduleFactoriesAddOnly) ||
			runtimeRequirements.has(RuntimeGlobals.require)
		) {
			source.add(`${prefix***REMOVED***var __webpack_modules__ = (`);
			source.add(chunkModules || "{***REMOVED***");
			source.add(");\n");
			source.add(
				"/************************************************************************/\n"
			);
		***REMOVED***

		if (bootstrap.header.length > 0) {
			const header = `${Template.asString(bootstrap.header)***REMOVED***\n`;
			source.add(
				new PrefixSource(
					prefix,
					useSourceMap
						? new OriginalSource(header, "webpack/bootstrap")
						: new RawSource(header)
				)
			);
			source.add(
				"/************************************************************************/\n"
			);
		***REMOVED***

		const runtimeModules =
			renderContext.chunkGraph.getChunkRuntimeModulesInOrder(chunk);

		if (runtimeModules.length > 0) {
			source.add(
				new PrefixSource(
					prefix,
					Template.renderRuntimeModules(runtimeModules, chunkRenderContext)
				)
			);
			source.add(
				"/************************************************************************/\n"
			);
			// runtimeRuntimeModules calls codeGeneration
			for (const module of runtimeModules) {
				compilation.codeGeneratedModules.add(module);
			***REMOVED***
		***REMOVED***
		if (inlinedModules) {
			if (bootstrap.beforeStartup.length > 0) {
				const beforeStartup = `${Template.asString(bootstrap.beforeStartup)***REMOVED***\n`;
				source.add(
					new PrefixSource(
						prefix,
						useSourceMap
							? new OriginalSource(beforeStartup, "webpack/before-startup")
							: new RawSource(beforeStartup)
					)
				);
			***REMOVED***
			const lastInlinedModule = /** @type {Module***REMOVED*** */ (last(inlinedModules));
			const startupSource = new ConcatSource();

			if (runtimeRequirements.has(RuntimeGlobals.exports)) {
				startupSource.add(`var ${RuntimeGlobals.exports***REMOVED*** = {***REMOVED***;\n`);
			***REMOVED***

			const avoidEntryIife = compilation.options.optimization.avoidEntryIife;
			/** @type {Map<Module, Source> | false***REMOVED*** */
			let renamedInlinedModule = false;
			if (avoidEntryIife) {
				renamedInlinedModule = this.getRenamedInlineModule(
					allModules,
					renderContext,
					inlinedModules,
					chunkRenderContext,
					hooks,
					allStrict,
					Boolean(chunkModules)
				);
			***REMOVED***

			for (const m of inlinedModules) {
				const renderedModule = renamedInlinedModule
					? renamedInlinedModule.get(m)
					: this.renderModule(m, chunkRenderContext, hooks, false);

				if (renderedModule) {
					const innerStrict =
						!allStrict && /** @type {BuildInfo***REMOVED*** */ (m.buildInfo).strict;
					const runtimeRequirements = chunkGraph.getModuleRuntimeRequirements(
						m,
						chunk.runtime
					);
					const exports = runtimeRequirements.has(RuntimeGlobals.exports);
					const webpackExports =
						exports && m.exportsArgument === RuntimeGlobals.exports;
					const iife = innerStrict
						? "it needs to be in strict mode."
						: inlinedModules.size > 1
							? // TODO check globals and top-level declarations of other entries and chunk modules
								// to make a better decision
								"it needs to be isolated against other entry modules."
							: chunkModules && !renamedInlinedModule
								? "it needs to be isolated against other modules in the chunk."
								: exports && !webpackExports
									? `it uses a non-standard name for the exports (${m.exportsArgument***REMOVED***).`
									: hooks.embedInRuntimeBailout.call(m, renderContext);
					let footer;
					if (iife !== undefined) {
						startupSource.add(
							`// This entry needs to be wrapped in an IIFE because ${iife***REMOVED***\n`
						);
						const arrow = runtimeTemplate.supportsArrowFunction();
						if (arrow) {
							startupSource.add("(() => {\n");
							footer = "\n***REMOVED***)();\n\n";
						***REMOVED*** else {
							startupSource.add("!function() {\n");
							footer = "\n***REMOVED***();\n";
						***REMOVED***
						if (innerStrict) startupSource.add('"use strict";\n');
					***REMOVED*** else {
						footer = "\n";
					***REMOVED***
					if (exports) {
						if (m !== lastInlinedModule)
							startupSource.add(`var ${m.exportsArgument***REMOVED*** = {***REMOVED***;\n`);
						else if (m.exportsArgument !== RuntimeGlobals.exports)
							startupSource.add(
								`var ${m.exportsArgument***REMOVED*** = ${RuntimeGlobals.exports***REMOVED***;\n`
							);
					***REMOVED***
					startupSource.add(renderedModule);
					startupSource.add(footer);
				***REMOVED***
			***REMOVED***
			if (runtimeRequirements.has(RuntimeGlobals.onChunksLoaded)) {
				startupSource.add(
					`${RuntimeGlobals.exports***REMOVED*** = ${RuntimeGlobals.onChunksLoaded***REMOVED***(${RuntimeGlobals.exports***REMOVED***);\n`
				);
			***REMOVED***
			source.add(
				hooks.renderStartup.call(startupSource, lastInlinedModule, {
					...renderContext,
					inlined: true
				***REMOVED***)
			);
			if (bootstrap.afterStartup.length > 0) {
				const afterStartup = `${Template.asString(bootstrap.afterStartup)***REMOVED***\n`;
				source.add(
					new PrefixSource(
						prefix,
						useSourceMap
							? new OriginalSource(afterStartup, "webpack/after-startup")
							: new RawSource(afterStartup)
					)
				);
			***REMOVED***
		***REMOVED*** else {
			const lastEntryModule =
				/** @type {Module***REMOVED*** */
				(last(chunkGraph.getChunkEntryModulesIterable(chunk)));
			/** @type {(content: string[], name: string) => Source***REMOVED*** */
			const toSource = useSourceMap
				? (content, name) =>
						new OriginalSource(Template.asString(content), name)
				: content => new RawSource(Template.asString(content));
			source.add(
				new PrefixSource(
					prefix,
					new ConcatSource(
						toSource(bootstrap.beforeStartup, "webpack/before-startup"),
						"\n",
						hooks.renderStartup.call(
							toSource(bootstrap.startup.concat(""), "webpack/startup"),
							lastEntryModule,
							{
								...renderContext,
								inlined: false
							***REMOVED***
						),
						toSource(bootstrap.afterStartup, "webpack/after-startup"),
						"\n"
					)
				)
			);
		***REMOVED***
		if (
			hasEntryModules &&
			runtimeRequirements.has(RuntimeGlobals.returnExportsFromRuntime)
		) {
			source.add(`${prefix***REMOVED***return ${RuntimeGlobals.exports***REMOVED***;\n`);
		***REMOVED***
		if (iife) {
			source.add("/******/ ***REMOVED***)()\n");
		***REMOVED***

		/** @type {Source***REMOVED*** */
		let finalSource = tryRunOrWebpackError(
			() => hooks.renderMain.call(source, renderContext),
			"JavascriptModulesPlugin.getCompilationHooks().renderMain"
		);
		if (!finalSource) {
			throw new Error(
				"JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().renderMain plugins should return something"
			);
		***REMOVED***
		finalSource = tryRunOrWebpackError(
			() => hooks.renderContent.call(finalSource, renderContext),
			"JavascriptModulesPlugin.getCompilationHooks().renderContent"
		);
		if (!finalSource) {
			throw new Error(
				"JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().renderContent plugins should return something"
			);
		***REMOVED***

		finalSource = InitFragment.addToSource(
			finalSource,
			chunkRenderContext.chunkInitFragments,
			chunkRenderContext
		);
		finalSource = tryRunOrWebpackError(
			() => hooks.render.call(finalSource, renderContext),
			"JavascriptModulesPlugin.getCompilationHooks().render"
		);
		if (!finalSource) {
			throw new Error(
				"JavascriptModulesPlugin error: JavascriptModulesPlugin.getCompilationHooks().render plugins should return something"
			);
		***REMOVED***
		chunk.rendered = true;
		return iife ? new ConcatSource(finalSource, ";") : finalSource;
	***REMOVED***

	/**
	 * @param {Hash***REMOVED*** hash the hash to be updated
	 * @param {RenderBootstrapContext***REMOVED*** renderContext options object
	 * @param {CompilationHooks***REMOVED*** hooks hooks
	 */
	updateHashWithBootstrap(hash, renderContext, hooks) {
		const bootstrap = this.renderBootstrap(renderContext, hooks);
		for (const _k of Object.keys(bootstrap)) {
			const key = /** @type {keyof Bootstrap***REMOVED*** */ (_k);
			hash.update(key);
			if (Array.isArray(bootstrap[key])) {
				for (const line of bootstrap[key]) {
					hash.update(line);
				***REMOVED***
			***REMOVED*** else {
				hash.update(JSON.stringify(bootstrap[key]));
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {RenderBootstrapContext***REMOVED*** renderContext options object
	 * @param {CompilationHooks***REMOVED*** hooks hooks
	 * @returns {Bootstrap***REMOVED*** the generated source of the bootstrap code
	 */
	renderBootstrap(renderContext, hooks) {
		const {
			chunkGraph,
			codeGenerationResults,
			moduleGraph,
			chunk,
			runtimeTemplate
		***REMOVED*** = renderContext;

		const runtimeRequirements = chunkGraph.getTreeRuntimeRequirements(chunk);

		const requireFunction = runtimeRequirements.has(RuntimeGlobals.require);
		const moduleCache = runtimeRequirements.has(RuntimeGlobals.moduleCache);
		const moduleFactories = runtimeRequirements.has(
			RuntimeGlobals.moduleFactories
		);
		const moduleUsed = runtimeRequirements.has(RuntimeGlobals.module);
		const requireScopeUsed = runtimeRequirements.has(
			RuntimeGlobals.requireScope
		);
		const interceptModuleExecution = runtimeRequirements.has(
			RuntimeGlobals.interceptModuleExecution
		);

		const useRequire =
			requireFunction || interceptModuleExecution || moduleUsed;

		/**
		 * @type {{startup: string[], beforeStartup: string[], header: string[], afterStartup: string[], allowInlineStartup: boolean***REMOVED******REMOVED***
		 */
		const result = {
			header: [],
			beforeStartup: [],
			startup: [],
			afterStartup: [],
			allowInlineStartup: true
		***REMOVED***;

		const { header: buf, startup, beforeStartup, afterStartup ***REMOVED*** = result;

		if (result.allowInlineStartup && moduleFactories) {
			startup.push(
				"// module factories are used so entry inlining is disabled"
			);
			result.allowInlineStartup = false;
		***REMOVED***
		if (result.allowInlineStartup && moduleCache) {
			startup.push("// module cache are used so entry inlining is disabled");
			result.allowInlineStartup = false;
		***REMOVED***
		if (result.allowInlineStartup && interceptModuleExecution) {
			startup.push(
				"// module execution is intercepted so entry inlining is disabled"
			);
			result.allowInlineStartup = false;
		***REMOVED***

		if (useRequire || moduleCache) {
			buf.push("// The module cache");
			buf.push("var __webpack_module_cache__ = {***REMOVED***;");
			buf.push("");
		***REMOVED***

		if (useRequire) {
			buf.push("// The require function");
			buf.push(`function ${RuntimeGlobals.require***REMOVED***(moduleId) {`);
			buf.push(Template.indent(this.renderRequire(renderContext, hooks)));
			buf.push("***REMOVED***");
			buf.push("");
		***REMOVED*** else if (runtimeRequirements.has(RuntimeGlobals.requireScope)) {
			buf.push("// The require scope");
			buf.push(`var ${RuntimeGlobals.require***REMOVED*** = {***REMOVED***;`);
			buf.push("");
		***REMOVED***

		if (
			moduleFactories ||
			runtimeRequirements.has(RuntimeGlobals.moduleFactoriesAddOnly)
		) {
			buf.push("// expose the modules object (__webpack_modules__)");
			buf.push(`${RuntimeGlobals.moduleFactories***REMOVED*** = __webpack_modules__;`);
			buf.push("");
		***REMOVED***

		if (moduleCache) {
			buf.push("// expose the module cache");
			buf.push(`${RuntimeGlobals.moduleCache***REMOVED*** = __webpack_module_cache__;`);
			buf.push("");
		***REMOVED***

		if (interceptModuleExecution) {
			buf.push("// expose the module execution interceptor");
			buf.push(`${RuntimeGlobals.interceptModuleExecution***REMOVED*** = [];`);
			buf.push("");
		***REMOVED***

		if (!runtimeRequirements.has(RuntimeGlobals.startupNoDefault)) {
			if (chunkGraph.getNumberOfEntryModules(chunk) > 0) {
				/** @type {string[]***REMOVED*** */
				const buf2 = [];
				const runtimeRequirements =
					chunkGraph.getTreeRuntimeRequirements(chunk);
				buf2.push("// Load entry module and return exports");
				let i = chunkGraph.getNumberOfEntryModules(chunk);
				for (const [
					entryModule,
					entrypoint
				] of chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk)) {
					if (!chunkGraph.getModuleSourceTypes(entryModule).has("javascript")) {
						i--;
						continue;
					***REMOVED***
					const chunks =
						/** @type {Entrypoint***REMOVED*** */
						(entrypoint).chunks.filter(c => c !== chunk);
					if (result.allowInlineStartup && chunks.length > 0) {
						buf2.push(
							"// This entry module depends on other loaded chunks and execution need to be delayed"
						);
						result.allowInlineStartup = false;
					***REMOVED***
					if (
						result.allowInlineStartup &&
						someInIterable(
							moduleGraph.getIncomingConnectionsByOriginModule(entryModule),
							([originModule, connections]) =>
								originModule &&
								connections.some(c => c.isTargetActive(chunk.runtime)) &&
								someInIterable(
									chunkGraph.getModuleRuntimes(originModule),
									runtime =>
										intersectRuntime(runtime, chunk.runtime) !== undefined
								)
						)
					) {
						buf2.push(
							"// This entry module is referenced by other modules so it can't be inlined"
						);
						result.allowInlineStartup = false;
					***REMOVED***

					let data;
					if (codeGenerationResults.has(entryModule, chunk.runtime)) {
						const result = codeGenerationResults.get(
							entryModule,
							chunk.runtime
						);
						data = result.data;
					***REMOVED***
					if (
						result.allowInlineStartup &&
						(!data || !data.get("topLevelDeclarations")) &&
						(!entryModule.buildInfo ||
							!entryModule.buildInfo.topLevelDeclarations)
					) {
						buf2.push(
							"// This entry module doesn't tell about it's top-level declarations so it can't be inlined"
						);
						result.allowInlineStartup = false;
					***REMOVED***
					if (result.allowInlineStartup) {
						const bailout = hooks.inlineInRuntimeBailout.call(
							entryModule,
							renderContext
						);
						if (bailout !== undefined) {
							buf2.push(
								`// This entry module can't be inlined because ${bailout***REMOVED***`
							);
							result.allowInlineStartup = false;
						***REMOVED***
					***REMOVED***
					i--;
					const moduleId = chunkGraph.getModuleId(entryModule);
					const entryRuntimeRequirements =
						chunkGraph.getModuleRuntimeRequirements(entryModule, chunk.runtime);
					let moduleIdExpr = JSON.stringify(moduleId);
					if (runtimeRequirements.has(RuntimeGlobals.entryModuleId)) {
						moduleIdExpr = `${RuntimeGlobals.entryModuleId***REMOVED*** = ${moduleIdExpr***REMOVED***`;
					***REMOVED***
					if (
						result.allowInlineStartup &&
						entryRuntimeRequirements.has(RuntimeGlobals.module)
					) {
						result.allowInlineStartup = false;
						buf2.push(
							"// This entry module used 'module' so it can't be inlined"
						);
					***REMOVED***
					if (chunks.length > 0) {
						buf2.push(
							`${i === 0 ? `var ${RuntimeGlobals.exports***REMOVED*** = ` : ""***REMOVED***${
								RuntimeGlobals.onChunksLoaded
							***REMOVED***(undefined, ${JSON.stringify(
								chunks.map(c => c.id)
							)***REMOVED***, ${runtimeTemplate.returningFunction(
								`${RuntimeGlobals.require***REMOVED***(${moduleIdExpr***REMOVED***)`
							)***REMOVED***)`
						);
					***REMOVED*** else if (useRequire) {
						buf2.push(
							`${i === 0 ? `var ${RuntimeGlobals.exports***REMOVED*** = ` : ""***REMOVED***${
								RuntimeGlobals.require
							***REMOVED***(${moduleIdExpr***REMOVED***);`
						);
					***REMOVED*** else {
						if (i === 0) buf2.push(`var ${RuntimeGlobals.exports***REMOVED*** = {***REMOVED***;`);
						if (requireScopeUsed) {
							buf2.push(
								`__webpack_modules__[${moduleIdExpr***REMOVED***](0, ${
									i === 0 ? RuntimeGlobals.exports : "{***REMOVED***"
								***REMOVED***, ${RuntimeGlobals.require***REMOVED***);`
							);
						***REMOVED*** else if (entryRuntimeRequirements.has(RuntimeGlobals.exports)) {
							buf2.push(
								`__webpack_modules__[${moduleIdExpr***REMOVED***](0, ${
									i === 0 ? RuntimeGlobals.exports : "{***REMOVED***"
								***REMOVED***);`
							);
						***REMOVED*** else {
							buf2.push(`__webpack_modules__[${moduleIdExpr***REMOVED***]();`);
						***REMOVED***
					***REMOVED***
				***REMOVED***
				if (runtimeRequirements.has(RuntimeGlobals.onChunksLoaded)) {
					buf2.push(
						`${RuntimeGlobals.exports***REMOVED*** = ${RuntimeGlobals.onChunksLoaded***REMOVED***(${RuntimeGlobals.exports***REMOVED***);`
					);
				***REMOVED***
				if (
					runtimeRequirements.has(RuntimeGlobals.startup) ||
					(runtimeRequirements.has(RuntimeGlobals.startupOnlyBefore) &&
						runtimeRequirements.has(RuntimeGlobals.startupOnlyAfter))
				) {
					result.allowInlineStartup = false;
					buf.push("// the startup function");
					buf.push(
						`${RuntimeGlobals.startup***REMOVED*** = ${runtimeTemplate.basicFunction("", [
							...buf2,
							`return ${RuntimeGlobals.exports***REMOVED***;`
						])***REMOVED***;`
					);
					buf.push("");
					startup.push("// run startup");
					startup.push(
						`var ${RuntimeGlobals.exports***REMOVED*** = ${RuntimeGlobals.startup***REMOVED***();`
					);
				***REMOVED*** else if (runtimeRequirements.has(RuntimeGlobals.startupOnlyBefore)) {
					buf.push("// the startup function");
					buf.push(
						`${RuntimeGlobals.startup***REMOVED*** = ${runtimeTemplate.emptyFunction()***REMOVED***;`
					);
					beforeStartup.push("// run runtime startup");
					beforeStartup.push(`${RuntimeGlobals.startup***REMOVED***();`);
					startup.push("// startup");
					startup.push(Template.asString(buf2));
				***REMOVED*** else if (runtimeRequirements.has(RuntimeGlobals.startupOnlyAfter)) {
					buf.push("// the startup function");
					buf.push(
						`${RuntimeGlobals.startup***REMOVED*** = ${runtimeTemplate.emptyFunction()***REMOVED***;`
					);
					startup.push("// startup");
					startup.push(Template.asString(buf2));
					afterStartup.push("// run runtime startup");
					afterStartup.push(`${RuntimeGlobals.startup***REMOVED***();`);
				***REMOVED*** else {
					startup.push("// startup");
					startup.push(Template.asString(buf2));
				***REMOVED***
			***REMOVED*** else if (
				runtimeRequirements.has(RuntimeGlobals.startup) ||
				runtimeRequirements.has(RuntimeGlobals.startupOnlyBefore) ||
				runtimeRequirements.has(RuntimeGlobals.startupOnlyAfter)
			) {
				buf.push(
					"// the startup function",
					"// It's empty as no entry modules are in this chunk",
					`${RuntimeGlobals.startup***REMOVED*** = ${runtimeTemplate.emptyFunction()***REMOVED***;`,
					""
				);
			***REMOVED***
		***REMOVED*** else if (
			runtimeRequirements.has(RuntimeGlobals.startup) ||
			runtimeRequirements.has(RuntimeGlobals.startupOnlyBefore) ||
			runtimeRequirements.has(RuntimeGlobals.startupOnlyAfter)
		) {
			result.allowInlineStartup = false;
			buf.push(
				"// the startup function",
				"// It's empty as some runtime module handles the default behavior",
				`${RuntimeGlobals.startup***REMOVED*** = ${runtimeTemplate.emptyFunction()***REMOVED***;`
			);
			startup.push("// run startup");
			startup.push(
				`var ${RuntimeGlobals.exports***REMOVED*** = ${RuntimeGlobals.startup***REMOVED***();`
			);
		***REMOVED***
		return result;
	***REMOVED***

	/**
	 * @param {RenderBootstrapContext***REMOVED*** renderContext options object
	 * @param {CompilationHooks***REMOVED*** hooks hooks
	 * @returns {string***REMOVED*** the generated source of the require function
	 */
	renderRequire(renderContext, hooks) {
		const {
			chunk,
			chunkGraph,
			runtimeTemplate: { outputOptions ***REMOVED***
		***REMOVED*** = renderContext;
		const runtimeRequirements = chunkGraph.getTreeRuntimeRequirements(chunk);
		const moduleExecution = runtimeRequirements.has(
			RuntimeGlobals.interceptModuleExecution
		)
			? Template.asString([
					`var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: ${RuntimeGlobals.require***REMOVED*** ***REMOVED***;`,
					`${RuntimeGlobals.interceptModuleExecution***REMOVED***.forEach(function(handler) { handler(execOptions); ***REMOVED***);`,
					"module = execOptions.module;",
					"execOptions.factory.call(module.exports, module, module.exports, execOptions.require);"
				])
			: runtimeRequirements.has(RuntimeGlobals.thisAsExports)
				? Template.asString([
						`__webpack_modules__[moduleId].call(module.exports, module, module.exports, ${RuntimeGlobals.require***REMOVED***);`
					])
				: Template.asString([
						`__webpack_modules__[moduleId](module, module.exports, ${RuntimeGlobals.require***REMOVED***);`
					]);
		const needModuleId = runtimeRequirements.has(RuntimeGlobals.moduleId);
		const needModuleLoaded = runtimeRequirements.has(
			RuntimeGlobals.moduleLoaded
		);
		const content = Template.asString([
			"// Check if module is in cache",
			"var cachedModule = __webpack_module_cache__[moduleId];",
			"if (cachedModule !== undefined) {",
			outputOptions.strictModuleErrorHandling
				? Template.indent([
						"if (cachedModule.error !== undefined) throw cachedModule.error;",
						"return cachedModule.exports;"
					])
				: Template.indent("return cachedModule.exports;"),
			"***REMOVED***",
			"// Create a new module (and put it into the cache)",
			"var module = __webpack_module_cache__[moduleId] = {",
			Template.indent([
				needModuleId ? "id: moduleId," : "// no module.id needed",
				needModuleLoaded ? "loaded: false," : "// no module.loaded needed",
				"exports: {***REMOVED***"
			]),
			"***REMOVED***;",
			"",
			outputOptions.strictModuleExceptionHandling
				? Template.asString([
						"// Execute the module function",
						"var threw = true;",
						"try {",
						Template.indent([moduleExecution, "threw = false;"]),
						"***REMOVED*** finally {",
						Template.indent([
							"if(threw) delete __webpack_module_cache__[moduleId];"
						]),
						"***REMOVED***"
					])
				: outputOptions.strictModuleErrorHandling
					? Template.asString([
							"// Execute the module function",
							"try {",
							Template.indent(moduleExecution),
							"***REMOVED*** catch(e) {",
							Template.indent(["module.error = e;", "throw e;"]),
							"***REMOVED***"
						])
					: Template.asString([
							"// Execute the module function",
							moduleExecution
						]),
			needModuleLoaded
				? Template.asString([
						"",
						"// Flag the module as loaded",
						`${RuntimeGlobals.moduleLoaded***REMOVED*** = true;`,
						""
					])
				: "",
			"// Return the exports of the module",
			"return module.exports;"
		]);
		return tryRunOrWebpackError(
			() => hooks.renderRequire.call(content, renderContext),
			"JavascriptModulesPlugin.getCompilationHooks().renderRequire"
		);
	***REMOVED***

	/**
	 * @param {Module[]***REMOVED*** allModules allModules
	 * @param {MainRenderContext***REMOVED*** renderContext renderContext
	 * @param {Set<Module>***REMOVED*** inlinedModules inlinedModules
	 * @param {ChunkRenderContext***REMOVED*** chunkRenderContext chunkRenderContext
	 * @param {CompilationHooks***REMOVED*** hooks hooks
	 * @param {boolean | undefined***REMOVED*** allStrict allStrict
	 * @param {boolean***REMOVED*** hasChunkModules hasChunkModules
	 * @returns {Map<Module, Source> | false***REMOVED*** renamed inlined modules
	 */
	getRenamedInlineModule(
		allModules,
		renderContext,
		inlinedModules,
		chunkRenderContext,
		hooks,
		allStrict,
		hasChunkModules
	) {
		const innerStrict =
			!allStrict &&
			allModules.every(m => /** @type {BuildInfo***REMOVED*** */ (m.buildInfo).strict);
		const isMultipleEntries = inlinedModules.size > 1;
		const singleEntryWithModules = inlinedModules.size === 1 && hasChunkModules;

		// TODO:
		// This step is before the IIFE reason calculation. Ideally, it should only be executed when this function can optimize the
		// IIFE reason. Otherwise, it should directly return false. There are four reasons now, we have skipped two already, the left
		// one is 'it uses a non-standard name for the exports'.
		if (isMultipleEntries || innerStrict || !singleEntryWithModules) {
			return false;
		***REMOVED***

		/** @type {Map<Module, Source>***REMOVED*** */
		const renamedInlinedModules = new Map();
		const { runtimeTemplate ***REMOVED*** = renderContext;

		/** @typedef {{ source: Source, module: Module, ast: Program, variables: Set<Variable>, through: Set<Reference>, usedInNonInlined: Set<Variable>, moduleScope: Scope ***REMOVED******REMOVED*** Info */
		/** @type {Map<Module, Info>***REMOVED*** */
		const inlinedModulesToInfo = new Map();
		/** @type {Set<string>***REMOVED*** */
		const nonInlinedModuleThroughIdentifiers = new Set();
		/** @type {Map<Module, Source>***REMOVED*** */

		for (const m of allModules) {
			const isInlinedModule = inlinedModules && inlinedModules.has(m);
			const moduleSource = this.renderModule(
				m,
				chunkRenderContext,
				hooks,
				!isInlinedModule
			);

			if (!moduleSource) continue;
			const code = /** @type {string***REMOVED*** */ (moduleSource.source());
			const ast = JavascriptParser._parse(code, {
				sourceType: "auto"
			***REMOVED***);

			const scopeManager = eslintScope.analyze(ast, {
				ecmaVersion: 6,
				sourceType: "module",
				optimistic: true,
				ignoreEval: true
			***REMOVED***);

			const globalScope = /** @type {Scope***REMOVED*** */ (scopeManager.acquire(ast));
			if (inlinedModules && inlinedModules.has(m)) {
				const moduleScope = globalScope.childScopes[0];
				inlinedModulesToInfo.set(m, {
					source: moduleSource,
					ast,
					module: m,
					variables: new Set(moduleScope.variables),
					through: new Set(moduleScope.through),
					usedInNonInlined: new Set(),
					moduleScope
				***REMOVED***);
			***REMOVED*** else {
				for (const ref of globalScope.through) {
					nonInlinedModuleThroughIdentifiers.add(ref.identifier.name);
				***REMOVED***
			***REMOVED***
		***REMOVED***

		for (const [, { variables, usedInNonInlined ***REMOVED***] of inlinedModulesToInfo) {
			for (const variable of variables) {
				if (
					nonInlinedModuleThroughIdentifiers.has(variable.name) ||
					RESERVED_NAMES.has(variable.name)
				) {
					usedInNonInlined.add(variable);
				***REMOVED***
			***REMOVED***
		***REMOVED***

		for (const [m, moduleInfo] of inlinedModulesToInfo) {
			const { ast, source: _source, usedInNonInlined ***REMOVED*** = moduleInfo;
			const source = new ReplaceSource(_source);
			if (usedInNonInlined.size === 0) {
				renamedInlinedModules.set(m, source);
				continue;
			***REMOVED***

			const info = /** @type {Info***REMOVED*** */ (inlinedModulesToInfo.get(m));
			const allUsedNames = new Set(
				Array.from(info.through, v => v.identifier.name)
			);

			for (const variable of usedInNonInlined) {
				allUsedNames.add(variable.name);
			***REMOVED***

			for (const variable of info.variables) {
				const usedNamesInScopeInfo = new Map();
				const ignoredScopes = new Set();

				const name = variable.name;
				const { usedNames, alreadyCheckedScopes ***REMOVED*** = getUsedNamesInScopeInfo(
					usedNamesInScopeInfo,
					info.module.identifier(),
					name
				);

				if (allUsedNames.has(name) || usedNames.has(name)) {
					const references = getAllReferences(variable);
					const allIdentifiers = new Set(
						references.map(r => r.identifier).concat(variable.identifiers)
					);
					for (const ref of references) {
						addScopeSymbols(
							ref.from,
							usedNames,
							alreadyCheckedScopes,
							ignoredScopes
						);
					***REMOVED***

					const newName = findNewName(
						variable.name,
						allUsedNames,
						usedNames,
						m.readableIdentifier(runtimeTemplate.requestShortener)
					);
					allUsedNames.add(newName);
					for (const identifier of allIdentifiers) {
						const r = /** @type {Range***REMOVED*** */ (identifier.range);
						const path = getPathInAst(ast, identifier);
						if (path && path.length > 1) {
							const maybeProperty =
								path[1].type === "AssignmentPattern" && path[1].left === path[0]
									? path[2]
									: path[1];
							if (
								maybeProperty.type === "Property" &&
								maybeProperty.shorthand
							) {
								source.insert(r[1], `: ${newName***REMOVED***`);
								continue;
							***REMOVED***
						***REMOVED***
						source.replace(r[0], r[1] - 1, newName);
					***REMOVED***
				***REMOVED***
				allUsedNames.add(name);
			***REMOVED***

			renamedInlinedModules.set(m, source);
		***REMOVED***

		return renamedInlinedModules;
	***REMOVED***
***REMOVED***

module.exports = JavascriptModulesPlugin;
module.exports.chunkHasJs = chunkHasJs;
