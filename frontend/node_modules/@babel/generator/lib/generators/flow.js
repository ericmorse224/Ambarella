"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.AnyTypeAnnotation = AnyTypeAnnotation;
exports.ArrayTypeAnnotation = ArrayTypeAnnotation;
exports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
exports.BooleanTypeAnnotation = BooleanTypeAnnotation;
exports.DeclareClass = DeclareClass;
exports.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
exports.DeclareExportDeclaration = DeclareExportDeclaration;
exports.DeclareFunction = DeclareFunction;
exports.DeclareInterface = DeclareInterface;
exports.DeclareModule = DeclareModule;
exports.DeclareModuleExports = DeclareModuleExports;
exports.DeclareOpaqueType = DeclareOpaqueType;
exports.DeclareTypeAlias = DeclareTypeAlias;
exports.DeclareVariable = DeclareVariable;
exports.DeclaredPredicate = DeclaredPredicate;
exports.EmptyTypeAnnotation = EmptyTypeAnnotation;
exports.EnumBooleanBody = EnumBooleanBody;
exports.EnumBooleanMember = EnumBooleanMember;
exports.EnumDeclaration = EnumDeclaration;
exports.EnumDefaultedMember = EnumDefaultedMember;
exports.EnumNumberBody = EnumNumberBody;
exports.EnumNumberMember = EnumNumberMember;
exports.EnumStringBody = EnumStringBody;
exports.EnumStringMember = EnumStringMember;
exports.EnumSymbolBody = EnumSymbolBody;
exports.ExistsTypeAnnotation = ExistsTypeAnnotation;
exports.FunctionTypeAnnotation = FunctionTypeAnnotation;
exports.FunctionTypeParam = FunctionTypeParam;
exports.IndexedAccessType = IndexedAccessType;
exports.InferredPredicate = InferredPredicate;
exports.InterfaceDeclaration = InterfaceDeclaration;
exports.GenericTypeAnnotation = exports.ClassImplements = exports.InterfaceExtends = InterfaceExtends;
exports.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
exports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
exports.MixedTypeAnnotation = MixedTypeAnnotation;
exports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
exports.NullableTypeAnnotation = NullableTypeAnnotation;
Object.defineProperty(exports, "NumberLiteralTypeAnnotation", {
  enumerable: true,
  get: function () {
    return _types2.NumericLiteral;
  ***REMOVED***
***REMOVED***);
exports.NumberTypeAnnotation = NumberTypeAnnotation;
exports.ObjectTypeAnnotation = ObjectTypeAnnotation;
exports.ObjectTypeCallProperty = ObjectTypeCallProperty;
exports.ObjectTypeIndexer = ObjectTypeIndexer;
exports.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
exports.ObjectTypeProperty = ObjectTypeProperty;
exports.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
exports.OpaqueType = OpaqueType;
exports.OptionalIndexedAccessType = OptionalIndexedAccessType;
exports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
Object.defineProperty(exports, "StringLiteralTypeAnnotation", {
  enumerable: true,
  get: function () {
    return _types2.StringLiteral;
  ***REMOVED***
***REMOVED***);
exports.StringTypeAnnotation = StringTypeAnnotation;
exports.SymbolTypeAnnotation = SymbolTypeAnnotation;
exports.ThisTypeAnnotation = ThisTypeAnnotation;
exports.TupleTypeAnnotation = TupleTypeAnnotation;
exports.TypeAlias = TypeAlias;
exports.TypeAnnotation = TypeAnnotation;
exports.TypeCastExpression = TypeCastExpression;
exports.TypeParameter = TypeParameter;
exports.TypeParameterDeclaration = exports.TypeParameterInstantiation = TypeParameterInstantiation;
exports.TypeofTypeAnnotation = TypeofTypeAnnotation;
exports.UnionTypeAnnotation = UnionTypeAnnotation;
exports.Variance = Variance;
exports.VoidTypeAnnotation = VoidTypeAnnotation;
exports._interfaceish = _interfaceish;
exports._variance = _variance;
var _t = require("@babel/types");
var _modules = require("./modules.js");
var _index = require("../node/index.js");
var _types2 = require("./types.js");
const {
  isDeclareExportDeclaration,
  isStatement
***REMOVED*** = _t;
function AnyTypeAnnotation() {
  this.word("any");
***REMOVED***
function ArrayTypeAnnotation(node) {
  this.print(node.elementType, true);
  this.tokenChar(91);
  this.tokenChar(93);
***REMOVED***
function BooleanTypeAnnotation() {
  this.word("boolean");
***REMOVED***
function BooleanLiteralTypeAnnotation(node) {
  this.word(node.value ? "true" : "false");
***REMOVED***
function NullLiteralTypeAnnotation() {
  this.word("null");
***REMOVED***
function DeclareClass(node, parent) {
  if (!isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  ***REMOVED***
  this.word("class");
  this.space();
  this._interfaceish(node);
***REMOVED***
function DeclareFunction(node, parent) {
  if (!isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  ***REMOVED***
  this.word("function");
  this.space();
  this.print(node.id);
  this.print(node.id.typeAnnotation.typeAnnotation);
  if (node.predicate) {
    this.space();
    this.print(node.predicate);
  ***REMOVED***
  this.semicolon();
***REMOVED***
function InferredPredicate() {
  this.tokenChar(37);
  this.word("checks");
***REMOVED***
function DeclaredPredicate(node) {
  this.tokenChar(37);
  this.word("checks");
  this.tokenChar(40);
  this.print(node.value);
  this.tokenChar(41);
***REMOVED***
function DeclareInterface(node) {
  this.word("declare");
  this.space();
  this.InterfaceDeclaration(node);
***REMOVED***
function DeclareModule(node) {
  this.word("declare");
  this.space();
  this.word("module");
  this.space();
  this.print(node.id);
  this.space();
  this.print(node.body);
***REMOVED***
function DeclareModuleExports(node) {
  this.word("declare");
  this.space();
  this.word("module");
  this.tokenChar(46);
  this.word("exports");
  this.print(node.typeAnnotation);
***REMOVED***
function DeclareTypeAlias(node) {
  this.word("declare");
  this.space();
  this.TypeAlias(node);
***REMOVED***
function DeclareOpaqueType(node, parent) {
  if (!isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  ***REMOVED***
  this.OpaqueType(node);
***REMOVED***
function DeclareVariable(node, parent) {
  if (!isDeclareExportDeclaration(parent)) {
    this.word("declare");
    this.space();
  ***REMOVED***
  this.word("var");
  this.space();
  this.print(node.id);
  this.print(node.id.typeAnnotation);
  this.semicolon();
***REMOVED***
function DeclareExportDeclaration(node) {
  this.word("declare");
  this.space();
  this.word("export");
  this.space();
  if (node.default) {
    this.word("default");
    this.space();
  ***REMOVED***
  FlowExportDeclaration.call(this, node);
***REMOVED***
function DeclareExportAllDeclaration(node) {
  this.word("declare");
  this.space();
  _modules.ExportAllDeclaration.call(this, node);
***REMOVED***
function EnumDeclaration(node) {
  const {
    id,
    body
  ***REMOVED*** = node;
  this.word("enum");
  this.space();
  this.print(id);
  this.print(body);
***REMOVED***
function enumExplicitType(context, name, hasExplicitType) {
  if (hasExplicitType) {
    context.space();
    context.word("of");
    context.space();
    context.word(name);
  ***REMOVED***
  context.space();
***REMOVED***
function enumBody(context, node) {
  const {
    members
  ***REMOVED*** = node;
  context.token("{");
  context.indent();
  context.newline();
  for (const member of members) {
    context.print(member);
    context.newline();
  ***REMOVED***
  if (node.hasUnknownMembers) {
    context.token("...");
    context.newline();
  ***REMOVED***
  context.dedent();
  context.token("***REMOVED***");
***REMOVED***
function EnumBooleanBody(node) {
  const {
    explicitType
  ***REMOVED*** = node;
  enumExplicitType(this, "boolean", explicitType);
  enumBody(this, node);
***REMOVED***
function EnumNumberBody(node) {
  const {
    explicitType
  ***REMOVED*** = node;
  enumExplicitType(this, "number", explicitType);
  enumBody(this, node);
***REMOVED***
function EnumStringBody(node) {
  const {
    explicitType
  ***REMOVED*** = node;
  enumExplicitType(this, "string", explicitType);
  enumBody(this, node);
***REMOVED***
function EnumSymbolBody(node) {
  enumExplicitType(this, "symbol", true);
  enumBody(this, node);
***REMOVED***
function EnumDefaultedMember(node) {
  const {
    id
  ***REMOVED*** = node;
  this.print(id);
  this.tokenChar(44);
***REMOVED***
function enumInitializedMember(context, node) {
  context.print(node.id);
  context.space();
  context.token("=");
  context.space();
  context.print(node.init);
  context.token(",");
***REMOVED***
function EnumBooleanMember(node) {
  enumInitializedMember(this, node);
***REMOVED***
function EnumNumberMember(node) {
  enumInitializedMember(this, node);
***REMOVED***
function EnumStringMember(node) {
  enumInitializedMember(this, node);
***REMOVED***
function FlowExportDeclaration(node) {
  if (node.declaration) {
    const declar = node.declaration;
    this.print(declar);
    if (!isStatement(declar)) this.semicolon();
  ***REMOVED*** else {
    this.tokenChar(123);
    if (node.specifiers.length) {
      this.space();
      this.printList(node.specifiers);
      this.space();
    ***REMOVED***
    this.tokenChar(125);
    if (node.source) {
      this.space();
      this.word("from");
      this.space();
      this.print(node.source);
    ***REMOVED***
    this.semicolon();
  ***REMOVED***
***REMOVED***
function ExistsTypeAnnotation() {
  this.tokenChar(42);
***REMOVED***
function FunctionTypeAnnotation(node, parent) {
  this.print(node.typeParameters);
  this.tokenChar(40);
  if (node.this) {
    this.word("this");
    this.tokenChar(58);
    this.space();
    this.print(node.this.typeAnnotation);
    if (node.params.length || node.rest) {
      this.tokenChar(44);
      this.space();
    ***REMOVED***
  ***REMOVED***
  this.printList(node.params);
  if (node.rest) {
    if (node.params.length) {
      this.tokenChar(44);
      this.space();
    ***REMOVED***
    this.token("...");
    this.print(node.rest);
  ***REMOVED***
  this.tokenChar(41);
  const type = parent == null ? void 0 : parent.type;
  if (type != null && (type === "ObjectTypeCallProperty" || type === "ObjectTypeInternalSlot" || type === "DeclareFunction" || type === "ObjectTypeProperty" && parent.method)) {
    this.tokenChar(58);
  ***REMOVED*** else {
    this.space();
    this.token("=>");
  ***REMOVED***
  this.space();
  this.print(node.returnType);
***REMOVED***
function FunctionTypeParam(node) {
  this.print(node.name);
  if (node.optional) this.tokenChar(63);
  if (node.name) {
    this.tokenChar(58);
    this.space();
  ***REMOVED***
  this.print(node.typeAnnotation);
***REMOVED***
function InterfaceExtends(node) {
  this.print(node.id);
  this.print(node.typeParameters, true);
***REMOVED***
function _interfaceish(node) {
  var _node$extends;
  this.print(node.id);
  this.print(node.typeParameters);
  if ((_node$extends = node.extends) != null && _node$extends.length) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(node.extends);
  ***REMOVED***
  if (node.type === "DeclareClass") {
    var _node$mixins, _node$implements;
    if ((_node$mixins = node.mixins) != null && _node$mixins.length) {
      this.space();
      this.word("mixins");
      this.space();
      this.printList(node.mixins);
    ***REMOVED***
    if ((_node$implements = node.implements) != null && _node$implements.length) {
      this.space();
      this.word("implements");
      this.space();
      this.printList(node.implements);
    ***REMOVED***
  ***REMOVED***
  this.space();
  this.print(node.body);
***REMOVED***
function _variance(node) {
  var _node$variance;
  const kind = (_node$variance = node.variance) == null ? void 0 : _node$variance.kind;
  if (kind != null) {
    if (kind === "plus") {
      this.tokenChar(43);
    ***REMOVED*** else if (kind === "minus") {
      this.tokenChar(45);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
function InterfaceDeclaration(node) {
  this.word("interface");
  this.space();
  this._interfaceish(node);
***REMOVED***
function andSeparator(occurrenceCount) {
  this.space();
  this.token("&", false, occurrenceCount);
  this.space();
***REMOVED***
function InterfaceTypeAnnotation(node) {
  var _node$extends2;
  this.word("interface");
  if ((_node$extends2 = node.extends) != null && _node$extends2.length) {
    this.space();
    this.word("extends");
    this.space();
    this.printList(node.extends);
  ***REMOVED***
  this.space();
  this.print(node.body);
***REMOVED***
function IntersectionTypeAnnotation(node) {
  this.printJoin(node.types, undefined, undefined, andSeparator);
***REMOVED***
function MixedTypeAnnotation() {
  this.word("mixed");
***REMOVED***
function EmptyTypeAnnotation() {
  this.word("empty");
***REMOVED***
function NullableTypeAnnotation(node) {
  this.tokenChar(63);
  this.print(node.typeAnnotation);
***REMOVED***
function NumberTypeAnnotation() {
  this.word("number");
***REMOVED***
function StringTypeAnnotation() {
  this.word("string");
***REMOVED***
function ThisTypeAnnotation() {
  this.word("this");
***REMOVED***
function TupleTypeAnnotation(node) {
  this.tokenChar(91);
  this.printList(node.types);
  this.tokenChar(93);
***REMOVED***
function TypeofTypeAnnotation(node) {
  this.word("typeof");
  this.space();
  this.print(node.argument);
***REMOVED***
function TypeAlias(node) {
  this.word("type");
  this.space();
  this.print(node.id);
  this.print(node.typeParameters);
  this.space();
  this.tokenChar(61);
  this.space();
  this.print(node.right);
  this.semicolon();
***REMOVED***
function TypeAnnotation(node, parent) {
  this.tokenChar(58);
  this.space();
  if (parent.type === "ArrowFunctionExpression") {
    this.tokenContext |= _index.TokenContext.arrowFlowReturnType;
  ***REMOVED*** else if (node.optional) {
    this.tokenChar(63);
  ***REMOVED***
  this.print(node.typeAnnotation);
***REMOVED***
function TypeParameterInstantiation(node) {
  this.tokenChar(60);
  this.printList(node.params);
  this.tokenChar(62);
***REMOVED***
function TypeParameter(node) {
  this._variance(node);
  this.word(node.name);
  if (node.bound) {
    this.print(node.bound);
  ***REMOVED***
  if (node.default) {
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.default);
  ***REMOVED***
***REMOVED***
function OpaqueType(node) {
  this.word("opaque");
  this.space();
  this.word("type");
  this.space();
  this.print(node.id);
  this.print(node.typeParameters);
  if (node.supertype) {
    this.tokenChar(58);
    this.space();
    this.print(node.supertype);
  ***REMOVED***
  if (node.impltype) {
    this.space();
    this.tokenChar(61);
    this.space();
    this.print(node.impltype);
  ***REMOVED***
  this.semicolon();
***REMOVED***
function ObjectTypeAnnotation(node) {
  if (node.exact) {
    this.token("{|");
  ***REMOVED*** else {
    this.tokenChar(123);
  ***REMOVED***
  const props = [...node.properties, ...(node.callProperties || []), ...(node.indexers || []), ...(node.internalSlots || [])];
  if (props.length) {
    this.newline();
    this.space();
    this.printJoin(props, true, true, undefined, undefined, function addNewlines(leading) {
      if (leading && !props[0]) return 1;
    ***REMOVED***, () => {
      if (props.length !== 1 || node.inexact) {
        this.tokenChar(44);
        this.space();
      ***REMOVED***
    ***REMOVED***);
    this.space();
  ***REMOVED***
  if (node.inexact) {
    this.indent();
    this.token("...");
    if (props.length) {
      this.newline();
    ***REMOVED***
    this.dedent();
  ***REMOVED***
  if (node.exact) {
    this.token("|***REMOVED***");
  ***REMOVED*** else {
    this.tokenChar(125);
  ***REMOVED***
***REMOVED***
function ObjectTypeInternalSlot(node) {
  if (node.static) {
    this.word("static");
    this.space();
  ***REMOVED***
  this.tokenChar(91);
  this.tokenChar(91);
  this.print(node.id);
  this.tokenChar(93);
  this.tokenChar(93);
  if (node.optional) this.tokenChar(63);
  if (!node.method) {
    this.tokenChar(58);
    this.space();
  ***REMOVED***
  this.print(node.value);
***REMOVED***
function ObjectTypeCallProperty(node) {
  if (node.static) {
    this.word("static");
    this.space();
  ***REMOVED***
  this.print(node.value);
***REMOVED***
function ObjectTypeIndexer(node) {
  if (node.static) {
    this.word("static");
    this.space();
  ***REMOVED***
  this._variance(node);
  this.tokenChar(91);
  if (node.id) {
    this.print(node.id);
    this.tokenChar(58);
    this.space();
  ***REMOVED***
  this.print(node.key);
  this.tokenChar(93);
  this.tokenChar(58);
  this.space();
  this.print(node.value);
***REMOVED***
function ObjectTypeProperty(node) {
  if (node.proto) {
    this.word("proto");
    this.space();
  ***REMOVED***
  if (node.static) {
    this.word("static");
    this.space();
  ***REMOVED***
  if (node.kind === "get" || node.kind === "set") {
    this.word(node.kind);
    this.space();
  ***REMOVED***
  this._variance(node);
  this.print(node.key);
  if (node.optional) this.tokenChar(63);
  if (!node.method) {
    this.tokenChar(58);
    this.space();
  ***REMOVED***
  this.print(node.value);
***REMOVED***
function ObjectTypeSpreadProperty(node) {
  this.token("...");
  this.print(node.argument);
***REMOVED***
function QualifiedTypeIdentifier(node) {
  this.print(node.qualification);
  this.tokenChar(46);
  this.print(node.id);
***REMOVED***
function SymbolTypeAnnotation() {
  this.word("symbol");
***REMOVED***
function orSeparator(occurrenceCount) {
  this.space();
  this.token("|", false, occurrenceCount);
  this.space();
***REMOVED***
function UnionTypeAnnotation(node) {
  this.printJoin(node.types, undefined, undefined, orSeparator);
***REMOVED***
function TypeCastExpression(node) {
  this.tokenChar(40);
  this.print(node.expression);
  this.print(node.typeAnnotation);
  this.tokenChar(41);
***REMOVED***
function Variance(node) {
  if (node.kind === "plus") {
    this.tokenChar(43);
  ***REMOVED*** else {
    this.tokenChar(45);
  ***REMOVED***
***REMOVED***
function VoidTypeAnnotation() {
  this.word("void");
***REMOVED***
function IndexedAccessType(node) {
  this.print(node.objectType, true);
  this.tokenChar(91);
  this.print(node.indexType);
  this.tokenChar(93);
***REMOVED***
function OptionalIndexedAccessType(node) {
  this.print(node.objectType);
  if (node.optional) {
    this.token("?.");
  ***REMOVED***
  this.tokenChar(91);
  this.print(node.indexType);
  this.tokenChar(93);
***REMOVED***

//# sourceMappingURL=flow.js.map
