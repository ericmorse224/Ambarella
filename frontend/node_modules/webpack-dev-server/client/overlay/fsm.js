function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; ***REMOVED***)), keys.push.apply(keys, symbols); ***REMOVED*** return keys; ***REMOVED***
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {***REMOVED***; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); ***REMOVED***) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); ***REMOVED***); ***REMOVED*** return target; ***REMOVED***
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true ***REMOVED***); ***REMOVED*** else { obj[key] = value; ***REMOVED*** return obj; ***REMOVED***
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); ***REMOVED***
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); ***REMOVED*** return (hint === "string" ? String : Number)(input); ***REMOVED***
/**
 * @typedef {Object***REMOVED*** StateDefinitions
 * @property {{[event: string]: { target: string; actions?: Array<string> ***REMOVED******REMOVED******REMOVED*** [on]
 */

/**
 * @typedef {Object***REMOVED*** Options
 * @property {{[state: string]: StateDefinitions***REMOVED******REMOVED*** states
 * @property {object***REMOVED*** context;
 * @property {string***REMOVED*** initial
 */

/**
 * @typedef {Object***REMOVED*** Implementation
 * @property {{[actionName: string]: (ctx: object, event: any) => object***REMOVED******REMOVED*** actions
 */

/**
 * A simplified `createMachine` from `@xstate/fsm` with the following differences:
 *
 *  - the returned machine is technically a "service". No `interpret(machine).start()` is needed.
 *  - the state definition only support `on` and target must be declared with { target: 'nextState', actions: [] ***REMOVED*** explicitly.
 *  - event passed to `send` must be an object with `type` property.
 *  - actions implementation will be [assign action](https://xstate.js.org/docs/guides/context.html#assign-action) if you return any value.
 *  Do not return anything if you just want to invoke side effect.
 *
 * The goal of this custom function is to avoid installing the entire `'xstate/fsm'` package, while enabling modeling using
 * state machine. You can copy the first parameter into the editor at https://stately.ai/viz to visualize the state machine.
 *
 * @param {Options***REMOVED*** options
 * @param {Implementation***REMOVED*** implementation
 */
function createMachine(_ref, _ref2) {
  var states = _ref.states,
    context = _ref.context,
    initial = _ref.initial;
  var actions = _ref2.actions;
  var currentState = initial;
  var currentContext = context;
  return {
    send: function send(event) {
      var currentStateOn = states[currentState].on;
      var transitionConfig = currentStateOn && currentStateOn[event.type];
      if (transitionConfig) {
        currentState = transitionConfig.target;
        if (transitionConfig.actions) {
          transitionConfig.actions.forEach(function (actName) {
            var actionImpl = actions[actName];
            var nextContextValue = actionImpl && actionImpl(currentContext, event);
            if (nextContextValue) {
              currentContext = _objectSpread(_objectSpread({***REMOVED***, currentContext), nextContextValue);
            ***REMOVED***
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;
***REMOVED***
export default createMachine;