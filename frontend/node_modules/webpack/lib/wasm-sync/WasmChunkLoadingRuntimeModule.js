/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/

"use strict";

const RuntimeGlobals = require("../RuntimeGlobals");
const RuntimeModule = require("../RuntimeModule");
const Template = require("../Template");
const { compareModulesByIdentifier ***REMOVED*** = require("../util/comparators");
const WebAssemblyUtils = require("./WebAssemblyUtils");

/** @typedef {import("@webassemblyjs/ast").Signature***REMOVED*** Signature */
/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../ChunkGraph").ModuleId***REMOVED*** ModuleId */
/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../Module").ReadOnlyRuntimeRequirements***REMOVED*** ReadOnlyRuntimeRequirements */
/** @typedef {import("../ModuleGraph")***REMOVED*** ModuleGraph */
/** @typedef {import("../util/runtime").RuntimeSpec***REMOVED*** RuntimeSpec */

// TODO webpack 6 remove the whole folder

// Get all wasm modules
/**
 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @param {Chunk***REMOVED*** chunk the chunk
 * @returns {Module[]***REMOVED*** all wasm modules
 */
const getAllWasmModules = (moduleGraph, chunkGraph, chunk) => {
	const wasmModules = chunk.getAllAsyncChunks();
	const array = [];
	for (const chunk of wasmModules) {
		for (const m of chunkGraph.getOrderedChunkModulesIterable(
			chunk,
			compareModulesByIdentifier
		)) {
			if (m.type.startsWith("webassembly")) {
				array.push(m);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	return array;
***REMOVED***;

/**
 * generates the import object function for a module
 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @param {Module***REMOVED*** module the module
 * @param {boolean | undefined***REMOVED*** mangle mangle imports
 * @param {string[]***REMOVED*** declarations array where declarations are pushed to
 * @param {RuntimeSpec***REMOVED*** runtime the runtime
 * @returns {string***REMOVED*** source code
 */
const generateImportObject = (
	chunkGraph,
	module,
	mangle,
	declarations,
	runtime
) => {
	const moduleGraph = chunkGraph.moduleGraph;
	/** @type {Map<string, string | number>***REMOVED*** */
	const waitForInstances = new Map();
	const properties = [];
	const usedWasmDependencies = WebAssemblyUtils.getUsedDependencies(
		moduleGraph,
		module,
		mangle
	);
	for (const usedDep of usedWasmDependencies) {
		const dep = usedDep.dependency;
		const importedModule = moduleGraph.getModule(dep);
		const exportName = dep.name;
		const usedName =
			importedModule &&
			moduleGraph
				.getExportsInfo(importedModule)
				.getUsedName(exportName, runtime);
		const description = dep.description;
		const direct = dep.onlyDirectImport;

		const module = usedDep.module;
		const name = usedDep.name;

		if (direct) {
			const instanceVar = `m${waitForInstances.size***REMOVED***`;
			waitForInstances.set(
				instanceVar,
				/** @type {ModuleId***REMOVED*** */
				(chunkGraph.getModuleId(/** @type {Module***REMOVED*** */ (importedModule)))
			);
			properties.push({
				module,
				name,
				value: `${instanceVar***REMOVED***[${JSON.stringify(usedName)***REMOVED***]`
			***REMOVED***);
		***REMOVED*** else {
			const params =
				/** @type {Signature***REMOVED*** */
				(description.signature).params.map(
					(param, k) => `p${k***REMOVED***${param.valtype***REMOVED***`
				);

			const mod = `${RuntimeGlobals.moduleCache***REMOVED***[${JSON.stringify(
				chunkGraph.getModuleId(/** @type {Module***REMOVED*** */ (importedModule))
			)***REMOVED***]`;
			const modExports = `${mod***REMOVED***.exports`;

			const cache = `wasmImportedFuncCache${declarations.length***REMOVED***`;
			declarations.push(`var ${cache***REMOVED***;`);

			const modCode =
				/** @type {Module***REMOVED*** */
				(importedModule).type.startsWith("webassembly")
					? `${mod***REMOVED*** ? ${modExports***REMOVED***[${JSON.stringify(usedName)***REMOVED***] : `
					: "";

			properties.push({
				module,
				name,
				value: Template.asString([
					`${modCode***REMOVED***function(${params***REMOVED***) {`,
					Template.indent([
						`if(${cache***REMOVED*** === undefined) ${cache***REMOVED*** = ${modExports***REMOVED***;`,
						`return ${cache***REMOVED***[${JSON.stringify(usedName)***REMOVED***](${params***REMOVED***);`
					]),
					"***REMOVED***"
				])
			***REMOVED***);
		***REMOVED***
	***REMOVED***

	let importObject;
	if (mangle) {
		importObject = [
			"return {",
			Template.indent([
				properties.map(p => `${JSON.stringify(p.name)***REMOVED***: ${p.value***REMOVED***`).join(",\n")
			]),
			"***REMOVED***;"
		];
	***REMOVED*** else {
		/** @type {Map<string, Array<{ name: string, value: string ***REMOVED***>>***REMOVED*** */
		const propertiesByModule = new Map();
		for (const p of properties) {
			let list = propertiesByModule.get(p.module);
			if (list === undefined) {
				propertiesByModule.set(p.module, (list = []));
			***REMOVED***
			list.push(p);
		***REMOVED***
		importObject = [
			"return {",
			Template.indent([
				Array.from(propertiesByModule, ([module, list]) =>
					Template.asString([
						`${JSON.stringify(module)***REMOVED***: {`,
						Template.indent([
							list.map(p => `${JSON.stringify(p.name)***REMOVED***: ${p.value***REMOVED***`).join(",\n")
						]),
						"***REMOVED***"
					])
				).join(",\n")
			]),
			"***REMOVED***;"
		];
	***REMOVED***

	const moduleIdStringified = JSON.stringify(chunkGraph.getModuleId(module));
	if (waitForInstances.size === 1) {
		const moduleId = Array.from(waitForInstances.values())[0];
		const promise = `installedWasmModules[${JSON.stringify(moduleId)***REMOVED***]`;
		const variable = Array.from(waitForInstances.keys())[0];
		return Template.asString([
			`${moduleIdStringified***REMOVED***: function() {`,
			Template.indent([
				`return promiseResolve().then(function() { return ${promise***REMOVED***; ***REMOVED***).then(function(${variable***REMOVED***) {`,
				Template.indent(importObject),
				"***REMOVED***);"
			]),
			"***REMOVED***,"
		]);
	***REMOVED*** else if (waitForInstances.size > 0) {
		const promises = Array.from(
			waitForInstances.values(),
			id => `installedWasmModules[${JSON.stringify(id)***REMOVED***]`
		).join(", ");
		const variables = Array.from(
			waitForInstances.keys(),
			(name, i) => `${name***REMOVED*** = array[${i***REMOVED***]`
		).join(", ");
		return Template.asString([
			`${moduleIdStringified***REMOVED***: function() {`,
			Template.indent([
				`return promiseResolve().then(function() { return Promise.all([${promises***REMOVED***]); ***REMOVED***).then(function(array) {`,
				Template.indent([`var ${variables***REMOVED***;`, ...importObject]),
				"***REMOVED***);"
			]),
			"***REMOVED***,"
		]);
	***REMOVED***
	return Template.asString([
		`${moduleIdStringified***REMOVED***: function() {`,
		Template.indent(importObject),
		"***REMOVED***,"
	]);
***REMOVED***;

/**
 * @typedef {object***REMOVED*** WasmChunkLoadingRuntimeModuleOptions
 * @property {(path: string) => string***REMOVED*** generateLoadBinaryCode
 * @property {boolean=***REMOVED*** supportsStreaming
 * @property {boolean=***REMOVED*** mangleImports
 * @property {ReadOnlyRuntimeRequirements***REMOVED*** runtimeRequirements
 */

class WasmChunkLoadingRuntimeModule extends RuntimeModule {
	/**
	 * @param {WasmChunkLoadingRuntimeModuleOptions***REMOVED*** options options
	 */
	constructor({
		generateLoadBinaryCode,
		supportsStreaming,
		mangleImports,
		runtimeRequirements
	***REMOVED***) {
		super("wasm chunk loading", RuntimeModule.STAGE_ATTACH);
		this.generateLoadBinaryCode = generateLoadBinaryCode;
		this.supportsStreaming = supportsStreaming;
		this.mangleImports = mangleImports;
		this._runtimeRequirements = runtimeRequirements;
	***REMOVED***

	/**
	 * @returns {string | null***REMOVED*** runtime code
	 */
	generate() {
		const fn = RuntimeGlobals.ensureChunkHandlers;
		const withHmr = this._runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadUpdateHandlers
		);
		const compilation = /** @type {Compilation***REMOVED*** */ (this.compilation);
		const { moduleGraph, outputOptions ***REMOVED*** = compilation;
		const chunkGraph = /** @type {ChunkGraph***REMOVED*** */ (this.chunkGraph);
		const chunk = /** @type {Chunk***REMOVED*** */ (this.chunk);
		const wasmModules = getAllWasmModules(moduleGraph, chunkGraph, chunk);
		const { mangleImports ***REMOVED*** = this;
		/** @type {string[]***REMOVED*** */
		const declarations = [];
		const importObjects = wasmModules.map(module =>
			generateImportObject(
				chunkGraph,
				module,
				mangleImports,
				declarations,
				chunk.runtime
			)
		);
		const chunkModuleIdMap = chunkGraph.getChunkModuleIdMap(chunk, m =>
			m.type.startsWith("webassembly")
		);
		/**
		 * @param {string***REMOVED*** content content
		 * @returns {string***REMOVED*** created import object
		 */
		const createImportObject = content =>
			mangleImports
				? `{ ${JSON.stringify(WebAssemblyUtils.MANGLED_MODULE)***REMOVED***: ${content***REMOVED*** ***REMOVED***`
				: content;
		const wasmModuleSrcPath = compilation.getPath(
			JSON.stringify(outputOptions.webassemblyModuleFilename),
			{
				hash: `" + ${RuntimeGlobals.getFullHash***REMOVED***() + "`,
				hashWithLength: length =>
					`" + ${RuntimeGlobals.getFullHash***REMOVED******REMOVED***().slice(0, ${length***REMOVED***) + "`,
				module: {
					id: '" + wasmModuleId + "',
					hash: `" + ${JSON.stringify(
						chunkGraph.getChunkModuleRenderedHashMap(chunk, m =>
							m.type.startsWith("webassembly")
						)
					)***REMOVED***[chunkId][wasmModuleId] + "`,
					hashWithLength(length) {
						return `" + ${JSON.stringify(
							chunkGraph.getChunkModuleRenderedHashMap(
								chunk,
								m => m.type.startsWith("webassembly"),
								length
							)
						)***REMOVED***[chunkId][wasmModuleId] + "`;
					***REMOVED***
				***REMOVED***,
				runtime: chunk.runtime
			***REMOVED***
		);

		const stateExpression = withHmr
			? `${RuntimeGlobals.hmrRuntimeStatePrefix***REMOVED***_wasm`
			: undefined;

		return Template.asString([
			"// object to store loaded and loading wasm modules",
			`var installedWasmModules = ${
				stateExpression ? `${stateExpression***REMOVED*** = ${stateExpression***REMOVED*** || ` : ""
			***REMOVED***{***REMOVED***;`,
			"",
			// This function is used to delay reading the installed wasm module promises
			// by a microtask. Sorting them doesn't help because there are edge cases where
			// sorting is not possible (modules splitted into different chunks).
			// So we not even trying and solve this by a microtask delay.
			"function promiseResolve() { return Promise.resolve(); ***REMOVED***",
			"",
			Template.asString(declarations),
			"var wasmImportObjects = {",
			Template.indent(importObjects),
			"***REMOVED***;",
			"",
			`var wasmModuleMap = ${JSON.stringify(
				chunkModuleIdMap,
				undefined,
				"\t"
			)***REMOVED***;`,
			"",
			"// object with all WebAssembly.instance exports",
			`${RuntimeGlobals.wasmInstances***REMOVED*** = {***REMOVED***;`,
			"",
			"// Fetch + compile chunk loading for webassembly",
			`${fn***REMOVED***.wasm = function(chunkId, promises) {`,
			Template.indent([
				"",
				"var wasmModules = wasmModuleMap[chunkId] || [];",
				"",
				"wasmModules.forEach(function(wasmModuleId, idx) {",
				Template.indent([
					"var installedWasmModuleData = installedWasmModules[wasmModuleId];",
					"",
					'// a Promise means "currently loading" or "already loaded".',
					"if(installedWasmModuleData)",
					Template.indent(["promises.push(installedWasmModuleData);"]),
					"else {",
					Template.indent([
						"var importObject = wasmImportObjects[wasmModuleId]();",
						`var req = ${this.generateLoadBinaryCode(wasmModuleSrcPath)***REMOVED***;`,
						"var promise;",
						this.supportsStreaming
							? Template.asString([
									"if(importObject && typeof importObject.then === 'function' && typeof WebAssembly.compileStreaming === 'function') {",
									Template.indent([
										"promise = Promise.all([WebAssembly.compileStreaming(req), importObject]).then(function(items) {",
										Template.indent([
											`return WebAssembly.instantiate(items[0], ${createImportObject(
												"items[1]"
											)***REMOVED***);`
										]),
										"***REMOVED***);"
									]),
									"***REMOVED*** else if(typeof WebAssembly.instantiateStreaming === 'function') {",
									Template.indent([
										`promise = WebAssembly.instantiateStreaming(req, ${createImportObject(
											"importObject"
										)***REMOVED***);`
									])
								])
							: Template.asString([
									"if(importObject && typeof importObject.then === 'function') {",
									Template.indent([
										"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); ***REMOVED***);",
										"promise = Promise.all([",
										Template.indent([
											"bytesPromise.then(function(bytes) { return WebAssembly.compile(bytes); ***REMOVED***),",
											"importObject"
										]),
										"]).then(function(items) {",
										Template.indent([
											`return WebAssembly.instantiate(items[0], ${createImportObject(
												"items[1]"
											)***REMOVED***);`
										]),
										"***REMOVED***);"
									])
								]),
						"***REMOVED*** else {",
						Template.indent([
							"var bytesPromise = req.then(function(x) { return x.arrayBuffer(); ***REMOVED***);",
							"promise = bytesPromise.then(function(bytes) {",
							Template.indent([
								`return WebAssembly.instantiate(bytes, ${createImportObject(
									"importObject"
								)***REMOVED***);`
							]),
							"***REMOVED***);"
						]),
						"***REMOVED***",
						"promises.push(installedWasmModules[wasmModuleId] = promise.then(function(res) {",
						Template.indent([
							`return ${RuntimeGlobals.wasmInstances***REMOVED***[wasmModuleId] = (res.instance || res).exports;`
						]),
						"***REMOVED***));"
					]),
					"***REMOVED***"
				]),
				"***REMOVED***);"
			]),
			"***REMOVED***;"
		]);
	***REMOVED***
***REMOVED***

module.exports = WasmChunkLoadingRuntimeModule;
