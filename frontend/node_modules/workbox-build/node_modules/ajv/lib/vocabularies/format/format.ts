import type {
  AddedFormat,
  FormatValidator,
  AsyncFormatValidator,
  CodeKeywordDefinition,
  KeywordErrorDefinition,
  ErrorObject,
***REMOVED*** from "../../types"
import type {KeywordCxt***REMOVED*** from "../../compile/validate"
import {_, str, nil, or, Code, getProperty, regexpCode***REMOVED*** from "../../compile/codegen"

type FormatValidate =
  | FormatValidator<string>
  | FormatValidator<number>
  | AsyncFormatValidator<string>
  | AsyncFormatValidator<number>
  | RegExp
  | string
  | true

export type FormatError = ErrorObject<"format", {format: string***REMOVED***, string | {$data: string***REMOVED***>

const error: KeywordErrorDefinition = {
  message: ({schemaCode***REMOVED***) => str`must match format "${schemaCode***REMOVED***"`,
  params: ({schemaCode***REMOVED***) => _`{format: ${schemaCode***REMOVED******REMOVED***`,
***REMOVED***

const def: CodeKeywordDefinition = {
  keyword: "format",
  type: ["number", "string"],
  schemaType: "string",
  $data: true,
  error,
  code(cxt: KeywordCxt, ruleType?: string) {
    const {gen, data, $data, schema, schemaCode, it***REMOVED*** = cxt
    const {opts, errSchemaPath, schemaEnv, self***REMOVED*** = it
    if (!opts.validateFormats) return

    if ($data) validate$DataFormat()
    else validateFormat()

    function validate$DataFormat(): void {
      const fmts = gen.scopeValue("formats", {
        ref: self.formats,
        code: opts.code.formats,
      ***REMOVED***)
      const fDef = gen.const("fDef", _`${fmts***REMOVED***[${schemaCode***REMOVED***]`)
      const fType = gen.let("fType")
      const format = gen.let("format")
      // TODO simplify
      gen.if(
        _`typeof ${fDef***REMOVED*** == "object" && !(${fDef***REMOVED*** instanceof RegExp)`,
        () => gen.assign(fType, _`${fDef***REMOVED***.type || "string"`).assign(format, _`${fDef***REMOVED***.validate`),
        () => gen.assign(fType, _`"string"`).assign(format, fDef)
      )
      cxt.fail$data(or(unknownFmt(), invalidFmt()))

      function unknownFmt(): Code {
        if (opts.strictSchema === false) return nil
        return _`${schemaCode***REMOVED*** && !${format***REMOVED***`
      ***REMOVED***

      function invalidFmt(): Code {
        const callFormat = schemaEnv.$async
          ? _`(${fDef***REMOVED***.async ? await ${format***REMOVED***(${data***REMOVED***) : ${format***REMOVED***(${data***REMOVED***))`
          : _`${format***REMOVED***(${data***REMOVED***)`
        const validData = _`(typeof ${format***REMOVED*** == "function" ? ${callFormat***REMOVED*** : ${format***REMOVED***.test(${data***REMOVED***))`
        return _`${format***REMOVED*** && ${format***REMOVED*** !== true && ${fType***REMOVED*** === ${ruleType***REMOVED*** && !${validData***REMOVED***`
      ***REMOVED***
    ***REMOVED***

    function validateFormat(): void {
      const formatDef: AddedFormat | undefined = self.formats[schema]
      if (!formatDef) {
        unknownFormat()
        return
      ***REMOVED***
      if (formatDef === true) return
      const [fmtType, format, fmtRef] = getFormat(formatDef)
      if (fmtType === ruleType) cxt.pass(validCondition())

      function unknownFormat(): void {
        if (opts.strictSchema === false) {
          self.logger.warn(unknownMsg())
          return
        ***REMOVED***
        throw new Error(unknownMsg())

        function unknownMsg(): string {
          return `unknown format "${schema as string***REMOVED***" ignored in schema at path "${errSchemaPath***REMOVED***"`
        ***REMOVED***
      ***REMOVED***

      function getFormat(fmtDef: AddedFormat): [string, FormatValidate, Code] {
        const code =
          fmtDef instanceof RegExp
            ? regexpCode(fmtDef)
            : opts.code.formats
            ? _`${opts.code.formats***REMOVED***${getProperty(schema)***REMOVED***`
            : undefined
        const fmt = gen.scopeValue("formats", {key: schema, ref: fmtDef, code***REMOVED***)
        if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
          return [fmtDef.type || "string", fmtDef.validate, _`${fmt***REMOVED***.validate`]
        ***REMOVED***

        return ["string", fmtDef, fmt]
      ***REMOVED***

      function validCondition(): Code {
        if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
          if (!schemaEnv.$async) throw new Error("async format in sync schema")
          return _`await ${fmtRef***REMOVED***(${data***REMOVED***)`
        ***REMOVED***
        return typeof format == "function" ? _`${fmtRef***REMOVED***(${data***REMOVED***)` : _`${fmtRef***REMOVED***.test(${data***REMOVED***)`
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***,
***REMOVED***

export default def
