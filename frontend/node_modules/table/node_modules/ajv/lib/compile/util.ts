import type {AnySchema, EvaluatedProperties, EvaluatedItems***REMOVED*** from "../types"
import type {SchemaCxt, SchemaObjCxt***REMOVED*** from "."
import {_, getProperty, Code, Name, CodeGen***REMOVED*** from "./codegen"
import {_Code***REMOVED*** from "./codegen/code"
import type {Rule, ValidationRules***REMOVED*** from "./rules"

// TODO refactor to use Set
export function toHash<T extends string = string>(arr: T[]): {[K in T]?: true***REMOVED*** {
  const hash: {[K in T]?: true***REMOVED*** = {***REMOVED***
  for (const item of arr) hash[item] = true
  return hash
***REMOVED***

export function alwaysValidSchema(it: SchemaCxt, schema: AnySchema): boolean | void {
  if (typeof schema == "boolean") return schema
  if (Object.keys(schema).length === 0) return true
  checkUnknownRules(it, schema)
  return !schemaHasRules(schema, it.self.RULES.all)
***REMOVED***

export function checkUnknownRules(it: SchemaCxt, schema: AnySchema = it.schema): void {
  const {opts, self***REMOVED*** = it
  if (!opts.strictSchema) return
  if (typeof schema === "boolean") return
  const rules = self.RULES.keywords
  for (const key in schema) {
    if (!rules[key]) checkStrictMode(it, `unknown keyword: "${key***REMOVED***"`)
  ***REMOVED***
***REMOVED***

export function schemaHasRules(
  schema: AnySchema,
  rules: {[Key in string]?: boolean | Rule***REMOVED***
): boolean {
  if (typeof schema == "boolean") return !schema
  for (const key in schema) if (rules[key]) return true
  return false
***REMOVED***

export function schemaHasRulesButRef(schema: AnySchema, RULES: ValidationRules): boolean {
  if (typeof schema == "boolean") return !schema
  for (const key in schema) if (key !== "$ref" && RULES.all[key]) return true
  return false
***REMOVED***

export function schemaRefOrVal(
  {topSchemaRef, schemaPath***REMOVED***: SchemaObjCxt,
  schema: unknown,
  keyword: string,
  $data?: string | false
): Code | number | boolean {
  if (!$data) {
    if (typeof schema == "number" || typeof schema == "boolean") return schema
    if (typeof schema == "string") return _`${schema***REMOVED***`
  ***REMOVED***
  return _`${topSchemaRef***REMOVED***${schemaPath***REMOVED***${getProperty(keyword)***REMOVED***`
***REMOVED***

export function unescapeFragment(str: string): string {
  return unescapeJsonPointer(decodeURIComponent(str))
***REMOVED***

export function escapeFragment(str: string | number): string {
  return encodeURIComponent(escapeJsonPointer(str))
***REMOVED***

export function escapeJsonPointer(str: string | number): string {
  if (typeof str == "number") return `${str***REMOVED***`
  return str.replace(/~/g, "~0").replace(/\//g, "~1")
***REMOVED***

export function unescapeJsonPointer(str: string): string {
  return str.replace(/~1/g, "/").replace(/~0/g, "~")
***REMOVED***

export function eachItem<T>(xs: T | T[], f: (x: T) => void): void {
  if (Array.isArray(xs)) {
    for (const x of xs) f(x)
  ***REMOVED*** else {
    f(xs)
  ***REMOVED***
***REMOVED***

type SomeEvaluated = EvaluatedProperties | EvaluatedItems

type MergeEvaluatedFunc<T extends SomeEvaluated> = (
  gen: CodeGen,
  from: Name | T,
  to: Name | Exclude<T, true> | undefined,
  toName?: typeof Name
) => Name | T

interface MakeMergeFuncArgs<T extends SomeEvaluated> {
  mergeNames: (gen: CodeGen, from: Name, to: Name) => void
  mergeToName: (gen: CodeGen, from: T, to: Name) => void
  mergeValues: (from: T, to: Exclude<T, true>) => T
  resultToName: (gen: CodeGen, res?: T) => Name
***REMOVED***

function makeMergeEvaluated<T extends SomeEvaluated>({
  mergeNames,
  mergeToName,
  mergeValues,
  resultToName,
***REMOVED***: MakeMergeFuncArgs<T>): MergeEvaluatedFunc<T> {
  return (gen, from, to, toName) => {
    const res =
      to === undefined
        ? from
        : to instanceof Name
        ? (from instanceof Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to)
        : from instanceof Name
        ? (mergeToName(gen, to, from), from)
        : mergeValues(from, to)
    return toName === Name && !(res instanceof Name) ? resultToName(gen, res) : res
  ***REMOVED***
***REMOVED***

interface MergeEvaluated {
  props: MergeEvaluatedFunc<EvaluatedProperties>
  items: MergeEvaluatedFunc<EvaluatedItems>
***REMOVED***

export const mergeEvaluated: MergeEvaluated = {
  props: makeMergeEvaluated({
    mergeNames: (gen, from, to) =>
      gen.if(_`${to***REMOVED*** !== true && ${from***REMOVED*** !== undefined`, () => {
        gen.if(
          _`${from***REMOVED*** === true`,
          () => gen.assign(to, true),
          () => gen.assign(to, _`${to***REMOVED*** || {***REMOVED***`).code(_`Object.assign(${to***REMOVED***, ${from***REMOVED***)`)
        )
      ***REMOVED***),
    mergeToName: (gen, from, to) =>
      gen.if(_`${to***REMOVED*** !== true`, () => {
        if (from === true) {
          gen.assign(to, true)
        ***REMOVED*** else {
          gen.assign(to, _`${to***REMOVED*** || {***REMOVED***`)
          setEvaluated(gen, to, from)
        ***REMOVED***
      ***REMOVED***),
    mergeValues: (from, to) => (from === true ? true : {...from, ...to***REMOVED***),
    resultToName: evaluatedPropsToName,
  ***REMOVED***),
  items: makeMergeEvaluated({
    mergeNames: (gen, from, to) =>
      gen.if(_`${to***REMOVED*** !== true && ${from***REMOVED*** !== undefined`, () =>
        gen.assign(to, _`${from***REMOVED*** === true ? true : ${to***REMOVED*** > ${from***REMOVED*** ? ${to***REMOVED*** : ${from***REMOVED***`)
      ),
    mergeToName: (gen, from, to) =>
      gen.if(_`${to***REMOVED*** !== true`, () =>
        gen.assign(to, from === true ? true : _`${to***REMOVED*** > ${from***REMOVED*** ? ${to***REMOVED*** : ${from***REMOVED***`)
      ),
    mergeValues: (from, to) => (from === true ? true : Math.max(from, to)),
    resultToName: (gen, items) => gen.var("items", items),
  ***REMOVED***),
***REMOVED***

export function evaluatedPropsToName(gen: CodeGen, ps?: EvaluatedProperties): Name {
  if (ps === true) return gen.var("props", true)
  const props = gen.var("props", _`{***REMOVED***`)
  if (ps !== undefined) setEvaluated(gen, props, ps)
  return props
***REMOVED***

export function setEvaluated(gen: CodeGen, props: Name, ps: {[K in string]?: true***REMOVED***): void {
  Object.keys(ps).forEach((p) => gen.assign(_`${props***REMOVED***${getProperty(p)***REMOVED***`, true))
***REMOVED***

const snippets: {[S in string]?: _Code***REMOVED*** = {***REMOVED***

export function useFunc(gen: CodeGen, f: {code: string***REMOVED***): Name {
  return gen.scopeValue("func", {
    ref: f,
    code: snippets[f.code] || (snippets[f.code] = new _Code(f.code)),
  ***REMOVED***)
***REMOVED***

export enum Type {
  Num,
  Str,
***REMOVED***

export function getErrorPath(
  dataProp: Name | string | number,
  dataPropType?: Type,
  jsPropertySyntax?: boolean
): Code | string {
  // let path
  if (dataProp instanceof Name) {
    const isNumber = dataPropType === Type.Num
    return jsPropertySyntax
      ? isNumber
        ? _`"[" + ${dataProp***REMOVED*** + "]"`
        : _`"['" + ${dataProp***REMOVED*** + "']"`
      : isNumber
      ? _`"/" + ${dataProp***REMOVED***`
      : _`"/" + ${dataProp***REMOVED***.replace(/~/g, "~0").replace(/\\//g, "~1")` // TODO maybe use global escapePointer
  ***REMOVED***
  return jsPropertySyntax ? getProperty(dataProp).toString() : "/" + escapeJsonPointer(dataProp)
***REMOVED***

export function checkStrictMode(
  it: SchemaCxt,
  msg: string,
  mode: boolean | "log" = it.opts.strictSchema
): void {
  if (!mode) return
  msg = `strict mode: ${msg***REMOVED***`
  if (mode === true) throw new Error(msg)
  it.self.logger.warn(msg)
***REMOVED***
