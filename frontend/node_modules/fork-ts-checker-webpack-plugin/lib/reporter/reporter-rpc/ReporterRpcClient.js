"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); ***REMOVED***); ***REMOVED***
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); ***REMOVED*** catch (e) { reject(e); ***REMOVED*** ***REMOVED***
        function rejected(value) { try { step(generator["throw"](value)); ***REMOVED*** catch (e) { reject(e); ***REMOVED*** ***REMOVED***
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); ***REMOVED***
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    ***REMOVED***);
***REMOVED***;
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod ***REMOVED***;
***REMOVED***;
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const rpc_1 = require("../../rpc");
const ReporterRpcProcedure_1 = require("./ReporterRpcProcedure");
const flatten_1 = __importDefault(require("../../utils/array/flatten"));
function createReporterRpcClient(channel, configuration) {
    const rpcClient = rpc_1.createRpcClient(channel.clientPort);
    return {
        isConnected: () => channel.isOpen() && rpcClient.isConnected(),
        connect: () => __awaiter(this, void 0, void 0, function* () {
            if (!channel.isOpen()) {
                yield channel.open();
            ***REMOVED***
            if (!rpcClient.isConnected()) {
                try {
                    yield rpcClient.connect();
                    yield rpcClient.dispatchCall(ReporterRpcProcedure_1.configure, configuration);
                ***REMOVED***
                catch (error) {
                    // connect or configure was not successful -
                    // close the reporter and re-throw an error
                    yield rpcClient.disconnect();
                    yield channel.close();
                    throw error;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***),
        disconnect: () => __awaiter(this, void 0, void 0, function* () {
            if (rpcClient.isConnected()) {
                yield rpcClient.disconnect();
            ***REMOVED***
            if (channel.isOpen()) {
                yield channel.close();
            ***REMOVED***
        ***REMOVED***),
        getReport: (change) => __awaiter(this, void 0, void 0, function* () {
            const reportId = yield rpcClient.dispatchCall(ReporterRpcProcedure_1.getReport, change);
            return {
                getDependencies() {
                    return rpcClient.dispatchCall(ReporterRpcProcedure_1.getDependencies, reportId);
                ***REMOVED***,
                getIssues() {
                    return rpcClient.dispatchCall(ReporterRpcProcedure_1.getIssues, reportId);
                ***REMOVED***,
                close() {
                    return rpcClient.dispatchCall(ReporterRpcProcedure_1.closeReport, reportId);
                ***REMOVED***,
            ***REMOVED***;
        ***REMOVED***),
    ***REMOVED***;
***REMOVED***
exports.createReporterRpcClient = createReporterRpcClient;
function composeReporterRpcClients(clients) {
    return {
        isConnected: () => clients.every((client) => client.isConnected()),
        connect: () => Promise.all(clients.map((client) => client.connect())).then(() => undefined),
        disconnect: () => Promise.all(clients.map((client) => client.disconnect())).then(() => undefined),
        getReport: (change) => Promise.all(clients.map((client) => client.getReport(change))).then((reports) => ({
            getDependencies: () => Promise.all(reports.map((report) => report.getDependencies())).then((dependencies) => dependencies.reduce((mergedDependencies, singleDependencies) => ({
                files: Array.from(new Set([...mergedDependencies.files, ...singleDependencies.files])),
                dirs: Array.from(new Set([...mergedDependencies.dirs, ...singleDependencies.dirs])),
                excluded: Array.from(new Set([...mergedDependencies.excluded, ...singleDependencies.excluded])),
                extensions: Array.from(new Set([...mergedDependencies.extensions, ...singleDependencies.extensions])),
            ***REMOVED***), { files: [], dirs: [], excluded: [], extensions: [] ***REMOVED***)),
            getIssues: () => Promise.all(reports.map((report) => report.getIssues())).then((issues) => flatten_1.default(issues)),
            close: () => Promise.all(reports.map((report) => report.close())).then(() => undefined),
        ***REMOVED***)),
    ***REMOVED***;
***REMOVED***
exports.composeReporterRpcClients = composeReporterRpcClients;
