/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { join, dirname, readJson ***REMOVED*** = require("../util/fs");

/** @typedef {import("../util/fs").InputFileSystem***REMOVED*** InputFileSystem */
/** @typedef {import("../util/fs").JsonObject***REMOVED*** JsonObject */
/** @typedef {import("../util/fs").JsonPrimitive***REMOVED*** JsonPrimitive */

// Extreme shorthand only for github. eg: foo/bar
const RE_URL_GITHUB_EXTREME_SHORT = /^[^/@:.\s][^/@:\s]*\/[^@:\s]*[^/@:\s]#\S+/;

// Short url with specific protocol. eg: github:foo/bar
const RE_GIT_URL_SHORT = /^(github|gitlab|bitbucket|gist):\/?[^/.]+\/?/i;

// Currently supported protocols
const RE_PROTOCOL =
	/^((git\+)?(ssh|https?|file)|git|github|gitlab|bitbucket|gist):$/i;

// Has custom protocol
const RE_CUSTOM_PROTOCOL = /^((git\+)?(ssh|https?|file)|git):\/\//i;

// Valid hash format for npm / yarn ...
const RE_URL_HASH_VERSION = /#(?:semver:)?(.+)/;

// Simple hostname validate
const RE_HOSTNAME = /^(?:[^/.]+(\.[^/]+)+|localhost)$/;

// For hostname with colon. eg: ssh://user@github.com:foo/bar
const RE_HOSTNAME_WITH_COLON =
	/([^/@#:.]+(?:\.[^/@#:.]+)+|localhost):([^#/0-9]+)/;

// Reg for url without protocol
const RE_NO_PROTOCOL = /^([^/@#:.]+(?:\.[^/@#:.]+)+)/;

// RegExp for version string
const VERSION_PATTERN_REGEXP = /^([\d^=v<>~]|[*xX]$)/;

// Specific protocol for short url without normal hostname
const PROTOCOLS_FOR_SHORT = [
	"github:",
	"gitlab:",
	"bitbucket:",
	"gist:",
	"file:"
];

// Default protocol for git url
const DEF_GIT_PROTOCOL = "git+ssh://";

// thanks to https://github.com/npm/hosted-git-info/blob/latest/git-host-info.js
const extractCommithashByDomain = {
	/**
	 * @param {string***REMOVED*** pathname pathname
	 * @param {string***REMOVED*** hash hash
	 * @returns {string | undefined***REMOVED*** hash
	 */
	"github.com": (pathname, hash) => {
		let [, user, project, type, commithash] = pathname.split("/", 5);
		if (type && type !== "tree") {
			return;
		***REMOVED***

		commithash = !type ? hash : `#${commithash***REMOVED***`;

		if (project && project.endsWith(".git")) {
			project = project.slice(0, -4);
		***REMOVED***

		if (!user || !project) {
			return;
		***REMOVED***

		return commithash;
	***REMOVED***,
	/**
	 * @param {string***REMOVED*** pathname pathname
	 * @param {string***REMOVED*** hash hash
	 * @returns {string | undefined***REMOVED*** hash
	 */
	"gitlab.com": (pathname, hash) => {
		const path = pathname.slice(1);
		if (path.includes("/-/") || path.includes("/archive.tar.gz")) {
			return;
		***REMOVED***

		const segments = path.split("/");
		let project = /** @type {string***REMOVED*** */ (segments.pop());
		if (project.endsWith(".git")) {
			project = project.slice(0, -4);
		***REMOVED***

		const user = segments.join("/");
		if (!user || !project) {
			return;
		***REMOVED***

		return hash;
	***REMOVED***,
	/**
	 * @param {string***REMOVED*** pathname pathname
	 * @param {string***REMOVED*** hash hash
	 * @returns {string | undefined***REMOVED*** hash
	 */
	"bitbucket.org": (pathname, hash) => {
		let [, user, project, aux] = pathname.split("/", 4);
		if (["get"].includes(aux)) {
			return;
		***REMOVED***

		if (project && project.endsWith(".git")) {
			project = project.slice(0, -4);
		***REMOVED***

		if (!user || !project) {
			return;
		***REMOVED***

		return hash;
	***REMOVED***,
	/**
	 * @param {string***REMOVED*** pathname pathname
	 * @param {string***REMOVED*** hash hash
	 * @returns {string | undefined***REMOVED*** hash
	 */
	"gist.github.com": (pathname, hash) => {
		let [, user, project, aux] = pathname.split("/", 4);
		if (aux === "raw") {
			return;
		***REMOVED***

		if (!project) {
			if (!user) {
				return;
			***REMOVED***

			project = user;
		***REMOVED***

		if (project.endsWith(".git")) {
			project = project.slice(0, -4);
		***REMOVED***

		return hash;
	***REMOVED***
***REMOVED***;

/**
 * extract commit hash from parsed url
 * @inner
 * @param {URL***REMOVED*** urlParsed parsed url
 * @returns {string***REMOVED*** commithash
 */
function getCommithash(urlParsed) {
	let { hostname, pathname, hash ***REMOVED*** = urlParsed;
	hostname = hostname.replace(/^www\./, "");

	try {
		hash = decodeURIComponent(hash);
		// eslint-disable-next-line no-empty
	***REMOVED*** catch (_err) {***REMOVED***

	if (
		extractCommithashByDomain[
			/** @type {keyof extractCommithashByDomain***REMOVED*** */ (hostname)
		]
	) {
		return (
			extractCommithashByDomain[
				/** @type {keyof extractCommithashByDomain***REMOVED*** */ (hostname)
			](pathname, hash) || ""
		);
	***REMOVED***

	return hash;
***REMOVED***

/**
 * make url right for URL parse
 * @inner
 * @param {string***REMOVED*** gitUrl git url
 * @returns {string***REMOVED*** fixed url
 */
function correctUrl(gitUrl) {
	// like:
	// proto://hostname.com:user/repo -> proto://hostname.com/user/repo
	return gitUrl.replace(RE_HOSTNAME_WITH_COLON, "$1/$2");
***REMOVED***

/**
 * make url protocol right for URL parse
 * @inner
 * @param {string***REMOVED*** gitUrl git url
 * @returns {string***REMOVED*** fixed url
 */
function correctProtocol(gitUrl) {
	// eg: github:foo/bar#v1.0. Should not add double slash, in case of error parsed `pathname`
	if (RE_GIT_URL_SHORT.test(gitUrl)) {
		return gitUrl;
	***REMOVED***

	// eg: user@github.com:foo/bar
	if (!RE_CUSTOM_PROTOCOL.test(gitUrl)) {
		return `${DEF_GIT_PROTOCOL***REMOVED***${gitUrl***REMOVED***`;
	***REMOVED***

	return gitUrl;
***REMOVED***

/**
 * extract git dep version from hash
 * @inner
 * @param {string***REMOVED*** hash hash
 * @returns {string***REMOVED*** git dep version
 */
function getVersionFromHash(hash) {
	const matched = hash.match(RE_URL_HASH_VERSION);

	return (matched && matched[1]) || "";
***REMOVED***

/**
 * if string can be decoded
 * @inner
 * @param {string***REMOVED*** str str to be checked
 * @returns {boolean***REMOVED*** if can be decoded
 */
function canBeDecoded(str) {
	try {
		decodeURIComponent(str);
	***REMOVED*** catch (_err) {
		return false;
	***REMOVED***

	return true;
***REMOVED***

/**
 * get right dep version from git url
 * @inner
 * @param {string***REMOVED*** gitUrl git url
 * @returns {string***REMOVED*** dep version
 */
function getGitUrlVersion(gitUrl) {
	const oriGitUrl = gitUrl;
	// github extreme shorthand
	gitUrl = RE_URL_GITHUB_EXTREME_SHORT.test(gitUrl)
		? `github:${gitUrl***REMOVED***`
		: correctProtocol(gitUrl);

	gitUrl = correctUrl(gitUrl);

	let parsed;
	try {
		parsed = new URL(gitUrl);
		// eslint-disable-next-line no-empty
	***REMOVED*** catch (_err) {***REMOVED***

	if (!parsed) {
		return "";
	***REMOVED***

	const { protocol, hostname, pathname, username, password ***REMOVED*** = parsed;
	if (!RE_PROTOCOL.test(protocol)) {
		return "";
	***REMOVED***

	// pathname shouldn't be empty or URL malformed
	if (!pathname || !canBeDecoded(pathname)) {
		return "";
	***REMOVED***

	// without protocol, there should have auth info
	if (RE_NO_PROTOCOL.test(oriGitUrl) && !username && !password) {
		return "";
	***REMOVED***

	if (!PROTOCOLS_FOR_SHORT.includes(protocol.toLowerCase())) {
		if (!RE_HOSTNAME.test(hostname)) {
			return "";
		***REMOVED***

		const commithash = getCommithash(parsed);
		return getVersionFromHash(commithash) || commithash;
	***REMOVED***

	// for protocol short
	return getVersionFromHash(gitUrl);
***REMOVED***

/**
 * @param {string***REMOVED*** str maybe required version
 * @returns {boolean***REMOVED*** true, if it looks like a version
 */
function isRequiredVersion(str) {
	return VERSION_PATTERN_REGEXP.test(str);
***REMOVED***

module.exports.isRequiredVersion = isRequiredVersion;

/**
 * @see https://docs.npmjs.com/cli/v7/configuring-npm/package-json#urls-as-dependencies
 * @param {string***REMOVED*** versionDesc version to be normalized
 * @returns {string***REMOVED*** normalized version
 */
function normalizeVersion(versionDesc) {
	versionDesc = (versionDesc && versionDesc.trim()) || "";

	if (isRequiredVersion(versionDesc)) {
		return versionDesc;
	***REMOVED***

	// add handle for URL Dependencies
	return getGitUrlVersion(versionDesc.toLowerCase());
***REMOVED***

module.exports.normalizeVersion = normalizeVersion;

/** @typedef {{ data: JsonObject, path: string ***REMOVED******REMOVED*** DescriptionFile */

/**
 * @param {InputFileSystem***REMOVED*** fs file system
 * @param {string***REMOVED*** directory directory to start looking into
 * @param {string[]***REMOVED*** descriptionFiles possible description filenames
 * @param {(err?: Error | null, descriptionFile?: DescriptionFile, paths?: string[]) => void***REMOVED*** callback callback
 * @param {(descriptionFile?: DescriptionFile) => boolean***REMOVED*** satisfiesDescriptionFileData file data compliance check
 * @param {Set<string>***REMOVED*** checkedFilePaths set of file paths that have been checked
 */
const getDescriptionFile = (
	fs,
	directory,
	descriptionFiles,
	callback,
	satisfiesDescriptionFileData,
	checkedFilePaths = new Set()
) => {
	let i = 0;

	const satisfiesDescriptionFileDataInternal = {
		check: satisfiesDescriptionFileData,
		checkedFilePaths
	***REMOVED***;

	const tryLoadCurrent = () => {
		if (i >= descriptionFiles.length) {
			const parentDirectory = dirname(fs, directory);
			if (!parentDirectory || parentDirectory === directory) {
				return callback(
					null,
					undefined,
					Array.from(satisfiesDescriptionFileDataInternal.checkedFilePaths)
				);
			***REMOVED***
			return getDescriptionFile(
				fs,
				parentDirectory,
				descriptionFiles,
				callback,
				satisfiesDescriptionFileDataInternal.check,
				satisfiesDescriptionFileDataInternal.checkedFilePaths
			);
		***REMOVED***
		const filePath = join(fs, directory, descriptionFiles[i]);
		readJson(fs, filePath, (err, data) => {
			if (err) {
				if ("code" in err && err.code === "ENOENT") {
					i++;
					return tryLoadCurrent();
				***REMOVED***
				return callback(err);
			***REMOVED***
			if (!data || typeof data !== "object" || Array.isArray(data)) {
				return callback(
					new Error(`Description file ${filePath***REMOVED*** is not an object`)
				);
			***REMOVED***
			if (
				typeof satisfiesDescriptionFileDataInternal.check === "function" &&
				!satisfiesDescriptionFileDataInternal.check({ data, path: filePath ***REMOVED***)
			) {
				i++;
				satisfiesDescriptionFileDataInternal.checkedFilePaths.add(filePath);
				return tryLoadCurrent();
			***REMOVED***
			callback(null, { data, path: filePath ***REMOVED***);
		***REMOVED***);
	***REMOVED***;
	tryLoadCurrent();
***REMOVED***;
module.exports.getDescriptionFile = getDescriptionFile;

/**
 * @param {JsonObject***REMOVED*** data description file data i.e.: package.json
 * @param {string***REMOVED*** packageName name of the dependency
 * @returns {string | undefined***REMOVED*** normalized version
 */
const getRequiredVersionFromDescriptionFile = (data, packageName) => {
	const dependencyTypes = [
		"optionalDependencies",
		"dependencies",
		"peerDependencies",
		"devDependencies"
	];

	for (const dependencyType of dependencyTypes) {
		const dependency = /** @type {JsonObject***REMOVED*** */ (data[dependencyType]);
		if (
			dependency &&
			typeof dependency === "object" &&
			packageName in dependency
		) {
			return normalizeVersion(
				/** @type {Exclude<JsonPrimitive, null | boolean| number>***REMOVED*** */ (
					dependency[packageName]
				)
			);
		***REMOVED***
	***REMOVED***
***REMOVED***;
module.exports.getRequiredVersionFromDescriptionFile =
	getRequiredVersionFromDescriptionFile;
