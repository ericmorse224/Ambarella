"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
exports.RULE_NAME = void 0;
const create_testing_library_rule_1 = require("../create-testing-library-rule");
const node_utils_1 = require("../node-utils");
exports.RULE_NAME = 'no-wait-for-side-effects';
exports.default = (0, create_testing_library_rule_1.createTestingLibraryRule)({
    name: exports.RULE_NAME,
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow the use of side effects in `waitFor`',
            recommendedConfig: {
                dom: 'error',
                angular: 'error',
                react: 'error',
                vue: 'error',
                marko: 'error',
            ***REMOVED***,
        ***REMOVED***,
        messages: {
            noSideEffectsWaitFor: 'Avoid using side effects within `waitFor` callback',
        ***REMOVED***,
        schema: [],
    ***REMOVED***,
    defaultOptions: [],
    create(context, _, helpers) {
        function isCallerWaitFor(node) {
            if (!node.parent) {
                return false;
            ***REMOVED***
            const callExpressionNode = node.parent.parent;
            const callExpressionIdentifier = (0, node_utils_1.getPropertyIdentifierNode)(callExpressionNode);
            return (!!callExpressionIdentifier &&
                helpers.isAsyncUtil(callExpressionIdentifier, ['waitFor']));
        ***REMOVED***
        function isCallerThen(node) {
            if (!node.parent) {
                return false;
            ***REMOVED***
            const callExpressionNode = node.parent.parent;
            return (0, node_utils_1.hasThenProperty)(callExpressionNode.callee);
        ***REMOVED***
        function isRenderInVariableDeclaration(node) {
            return ((0, node_utils_1.isVariableDeclaration)(node) &&
                node.declarations.some(helpers.isRenderVariableDeclarator));
        ***REMOVED***
        function isRenderInExpressionStatement(node) {
            if (!(0, node_utils_1.isExpressionStatement)(node) ||
                !(0, node_utils_1.isAssignmentExpression)(node.expression)) {
                return false;
            ***REMOVED***
            const expressionIdentifier = (0, node_utils_1.getPropertyIdentifierNode)(node.expression.right);
            if (!expressionIdentifier) {
                return false;
            ***REMOVED***
            return helpers.isRenderUtil(expressionIdentifier);
        ***REMOVED***
        function isRenderInAssignmentExpression(node) {
            if (!(0, node_utils_1.isAssignmentExpression)(node)) {
                return false;
            ***REMOVED***
            const expressionIdentifier = (0, node_utils_1.getPropertyIdentifierNode)(node.right);
            if (!expressionIdentifier) {
                return false;
            ***REMOVED***
            return helpers.isRenderUtil(expressionIdentifier);
        ***REMOVED***
        function isRenderInSequenceAssignment(node) {
            if (!(0, node_utils_1.isSequenceExpression)(node)) {
                return false;
            ***REMOVED***
            return node.expressions.some(isRenderInAssignmentExpression);
        ***REMOVED***
        function isSideEffectInVariableDeclaration(node) {
            return node.declarations.some((declaration) => {
                if ((0, node_utils_1.isCallExpression)(declaration.init)) {
                    const test = (0, node_utils_1.getPropertyIdentifierNode)(declaration.init);
                    if (!test) {
                        return false;
                    ***REMOVED***
                    return (helpers.isFireEventUtil(test) ||
                        helpers.isUserEventUtil(test) ||
                        helpers.isRenderUtil(test));
                ***REMOVED***
                return false;
            ***REMOVED***);
            return false;
        ***REMOVED***
        function getSideEffectNodes(body) {
            return body.filter((node) => {
                if (!(0, node_utils_1.isExpressionStatement)(node) && !(0, node_utils_1.isVariableDeclaration)(node)) {
                    return false;
                ***REMOVED***
                if (isRenderInVariableDeclaration(node) ||
                    isRenderInExpressionStatement(node)) {
                    return true;
                ***REMOVED***
                if ((0, node_utils_1.isVariableDeclaration)(node) &&
                    isSideEffectInVariableDeclaration(node)) {
                    return true;
                ***REMOVED***
                const expressionIdentifier = (0, node_utils_1.getPropertyIdentifierNode)(node);
                if (!expressionIdentifier) {
                    return false;
                ***REMOVED***
                return (helpers.isFireEventUtil(expressionIdentifier) ||
                    helpers.isUserEventUtil(expressionIdentifier) ||
                    helpers.isRenderUtil(expressionIdentifier));
            ***REMOVED***);
        ***REMOVED***
        function reportSideEffects(node) {
            if (!isCallerWaitFor(node)) {
                return;
            ***REMOVED***
            if (isCallerThen(node)) {
                return;
            ***REMOVED***
            getSideEffectNodes(node.body).forEach((sideEffectNode) => context.report({
                node: sideEffectNode,
                messageId: 'noSideEffectsWaitFor',
            ***REMOVED***));
        ***REMOVED***
        function reportImplicitReturnSideEffect(node) {
            if (!isCallerWaitFor(node)) {
                return;
            ***REMOVED***
            const expressionIdentifier = (0, node_utils_1.isCallExpression)(node)
                ? (0, node_utils_1.getPropertyIdentifierNode)(node.callee)
                : null;
            if (!expressionIdentifier &&
                !isRenderInAssignmentExpression(node) &&
                !isRenderInSequenceAssignment(node)) {
                return;
            ***REMOVED***
            if (expressionIdentifier &&
                !helpers.isFireEventUtil(expressionIdentifier) &&
                !helpers.isUserEventUtil(expressionIdentifier) &&
                !helpers.isRenderUtil(expressionIdentifier)) {
                return;
            ***REMOVED***
            context.report({
                node,
                messageId: 'noSideEffectsWaitFor',
            ***REMOVED***);
        ***REMOVED***
        return {
            'CallExpression > ArrowFunctionExpression > BlockStatement': reportSideEffects,
            'CallExpression > ArrowFunctionExpression > CallExpression': reportImplicitReturnSideEffect,
            'CallExpression > ArrowFunctionExpression > AssignmentExpression': reportImplicitReturnSideEffect,
            'CallExpression > ArrowFunctionExpression > SequenceExpression': reportImplicitReturnSideEffect,
            'CallExpression > FunctionExpression > BlockStatement': reportSideEffects,
        ***REMOVED***;
    ***REMOVED***,
***REMOVED***);
