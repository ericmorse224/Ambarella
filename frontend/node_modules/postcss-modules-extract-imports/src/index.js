const topologicalSort = require("./topologicalSort");

const matchImports = /^(.+?)\s+from\s+(?:"([^"]+)"|'([^']+)'|(global))$/;
const icssImport = /^:import\((?:"([^"]+)"|'([^']+)')\)/;

const VISITED_MARKER = 1;

/**
 * :import('G') {***REMOVED***
 *
 * Rule
 *   composes: ... from 'A'
 *   composes: ... from 'B'

 * Rule
 *   composes: ... from 'A'
 *   composes: ... from 'A'
 *   composes: ... from 'C'
 *
 * Results in:
 *
 * graph: {
 *   G: [],
 *   A: [],
 *   B: ['A'],
 *   C: ['A'],
 * ***REMOVED***
 */
function addImportToGraph(importId, parentId, graph, visited) {
  const siblingsId = parentId + "_" + "siblings";
  const visitedId = parentId + "_" + importId;

  if (visited[visitedId] !== VISITED_MARKER) {
    if (!Array.isArray(visited[siblingsId])) {
      visited[siblingsId] = [];
    ***REMOVED***

    const siblings = visited[siblingsId];

    if (Array.isArray(graph[importId])) {
      graph[importId] = graph[importId].concat(siblings);
    ***REMOVED*** else {
      graph[importId] = siblings.slice();
    ***REMOVED***

    visited[visitedId] = VISITED_MARKER;

    siblings.push(importId);
  ***REMOVED***
***REMOVED***

module.exports = (options = {***REMOVED***) => {
  let importIndex = 0;
  const createImportedName =
    typeof options.createImportedName !== "function"
      ? (importName /*, path*/) =>
          `i__imported_${importName.replace(/\W/g, "_")***REMOVED***_${importIndex++***REMOVED***`
      : options.createImportedName;
  const failOnWrongOrder = options.failOnWrongOrder;

  return {
    postcssPlugin: "postcss-modules-extract-imports",
    prepare() {
      const graph = {***REMOVED***;
      const visited = {***REMOVED***;
      const existingImports = {***REMOVED***;
      const importDecls = {***REMOVED***;
      const imports = {***REMOVED***;

      return {
        Once(root, postcss) {
          // Check the existing imports order and save refs
          root.walkRules((rule) => {
            const matches = icssImport.exec(rule.selector);

            if (matches) {
              const [, /*match*/ doubleQuotePath, singleQuotePath] = matches;
              const importPath = doubleQuotePath || singleQuotePath;

              addImportToGraph(importPath, "root", graph, visited);

              existingImports[importPath] = rule;
            ***REMOVED***
          ***REMOVED***);

          root.walkDecls(/^composes$/, (declaration) => {
            const multiple = declaration.value.split(",");
            const values = [];

            multiple.forEach((value) => {
              const matches = value.trim().match(matchImports);

              if (!matches) {
                values.push(value);

                return;
              ***REMOVED***

              let tmpSymbols;
              let [
                ,
                /*match*/ symbols,
                doubleQuotePath,
                singleQuotePath,
                global,
              ] = matches;

              if (global) {
                // Composing globals simply means changing these classes to wrap them in global(name)
                tmpSymbols = symbols.split(/\s+/).map((s) => `global(${s***REMOVED***)`);
              ***REMOVED*** else {
                const importPath = doubleQuotePath || singleQuotePath;

                let parent = declaration.parent;
                let parentIndexes = "";

                while (parent.type !== "root") {
                  parentIndexes =
                    parent.parent.index(parent) + "_" + parentIndexes;
                  parent = parent.parent;
                ***REMOVED***

                const { selector ***REMOVED*** = declaration.parent;
                const parentRule = `_${parentIndexes***REMOVED***${selector***REMOVED***`;

                addImportToGraph(importPath, parentRule, graph, visited);

                importDecls[importPath] = declaration;
                imports[importPath] = imports[importPath] || {***REMOVED***;

                tmpSymbols = symbols.split(/\s+/).map((s) => {
                  if (!imports[importPath][s]) {
                    imports[importPath][s] = createImportedName(s, importPath);
                  ***REMOVED***

                  return imports[importPath][s];
                ***REMOVED***);
              ***REMOVED***

              values.push(tmpSymbols.join(" "));
            ***REMOVED***);

            declaration.value = values.join(", ");
          ***REMOVED***);

          const importsOrder = topologicalSort(graph, failOnWrongOrder);

          if (importsOrder instanceof Error) {
            const importPath = importsOrder.nodes.find((importPath) =>
              // eslint-disable-next-line no-prototype-builtins
              importDecls.hasOwnProperty(importPath)
            );
            const decl = importDecls[importPath];

            throw decl.error(
              "Failed to resolve order of composed modules " +
                importsOrder.nodes
                  .map((importPath) => "`" + importPath + "`")
                  .join(", ") +
                ".",
              {
                plugin: "postcss-modules-extract-imports",
                word: "composes",
              ***REMOVED***
            );
          ***REMOVED***

          let lastImportRule;

          importsOrder.forEach((path) => {
            const importedSymbols = imports[path];
            let rule = existingImports[path];

            if (!rule && importedSymbols) {
              rule = postcss.rule({
                selector: `:import("${path***REMOVED***")`,
                raws: { after: "\n" ***REMOVED***,
              ***REMOVED***);

              if (lastImportRule) {
                root.insertAfter(lastImportRule, rule);
              ***REMOVED*** else {
                root.prepend(rule);
              ***REMOVED***
            ***REMOVED***

            lastImportRule = rule;

            if (!importedSymbols) {
              return;
            ***REMOVED***

            Object.keys(importedSymbols).forEach((importedSymbol) => {
              rule.append(
                postcss.decl({
                  value: importedSymbol,
                  prop: importedSymbols[importedSymbol],
                  raws: { before: "\n  " ***REMOVED***,
                ***REMOVED***)
              );
            ***REMOVED***);
          ***REMOVED***);
        ***REMOVED***,
      ***REMOVED***;
    ***REMOVED***,
  ***REMOVED***;
***REMOVED***;

module.exports.postcss = true;
