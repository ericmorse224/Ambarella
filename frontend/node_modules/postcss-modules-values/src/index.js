"use strict";

const ICSSUtils = require("icss-utils");

const matchImports = /^(.+?|\([\s\S]+?\))\s+from\s+("[^"]*"|'[^']*'|[\w-]+)$/;
const matchValueDefinition = /(?:\s+|^)([\w-]+):?(.*?)$/;
const matchImport = /^([\w-]+)(?:\s+as\s+([\w-]+))?/;

module.exports = (options) => {
  let importIndex = 0;
  const createImportedName =
    (options && options.createImportedName) ||
    ((importName /*, path*/) =>
      `i__const_${importName.replace(/\W/g, "_")***REMOVED***_${importIndex++***REMOVED***`);

  return {
    postcssPlugin: "postcss-modules-values",
    prepare(result) {
      const importAliases = [];
      const definitions = {***REMOVED***;

      return {
        Once(root, postcss) {
          root.walkAtRules(/value/i, (atRule) => {
            const matches = atRule.params.match(matchImports);

            if (matches) {
              let [, /*match*/ aliases, path] = matches;

              // We can use constants for path names
              if (definitions[path]) {
                path = definitions[path];
              ***REMOVED***

              const imports = aliases
                .replace(/^\(\s*([\s\S]+)\s*\)$/, "$1")
                .split(/\s*,\s*/)
                .map((alias) => {
                  const tokens = matchImport.exec(alias);

                  if (tokens) {
                    const [, /*match*/ theirName, myName = theirName] = tokens;
                    const importedName = createImportedName(myName);
                    definitions[myName] = importedName;
                    return { theirName, importedName ***REMOVED***;
                  ***REMOVED*** else {
                    throw new Error(`@import statement "${alias***REMOVED***" is invalid!`);
                  ***REMOVED***
                ***REMOVED***);

              importAliases.push({ path, imports ***REMOVED***);

              atRule.remove();

              return;
            ***REMOVED***

            if (atRule.params.indexOf("@value") !== -1) {
              result.warn("Invalid value definition: " + atRule.params);
            ***REMOVED***

            let [, key, value] = `${atRule.params***REMOVED***${atRule.raws.between***REMOVED***`.match(
              matchValueDefinition
            );

            const normalizedValue = value.replace(/\/\*((?!\*\/).*?)\*\//g, "");

            if (normalizedValue.length === 0) {
              result.warn("Invalid value definition: " + atRule.params);
              atRule.remove();

              return;
            ***REMOVED***

            let isOnlySpace = /^\s+$/.test(normalizedValue);

            if (!isOnlySpace) {
              value = value.trim();
            ***REMOVED***

            // Add to the definitions, knowing that values can refer to each other
            definitions[key] = ICSSUtils.replaceValueSymbols(
              value,
              definitions
            );

            atRule.remove();
          ***REMOVED***);

          /* If we have no definitions, don't continue */
          if (!Object.keys(definitions).length) {
            return;
          ***REMOVED***

          /* Perform replacements */
          ICSSUtils.replaceSymbols(root, definitions);

          /* We want to export anything defined by now, but don't add it to the CSS yet or it well get picked up by the replacement stuff */
          const exportDeclarations = Object.keys(definitions).map((key) =>
            postcss.decl({
              value: definitions[key],
              prop: key,
              raws: { before: "\n  " ***REMOVED***,
            ***REMOVED***)
          );

          /* Add export rules if any */
          if (exportDeclarations.length > 0) {
            const exportRule = postcss.rule({
              selector: ":export",
              raws: { after: "\n" ***REMOVED***,
            ***REMOVED***);

            exportRule.append(exportDeclarations);

            root.prepend(exportRule);
          ***REMOVED***

          /* Add import rules */
          importAliases.reverse().forEach(({ path, imports ***REMOVED***) => {
            const importRule = postcss.rule({
              selector: `:import(${path***REMOVED***)`,
              raws: { after: "\n" ***REMOVED***,
            ***REMOVED***);

            imports.forEach(({ theirName, importedName ***REMOVED***) => {
              importRule.append({
                value: theirName,
                prop: importedName,
                raws: { before: "\n  " ***REMOVED***,
              ***REMOVED***);
            ***REMOVED***);

            root.prepend(importRule);
          ***REMOVED***);
        ***REMOVED***,
      ***REMOVED***;
    ***REMOVED***,
  ***REMOVED***;
***REMOVED***;

module.exports.postcss = true;
