"use strict";

const path = require("path");

// Based on https://github.com/webpack/webpack/blob/master/lib/cli.js
// Please do not modify it

/** @typedef {"unknown-argument" | "unexpected-non-array-in-path" | "unexpected-non-object-in-path" | "multiple-values-unexpected" | "invalid-value"***REMOVED*** ProblemType */

/**
 * @typedef {Object***REMOVED*** Problem
 * @property {ProblemType***REMOVED*** type
 * @property {string***REMOVED*** path
 * @property {string***REMOVED*** argument
 * @property {any=***REMOVED*** value
 * @property {number=***REMOVED*** index
 * @property {string=***REMOVED*** expected
 */

/**
 * @typedef {Object***REMOVED*** LocalProblem
 * @property {ProblemType***REMOVED*** type
 * @property {string***REMOVED*** path
 * @property {string=***REMOVED*** expected
 */

/**
 * @typedef {Object***REMOVED*** ArgumentConfig
 * @property {string***REMOVED*** description
 * @property {string***REMOVED*** path
 * @property {boolean***REMOVED*** multiple
 * @property {"enum"|"string"|"path"|"number"|"boolean"|"RegExp"|"reset"***REMOVED*** type
 * @property {any[]=***REMOVED*** values
 */

/**
 * @typedef {Object***REMOVED*** Argument
 * @property {string***REMOVED*** description
 * @property {"string"|"number"|"boolean"***REMOVED*** simpleType
 * @property {boolean***REMOVED*** multiple
 * @property {ArgumentConfig[]***REMOVED*** configs
 */

const cliAddedItems = new WeakMap();

/**
 * @param {any***REMOVED*** config configuration
 * @param {string***REMOVED*** schemaPath path in the config
 * @param {number | undefined***REMOVED*** index index of value when multiple values are provided, otherwise undefined
 * @returns {{ problem?: LocalProblem, object?: any, property?: string | number, value?: any ***REMOVED******REMOVED*** problem or object with property and value
 */
const getObjectAndProperty = (config, schemaPath, index = 0) => {
  if (!schemaPath) {
    return { value: config ***REMOVED***;
  ***REMOVED***

  const parts = schemaPath.split(".");
  const property = parts.pop();
  let current = config;
  let i = 0;

  for (const part of parts) {
    const isArray = part.endsWith("[]");
    const name = isArray ? part.slice(0, -2) : part;
    let value = current[name];

    if (isArray) {
      // eslint-disable-next-line no-undefined
      if (value === undefined) {
        value = {***REMOVED***;
        current[name] = [...Array.from({ length: index ***REMOVED***), value];
        cliAddedItems.set(current[name], index + 1);
      ***REMOVED*** else if (!Array.isArray(value)) {
        return {
          problem: {
            type: "unexpected-non-array-in-path",
            path: parts.slice(0, i).join("."),
          ***REMOVED***,
        ***REMOVED***;
      ***REMOVED*** else {
        let addedItems = cliAddedItems.get(value) || 0;

        while (addedItems <= index) {
          // eslint-disable-next-line no-undefined
          value.push(undefined);
          // eslint-disable-next-line no-plusplus
          addedItems++;
        ***REMOVED***

        cliAddedItems.set(value, addedItems);

        const x = value.length - addedItems + index;

        // eslint-disable-next-line no-undefined
        if (value[x] === undefined) {
          value[x] = {***REMOVED***;
        ***REMOVED*** else if (value[x] === null || typeof value[x] !== "object") {
          return {
            problem: {
              type: "unexpected-non-object-in-path",
              path: parts.slice(0, i).join("."),
            ***REMOVED***,
          ***REMOVED***;
        ***REMOVED***

        value = value[x];
      ***REMOVED***
      // eslint-disable-next-line no-undefined
    ***REMOVED*** else if (value === undefined) {
      // eslint-disable-next-line no-multi-assign
      value = current[name] = {***REMOVED***;
    ***REMOVED*** else if (value === null || typeof value !== "object") {
      return {
        problem: {
          type: "unexpected-non-object-in-path",
          path: parts.slice(0, i).join("."),
        ***REMOVED***,
      ***REMOVED***;
    ***REMOVED***

    current = value;
    // eslint-disable-next-line no-plusplus
    i++;
  ***REMOVED***

  const value = current[/** @type {string***REMOVED*** */ (property)];

  if (/** @type {string***REMOVED*** */ (property).endsWith("[]")) {
    const name = /** @type {string***REMOVED*** */ (property).slice(0, -2);
    // eslint-disable-next-line no-shadow
    const value = current[name];

    // eslint-disable-next-line no-undefined
    if (value === undefined) {
      // eslint-disable-next-line no-undefined
      current[name] = [...Array.from({ length: index ***REMOVED***), undefined];
      cliAddedItems.set(current[name], index + 1);

      // eslint-disable-next-line no-undefined
      return { object: current[name], property: index, value: undefined ***REMOVED***;
    ***REMOVED*** else if (!Array.isArray(value)) {
      // eslint-disable-next-line no-undefined
      current[name] = [value, ...Array.from({ length: index ***REMOVED***), undefined];
      cliAddedItems.set(current[name], index + 1);

      // eslint-disable-next-line no-undefined
      return { object: current[name], property: index + 1, value: undefined ***REMOVED***;
    ***REMOVED***

    let addedItems = cliAddedItems.get(value) || 0;

    while (addedItems <= index) {
      // eslint-disable-next-line no-undefined
      value.push(undefined);
      // eslint-disable-next-line no-plusplus
      addedItems++;
    ***REMOVED***

    cliAddedItems.set(value, addedItems);

    const x = value.length - addedItems + index;

    // eslint-disable-next-line no-undefined
    if (value[x] === undefined) {
      value[x] = {***REMOVED***;
    ***REMOVED*** else if (value[x] === null || typeof value[x] !== "object") {
      return {
        problem: {
          type: "unexpected-non-object-in-path",
          path: schemaPath,
        ***REMOVED***,
      ***REMOVED***;
    ***REMOVED***

    return {
      object: value,
      property: x,
      value: value[x],
    ***REMOVED***;
  ***REMOVED***

  return { object: current, property, value ***REMOVED***;
***REMOVED***;

/**
 * @param {ArgumentConfig***REMOVED*** argConfig processing instructions
 * @param {any***REMOVED*** value the value
 * @returns {any | undefined***REMOVED*** parsed value
 */
const parseValueForArgumentConfig = (argConfig, value) => {
  // eslint-disable-next-line default-case
  switch (argConfig.type) {
    case "string":
      if (typeof value === "string") {
        return value;
      ***REMOVED***
      break;
    case "path":
      if (typeof value === "string") {
        return path.resolve(value);
      ***REMOVED***
      break;
    case "number":
      if (typeof value === "number") {
        return value;
      ***REMOVED***

      if (typeof value === "string" && /^[+-]?\d*(\.\d*)[eE]\d+$/) {
        const n = +value;
        if (!isNaN(n)) return n;
      ***REMOVED***

      break;
    case "boolean":
      if (typeof value === "boolean") {
        return value;
      ***REMOVED***

      if (value === "true") {
        return true;
      ***REMOVED***

      if (value === "false") {
        return false;
      ***REMOVED***

      break;
    case "RegExp":
      if (value instanceof RegExp) {
        return value;
      ***REMOVED***

      if (typeof value === "string") {
        // cspell:word yugi
        const match = /^\/(.*)\/([yugi]*)$/.exec(value);

        if (match && !/[^\\]\//.test(match[1])) {
          return new RegExp(match[1], match[2]);
        ***REMOVED***
      ***REMOVED***

      break;
    case "enum":
      if (/** @type {any[]***REMOVED*** */ (argConfig.values).includes(value)) {
        return value;
      ***REMOVED***

      for (const item of /** @type {any[]***REMOVED*** */ (argConfig.values)) {
        if (`${item***REMOVED***` === value) return item;
      ***REMOVED***

      break;
    case "reset":
      if (value === true) {
        return [];
      ***REMOVED***

      break;
  ***REMOVED***
***REMOVED***;

/**
 * @param {ArgumentConfig***REMOVED*** argConfig processing instructions
 * @returns {string | undefined***REMOVED*** expected message
 */
const getExpectedValue = (argConfig) => {
  switch (argConfig.type) {
    default:
      return argConfig.type;
    case "boolean":
      return "true | false";
    case "RegExp":
      return "regular expression (example: /ab?c*/)";
    case "enum":
      return /** @type {any[]***REMOVED*** */ (argConfig.values)
        .map((v) => `${v***REMOVED***`)
        .join(" | ");
    case "reset":
      return "true (will reset the previous value to an empty array)";
  ***REMOVED***
***REMOVED***;

/**
 * @param {any***REMOVED*** config configuration
 * @param {string***REMOVED*** schemaPath path in the config
 * @param {any***REMOVED*** value parsed value
 * @param {number | undefined***REMOVED*** index index of value when multiple values are provided, otherwise undefined
 * @returns {LocalProblem | null***REMOVED*** problem or null for success
 */
const setValue = (config, schemaPath, value, index) => {
  const { problem, object, property ***REMOVED*** = getObjectAndProperty(
    config,
    schemaPath,
    index
  );

  if (problem) {
    return problem;
  ***REMOVED***

  object[/** @type {string***REMOVED*** */ (property)] = value;

  return null;
***REMOVED***;

/**
 * @param {ArgumentConfig***REMOVED*** argConfig processing instructions
 * @param {any***REMOVED*** config configuration
 * @param {any***REMOVED*** value the value
 * @param {number | undefined***REMOVED*** index the index if multiple values provided
 * @returns {LocalProblem | null***REMOVED*** a problem if any
 */
const processArgumentConfig = (argConfig, config, value, index) => {
  // eslint-disable-next-line no-undefined
  if (index !== undefined && !argConfig.multiple) {
    return {
      type: "multiple-values-unexpected",
      path: argConfig.path,
    ***REMOVED***;
  ***REMOVED***

  const parsed = parseValueForArgumentConfig(argConfig, value);

  // eslint-disable-next-line no-undefined
  if (parsed === undefined) {
    return {
      type: "invalid-value",
      path: argConfig.path,
      expected: getExpectedValue(argConfig),
    ***REMOVED***;
  ***REMOVED***

  const problem = setValue(config, argConfig.path, parsed, index);

  if (problem) {
    return problem;
  ***REMOVED***

  return null;
***REMOVED***;

/**
 * @param {Record<string, Argument>***REMOVED*** args object of arguments
 * @param {any***REMOVED*** config configuration
 * @param {Record<string, string | number | boolean | RegExp | (string | number | boolean | RegExp)[]>***REMOVED*** values object with values
 * @returns {Problem[] | null***REMOVED*** problems or null for success
 */
const processArguments = (args, config, values) => {
  /**
   * @type {Problem[]***REMOVED***
   */
  const problems = [];

  for (const key of Object.keys(values)) {
    const arg = args[key];

    if (!arg) {
      problems.push({
        type: "unknown-argument",
        path: "",
        argument: key,
      ***REMOVED***);

      // eslint-disable-next-line no-continue
      continue;
    ***REMOVED***

    /**
     * @param {any***REMOVED*** value
     * @param {number | undefined***REMOVED*** i
     */
    const processValue = (value, i) => {
      const currentProblems = [];

      for (const argConfig of arg.configs) {
        const problem = processArgumentConfig(argConfig, config, value, i);

        if (!problem) {
          return;
        ***REMOVED***

        currentProblems.push({
          ...problem,
          argument: key,
          value,
          index: i,
        ***REMOVED***);
      ***REMOVED***

      problems.push(...currentProblems);
    ***REMOVED***;

    const value = values[key];

    if (Array.isArray(value)) {
      for (let i = 0; i < value.length; i++) {
        processValue(value[i], i);
      ***REMOVED***
    ***REMOVED*** else {
      // eslint-disable-next-line no-undefined
      processValue(value, undefined);
    ***REMOVED***
  ***REMOVED***

  if (problems.length === 0) {
    return null;
  ***REMOVED***

  return problems;
***REMOVED***;

module.exports = processArguments;
