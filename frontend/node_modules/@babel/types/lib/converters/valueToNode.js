"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.default = void 0;
var _isValidIdentifier = require("../validators/isValidIdentifier.js");
var _index = require("../builders/generated/index.js");
var _default = exports.default = valueToNode;
const objectToString = Function.call.bind(Object.prototype.toString);
function isRegExp(value) {
  return objectToString(value) === "[object RegExp]";
***REMOVED***
function isPlainObject(value) {
  if (typeof value !== "object" || value === null || Object.prototype.toString.call(value) !== "[object Object]") {
    return false;
  ***REMOVED***
  const proto = Object.getPrototypeOf(value);
  return proto === null || Object.getPrototypeOf(proto) === null;
***REMOVED***
function valueToNode(value) {
  if (value === undefined) {
    return (0, _index.identifier)("undefined");
  ***REMOVED***
  if (value === true || value === false) {
    return (0, _index.booleanLiteral)(value);
  ***REMOVED***
  if (value === null) {
    return (0, _index.nullLiteral)();
  ***REMOVED***
  if (typeof value === "string") {
    return (0, _index.stringLiteral)(value);
  ***REMOVED***
  if (typeof value === "number") {
    let result;
    if (Number.isFinite(value)) {
      result = (0, _index.numericLiteral)(Math.abs(value));
    ***REMOVED*** else {
      let numerator;
      if (Number.isNaN(value)) {
        numerator = (0, _index.numericLiteral)(0);
      ***REMOVED*** else {
        numerator = (0, _index.numericLiteral)(1);
      ***REMOVED***
      result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));
    ***REMOVED***
    if (value < 0 || Object.is(value, -0)) {
      result = (0, _index.unaryExpression)("-", result);
    ***REMOVED***
    return result;
  ***REMOVED***
  if (typeof value === "bigint") {
    return (0, _index.bigIntLiteral)(value.toString());
  ***REMOVED***
  if (isRegExp(value)) {
    const pattern = value.source;
    const flags = /\/([a-z]*)$/.exec(value.toString())[1];
    return (0, _index.regExpLiteral)(pattern, flags);
  ***REMOVED***
  if (Array.isArray(value)) {
    return (0, _index.arrayExpression)(value.map(valueToNode));
  ***REMOVED***
  if (isPlainObject(value)) {
    const props = [];
    for (const key of Object.keys(value)) {
      let nodeKey,
        computed = false;
      if ((0, _isValidIdentifier.default)(key)) {
        if (key === "__proto__") {
          computed = true;
          nodeKey = (0, _index.stringLiteral)(key);
        ***REMOVED*** else {
          nodeKey = (0, _index.identifier)(key);
        ***REMOVED***
      ***REMOVED*** else {
        nodeKey = (0, _index.stringLiteral)(key);
      ***REMOVED***
      props.push((0, _index.objectProperty)(nodeKey, valueToNode(value[key]), computed));
    ***REMOVED***
    return (0, _index.objectExpression)(props);
  ***REMOVED***
  throw new Error("don't know how to turn this value into a node");
***REMOVED***

//# sourceMappingURL=valueToNode.js.map
