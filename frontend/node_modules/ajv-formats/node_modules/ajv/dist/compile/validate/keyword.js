"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
const codegen_1 = require("../codegen");
const names_1 = require("../names");
const code_1 = require("../../vocabularies/code");
const errors_1 = require("../errors");
function macroKeywordCode(cxt, def) {
    const { gen, keyword, schema, parentSchema, it ***REMOVED*** = cxt;
    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
    const schemaRef = useKeyword(gen, keyword, macroSchema);
    if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
    const valid = gen.name("valid");
    cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath***REMOVED***/${keyword***REMOVED***`,
        topSchemaRef: schemaRef,
        compositeRule: true,
    ***REMOVED***, valid);
    cxt.pass(valid, () => cxt.error(true));
***REMOVED***
exports.macroKeywordCode = macroKeywordCode;
function funcKeywordCode(cxt, def) {
    var _a;
    const { gen, keyword, schema, parentSchema, $data, it ***REMOVED*** = cxt;
    checkAsyncKeyword(it, def);
    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
    const validateRef = useKeyword(gen, keyword, validate);
    const valid = gen.let("valid");
    cxt.block$data(valid, validateKeyword);
    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
    function validateKeyword() {
        if (def.errors === false) {
            assignValid();
            if (def.modifying)
                modifyData(cxt);
            reportErrs(() => cxt.error());
        ***REMOVED***
        else {
            const ruleErrs = def.async ? validateAsync() : validateSync();
            if (def.modifying)
                modifyData(cxt);
            reportErrs(() => addErrs(cxt, ruleErrs));
        ***REMOVED***
    ***REMOVED***
    function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._) `await `), (e) => gen.assign(valid, false).if((0, codegen_1._) `${e***REMOVED*** instanceof ${it.ValidationError***REMOVED***`, () => gen.assign(ruleErrs, (0, codegen_1._) `${e***REMOVED***.errors`), () => gen.throw(e)));
        return ruleErrs;
    ***REMOVED***
    function validateSync() {
        const validateErrs = (0, codegen_1._) `${validateRef***REMOVED***.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
    ***REMOVED***
    function assignValid(_await = def.async ? (0, codegen_1._) `await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !(("compile" in def && !$data) || def.schema === false);
        gen.assign(valid, (0, codegen_1._) `${_await***REMOVED***${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)***REMOVED***`, def.modifying);
    ***REMOVED***
    function reportErrs(errors) {
        var _a;
        gen.if((0, codegen_1.not)((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);
    ***REMOVED***
***REMOVED***
exports.funcKeywordCode = funcKeywordCode;
function modifyData(cxt) {
    const { gen, data, it ***REMOVED*** = cxt;
    gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._) `${it.parentData***REMOVED***[${it.parentDataProperty***REMOVED***]`));
***REMOVED***
function addErrs(cxt, errs) {
    const { gen ***REMOVED*** = cxt;
    gen.if((0, codegen_1._) `Array.isArray(${errs***REMOVED***)`, () => {
        gen
            .assign(names_1.default.vErrors, (0, codegen_1._) `${names_1.default.vErrors***REMOVED*** === null ? ${errs***REMOVED*** : ${names_1.default.vErrors***REMOVED***.concat(${errs***REMOVED***)`)
            .assign(names_1.default.errors, (0, codegen_1._) `${names_1.default.vErrors***REMOVED***.length`);
        (0, errors_1.extendErrors)(cxt);
    ***REMOVED***, () => cxt.error());
***REMOVED***
function checkAsyncKeyword({ schemaEnv ***REMOVED***, def) {
    if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
***REMOVED***
function useKeyword(gen, keyword, result) {
    if (result === undefined)
        throw new Error(`keyword "${keyword***REMOVED***" failed to compile`);
    return gen.scopeValue("keyword", typeof result == "function" ? { ref: result ***REMOVED*** : { ref: result, code: (0, codegen_1.stringify)(result) ***REMOVED***);
***REMOVED***
function validSchemaType(schema, schemaType, allowUndefined = false) {
    // TODO add tests
    return (!schemaType.length ||
        schemaType.some((st) => st === "array"
            ? Array.isArray(schema)
            : st === "object"
                ? schema && typeof schema == "object" && !Array.isArray(schema)
                : typeof schema == st || (allowUndefined && typeof schema == "undefined")));
***REMOVED***
exports.validSchemaType = validSchemaType;
function validateKeywordUsage({ schema, opts, self, errSchemaPath ***REMOVED***, def, keyword) {
    /* istanbul ignore if */
    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
    ***REMOVED***
    const deps = def.dependencies;
    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword***REMOVED***: ${deps.join(",")***REMOVED***`);
    ***REMOVED***
    if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
            const msg = `keyword "${keyword***REMOVED***" value is invalid at path "${errSchemaPath***REMOVED***": ` +
                self.errorsText(def.validateSchema.errors);
            if (opts.validateSchema === "log")
                self.logger.error(msg);
            else
                throw new Error(msg);
        ***REMOVED***
    ***REMOVED***
***REMOVED***
exports.validateKeywordUsage = validateKeywordUsage;
//# sourceMappingURL=keyword.js.map