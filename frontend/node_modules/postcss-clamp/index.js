let valueParser = require('postcss-value-parser')

function parseValue (value) {
  let parsed = value.match(/([\d.-]+)(.*)/)
  if (!parsed || !parsed[1] || !parsed[2] || isNaN(parsed[1])) {
    return undefined
  ***REMOVED***
  return [parseFloat(parsed[1]), parsed[2]]
***REMOVED***

function compose (first, second, third) {
  if (first && second && third) {
    return `max(${first***REMOVED***, min(${second***REMOVED***, ${third***REMOVED***))`
  ***REMOVED***
  if (first && second) {
    return `max(${first***REMOVED***, ${second***REMOVED***)`
  ***REMOVED***

  return first
***REMOVED***

function updateValue (declaration, value, preserve) {
  let newValue = value
  let newValueAst = valueParser(value)
  let valueAST = valueParser(declaration.value)
  // Walk can't be interrupted, so we only care about first
  let foundClamp = false

  valueAST.walk((node, index, nodes) => {
    let isClamp = node.type === 'function' && node.value === 'clamp'

    if (!isClamp || foundClamp) {
      return
    ***REMOVED***

    foundClamp = true
    nodes[index] = newValueAst
  ***REMOVED***)

  if (foundClamp) {
    newValue = valueAST.toString()
  ***REMOVED***

  if (preserve) {
    declaration.cloneBefore({ value: newValue ***REMOVED***)
  ***REMOVED*** else {
    declaration.value = newValue
  ***REMOVED***
***REMOVED***

module.exports = opts => {
  opts = opts || {***REMOVED***
  let precalculate = opts.precalculate ? Boolean(opts.precalculate) : false
  let preserve = opts.preserve ? Boolean(opts.preserve) : false

  return {
    postcssPlugin: 'postcss-clamp',
    Declaration (decl) {
      if (!decl || !decl.value.includes('clamp')) {
        return
      ***REMOVED***
      valueParser(decl.value).walk(node => {
        let nodes = node.nodes
        if (
          node.type !== 'function' ||
          node.value !== 'clamp' ||
          nodes.length !== 5
        ) {
          return
        ***REMOVED***
        let first = nodes[0]
        let second = nodes[2]
        let third = nodes[4]
        let naive = compose(
          valueParser.stringify(first),
          valueParser.stringify(second),
          valueParser.stringify(third)
        )
        if (!precalculate || second.type !== 'word' || third.type !== 'word') {
          updateValue(decl, naive, preserve)
          return
        ***REMOVED***
        let parsedSecond = parseValue(second.value)
        let parsedThird = parseValue(third.value)
        if (parsedSecond === undefined || parsedThird === undefined) {
          updateValue(decl, naive, preserve)
          return
        ***REMOVED***
        let [secondValue, secondUnit] = parsedSecond
        let [thirdValue, thirdUnit] = parsedThird
        if (secondUnit !== thirdUnit) {
          updateValue(decl, naive, preserve)
          return
        ***REMOVED***
        let parsedFirst = parseValue(first.value)
        if (parsedFirst === undefined) {
          let secondThirdValue = `${secondValue + thirdValue***REMOVED***${secondUnit***REMOVED***`
          updateValue(
            decl,
            compose(valueParser.stringify(first), secondThirdValue),
            preserve
          )
          return
        ***REMOVED***
        let [firstValue, firstUnit] = parsedFirst
        if (firstUnit !== secondUnit) {
          let secondThirdValue = `${secondValue + thirdValue***REMOVED***${secondUnit***REMOVED***`
          updateValue(
            decl,
            compose(valueParser.stringify(first), secondThirdValue),
            preserve
          )
          return
        ***REMOVED***

        updateValue(
          decl,
          compose(`${firstValue + secondValue + thirdValue***REMOVED***${secondUnit***REMOVED***`),
          preserve
        )
      ***REMOVED***)
    ***REMOVED***
  ***REMOVED***
***REMOVED***

module.exports.postcss = true
