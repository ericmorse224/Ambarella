'use strict';

const zlib = require('zlib');

const bufferUtil = require('./buffer-util');
const Limiter = require('./limiter');
const { kStatusCode ***REMOVED*** = require('./constants');

const FastBuffer = Buffer[Symbol.species];
const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object***REMOVED*** [options] Configuration options
   * @param {(Boolean|Number)***REMOVED*** [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean***REMOVED*** [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number***REMOVED*** [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)***REMOVED*** [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean***REMOVED*** [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number***REMOVED*** [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object***REMOVED*** [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object***REMOVED*** [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean***REMOVED*** [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number***REMOVED*** [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {***REMOVED***;
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    ***REMOVED***
  ***REMOVED***

  /**
   * @type {String***REMOVED***
   */
  static get extensionName() {
    return 'permessage-deflate';
  ***REMOVED***

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object***REMOVED*** Extension parameters
   * @public
   */
  offer() {
    const params = {***REMOVED***;

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    ***REMOVED***
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    ***REMOVED***
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    ***REMOVED***
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    ***REMOVED*** else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    ***REMOVED***

    return params;
  ***REMOVED***

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array***REMOVED*** configurations The extension negotiation offers/reponse
   * @return {Object***REMOVED*** Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  ***REMOVED***

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    ***REMOVED***

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array***REMOVED*** offers The extension negotiation offers
   * @return {Object***REMOVED*** Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      ***REMOVED***

      return true;
    ***REMOVED***);

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    ***REMOVED***

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    ***REMOVED***
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    ***REMOVED***
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    ***REMOVED***
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    ***REMOVED*** else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    ***REMOVED***

    return accepted;
  ***REMOVED***

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array***REMOVED*** response The extension negotiation response
   * @return {Object***REMOVED*** Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    ***REMOVED***

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      ***REMOVED***
    ***REMOVED*** else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    ***REMOVED***

    return params;
  ***REMOVED***

  /**
   * Normalize parameters.
   *
   * @param {Array***REMOVED*** configurations The extension negotiation offers/reponse
   * @return {Array***REMOVED*** The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key***REMOVED***" must have only a single value`);
        ***REMOVED***

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key***REMOVED***": ${value***REMOVED***`
              );
            ***REMOVED***
            value = num;
          ***REMOVED*** else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key***REMOVED***": ${value***REMOVED***`
            );
          ***REMOVED***
        ***REMOVED*** else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key***REMOVED***": ${value***REMOVED***`
            );
          ***REMOVED***
          value = num;
        ***REMOVED*** else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key***REMOVED***": ${value***REMOVED***`
            );
          ***REMOVED***
        ***REMOVED*** else {
          throw new Error(`Unknown parameter "${key***REMOVED***"`);
        ***REMOVED***

        params[key] = value;
      ***REMOVED***);
    ***REMOVED***);

    return configurations;
  ***REMOVED***

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer***REMOVED*** data Compressed data
   * @param {Boolean***REMOVED*** fin Specifies whether or not this is the last fragment
   * @param {Function***REMOVED*** callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)***REMOVED*** data Data to compress
   * @param {Boolean***REMOVED*** fin Specifies whether or not this is the last fragment
   * @param {Function***REMOVED*** callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Decompress data.
   *
   * @param {Buffer***REMOVED*** data Compressed data
   * @param {Boolean***REMOVED*** fin Specifies whether or not this is the last fragment
   * @param {Function***REMOVED*** callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint***REMOVED***_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      ***REMOVED***);
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    ***REMOVED***

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      ***REMOVED***

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      ***REMOVED*** else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint***REMOVED***_no_context_takeover`]) {
          this._inflate.reset();
        ***REMOVED***
      ***REMOVED***

      callback(null, data);
    ***REMOVED***);
  ***REMOVED***

  /**
   * Compress data.
   *
   * @param {(Buffer|String)***REMOVED*** data Data to compress
   * @param {Boolean***REMOVED*** fin Specifies whether or not this is the last fragment
   * @param {Function***REMOVED*** callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint***REMOVED***_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      ***REMOVED***);

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      this._deflate.on('data', deflateOnData);
    ***REMOVED***

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      ***REMOVED***

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) {
        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
      ***REMOVED***

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint***REMOVED***_no_context_takeover`]) {
        this._deflate.reset();
      ***REMOVED***

      callback(null, data);
    ***REMOVED***);
  ***REMOVED***
***REMOVED***

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer***REMOVED*** chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
***REMOVED***

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer***REMOVED*** chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  ***REMOVED***

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);

  //
  // The choice to employ `zlib.reset()` over `zlib.close()` is dictated by the
  // fact that in Node.js versions prior to 13.10.0, the callback for
  // `zlib.flush()` is not called if `zlib.close()` is used. Utilizing
  // `zlib.reset()` ensures that either the callback is invoked or an error is
  // emitted.
  //
  this.reset();
***REMOVED***

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error***REMOVED*** err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;

  if (this[kError]) {
    this[kCallback](this[kError]);
    return;
  ***REMOVED***

  err[kStatusCode] = 1007;
  this[kCallback](err);
***REMOVED***
