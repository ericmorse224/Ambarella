/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const fs = require("graceful-fs");
const CachedInputFileSystem = require("./CachedInputFileSystem");
const ResolverFactory = require("./ResolverFactory");

/** @typedef {import("./PnpPlugin").PnpApiImpl***REMOVED*** PnpApi */
/** @typedef {import("./Resolver")***REMOVED*** Resolver */
/** @typedef {import("./Resolver").FileSystem***REMOVED*** FileSystem */
/** @typedef {import("./Resolver").ResolveCallback***REMOVED*** ResolveCallback */
/** @typedef {import("./Resolver").ResolveContext***REMOVED*** ResolveContext */
/** @typedef {import("./Resolver").ResolveRequest***REMOVED*** ResolveRequest */
/** @typedef {import("./ResolverFactory").Plugin***REMOVED*** Plugin */
/** @typedef {import("./ResolverFactory").UserResolveOptions***REMOVED*** ResolveOptions */
/** @typedef {{
 * (context: object, path: string, request: string, resolveContext: ResolveContext, callback: ResolveCallback): void;
 * (context: object, path: string, request: string, callback: ResolveCallback): void;
 * (path: string, request: string, resolveContext: ResolveContext, callback: ResolveCallback): void;
 * (path: string, request: string, callback: ResolveCallback): void;
 * ***REMOVED******REMOVED*** ResolveFunctionAsync
 */
/** @typedef {{
 * (context: object, path: string, request: string): string|false;
 * (path: string, request: string): string|false;
 * ***REMOVED******REMOVED*** ResolveFunction
 */

const nodeFileSystem = new CachedInputFileSystem(fs, 4000);

const nodeContext = {
	environments: ["node+es3+es5+process+native"]
***REMOVED***;

const asyncResolver = ResolverFactory.createResolver({
	conditionNames: ["node"],
	extensions: [".js", ".json", ".node"],
	fileSystem: nodeFileSystem
***REMOVED***);

/**
 * @type {ResolveFunctionAsync***REMOVED***
 */
const resolve =
	/**
	 * @param {object|string***REMOVED*** context
	 * @param {string***REMOVED*** path
	 * @param {string|ResolveContext|ResolveCallback***REMOVED*** request
	 * @param {ResolveContext|ResolveCallback=***REMOVED*** resolveContext
	 * @param {ResolveCallback=***REMOVED*** callback
	 */
	(context, path, request, resolveContext, callback) => {
		if (typeof context === "string") {
			callback = /** @type {ResolveCallback***REMOVED*** */ (resolveContext);
			resolveContext = /** @type {ResolveContext***REMOVED*** */ (request);
			request = path;
			path = context;
			context = nodeContext;
		***REMOVED***
		if (typeof callback !== "function") {
			callback = /** @type {ResolveCallback***REMOVED*** */ (resolveContext);
		***REMOVED***
		asyncResolver.resolve(
			context,
			path,
			/** @type {string***REMOVED*** */ (request),
			/** @type {ResolveContext***REMOVED*** */ (resolveContext),
			/** @type {ResolveCallback***REMOVED*** */ (callback)
		);
	***REMOVED***;

const syncResolver = ResolverFactory.createResolver({
	conditionNames: ["node"],
	extensions: [".js", ".json", ".node"],
	useSyncFileSystemCalls: true,
	fileSystem: nodeFileSystem
***REMOVED***);

/**
 * @type {ResolveFunction***REMOVED***
 */
const resolveSync =
	/**
	 * @param {object|string***REMOVED*** context
	 * @param {string***REMOVED*** path
	 * @param {string=***REMOVED*** request
	 */
	(context, path, request) => {
		if (typeof context === "string") {
			request = path;
			path = context;
			context = nodeContext;
		***REMOVED***
		return syncResolver.resolveSync(
			context,
			path,
			/** @type {string***REMOVED*** */ (request)
		);
	***REMOVED***;

/** @typedef {Omit<ResolveOptions, "fileSystem"> & Partial<Pick<ResolveOptions, "fileSystem">>***REMOVED*** ResolveOptionsOptionalFS */

/**
 * @param {ResolveOptionsOptionalFS***REMOVED*** options Resolver options
 * @returns {ResolveFunctionAsync***REMOVED*** Resolver function
 */
function create(options) {
	const resolver = ResolverFactory.createResolver({
		fileSystem: nodeFileSystem,
		...options
	***REMOVED***);
	/**
	 * @param {object|string***REMOVED*** context Custom context
	 * @param {string***REMOVED*** path Base path
	 * @param {string|ResolveContext|ResolveCallback***REMOVED*** request String to resolve
	 * @param {ResolveContext|ResolveCallback=***REMOVED*** resolveContext Resolve context
	 * @param {ResolveCallback=***REMOVED*** callback Result callback
	 */
	return function (context, path, request, resolveContext, callback) {
		if (typeof context === "string") {
			callback = /** @type {ResolveCallback***REMOVED*** */ (resolveContext);
			resolveContext = /** @type {ResolveContext***REMOVED*** */ (request);
			request = path;
			path = context;
			context = nodeContext;
		***REMOVED***
		if (typeof callback !== "function") {
			callback = /** @type {ResolveCallback***REMOVED*** */ (resolveContext);
		***REMOVED***
		resolver.resolve(
			context,
			path,
			/** @type {string***REMOVED*** */ (request),
			/** @type {ResolveContext***REMOVED*** */ (resolveContext),
			callback
		);
	***REMOVED***;
***REMOVED***

/**
 * @param {ResolveOptionsOptionalFS***REMOVED*** options Resolver options
 * @returns {ResolveFunction***REMOVED*** Resolver function
 */
function createSync(options) {
	const resolver = ResolverFactory.createResolver({
		useSyncFileSystemCalls: true,
		fileSystem: nodeFileSystem,
		...options
	***REMOVED***);
	/**
	 * @param {object|string***REMOVED*** context custom context
	 * @param {string***REMOVED*** path base path
	 * @param {string=***REMOVED*** request request to resolve
	 * @returns {string|false***REMOVED*** Resolved path or false
	 */
	return function (context, path, request) {
		if (typeof context === "string") {
			request = path;
			path = context;
			context = nodeContext;
		***REMOVED***
		return resolver.resolveSync(context, path, /** @type {string***REMOVED*** */ (request));
	***REMOVED***;
***REMOVED***

/**
 * @template A
 * @template B
 * @param {A***REMOVED*** obj input a
 * @param {B***REMOVED*** exports input b
 * @returns {A & B***REMOVED*** merged
 */
const mergeExports = (obj, exports) => {
	const descriptors = Object.getOwnPropertyDescriptors(exports);
	Object.defineProperties(obj, descriptors);
	return /** @type {A & B***REMOVED*** */ (Object.freeze(obj));
***REMOVED***;

module.exports = mergeExports(resolve, {
	get sync() {
		return resolveSync;
	***REMOVED***,
	create: mergeExports(create, {
		get sync() {
			return createSync;
		***REMOVED***
	***REMOVED***),
	ResolverFactory,
	CachedInputFileSystem,
	get CloneBasenamePlugin() {
		return require("./CloneBasenamePlugin");
	***REMOVED***,
	get LogInfoPlugin() {
		return require("./LogInfoPlugin");
	***REMOVED***,
	get forEachBail() {
		return require("./forEachBail");
	***REMOVED***
***REMOVED***);
