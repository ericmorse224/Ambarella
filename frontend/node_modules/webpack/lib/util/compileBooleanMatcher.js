/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

/**
 * @param {string***REMOVED*** str string
 * @returns {string***REMOVED*** quoted meta
 */
const quoteMeta = str => str.replace(/[-[\]\\/{***REMOVED***()*+?.^$|]/g, "\\$&");

/**
 * @param {string***REMOVED*** str string
 * @returns {string***REMOVED*** string
 */
const toSimpleString = str => {
	if (`${Number(str)***REMOVED***` === str) {
		return str;
	***REMOVED***
	return JSON.stringify(str);
***REMOVED***;

/**
 * @param {Record<string | number, boolean>***REMOVED*** map value map
 * @returns {boolean | ((value: string) => string)***REMOVED*** true/false, when unconditionally true/false, or a template function to determine the value at runtime
 */
const compileBooleanMatcher = map => {
	const positiveItems = Object.keys(map).filter(i => map[i]);
	const negativeItems = Object.keys(map).filter(i => !map[i]);
	if (positiveItems.length === 0) return false;
	if (negativeItems.length === 0) return true;
	return compileBooleanMatcherFromLists(positiveItems, negativeItems);
***REMOVED***;

/**
 * @param {string[]***REMOVED*** positiveItems positive items
 * @param {string[]***REMOVED*** negativeItems negative items
 * @returns {(value: string) => string***REMOVED*** a template function to determine the value at runtime
 */
const compileBooleanMatcherFromLists = (positiveItems, negativeItems) => {
	if (positiveItems.length === 0) return () => "false";
	if (negativeItems.length === 0) return () => "true";
	if (positiveItems.length === 1)
		return value => `${toSimpleString(positiveItems[0])***REMOVED*** == ${value***REMOVED***`;
	if (negativeItems.length === 1)
		return value => `${toSimpleString(negativeItems[0])***REMOVED*** != ${value***REMOVED***`;
	const positiveRegexp = itemsToRegexp(positiveItems);
	const negativeRegexp = itemsToRegexp(negativeItems);
	if (positiveRegexp.length <= negativeRegexp.length) {
		return value => `/^${positiveRegexp***REMOVED***$/.test(${value***REMOVED***)`;
	***REMOVED***
	return value => `!/^${negativeRegexp***REMOVED***$/.test(${value***REMOVED***)`;
***REMOVED***;

/**
 * @param {Set<string>***REMOVED*** itemsSet items set
 * @param {(str: string) => string | false***REMOVED*** getKey get key function
 * @param {(str: Array<string>) => boolean***REMOVED*** condition condition
 * @returns {Array<Array<string>>***REMOVED*** list of common items
 */
const popCommonItems = (itemsSet, getKey, condition) => {
	/** @type {Map<string, Array<string>>***REMOVED*** */
	const map = new Map();
	for (const item of itemsSet) {
		const key = getKey(item);
		if (key) {
			let list = map.get(key);
			if (list === undefined) {
				/** @type {Array<string>***REMOVED*** */
				list = [];
				map.set(key, list);
			***REMOVED***
			list.push(item);
		***REMOVED***
	***REMOVED***
	/** @type {Array<Array<string>>***REMOVED*** */
	const result = [];
	for (const list of map.values()) {
		if (condition(list)) {
			for (const item of list) {
				itemsSet.delete(item);
			***REMOVED***
			result.push(list);
		***REMOVED***
	***REMOVED***
	return result;
***REMOVED***;

/**
 * @param {Array<string>***REMOVED*** items items
 * @returns {string***REMOVED*** common prefix
 */
const getCommonPrefix = items => {
	let prefix = items[0];
	for (let i = 1; i < items.length; i++) {
		const item = items[i];
		for (let p = 0; p < prefix.length; p++) {
			if (item[p] !== prefix[p]) {
				prefix = prefix.slice(0, p);
				break;
			***REMOVED***
		***REMOVED***
	***REMOVED***
	return prefix;
***REMOVED***;

/**
 * @param {Array<string>***REMOVED*** items items
 * @returns {string***REMOVED*** common suffix
 */
const getCommonSuffix = items => {
	let suffix = items[0];
	for (let i = 1; i < items.length; i++) {
		const item = items[i];
		for (let p = item.length - 1, s = suffix.length - 1; s >= 0; p--, s--) {
			if (item[p] !== suffix[s]) {
				suffix = suffix.slice(s + 1);
				break;
			***REMOVED***
		***REMOVED***
	***REMOVED***
	return suffix;
***REMOVED***;

/**
 * @param {Array<string>***REMOVED*** itemsArr array of items
 * @returns {string***REMOVED*** regexp
 */
const itemsToRegexp = itemsArr => {
	if (itemsArr.length === 1) {
		return quoteMeta(itemsArr[0]);
	***REMOVED***
	/** @type {Array<string>***REMOVED*** */
	const finishedItems = [];

	// merge single char items: (a|b|c|d|ef) => ([abcd]|ef)
	let countOfSingleCharItems = 0;
	for (const item of itemsArr) {
		if (item.length === 1) {
			countOfSingleCharItems++;
		***REMOVED***
	***REMOVED***
	// special case for only single char items
	if (countOfSingleCharItems === itemsArr.length) {
		return `[${quoteMeta(itemsArr.sort().join(""))***REMOVED***]`;
	***REMOVED***
	const items = new Set(itemsArr.sort());
	if (countOfSingleCharItems > 2) {
		let singleCharItems = "";
		for (const item of items) {
			if (item.length === 1) {
				singleCharItems += item;
				items.delete(item);
			***REMOVED***
		***REMOVED***
		finishedItems.push(`[${quoteMeta(singleCharItems)***REMOVED***]`);
	***REMOVED***

	// special case for 2 items with common prefix/suffix
	if (finishedItems.length === 0 && items.size === 2) {
		const prefix = getCommonPrefix(itemsArr);
		const suffix = getCommonSuffix(
			itemsArr.map(item => item.slice(prefix.length))
		);
		if (prefix.length > 0 || suffix.length > 0) {
			return `${quoteMeta(prefix)***REMOVED***${itemsToRegexp(
				itemsArr.map(i => i.slice(prefix.length, -suffix.length || undefined))
			)***REMOVED***${quoteMeta(suffix)***REMOVED***`;
		***REMOVED***
	***REMOVED***

	// special case for 2 items with common suffix
	if (finishedItems.length === 0 && items.size === 2) {
		/** @type {Iterator<string>***REMOVED*** */
		const it = items[Symbol.iterator]();
		const a = it.next().value;
		const b = it.next().value;
		if (a.length > 0 && b.length > 0 && a.slice(-1) === b.slice(-1)) {
			return `${itemsToRegexp([a.slice(0, -1), b.slice(0, -1)])***REMOVED***${quoteMeta(
				a.slice(-1)
			)***REMOVED***`;
		***REMOVED***
	***REMOVED***

	// find common prefix: (a1|a2|a3|a4|b5) => (a(1|2|3|4)|b5)
	const prefixed = popCommonItems(
		items,
		item => (item.length >= 1 ? item[0] : false),
		list => {
			if (list.length >= 3) return true;
			if (list.length <= 1) return false;
			return list[0][1] === list[1][1];
		***REMOVED***
	);
	for (const prefixedItems of prefixed) {
		const prefix = getCommonPrefix(prefixedItems);
		finishedItems.push(
			`${quoteMeta(prefix)***REMOVED***${itemsToRegexp(
				prefixedItems.map(i => i.slice(prefix.length))
			)***REMOVED***`
		);
	***REMOVED***

	// find common suffix: (a1|b1|c1|d1|e2) => ((a|b|c|d)1|e2)
	const suffixed = popCommonItems(
		items,
		item => (item.length >= 1 ? item.slice(-1) : false),
		list => {
			if (list.length >= 3) return true;
			if (list.length <= 1) return false;
			return list[0].slice(-2) === list[1].slice(-2);
		***REMOVED***
	);
	for (const suffixedItems of suffixed) {
		const suffix = getCommonSuffix(suffixedItems);
		finishedItems.push(
			`${itemsToRegexp(
				suffixedItems.map(i => i.slice(0, -suffix.length))
			)***REMOVED***${quoteMeta(suffix)***REMOVED***`
		);
	***REMOVED***

	// TODO further optimize regexp, i. e.
	// use ranges: (1|2|3|4|a) => [1-4a]
	const conditional = finishedItems.concat(Array.from(items, quoteMeta));
	if (conditional.length === 1) return conditional[0];
	return `(${conditional.join("|")***REMOVED***)`;
***REMOVED***;

compileBooleanMatcher.fromLists = compileBooleanMatcherFromLists;
compileBooleanMatcher.itemsToRegexp = itemsToRegexp;
module.exports = compileBooleanMatcher;
