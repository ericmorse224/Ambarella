"use strict";

const path = require("path");

const mime = require("mime-types");

const parseRange = require("range-parser");

const getFilenameFromUrl = require("./utils/getFilenameFromUrl");

const {
  getHeaderNames,
  getHeaderFromRequest,
  getHeaderFromResponse,
  setHeaderForResponse,
  setStatusCode,
  send,
  sendError
***REMOVED*** = require("./utils/compatibleAPI");

const ready = require("./utils/ready");
/** @typedef {import("./index.js").NextFunction***REMOVED*** NextFunction */

/** @typedef {import("./index.js").IncomingMessage***REMOVED*** IncomingMessage */

/** @typedef {import("./index.js").ServerResponse***REMOVED*** ServerResponse */

/**
 * @param {string***REMOVED*** type
 * @param {number***REMOVED*** size
 * @param {import("range-parser").Range***REMOVED*** [range]
 * @returns {string***REMOVED***
 */


function getValueContentRangeHeader(type, size, range) {
  return `${type***REMOVED*** ${range ? `${range.start***REMOVED***-${range.end***REMOVED***` : "*"***REMOVED***/${size***REMOVED***`;
***REMOVED***
/**
 * @param {string | number***REMOVED*** title
 * @param {string***REMOVED*** body
 * @returns {string***REMOVED***
 */


function createHtmlDocument(title, body) {
  return `${"<!DOCTYPE html>\n" + '<html lang="en">\n' + "<head>\n" + '<meta charset="utf-8">\n' + "<title>"***REMOVED***${title***REMOVED***</title>\n` + `</head>\n` + `<body>\n` + `<pre>${body***REMOVED***</pre>\n` + `</body>\n` + `</html>\n`;
***REMOVED***

const BYTES_RANGE_REGEXP = /^ *bytes/i;
/**
 * @template {IncomingMessage***REMOVED*** Request
 * @template {ServerResponse***REMOVED*** Response
 * @param {import("./index.js").Context<Request, Response>***REMOVED*** context
 * @return {import("./index.js").Middleware<Request, Response>***REMOVED***
 */

function wrapper(context) {
  return async function middleware(req, res, next) {
    const acceptedMethods = context.options.methods || ["GET", "HEAD"]; // fixes #282. credit @cexoso. in certain edge situations res.locals is undefined.
    // eslint-disable-next-line no-param-reassign

    res.locals = res.locals || {***REMOVED***;

    if (req.method && !acceptedMethods.includes(req.method)) {
      await goNext();
      return;
    ***REMOVED***

    ready(context, processRequest, req);

    async function goNext() {
      if (!context.options.serverSideRender) {
        return next();
      ***REMOVED***

      return new Promise(resolve => {
        ready(context, () => {
          /** @type {any***REMOVED*** */
          // eslint-disable-next-line no-param-reassign
          res.locals.webpack = {
            devMiddleware: context
          ***REMOVED***;
          resolve(next());
        ***REMOVED***, req);
      ***REMOVED***);
    ***REMOVED***

    async function processRequest() {
      /** @type {import("./utils/getFilenameFromUrl").Extra***REMOVED*** */
      const extra = {***REMOVED***;
      const filename = getFilenameFromUrl(context,
      /** @type {string***REMOVED*** */
      req.url, extra);

      if (!filename) {
        await goNext();
        return;
      ***REMOVED***

      if (extra.errorCode) {
        if (extra.errorCode === 403) {
          context.logger.error(`Malicious path "${filename***REMOVED***".`);
        ***REMOVED***

        sendError(req, res, extra.errorCode);
        return;
      ***REMOVED***

      let {
        headers
      ***REMOVED*** = context.options;

      if (typeof headers === "function") {
        // @ts-ignore
        headers = headers(req, res, context);
      ***REMOVED***
      /**
       * @type {{key: string, value: string | number***REMOVED***[]***REMOVED***
       */


      const allHeaders = [];

      if (typeof headers !== "undefined") {
        if (!Array.isArray(headers)) {
          // eslint-disable-next-line guard-for-in
          for (const name in headers) {
            // @ts-ignore
            allHeaders.push({
              key: name,
              value: headers[name]
            ***REMOVED***);
          ***REMOVED***

          headers = allHeaders;
        ***REMOVED***

        headers.forEach(
        /**
         * @param {{key: string, value: any***REMOVED******REMOVED*** header
         */
        header => {
          setHeaderForResponse(res, header.key, header.value);
        ***REMOVED***);
      ***REMOVED***

      if (!getHeaderFromResponse(res, "Content-Type")) {
        // content-type name(like application/javascript; charset=utf-8) or false
        const contentType = mime.contentType(path.extname(filename)); // Only set content-type header if media type is known
        // https://tools.ietf.org/html/rfc7231#section-3.1.1.5

        if (contentType) {
          setHeaderForResponse(res, "Content-Type", contentType);
        ***REMOVED***
      ***REMOVED***

      if (!getHeaderFromResponse(res, "Accept-Ranges")) {
        setHeaderForResponse(res, "Accept-Ranges", "bytes");
      ***REMOVED***

      const rangeHeader = getHeaderFromRequest(req, "range");
      let start;
      let end;

      if (rangeHeader && BYTES_RANGE_REGEXP.test(rangeHeader)) {
        const size = await new Promise(resolve => {
          /** @type {import("fs").lstat***REMOVED*** */
          context.outputFileSystem.lstat(filename, (error, stats) => {
            if (error) {
              context.logger.error(error);
              return;
            ***REMOVED***

            resolve(stats.size);
          ***REMOVED***);
        ***REMOVED***);
        const parsedRanges = parseRange(size, rangeHeader, {
          combine: true
        ***REMOVED***);

        if (parsedRanges === -1) {
          const message = "Unsatisfiable range for 'Range' header.";
          context.logger.error(message);
          const existingHeaders = getHeaderNames(res);

          for (let i = 0; i < existingHeaders.length; i++) {
            res.removeHeader(existingHeaders[i]);
          ***REMOVED***

          setStatusCode(res, 416);
          setHeaderForResponse(res, "Content-Range", getValueContentRangeHeader("bytes", size));
          setHeaderForResponse(res, "Content-Type", "text/html; charset=utf-8");
          const document = createHtmlDocument(416, `Error: ${message***REMOVED***`);
          const byteLength = Buffer.byteLength(document);
          setHeaderForResponse(res, "Content-Length", Buffer.byteLength(document));
          send(req, res, document, byteLength);
          return;
        ***REMOVED*** else if (parsedRanges === -2) {
          context.logger.error("A malformed 'Range' header was provided. A regular response will be sent for this request.");
        ***REMOVED*** else if (parsedRanges.length > 1) {
          context.logger.error("A 'Range' header with multiple ranges was provided. Multiple ranges are not supported, so a regular response will be sent for this request.");
        ***REMOVED***

        if (parsedRanges !== -2 && parsedRanges.length === 1) {
          // Content-Range
          setStatusCode(res, 206);
          setHeaderForResponse(res, "Content-Range", getValueContentRangeHeader("bytes", size,
          /** @type {import("range-parser").Ranges***REMOVED*** */
          parsedRanges[0]));
          [{
            start,
            end
          ***REMOVED***] = parsedRanges;
        ***REMOVED***
      ***REMOVED***

      const isFsSupportsStream = typeof context.outputFileSystem.createReadStream === "function";
      let bufferOtStream;
      let byteLength;

      try {
        if (typeof start !== "undefined" && typeof end !== "undefined" && isFsSupportsStream) {
          bufferOtStream =
          /** @type {import("fs").createReadStream***REMOVED*** */
          context.outputFileSystem.createReadStream(filename, {
            start,
            end
          ***REMOVED***);
          byteLength = end - start + 1;
        ***REMOVED*** else {
          bufferOtStream =
          /** @type {import("fs").readFileSync***REMOVED*** */
          context.outputFileSystem.readFileSync(filename);
          ({
            byteLength
          ***REMOVED*** = bufferOtStream);
        ***REMOVED***
      ***REMOVED*** catch (_ignoreError) {
        await goNext();
        return;
      ***REMOVED***

      send(req, res, bufferOtStream, byteLength);
    ***REMOVED***
  ***REMOVED***;
***REMOVED***

module.exports = wrapper;