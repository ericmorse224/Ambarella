const EventEmitter = require('events').EventEmitter;
const childProcess = require('child_process');
const path = require('path');
const fs = require('fs');

const { Argument, humanReadableArgName ***REMOVED*** = require('./argument.js');
const { CommanderError ***REMOVED*** = require('./error.js');
const { Help ***REMOVED*** = require('./help.js');
const { Option, splitOptionFlags ***REMOVED*** = require('./option.js');
const { suggestSimilar ***REMOVED*** = require('./suggestSimilar');

// @ts-check

class Command extends EventEmitter {
  /**
   * Initialize a new `Command`.
   *
   * @param {string***REMOVED*** [name]
   */

  constructor(name) {
    super();
    /** @type {Command[]***REMOVED*** */
    this.commands = [];
    /** @type {Option[]***REMOVED*** */
    this.options = [];
    this.parent = null;
    this._allowUnknownOption = false;
    this._allowExcessArguments = true;
    /** @type {Argument[]***REMOVED*** */
    this._args = [];
    /** @type {string[]***REMOVED*** */
    this.args = []; // cli args with options removed
    this.rawArgs = [];
    this.processedArgs = []; // like .args but after custom processing and collecting variadic
    this._scriptPath = null;
    this._name = name || '';
    this._optionValues = {***REMOVED***;
    this._optionValueSources = {***REMOVED***; // default < config < env < cli
    this._storeOptionsAsProperties = false;
    this._actionHandler = null;
    this._executableHandler = false;
    this._executableFile = null; // custom name for executable
    this._defaultCommandName = null;
    this._exitCallback = null;
    this._aliases = [];
    this._combineFlagAndOptionalValue = true;
    this._description = '';
    this._argsDescription = undefined; // legacy
    this._enablePositionalOptions = false;
    this._passThroughOptions = false;
    this._lifeCycleHooks = {***REMOVED***; // a hash of arrays
    /** @type {boolean | string***REMOVED*** */
    this._showHelpAfterError = false;
    this._showSuggestionAfterError = false;

    // see .configureOutput() for docs
    this._outputConfiguration = {
      writeOut: (str) => process.stdout.write(str),
      writeErr: (str) => process.stderr.write(str),
      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,
      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,
      outputError: (str, write) => write(str)
    ***REMOVED***;

    this._hidden = false;
    this._hasHelpOption = true;
    this._helpFlags = '-h, --help';
    this._helpDescription = 'display help for command';
    this._helpShortFlag = '-h';
    this._helpLongFlag = '--help';
    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false
    this._helpCommandName = 'help';
    this._helpCommandnameAndArgs = 'help [command]';
    this._helpCommandDescription = 'display help for command';
    this._helpConfiguration = {***REMOVED***;
  ***REMOVED***

  /**
   * Copy settings that are useful to have in common across root command and subcommands.
   *
   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
   *
   * @param {Command***REMOVED*** sourceCommand
   * @return {Command***REMOVED*** returns `this` for executable command
   */
  copyInheritedSettings(sourceCommand) {
    this._outputConfiguration = sourceCommand._outputConfiguration;
    this._hasHelpOption = sourceCommand._hasHelpOption;
    this._helpFlags = sourceCommand._helpFlags;
    this._helpDescription = sourceCommand._helpDescription;
    this._helpShortFlag = sourceCommand._helpShortFlag;
    this._helpLongFlag = sourceCommand._helpLongFlag;
    this._helpCommandName = sourceCommand._helpCommandName;
    this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
    this._helpCommandDescription = sourceCommand._helpCommandDescription;
    this._helpConfiguration = sourceCommand._helpConfiguration;
    this._exitCallback = sourceCommand._exitCallback;
    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
    this._allowExcessArguments = sourceCommand._allowExcessArguments;
    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
    this._showHelpAfterError = sourceCommand._showHelpAfterError;
    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;

    return this;
  ***REMOVED***

  /**
   * Define a command.
   *
   * There are two styles of command: pay attention to where to put the description.
   *
   * @example
   * // Command implemented using action handler (description is supplied separately to `.command`)
   * program
   *   .command('clone <source> [destination]')
   *   .description('clone a repository into a newly created directory')
   *   .action((source, destination) => {
   *     console.log('clone command called');
   *   ***REMOVED***);
   *
   * // Command implemented using separate executable file (description is second parameter to `.command`)
   * program
   *   .command('start <service>', 'start named service')
   *   .command('stop [service]', 'stop named service, or all if no name supplied');
   *
   * @param {string***REMOVED*** nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
   * @param {Object|string***REMOVED*** [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
   * @param {Object***REMOVED*** [execOpts] - configuration options (for executable)
   * @return {Command***REMOVED*** returns new command for action handler, or `this` for executable command
   */

  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
    let desc = actionOptsOrExecDesc;
    let opts = execOpts;
    if (typeof desc === 'object' && desc !== null) {
      opts = desc;
      desc = null;
    ***REMOVED***
    opts = opts || {***REMOVED***;
    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);

    const cmd = this.createCommand(name);
    if (desc) {
      cmd.description(desc);
      cmd._executableHandler = true;
    ***REMOVED***
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden
    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor
    if (args) cmd.arguments(args);
    this.commands.push(cmd);
    cmd.parent = this;
    cmd.copyInheritedSettings(this);

    if (desc) return this;
    return cmd;
  ***REMOVED***;

  /**
   * Factory routine to create a new unattached command.
   *
   * See .command() for creating an attached subcommand, which uses this routine to
   * create the command. You can override createCommand to customise subcommands.
   *
   * @param {string***REMOVED*** [name]
   * @return {Command***REMOVED*** new command
   */

  createCommand(name) {
    return new Command(name);
  ***REMOVED***;

  /**
   * You can customise the help with a subclass of Help by overriding createHelp,
   * or by overriding Help properties using configureHelp().
   *
   * @return {Help***REMOVED***
   */

  createHelp() {
    return Object.assign(new Help(), this.configureHelp());
  ***REMOVED***;

  /**
   * You can customise the help by overriding Help properties using configureHelp(),
   * or with a subclass of Help by overriding createHelp().
   *
   * @param {Object***REMOVED*** [configuration] - configuration options
   * @return {Command|Object***REMOVED*** `this` command for chaining, or stored configuration
   */

  configureHelp(configuration) {
    if (configuration === undefined) return this._helpConfiguration;

    this._helpConfiguration = configuration;
    return this;
  ***REMOVED***

  /**
   * The default output goes to stdout and stderr. You can customise this for special
   * applications. You can also customise the display of errors by overriding outputError.
   *
   * The configuration properties are all functions:
   *
   *     // functions to change where being written, stdout and stderr
   *     writeOut(str)
   *     writeErr(str)
   *     // matching functions to specify width for wrapping help
   *     getOutHelpWidth()
   *     getErrHelpWidth()
   *     // functions based on what is being written out
   *     outputError(str, write) // used for displaying errors, and not used for displaying help
   *
   * @param {Object***REMOVED*** [configuration] - configuration options
   * @return {Command|Object***REMOVED*** `this` command for chaining, or stored configuration
   */

  configureOutput(configuration) {
    if (configuration === undefined) return this._outputConfiguration;

    Object.assign(this._outputConfiguration, configuration);
    return this;
  ***REMOVED***

  /**
   * Display the help or a custom message after an error occurs.
   *
   * @param {boolean|string***REMOVED*** [displayHelp]
   * @return {Command***REMOVED*** `this` command for chaining
   */
  showHelpAfterError(displayHelp = true) {
    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;
    this._showHelpAfterError = displayHelp;
    return this;
  ***REMOVED***

  /**
   * Display suggestion of similar commands for unknown commands, or options for unknown options.
   *
   * @param {boolean***REMOVED*** [displaySuggestion]
   * @return {Command***REMOVED*** `this` command for chaining
   */
  showSuggestionAfterError(displaySuggestion = true) {
    this._showSuggestionAfterError = !!displaySuggestion;
    return this;
  ***REMOVED***

  /**
   * Add a prepared subcommand.
   *
   * See .command() for creating an attached subcommand which inherits settings from its parent.
   *
   * @param {Command***REMOVED*** cmd - new subcommand
   * @param {Object***REMOVED*** [opts] - configuration options
   * @return {Command***REMOVED*** `this` command for chaining
   */

  addCommand(cmd, opts) {
    if (!cmd._name) throw new Error('Command passed to .addCommand() must have a name');

    // To keep things simple, block automatic name generation for deeply nested executables.
    // Fail fast and detect when adding rather than later when parsing.
    function checkExplicitNames(commandArray) {
      commandArray.forEach((cmd) => {
        if (cmd._executableHandler && !cmd._executableFile) {
          throw new Error(`Must specify executableFile for deeply nested executable: ${cmd.name()***REMOVED***`);
        ***REMOVED***
        checkExplicitNames(cmd.commands);
      ***REMOVED***);
    ***REMOVED***
    checkExplicitNames(cmd.commands);

    opts = opts || {***REMOVED***;
    if (opts.isDefault) this._defaultCommandName = cmd._name;
    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation

    this.commands.push(cmd);
    cmd.parent = this;
    return this;
  ***REMOVED***;

  /**
   * Factory routine to create a new unattached argument.
   *
   * See .argument() for creating an attached argument, which uses this routine to
   * create the argument. You can override createArgument to return a custom argument.
   *
   * @param {string***REMOVED*** name
   * @param {string***REMOVED*** [description]
   * @return {Argument***REMOVED*** new argument
   */

  createArgument(name, description) {
    return new Argument(name, description);
  ***REMOVED***;

  /**
   * Define argument syntax for command.
   *
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @example
   * program.argument('<input-file>');
   * program.argument('[output-file]');
   *
   * @param {string***REMOVED*** name
   * @param {string***REMOVED*** [description]
   * @param {Function|****REMOVED*** [fn] - custom argument processing function
   * @param {****REMOVED*** [defaultValue]
   * @return {Command***REMOVED*** `this` command for chaining
   */
  argument(name, description, fn, defaultValue) {
    const argument = this.createArgument(name, description);
    if (typeof fn === 'function') {
      argument.default(defaultValue).argParser(fn);
    ***REMOVED*** else {
      argument.default(fn);
    ***REMOVED***
    this.addArgument(argument);
    return this;
  ***REMOVED***

  /**
   * Define argument syntax for command, adding multiple at once (without descriptions).
   *
   * See also .argument().
   *
   * @example
   * program.arguments('<cmd> [env]');
   *
   * @param {string***REMOVED*** names
   * @return {Command***REMOVED*** `this` command for chaining
   */

  arguments(names) {
    names.split(/ +/).forEach((detail) => {
      this.argument(detail);
    ***REMOVED***);
    return this;
  ***REMOVED***;

  /**
   * Define argument syntax for command, adding a prepared argument.
   *
   * @param {Argument***REMOVED*** argument
   * @return {Command***REMOVED*** `this` command for chaining
   */
  addArgument(argument) {
    const previousArgument = this._args.slice(-1)[0];
    if (previousArgument && previousArgument.variadic) {
      throw new Error(`only the last argument can be variadic '${previousArgument.name()***REMOVED***'`);
    ***REMOVED***
    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {
      throw new Error(`a default value for a required argument is never used: '${argument.name()***REMOVED***'`);
    ***REMOVED***
    this._args.push(argument);
    return this;
  ***REMOVED***

  /**
   * Override default decision whether to add implicit help command.
   *
   *    addHelpCommand() // force on
   *    addHelpCommand(false); // force off
   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details
   *
   * @return {Command***REMOVED*** `this` command for chaining
   */

  addHelpCommand(enableOrNameAndArgs, description) {
    if (enableOrNameAndArgs === false) {
      this._addImplicitHelpCommand = false;
    ***REMOVED*** else {
      this._addImplicitHelpCommand = true;
      if (typeof enableOrNameAndArgs === 'string') {
        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];
        this._helpCommandnameAndArgs = enableOrNameAndArgs;
      ***REMOVED***
      this._helpCommandDescription = description || this._helpCommandDescription;
    ***REMOVED***
    return this;
  ***REMOVED***;

  /**
   * @return {boolean***REMOVED***
   * @api private
   */

  _hasImplicitHelpCommand() {
    if (this._addImplicitHelpCommand === undefined) {
      return this.commands.length && !this._actionHandler && !this._findCommand('help');
    ***REMOVED***
    return this._addImplicitHelpCommand;
  ***REMOVED***;

  /**
   * Add hook for life cycle event.
   *
   * @param {string***REMOVED*** event
   * @param {Function***REMOVED*** listener
   * @return {Command***REMOVED*** `this` command for chaining
   */

  hook(event, listener) {
    const allowedValues = ['preAction', 'postAction'];
    if (!allowedValues.includes(event)) {
      throw new Error(`Unexpected value for event passed to hook : '${event***REMOVED***'.
Expecting one of '${allowedValues.join("', '")***REMOVED***'`);
    ***REMOVED***
    if (this._lifeCycleHooks[event]) {
      this._lifeCycleHooks[event].push(listener);
    ***REMOVED*** else {
      this._lifeCycleHooks[event] = [listener];
    ***REMOVED***
    return this;
  ***REMOVED***

  /**
   * Register callback to use as replacement for calling process.exit.
   *
   * @param {Function***REMOVED*** [fn] optional callback which will be passed a CommanderError, defaults to throwing
   * @return {Command***REMOVED*** `this` command for chaining
   */

  exitOverride(fn) {
    if (fn) {
      this._exitCallback = fn;
    ***REMOVED*** else {
      this._exitCallback = (err) => {
        if (err.code !== 'commander.executeSubCommandAsync') {
          throw err;
        ***REMOVED*** else {
          // Async callback from spawn events, not useful to throw.
        ***REMOVED***
      ***REMOVED***;
    ***REMOVED***
    return this;
  ***REMOVED***;

  /**
   * Call process.exit, and _exitCallback if defined.
   *
   * @param {number***REMOVED*** exitCode exit code for using with process.exit
   * @param {string***REMOVED*** code an id string representing the error
   * @param {string***REMOVED*** message human-readable description of the error
   * @return never
   * @api private
   */

  _exit(exitCode, code, message) {
    if (this._exitCallback) {
      this._exitCallback(new CommanderError(exitCode, code, message));
      // Expecting this line is not reached.
    ***REMOVED***
    process.exit(exitCode);
  ***REMOVED***;

  /**
   * Register callback `fn` for the command.
   *
   * @example
   * program
   *   .command('serve')
   *   .description('start service')
   *   .action(function() {
   *      // do work here
   *   ***REMOVED***);
   *
   * @param {Function***REMOVED*** fn
   * @return {Command***REMOVED*** `this` command for chaining
   */

  action(fn) {
    const listener = (args) => {
      // The .action callback takes an extra parameter which is the command or options.
      const expectedArgsCount = this._args.length;
      const actionArgs = args.slice(0, expectedArgsCount);
      if (this._storeOptionsAsProperties) {
        actionArgs[expectedArgsCount] = this; // backwards compatible "options"
      ***REMOVED*** else {
        actionArgs[expectedArgsCount] = this.opts();
      ***REMOVED***
      actionArgs.push(this);

      return fn.apply(this, actionArgs);
    ***REMOVED***;
    this._actionHandler = listener;
    return this;
  ***REMOVED***;

  /**
   * Factory routine to create a new unattached option.
   *
   * See .option() for creating an attached option, which uses this routine to
   * create the option. You can override createOption to return a custom option.
   *
   * @param {string***REMOVED*** flags
   * @param {string***REMOVED*** [description]
   * @return {Option***REMOVED*** new option
   */

  createOption(flags, description) {
    return new Option(flags, description);
  ***REMOVED***;

  /**
   * Add an option.
   *
   * @param {Option***REMOVED*** option
   * @return {Command***REMOVED*** `this` command for chaining
   */
  addOption(option) {
    const oname = option.name();
    const name = option.attributeName();

    let defaultValue = option.defaultValue;

    // preassign default value for --no-*, [optional], <required>, or plain flag if boolean value
    if (option.negate || option.optional || option.required || typeof defaultValue === 'boolean') {
      // when --no-foo we make sure default is true, unless a --foo option is already defined
      if (option.negate) {
        const positiveLongFlag = option.long.replace(/^--no-/, '--');
        defaultValue = this._findOption(positiveLongFlag) ? this.getOptionValue(name) : true;
      ***REMOVED***
      // preassign only if we have a default
      if (defaultValue !== undefined) {
        this.setOptionValueWithSource(name, defaultValue, 'default');
      ***REMOVED***
    ***REMOVED***

    // register the option
    this.options.push(option);

    // handler for cli and env supplied values
    const handleOptionValue = (val, invalidValueMessage, valueSource) => {
      // Note: using closure to access lots of lexical scoped variables.
      const oldValue = this.getOptionValue(name);

      // custom processing
      if (val !== null && option.parseArg) {
        try {
          val = option.parseArg(val, oldValue === undefined ? defaultValue : oldValue);
        ***REMOVED*** catch (err) {
          if (err.code === 'commander.invalidArgument') {
            const message = `${invalidValueMessage***REMOVED*** ${err.message***REMOVED***`;
            this._displayError(err.exitCode, err.code, message);
          ***REMOVED***
          throw err;
        ***REMOVED***
      ***REMOVED*** else if (val !== null && option.variadic) {
        val = option._concatValue(val, oldValue);
      ***REMOVED***

      // unassigned or boolean value
      if (typeof oldValue === 'boolean' || typeof oldValue === 'undefined') {
        // if no value, negate false, and we have a default, then use it!
        if (val == null) {
          this.setOptionValueWithSource(name, option.negate ? false : defaultValue || true, valueSource);
        ***REMOVED*** else {
          this.setOptionValueWithSource(name, val, valueSource);
        ***REMOVED***
      ***REMOVED*** else if (val !== null) {
        // reassign
        this.setOptionValueWithSource(name, option.negate ? false : val, valueSource);
      ***REMOVED***
    ***REMOVED***;

    this.on('option:' + oname, (val) => {
      const invalidValueMessage = `error: option '${option.flags***REMOVED***' argument '${val***REMOVED***' is invalid.`;
      handleOptionValue(val, invalidValueMessage, 'cli');
    ***REMOVED***);

    if (option.envVar) {
      this.on('optionEnv:' + oname, (val) => {
        const invalidValueMessage = `error: option '${option.flags***REMOVED***' value '${val***REMOVED***' from env '${option.envVar***REMOVED***' is invalid.`;
        handleOptionValue(val, invalidValueMessage, 'env');
      ***REMOVED***);
    ***REMOVED***

    return this;
  ***REMOVED***

  /**
   * Internal implementation shared by .option() and .requiredOption()
   *
   * @api private
   */
  _optionEx(config, flags, description, fn, defaultValue) {
    const option = this.createOption(flags, description);
    option.makeOptionMandatory(!!config.mandatory);
    if (typeof fn === 'function') {
      option.default(defaultValue).argParser(fn);
    ***REMOVED*** else if (fn instanceof RegExp) {
      // deprecated
      const regex = fn;
      fn = (val, def) => {
        const m = regex.exec(val);
        return m ? m[0] : def;
      ***REMOVED***;
      option.default(defaultValue).argParser(fn);
    ***REMOVED*** else {
      option.default(fn);
    ***REMOVED***

    return this.addOption(option);
  ***REMOVED***

  /**
   * Define option with `flags`, `description` and optional
   * coercion `fn`.
   *
   * The `flags` string contains the short and/or long flags,
   * separated by comma, a pipe or space. The following are all valid
   * all will output this way when `--help` is used.
   *
   *     "-p, --pepper"
   *     "-p|--pepper"
   *     "-p --pepper"
   *
   * @example
   * // simple boolean defaulting to undefined
   * program.option('-p, --pepper', 'add pepper');
   *
   * program.pepper
   * // => undefined
   *
   * --pepper
   * program.pepper
   * // => true
   *
   * // simple boolean defaulting to true (unless non-negated option is also defined)
   * program.option('-C, --no-cheese', 'remove cheese');
   *
   * program.cheese
   * // => true
   *
   * --no-cheese
   * program.cheese
   * // => false
   *
   * // required argument
   * program.option('-C, --chdir <path>', 'change the working directory');
   *
   * --chdir /tmp
   * program.chdir
   * // => "/tmp"
   *
   * // optional argument
   * program.option('-c, --cheese [type]', 'add cheese [marble]');
   *
   * @param {string***REMOVED*** flags
   * @param {string***REMOVED*** [description]
   * @param {Function|****REMOVED*** [fn] - custom option processing function or default value
   * @param {****REMOVED*** [defaultValue]
   * @return {Command***REMOVED*** `this` command for chaining
   */

  option(flags, description, fn, defaultValue) {
    return this._optionEx({***REMOVED***, flags, description, fn, defaultValue);
  ***REMOVED***;

  /**
  * Add a required option which must have a value after parsing. This usually means
  * the option must be specified on the command line. (Otherwise the same as .option().)
  *
  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
  *
  * @param {string***REMOVED*** flags
  * @param {string***REMOVED*** [description]
  * @param {Function|****REMOVED*** [fn] - custom option processing function or default value
  * @param {****REMOVED*** [defaultValue]
  * @return {Command***REMOVED*** `this` command for chaining
  */

  requiredOption(flags, description, fn, defaultValue) {
    return this._optionEx({ mandatory: true ***REMOVED***, flags, description, fn, defaultValue);
  ***REMOVED***;

  /**
   * Alter parsing of short flags with optional values.
   *
   * @example
   * // for `.option('-f,--flag [value]'):
   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
   *
   * @param {Boolean***REMOVED*** [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.
   */
  combineFlagAndOptionalValue(combine = true) {
    this._combineFlagAndOptionalValue = !!combine;
    return this;
  ***REMOVED***;

  /**
   * Allow unknown options on the command line.
   *
   * @param {Boolean***REMOVED*** [allowUnknown=true] - if `true` or omitted, no error will be thrown
   * for unknown options.
   */
  allowUnknownOption(allowUnknown = true) {
    this._allowUnknownOption = !!allowUnknown;
    return this;
  ***REMOVED***;

  /**
   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
   *
   * @param {Boolean***REMOVED*** [allowExcess=true] - if `true` or omitted, no error will be thrown
   * for excess arguments.
   */
  allowExcessArguments(allowExcess = true) {
    this._allowExcessArguments = !!allowExcess;
    return this;
  ***REMOVED***;

  /**
   * Enable positional options. Positional means global options are specified before subcommands which lets
   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
   * The default behaviour is non-positional and global options may appear anywhere on the command line.
   *
   * @param {Boolean***REMOVED*** [positional=true]
   */
  enablePositionalOptions(positional = true) {
    this._enablePositionalOptions = !!positional;
    return this;
  ***REMOVED***;

  /**
   * Pass through options that come after command-arguments rather than treat them as command-options,
   * so actual command-options come before command-arguments. Turning this on for a subcommand requires
   * positional options to have been enabled on the program (parent commands).
   * The default behaviour is non-positional and options may appear before or after command-arguments.
   *
   * @param {Boolean***REMOVED*** [passThrough=true]
   * for unknown options.
   */
  passThroughOptions(passThrough = true) {
    this._passThroughOptions = !!passThrough;
    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');
    ***REMOVED***
    return this;
  ***REMOVED***;

  /**
    * Whether to store option values as properties on command object,
    * or store separately (specify false). In both cases the option values can be accessed using .opts().
    *
    * @param {boolean***REMOVED*** [storeAsProperties=true]
    * @return {Command***REMOVED*** `this` command for chaining
    */

  storeOptionsAsProperties(storeAsProperties = true) {
    this._storeOptionsAsProperties = !!storeAsProperties;
    if (this.options.length) {
      throw new Error('call .storeOptionsAsProperties() before adding options');
    ***REMOVED***
    return this;
  ***REMOVED***;

  /**
   * Retrieve option value.
   *
   * @param {string***REMOVED*** key
   * @return {Object***REMOVED*** value
   */

  getOptionValue(key) {
    if (this._storeOptionsAsProperties) {
      return this[key];
    ***REMOVED***
    return this._optionValues[key];
  ***REMOVED***;

  /**
   * Store option value.
   *
   * @param {string***REMOVED*** key
   * @param {Object***REMOVED*** value
   * @return {Command***REMOVED*** `this` command for chaining
   */

  setOptionValue(key, value) {
    if (this._storeOptionsAsProperties) {
      this[key] = value;
    ***REMOVED*** else {
      this._optionValues[key] = value;
    ***REMOVED***
    return this;
  ***REMOVED***;

  /**
   * Store option value and where the value came from.
    *
    * @param {string***REMOVED*** key
    * @param {Object***REMOVED*** value
    * @param {string***REMOVED*** source - expected values are default/config/env/cli
    * @return {Command***REMOVED*** `this` command for chaining
    */

  setOptionValueWithSource(key, value, source) {
    this.setOptionValue(key, value);
    this._optionValueSources[key] = source;
    return this;
  ***REMOVED***

  /**
    * Get source of option value.
    * Expected values are default | config | env | cli
    *
    * @param {string***REMOVED*** key
    * @return {string***REMOVED***
    */

  getOptionValueSource(key) {
    return this._optionValueSources[key];
  ***REMOVED***;

  /**
   * Get user arguments implied or explicit arguments.
   * Side-effects: set _scriptPath if args included application, and use that to set implicit command name.
   *
   * @api private
   */

  _prepareUserArgs(argv, parseOptions) {
    if (argv !== undefined && !Array.isArray(argv)) {
      throw new Error('first parameter to parse must be array or undefined');
    ***REMOVED***
    parseOptions = parseOptions || {***REMOVED***;

    // Default to using process.argv
    if (argv === undefined) {
      argv = process.argv;
      // @ts-ignore: unknown property
      if (process.versions && process.versions.electron) {
        parseOptions.from = 'electron';
      ***REMOVED***
    ***REMOVED***
    this.rawArgs = argv.slice();

    // make it a little easier for callers by supporting various argv conventions
    let userArgs;
    switch (parseOptions.from) {
      case undefined:
      case 'node':
        this._scriptPath = argv[1];
        userArgs = argv.slice(2);
        break;
      case 'electron':
        // @ts-ignore: unknown property
        if (process.defaultApp) {
          this._scriptPath = argv[1];
          userArgs = argv.slice(2);
        ***REMOVED*** else {
          userArgs = argv.slice(1);
        ***REMOVED***
        break;
      case 'user':
        userArgs = argv.slice(0);
        break;
      default:
        throw new Error(`unexpected parse option { from: '${parseOptions.from***REMOVED***' ***REMOVED***`);
    ***REMOVED***
    if (!this._scriptPath && require.main) {
      this._scriptPath = require.main.filename;
    ***REMOVED***

    // Guess name, used in usage in help.
    this._name = this._name || (this._scriptPath && path.basename(this._scriptPath, path.extname(this._scriptPath)));

    return userArgs;
  ***REMOVED***

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * The default expectation is that the arguments are from node and have the application as argv[0]
   * and the script being run in argv[1], with user parameters after that.
   *
   * @example
   * program.parse(process.argv);
   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
   * program.parse(my-args, { from: 'user' ***REMOVED***); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]***REMOVED*** [argv] - optional, defaults to process.argv
   * @param {Object***REMOVED*** [parseOptions] - optionally specify style of options with from: node/user/electron
   * @param {string***REMOVED*** [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
   * @return {Command***REMOVED*** `this` command for chaining
   */

  parse(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    this._parseCommand([], userArgs);

    return this;
  ***REMOVED***;

  /**
   * Parse `argv`, setting options and invoking commands when defined.
   *
   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
   *
   * The default expectation is that the arguments are from node and have the application as argv[0]
   * and the script being run in argv[1], with user parameters after that.
   *
   * @example
   * await program.parseAsync(process.argv);
   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
   * await program.parseAsync(my-args, { from: 'user' ***REMOVED***); // just user supplied arguments, nothing special about argv[0]
   *
   * @param {string[]***REMOVED*** [argv]
   * @param {Object***REMOVED*** [parseOptions]
   * @param {string***REMOVED*** parseOptions.from - where the args are from: 'node', 'user', 'electron'
   * @return {Promise***REMOVED***
   */

  async parseAsync(argv, parseOptions) {
    const userArgs = this._prepareUserArgs(argv, parseOptions);
    await this._parseCommand([], userArgs);

    return this;
  ***REMOVED***;

  /**
   * Execute a sub-command executable.
   *
   * @api private
   */

  _executeSubCommand(subcommand, args) {
    args = args.slice();
    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.
    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];

    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.
    this._checkForMissingMandatoryOptions();

    // Want the entry script as the reference for command name and directory for searching for other files.
    let scriptPath = this._scriptPath;
    // Fallback in case not set, due to how Command created or called.
    if (!scriptPath && require.main) {
      scriptPath = require.main.filename;
    ***REMOVED***

    let baseDir;
    try {
      const resolvedLink = fs.realpathSync(scriptPath);
      baseDir = path.dirname(resolvedLink);
    ***REMOVED*** catch (e) {
      baseDir = '.'; // dummy, probably not going to find executable!
    ***REMOVED***

    // name of the subcommand, like `pm-install`
    let bin = path.basename(scriptPath, path.extname(scriptPath)) + '-' + subcommand._name;
    if (subcommand._executableFile) {
      bin = subcommand._executableFile;
    ***REMOVED***

    const localBin = path.join(baseDir, bin);
    if (fs.existsSync(localBin)) {
      // prefer local `./<bin>` to bin in the $PATH
      bin = localBin;
    ***REMOVED*** else {
      // Look for source files.
      sourceExt.forEach((ext) => {
        if (fs.existsSync(`${localBin***REMOVED***${ext***REMOVED***`)) {
          bin = `${localBin***REMOVED***${ext***REMOVED***`;
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
    launchWithNode = sourceExt.includes(path.extname(bin));

    let proc;
    if (process.platform !== 'win32') {
      if (launchWithNode) {
        args.unshift(bin);
        // add executable arguments to spawn
        args = incrementNodeInspectorPort(process.execArgv).concat(args);

        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' ***REMOVED***);
      ***REMOVED*** else {
        proc = childProcess.spawn(bin, args, { stdio: 'inherit' ***REMOVED***);
      ***REMOVED***
    ***REMOVED*** else {
      args.unshift(bin);
      // add executable arguments to spawn
      args = incrementNodeInspectorPort(process.execArgv).concat(args);
      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' ***REMOVED***);
    ***REMOVED***

    const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
    signals.forEach((signal) => {
      // @ts-ignore
      process.on(signal, () => {
        if (proc.killed === false && proc.exitCode === null) {
          proc.kill(signal);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***);

    // By default terminate process when spawned process terminates.
    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!
    const exitCallback = this._exitCallback;
    if (!exitCallback) {
      proc.on('close', process.exit.bind(process));
    ***REMOVED*** else {
      proc.on('close', () => {
        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));
      ***REMOVED***);
    ***REMOVED***
    proc.on('error', (err) => {
      // @ts-ignore
      if (err.code === 'ENOENT') {
        const executableMissing = `'${bin***REMOVED***' does not exist
 - if '${subcommand._name***REMOVED***' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name`;
        throw new Error(executableMissing);
      // @ts-ignore
      ***REMOVED*** else if (err.code === 'EACCES') {
        throw new Error(`'${bin***REMOVED***' not executable`);
      ***REMOVED***
      if (!exitCallback) {
        process.exit(1);
      ***REMOVED*** else {
        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');
        wrappedError.nestedError = err;
        exitCallback(wrappedError);
      ***REMOVED***
    ***REMOVED***);

    // Store the reference to the child process
    this.runningCommand = proc;
  ***REMOVED***;

  /**
   * @api private
   */

  _dispatchSubcommand(commandName, operands, unknown) {
    const subCommand = this._findCommand(commandName);
    if (!subCommand) this.help({ error: true ***REMOVED***);

    if (subCommand._executableHandler) {
      this._executeSubCommand(subCommand, operands.concat(unknown));
    ***REMOVED*** else {
      return subCommand._parseCommand(operands, unknown);
    ***REMOVED***
  ***REMOVED***;

  /**
   * Check this.args against expected this._args.
   *
   * @api private
   */

  _checkNumberOfArguments() {
    // too few
    this._args.forEach((arg, i) => {
      if (arg.required && this.args[i] == null) {
        this.missingArgument(arg.name());
      ***REMOVED***
    ***REMOVED***);
    // too many
    if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {
      return;
    ***REMOVED***
    if (this.args.length > this._args.length) {
      this._excessArguments(this.args);
    ***REMOVED***
  ***REMOVED***;

  /**
   * Process this.args using this._args and save as this.processedArgs!
   *
   * @api private
   */

  _processArguments() {
    const myParseArg = (argument, value, previous) => {
      // Extra processing for nice error message on parsing failure.
      let parsedValue = value;
      if (value !== null && argument.parseArg) {
        try {
          parsedValue = argument.parseArg(value, previous);
        ***REMOVED*** catch (err) {
          if (err.code === 'commander.invalidArgument') {
            const message = `error: command-argument value '${value***REMOVED***' is invalid for argument '${argument.name()***REMOVED***'. ${err.message***REMOVED***`;
            this._displayError(err.exitCode, err.code, message);
          ***REMOVED***
          throw err;
        ***REMOVED***
      ***REMOVED***
      return parsedValue;
    ***REMOVED***;

    this._checkNumberOfArguments();

    const processedArgs = [];
    this._args.forEach((declaredArg, index) => {
      let value = declaredArg.defaultValue;
      if (declaredArg.variadic) {
        // Collect together remaining arguments for passing together as an array.
        if (index < this.args.length) {
          value = this.args.slice(index);
          if (declaredArg.parseArg) {
            value = value.reduce((processed, v) => {
              return myParseArg(declaredArg, v, processed);
            ***REMOVED***, declaredArg.defaultValue);
          ***REMOVED***
        ***REMOVED*** else if (value === undefined) {
          value = [];
        ***REMOVED***
      ***REMOVED*** else if (index < this.args.length) {
        value = this.args[index];
        if (declaredArg.parseArg) {
          value = myParseArg(declaredArg, value, declaredArg.defaultValue);
        ***REMOVED***
      ***REMOVED***
      processedArgs[index] = value;
    ***REMOVED***);
    this.processedArgs = processedArgs;
  ***REMOVED***

  /**
   * Once we have a promise we chain, but call synchronously until then.
   *
   * @param {Promise|undefined***REMOVED*** promise
   * @param {Function***REMOVED*** fn
   * @return {Promise|undefined***REMOVED***
   * @api private
   */

  _chainOrCall(promise, fn) {
    // thenable
    if (promise && promise.then && typeof promise.then === 'function') {
      // already have a promise, chain callback
      return promise.then(() => fn());
    ***REMOVED***
    // callback might return a promise
    return fn();
  ***REMOVED***

  /**
   *
   * @param {Promise|undefined***REMOVED*** promise
   * @param {string***REMOVED*** event
   * @return {Promise|undefined***REMOVED***
   * @api private
   */

  _chainOrCallHooks(promise, event) {
    let result = promise;
    const hooks = [];
    getCommandAndParents(this)
      .reverse()
      .filter(cmd => cmd._lifeCycleHooks[event] !== undefined)
      .forEach(hookedCommand => {
        hookedCommand._lifeCycleHooks[event].forEach((callback) => {
          hooks.push({ hookedCommand, callback ***REMOVED***);
        ***REMOVED***);
      ***REMOVED***);
    if (event === 'postAction') {
      hooks.reverse();
    ***REMOVED***

    hooks.forEach((hookDetail) => {
      result = this._chainOrCall(result, () => {
        return hookDetail.callback(hookDetail.hookedCommand, this);
      ***REMOVED***);
    ***REMOVED***);
    return result;
  ***REMOVED***

  /**
   * Process arguments in context of this command.
   * Returns action result, in case it is a promise.
   *
   * @api private
   */

  _parseCommand(operands, unknown) {
    const parsed = this.parseOptions(unknown);
    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env
    operands = operands.concat(parsed.operands);
    unknown = parsed.unknown;
    this.args = operands.concat(unknown);

    if (operands && this._findCommand(operands[0])) {
      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
    ***REMOVED***
    if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
      if (operands.length === 1) {
        this.help();
      ***REMOVED***
      return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);
    ***REMOVED***
    if (this._defaultCommandName) {
      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command
      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
    ***REMOVED***
    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
      // probably missing subcommand and no handler, user needs help (and exit)
      this.help({ error: true ***REMOVED***);
    ***REMOVED***

    outputHelpIfRequested(this, parsed.unknown);
    this._checkForMissingMandatoryOptions();

    // We do not always call this check to avoid masking a "better" error, like unknown command.
    const checkForUnknownOptions = () => {
      if (parsed.unknown.length > 0) {
        this.unknownOption(parsed.unknown[0]);
      ***REMOVED***
    ***REMOVED***;

    const commandEvent = `command:${this.name()***REMOVED***`;
    if (this._actionHandler) {
      checkForUnknownOptions();
      this._processArguments();

      let actionResult;
      actionResult = this._chainOrCallHooks(actionResult, 'preAction');
      actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));
      if (this.parent) this.parent.emit(commandEvent, operands, unknown); // legacy
      actionResult = this._chainOrCallHooks(actionResult, 'postAction');
      return actionResult;
    ***REMOVED***
    if (this.parent && this.parent.listenerCount(commandEvent)) {
      checkForUnknownOptions();
      this._processArguments();
      this.parent.emit(commandEvent, operands, unknown); // legacy
    ***REMOVED*** else if (operands.length) {
      if (this._findCommand('*')) { // legacy default command
        return this._dispatchSubcommand('*', operands, unknown);
      ***REMOVED***
      if (this.listenerCount('command:*')) {
        // skip option check, emit event for possible misspelling suggestion
        this.emit('command:*', operands, unknown);
      ***REMOVED*** else if (this.commands.length) {
        this.unknownCommand();
      ***REMOVED*** else {
        checkForUnknownOptions();
        this._processArguments();
      ***REMOVED***
    ***REMOVED*** else if (this.commands.length) {
      checkForUnknownOptions();
      // This command has subcommands and nothing hooked up at this level, so display help (and exit).
      this.help({ error: true ***REMOVED***);
    ***REMOVED*** else {
      checkForUnknownOptions();
      this._processArguments();
      // fall through for caller to handle after calling .parse()
    ***REMOVED***
  ***REMOVED***;

  /**
   * Find matching command.
   *
   * @api private
   */
  _findCommand(name) {
    if (!name) return undefined;
    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));
  ***REMOVED***;

  /**
   * Return an option matching `arg` if any.
   *
   * @param {string***REMOVED*** arg
   * @return {Option***REMOVED***
   * @api private
   */

  _findOption(arg) {
    return this.options.find(option => option.is(arg));
  ***REMOVED***;

  /**
   * Display an error message if a mandatory option does not have a value.
   * Lazy calling after checking for help flags from leaf subcommand.
   *
   * @api private
   */

  _checkForMissingMandatoryOptions() {
    // Walk up hierarchy so can call in subcommand after checking for displaying help.
    for (let cmd = this; cmd; cmd = cmd.parent) {
      cmd.options.forEach((anOption) => {
        if (anOption.mandatory && (cmd.getOptionValue(anOption.attributeName()) === undefined)) {
          cmd.missingMandatoryOptionValue(anOption);
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***;

  /**
   * Parse options from `argv` removing known options,
   * and return argv split into operands and unknown arguments.
   *
   * Examples:
   *
   *     argv => operands, unknown
   *     --known kkk op => [op], []
   *     op --known kkk => [op], []
   *     sub --unknown uuu op => [sub], [--unknown uuu op]
   *     sub -- --unknown uuu op => [sub --unknown uuu op], []
   *
   * @param {String[]***REMOVED*** argv
   * @return {{operands: String[], unknown: String[]***REMOVED******REMOVED***
   */

  parseOptions(argv) {
    const operands = []; // operands, not options or values
    const unknown = []; // first unknown option and remaining unknown args
    let dest = operands;
    const args = argv.slice();

    function maybeOption(arg) {
      return arg.length > 1 && arg[0] === '-';
    ***REMOVED***

    // parse options
    let activeVariadicOption = null;
    while (args.length) {
      const arg = args.shift();

      // literal
      if (arg === '--') {
        if (dest === unknown) dest.push(arg);
        dest.push(...args);
        break;
      ***REMOVED***

      if (activeVariadicOption && !maybeOption(arg)) {
        this.emit(`option:${activeVariadicOption.name()***REMOVED***`, arg);
        continue;
      ***REMOVED***
      activeVariadicOption = null;

      if (maybeOption(arg)) {
        const option = this._findOption(arg);
        // recognised option, call listener to assign value with possible custom processing
        if (option) {
          if (option.required) {
            const value = args.shift();
            if (value === undefined) this.optionMissingArgument(option);
            this.emit(`option:${option.name()***REMOVED***`, value);
          ***REMOVED*** else if (option.optional) {
            let value = null;
            // historical behaviour is optional value is following arg unless an option
            if (args.length > 0 && !maybeOption(args[0])) {
              value = args.shift();
            ***REMOVED***
            this.emit(`option:${option.name()***REMOVED***`, value);
          ***REMOVED*** else { // boolean flag
            this.emit(`option:${option.name()***REMOVED***`);
          ***REMOVED***
          activeVariadicOption = option.variadic ? option : null;
          continue;
        ***REMOVED***
      ***REMOVED***

      // Look for combo options following single dash, eat first one if known.
      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
        const option = this._findOption(`-${arg[1]***REMOVED***`);
        if (option) {
          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {
            // option with value following in same argument
            this.emit(`option:${option.name()***REMOVED***`, arg.slice(2));
          ***REMOVED*** else {
            // boolean option, emit and put back remainder of arg for further processing
            this.emit(`option:${option.name()***REMOVED***`);
            args.unshift(`-${arg.slice(2)***REMOVED***`);
          ***REMOVED***
          continue;
        ***REMOVED***
      ***REMOVED***

      // Look for known long flag with value, like --foo=bar
      if (/^--[^=]+=/.test(arg)) {
        const index = arg.indexOf('=');
        const option = this._findOption(arg.slice(0, index));
        if (option && (option.required || option.optional)) {
          this.emit(`option:${option.name()***REMOVED***`, arg.slice(index + 1));
          continue;
        ***REMOVED***
      ***REMOVED***

      // Not a recognised option by this command.
      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.

      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.
      if (maybeOption(arg)) {
        dest = unknown;
      ***REMOVED***

      // If using positionalOptions, stop processing our options at subcommand.
      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
        if (this._findCommand(arg)) {
          operands.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        ***REMOVED*** else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
          operands.push(arg);
          if (args.length > 0) operands.push(...args);
          break;
        ***REMOVED*** else if (this._defaultCommandName) {
          unknown.push(arg);
          if (args.length > 0) unknown.push(...args);
          break;
        ***REMOVED***
      ***REMOVED***

      // If using passThroughOptions, stop processing options at first command-argument.
      if (this._passThroughOptions) {
        dest.push(arg);
        if (args.length > 0) dest.push(...args);
        break;
      ***REMOVED***

      // add arg
      dest.push(arg);
    ***REMOVED***

    return { operands, unknown ***REMOVED***;
  ***REMOVED***;

  /**
   * Return an object containing options as key-value pairs
   *
   * @return {Object***REMOVED***
   */
  opts() {
    if (this._storeOptionsAsProperties) {
      // Preserve original behaviour so backwards compatible when still using properties
      const result = {***REMOVED***;
      const len = this.options.length;

      for (let i = 0; i < len; i++) {
        const key = this.options[i].attributeName();
        result[key] = key === this._versionOptionName ? this._version : this[key];
      ***REMOVED***
      return result;
    ***REMOVED***

    return this._optionValues;
  ***REMOVED***;

  /**
   * Internal bottleneck for handling of parsing errors.
   *
   * @api private
   */
  _displayError(exitCode, code, message) {
    this._outputConfiguration.outputError(`${message***REMOVED***\n`, this._outputConfiguration.writeErr);
    if (typeof this._showHelpAfterError === 'string') {
      this._outputConfiguration.writeErr(`${this._showHelpAfterError***REMOVED***\n`);
    ***REMOVED*** else if (this._showHelpAfterError) {
      this._outputConfiguration.writeErr('\n');
      this.outputHelp({ error: true ***REMOVED***);
    ***REMOVED***
    this._exit(exitCode, code, message);
  ***REMOVED***

  /**
   * Apply any option related environment variables, if option does
   * not have a value from cli or client code.
   *
   * @api private
   */
  _parseOptionsEnv() {
    this.options.forEach((option) => {
      if (option.envVar && option.envVar in process.env) {
        const optionKey = option.attributeName();
        // Priority check. Do not overwrite cli or options from unknown source (client-code).
        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {
          if (option.required || option.optional) { // option can take a value
            // keep very simple, optional always takes value
            this.emit(`optionEnv:${option.name()***REMOVED***`, process.env[option.envVar]);
          ***REMOVED*** else { // boolean
            // keep very simple, only care that envVar defined and not the value
            this.emit(`optionEnv:${option.name()***REMOVED***`);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***

  /**
   * Argument `name` is missing.
   *
   * @param {string***REMOVED*** name
   * @api private
   */

  missingArgument(name) {
    const message = `error: missing required argument '${name***REMOVED***'`;
    this._displayError(1, 'commander.missingArgument', message);
  ***REMOVED***;

  /**
   * `Option` is missing an argument.
   *
   * @param {Option***REMOVED*** option
   * @api private
   */

  optionMissingArgument(option) {
    const message = `error: option '${option.flags***REMOVED***' argument missing`;
    this._displayError(1, 'commander.optionMissingArgument', message);
  ***REMOVED***;

  /**
   * `Option` does not have a value, and is a mandatory option.
   *
   * @param {Option***REMOVED*** option
   * @api private
   */

  missingMandatoryOptionValue(option) {
    const message = `error: required option '${option.flags***REMOVED***' not specified`;
    this._displayError(1, 'commander.missingMandatoryOptionValue', message);
  ***REMOVED***;

  /**
   * Unknown option `flag`.
   *
   * @param {string***REMOVED*** flag
   * @api private
   */

  unknownOption(flag) {
    if (this._allowUnknownOption) return;
    let suggestion = '';

    if (flag.startsWith('--') && this._showSuggestionAfterError) {
      // Looping to pick up the global options too
      let candidateFlags = [];
      let command = this;
      do {
        const moreFlags = command.createHelp().visibleOptions(command)
          .filter(option => option.long)
          .map(option => option.long);
        candidateFlags = candidateFlags.concat(moreFlags);
        command = command.parent;
      ***REMOVED*** while (command && !command._enablePositionalOptions);
      suggestion = suggestSimilar(flag, candidateFlags);
    ***REMOVED***

    const message = `error: unknown option '${flag***REMOVED***'${suggestion***REMOVED***`;
    this._displayError(1, 'commander.unknownOption', message);
  ***REMOVED***;

  /**
   * Excess arguments, more than expected.
   *
   * @param {string[]***REMOVED*** receivedArgs
   * @api private
   */

  _excessArguments(receivedArgs) {
    if (this._allowExcessArguments) return;

    const expected = this._args.length;
    const s = (expected === 1) ? '' : 's';
    const forSubcommand = this.parent ? ` for '${this.name()***REMOVED***'` : '';
    const message = `error: too many arguments${forSubcommand***REMOVED***. Expected ${expected***REMOVED*** argument${s***REMOVED*** but got ${receivedArgs.length***REMOVED***.`;
    this._displayError(1, 'commander.excessArguments', message);
  ***REMOVED***;

  /**
   * Unknown command.
   *
   * @api private
   */

  unknownCommand() {
    const unknownName = this.args[0];
    let suggestion = '';

    if (this._showSuggestionAfterError) {
      const candidateNames = [];
      this.createHelp().visibleCommands(this).forEach((command) => {
        candidateNames.push(command.name());
        // just visible alias
        if (command.alias()) candidateNames.push(command.alias());
      ***REMOVED***);
      suggestion = suggestSimilar(unknownName, candidateNames);
    ***REMOVED***

    const message = `error: unknown command '${unknownName***REMOVED***'${suggestion***REMOVED***`;
    this._displayError(1, 'commander.unknownCommand', message);
  ***REMOVED***;

  /**
   * Set the program version to `str`.
   *
   * This method auto-registers the "-V, --version" flag
   * which will print the version number when passed.
   *
   * You can optionally supply the  flags and description to override the defaults.
   *
   * @param {string***REMOVED*** str
   * @param {string***REMOVED*** [flags]
   * @param {string***REMOVED*** [description]
   * @return {this | string***REMOVED*** `this` command for chaining, or version string if no arguments
   */

  version(str, flags, description) {
    if (str === undefined) return this._version;
    this._version = str;
    flags = flags || '-V, --version';
    description = description || 'output the version number';
    const versionOption = this.createOption(flags, description);
    this._versionOptionName = versionOption.attributeName();
    this.options.push(versionOption);
    this.on('option:' + versionOption.name(), () => {
      this._outputConfiguration.writeOut(`${str***REMOVED***\n`);
      this._exit(0, 'commander.version', str);
    ***REMOVED***);
    return this;
  ***REMOVED***;

  /**
   * Set the description to `str`.
   *
   * @param {string***REMOVED*** [str]
   * @param {Object***REMOVED*** [argsDescription]
   * @return {string|Command***REMOVED***
   */
  description(str, argsDescription) {
    if (str === undefined && argsDescription === undefined) return this._description;
    this._description = str;
    if (argsDescription) {
      this._argsDescription = argsDescription;
    ***REMOVED***
    return this;
  ***REMOVED***;

  /**
   * Set an alias for the command.
   *
   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
   *
   * @param {string***REMOVED*** [alias]
   * @return {string|Command***REMOVED***
   */

  alias(alias) {
    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility

    /** @type {Command***REMOVED*** */
    let command = this;
    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
      // assume adding alias for last added executable subcommand, rather than this
      command = this.commands[this.commands.length - 1];
    ***REMOVED***

    if (alias === command._name) throw new Error('Command alias can\'t be the same as its name');

    command._aliases.push(alias);
    return this;
  ***REMOVED***;

  /**
   * Set aliases for the command.
   *
   * Only the first alias is shown in the auto-generated help.
   *
   * @param {string[]***REMOVED*** [aliases]
   * @return {string[]|Command***REMOVED***
   */

  aliases(aliases) {
    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().
    if (aliases === undefined) return this._aliases;

    aliases.forEach((alias) => this.alias(alias));
    return this;
  ***REMOVED***;

  /**
   * Set / get the command usage `str`.
   *
   * @param {string***REMOVED*** [str]
   * @return {String|Command***REMOVED***
   */

  usage(str) {
    if (str === undefined) {
      if (this._usage) return this._usage;

      const args = this._args.map((arg) => {
        return humanReadableArgName(arg);
      ***REMOVED***);
      return [].concat(
        (this.options.length || this._hasHelpOption ? '[options]' : []),
        (this.commands.length ? '[command]' : []),
        (this._args.length ? args : [])
      ).join(' ');
    ***REMOVED***

    this._usage = str;
    return this;
  ***REMOVED***;

  /**
   * Get or set the name of the command
   *
   * @param {string***REMOVED*** [str]
   * @return {string|Command***REMOVED***
   */

  name(str) {
    if (str === undefined) return this._name;
    this._name = str;
    return this;
  ***REMOVED***;

  /**
   * Return program help documentation.
   *
   * @param {{ error: boolean ***REMOVED******REMOVED*** [contextOptions] - pass {error:true***REMOVED*** to wrap for stderr instead of stdout
   * @return {string***REMOVED***
   */

  helpInformation(contextOptions) {
    const helper = this.createHelp();
    if (helper.helpWidth === undefined) {
      helper.helpWidth = (contextOptions && contextOptions.error) ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
    ***REMOVED***
    return helper.formatHelp(this, helper);
  ***REMOVED***;

  /**
   * @api private
   */

  _getHelpContext(contextOptions) {
    contextOptions = contextOptions || {***REMOVED***;
    const context = { error: !!contextOptions.error ***REMOVED***;
    let write;
    if (context.error) {
      write = (arg) => this._outputConfiguration.writeErr(arg);
    ***REMOVED*** else {
      write = (arg) => this._outputConfiguration.writeOut(arg);
    ***REMOVED***
    context.write = contextOptions.write || write;
    context.command = this;
    return context;
  ***REMOVED***

  /**
   * Output help information for this command.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean ***REMOVED*** | Function***REMOVED*** [contextOptions] - pass {error:true***REMOVED*** to write to stderr instead of stdout
   */

  outputHelp(contextOptions) {
    let deprecatedCallback;
    if (typeof contextOptions === 'function') {
      deprecatedCallback = contextOptions;
      contextOptions = undefined;
    ***REMOVED***
    const context = this._getHelpContext(contextOptions);

    getCommandAndParents(this).reverse().forEach(command => command.emit('beforeAllHelp', context));
    this.emit('beforeHelp', context);

    let helpInformation = this.helpInformation(context);
    if (deprecatedCallback) {
      helpInformation = deprecatedCallback(helpInformation);
      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {
        throw new Error('outputHelp callback must return a string or a Buffer');
      ***REMOVED***
    ***REMOVED***
    context.write(helpInformation);

    this.emit(this._helpLongFlag); // deprecated
    this.emit('afterHelp', context);
    getCommandAndParents(this).forEach(command => command.emit('afterAllHelp', context));
  ***REMOVED***;

  /**
   * You can pass in flags and a description to override the help
   * flags and help description for your command. Pass in false to
   * disable the built-in help option.
   *
   * @param {string | boolean***REMOVED*** [flags]
   * @param {string***REMOVED*** [description]
   * @return {Command***REMOVED*** `this` command for chaining
   */

  helpOption(flags, description) {
    if (typeof flags === 'boolean') {
      this._hasHelpOption = flags;
      return this;
    ***REMOVED***
    this._helpFlags = flags || this._helpFlags;
    this._helpDescription = description || this._helpDescription;

    const helpFlags = splitOptionFlags(this._helpFlags);
    this._helpShortFlag = helpFlags.shortFlag;
    this._helpLongFlag = helpFlags.longFlag;

    return this;
  ***REMOVED***;

  /**
   * Output help information and exit.
   *
   * Outputs built-in help, and custom text added using `.addHelpText()`.
   *
   * @param {{ error: boolean ***REMOVED******REMOVED*** [contextOptions] - pass {error:true***REMOVED*** to write to stderr instead of stdout
   */

  help(contextOptions) {
    this.outputHelp(contextOptions);
    let exitCode = process.exitCode || 0;
    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {
      exitCode = 1;
    ***REMOVED***
    // message: do not have all displayed text available so only passing placeholder.
    this._exit(exitCode, 'commander.help', '(outputHelp)');
  ***REMOVED***;

  /**
   * Add additional text to be displayed with the built-in help.
   *
   * Position is 'before' or 'after' to affect just this command,
   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
   *
   * @param {string***REMOVED*** position - before or after built-in help
   * @param {string | Function***REMOVED*** text - string to add, or a function returning a string
   * @return {Command***REMOVED*** `this` command for chaining
   */
  addHelpText(position, text) {
    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];
    if (!allowedValues.includes(position)) {
      throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")***REMOVED***'`);
    ***REMOVED***
    const helpEvent = `${position***REMOVED***Help`;
    this.on(helpEvent, (context) => {
      let helpStr;
      if (typeof text === 'function') {
        helpStr = text({ error: context.error, command: context.command ***REMOVED***);
      ***REMOVED*** else {
        helpStr = text;
      ***REMOVED***
      // Ignore falsy value when nothing to output.
      if (helpStr) {
        context.write(`${helpStr***REMOVED***\n`);
      ***REMOVED***
    ***REMOVED***);
    return this;
  ***REMOVED***
***REMOVED***;

/**
 * Output help information if help flags specified
 *
 * @param {Command***REMOVED*** cmd - command to output help for
 * @param {Array***REMOVED*** args - array of options to search for help flags
 * @api private
 */

function outputHelpIfRequested(cmd, args) {
  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
  if (helpOption) {
    cmd.outputHelp();
    // (Do not have all displayed text available so only passing placeholder.)
    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');
  ***REMOVED***
***REMOVED***

/**
 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
 *
 * @param {string[]***REMOVED*** args - array of arguments from node.execArgv
 * @returns {string[]***REMOVED***
 * @api private
 */

function incrementNodeInspectorPort(args) {
  // Testing for these options:
  //  --inspect[=[host:]port]
  //  --inspect-brk[=[host:]port]
  //  --inspect-port=[host:]port
  return args.map((arg) => {
    if (!arg.startsWith('--inspect')) {
      return arg;
    ***REMOVED***
    let debugOption;
    let debugHost = '127.0.0.1';
    let debugPort = '9229';
    let match;
    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
      // e.g. --inspect
      debugOption = match[1];
    ***REMOVED*** else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
      debugOption = match[1];
      if (/^\d+$/.test(match[3])) {
        // e.g. --inspect=1234
        debugPort = match[3];
      ***REMOVED*** else {
        // e.g. --inspect=localhost
        debugHost = match[3];
      ***REMOVED***
    ***REMOVED*** else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
      // e.g. --inspect=localhost:1234
      debugOption = match[1];
      debugHost = match[3];
      debugPort = match[4];
    ***REMOVED***

    if (debugOption && debugPort !== '0') {
      return `${debugOption***REMOVED***=${debugHost***REMOVED***:${parseInt(debugPort) + 1***REMOVED***`;
    ***REMOVED***
    return arg;
  ***REMOVED***);
***REMOVED***

/**
 * @param {Command***REMOVED*** startCommand
 * @returns {Command[]***REMOVED***
 * @api private
 */

function getCommandAndParents(startCommand) {
  const result = [];
  for (let command = startCommand; command; command = command.parent) {
    result.push(command);
  ***REMOVED***
  return result;
***REMOVED***

exports.Command = Command;
