/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { DEFAULTS ***REMOVED*** = require("../config/defaults");
const {
	compareModulesByPreOrderIndexOrIdentifier
***REMOVED*** = require("../util/comparators");
const createSchemaValidation = require("../util/create-schema-validation");
const createHash = require("../util/createHash");
const {
	getUsedModuleIdsAndModules,
	getFullModuleName
***REMOVED*** = require("./IdHelpers");

/** @typedef {import("../../declarations/plugins/HashedModuleIdsPlugin").HashedModuleIdsPluginOptions***REMOVED*** HashedModuleIdsPluginOptions */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */

const validate = createSchemaValidation(
	require("../../schemas/plugins/HashedModuleIdsPlugin.check.js"),
	() => require("../../schemas/plugins/HashedModuleIdsPlugin.json"),
	{
		name: "Hashed Module Ids Plugin",
		baseDataPath: "options"
	***REMOVED***
);

const PLUGIN_NAME = "HashedModuleIdsPlugin";

class HashedModuleIdsPlugin {
	/**
	 * @param {HashedModuleIdsPluginOptions=***REMOVED*** options options object
	 */
	constructor(options = {***REMOVED***) {
		validate(options);

		/** @type {HashedModuleIdsPluginOptions***REMOVED*** */
		this.options = {
			context: undefined,
			hashFunction: DEFAULTS.HASH_FUNCTION,
			hashDigest: "base64",
			hashDigestLength: 4,
			...options
		***REMOVED***;
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {
			compilation.hooks.moduleIds.tap(PLUGIN_NAME, () => {
				const chunkGraph = compilation.chunkGraph;
				const context = this.options.context
					? this.options.context
					: compiler.context;

				const [usedIds, modules] = getUsedModuleIdsAndModules(compilation);
				const modulesInNaturalOrder = modules.sort(
					compareModulesByPreOrderIndexOrIdentifier(compilation.moduleGraph)
				);
				for (const module of modulesInNaturalOrder) {
					const ident = getFullModuleName(module, context, compiler.root);
					const hash = createHash(
						/** @type {NonNullable<HashedModuleIdsPluginOptions["hashFunction"]>***REMOVED*** */ (
							options.hashFunction
						)
					);
					hash.update(ident || "");
					const hashId = /** @type {string***REMOVED*** */ (
						hash.digest(options.hashDigest)
					);
					let len = options.hashDigestLength;
					while (usedIds.has(hashId.slice(0, len)))
						/** @type {number***REMOVED*** */ (len)++;
					const moduleId = hashId.slice(0, len);
					chunkGraph.setModuleId(module, moduleId);
					usedIds.add(moduleId);
				***REMOVED***
			***REMOVED***);
		***REMOVED***);
	***REMOVED***
***REMOVED***

module.exports = HashedModuleIdsPlugin;
