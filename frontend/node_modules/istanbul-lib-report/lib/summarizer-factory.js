/*
 Copyright 2012-2015, Yahoo Inc.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

const coverage = require('istanbul-lib-coverage');
const Path = require('./path');
const { BaseNode, BaseTree ***REMOVED*** = require('./tree');

class ReportNode extends BaseNode {
    constructor(path, fileCoverage) {
        super();

        this.path = path;
        this.parent = null;
        this.fileCoverage = fileCoverage;
        this.children = [];
    ***REMOVED***

    static createRoot(children) {
        const root = new ReportNode(new Path([]));

        children.forEach(child => {
            root.addChild(child);
        ***REMOVED***);

        return root;
    ***REMOVED***

    addChild(child) {
        child.parent = this;
        this.children.push(child);
    ***REMOVED***

    asRelative(p) {
        if (p.substring(0, 1) === '/') {
            return p.substring(1);
        ***REMOVED***
        return p;
    ***REMOVED***

    getQualifiedName() {
        return this.asRelative(this.path.toString());
    ***REMOVED***

    getRelativeName() {
        const parent = this.getParent();
        const myPath = this.path;
        let relPath;
        let i;
        const parentPath = parent ? parent.path : new Path([]);
        if (parentPath.ancestorOf(myPath)) {
            relPath = new Path(myPath.elements());
            for (i = 0; i < parentPath.length; i += 1) {
                relPath.shift();
            ***REMOVED***
            return this.asRelative(relPath.toString());
        ***REMOVED***
        return this.asRelative(this.path.toString());
    ***REMOVED***

    getParent() {
        return this.parent;
    ***REMOVED***

    getChildren() {
        return this.children;
    ***REMOVED***

    isSummary() {
        return !this.fileCoverage;
    ***REMOVED***

    getFileCoverage() {
        return this.fileCoverage;
    ***REMOVED***

    getCoverageSummary(filesOnly) {
        const cacheProp = `c_${filesOnly ? 'files' : 'full'***REMOVED***`;
        let summary;

        if (Object.prototype.hasOwnProperty.call(this, cacheProp)) {
            return this[cacheProp];
        ***REMOVED***

        if (!this.isSummary()) {
            summary = this.getFileCoverage().toSummary();
        ***REMOVED*** else {
            let count = 0;
            summary = coverage.createCoverageSummary();
            this.getChildren().forEach(child => {
                if (filesOnly && child.isSummary()) {
                    return;
                ***REMOVED***
                count += 1;
                summary.merge(child.getCoverageSummary(filesOnly));
            ***REMOVED***);
            if (count === 0 && filesOnly) {
                summary = null;
            ***REMOVED***
        ***REMOVED***
        this[cacheProp] = summary;
        return summary;
    ***REMOVED***
***REMOVED***

class ReportTree extends BaseTree {
    constructor(root, childPrefix) {
        super(root);

        const maybePrefix = node => {
            if (childPrefix && !node.isRoot()) {
                node.path.unshift(childPrefix);
            ***REMOVED***
        ***REMOVED***;
        this.visit({
            onDetail: maybePrefix,
            onSummary(node) {
                maybePrefix(node);
                node.children.sort((a, b) => {
                    const astr = a.path.toString();
                    const bstr = b.path.toString();
                    return astr < bstr
                        ? -1
                        : astr > bstr
                        ? 1
                        : /* istanbul ignore next */ 0;
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
***REMOVED***

function findCommonParent(paths) {
    return paths.reduce(
        (common, path) => common.commonPrefixPath(path),
        paths[0] || new Path([])
    );
***REMOVED***

function findOrCreateParent(parentPath, nodeMap, created = () => {***REMOVED***) {
    let parent = nodeMap[parentPath.toString()];

    if (!parent) {
        parent = new ReportNode(parentPath);
        nodeMap[parentPath.toString()] = parent;
        created(parentPath, parent);
    ***REMOVED***

    return parent;
***REMOVED***

function toDirParents(list) {
    const nodeMap = Object.create(null);
    list.forEach(o => {
        const parent = findOrCreateParent(o.path.parent(), nodeMap);
        parent.addChild(new ReportNode(o.path, o.fileCoverage));
    ***REMOVED***);

    return Object.values(nodeMap);
***REMOVED***

function addAllPaths(topPaths, nodeMap, path, node) {
    const parent = findOrCreateParent(
        path.parent(),
        nodeMap,
        (parentPath, parent) => {
            if (parentPath.hasParent()) {
                addAllPaths(topPaths, nodeMap, parentPath, parent);
            ***REMOVED*** else {
                topPaths.push(parent);
            ***REMOVED***
        ***REMOVED***
    );

    parent.addChild(node);
***REMOVED***

function foldIntoOneDir(node, parent) {
    const { children ***REMOVED*** = node;
    if (children.length === 1 && !children[0].fileCoverage) {
        children[0].parent = parent;
        return foldIntoOneDir(children[0], parent);
    ***REMOVED***
    node.children = children.map(child => foldIntoOneDir(child, node));
    return node;
***REMOVED***

function pkgSummaryPrefix(dirParents, commonParent) {
    if (!dirParents.some(dp => dp.path.length === 0)) {
        return;
    ***REMOVED***

    if (commonParent.length === 0) {
        return 'root';
    ***REMOVED***

    return commonParent.name();
***REMOVED***

class SummarizerFactory {
    constructor(coverageMap, defaultSummarizer = 'pkg') {
        this._coverageMap = coverageMap;
        this._defaultSummarizer = defaultSummarizer;
        this._initialList = coverageMap.files().map(filePath => ({
            filePath,
            path: new Path(filePath),
            fileCoverage: coverageMap.fileCoverageFor(filePath)
        ***REMOVED***));
        this._commonParent = findCommonParent(
            this._initialList.map(o => o.path.parent())
        );
        if (this._commonParent.length > 0) {
            this._initialList.forEach(o => {
                o.path.splice(0, this._commonParent.length);
            ***REMOVED***);
        ***REMOVED***
    ***REMOVED***

    get defaultSummarizer() {
        return this[this._defaultSummarizer];
    ***REMOVED***

    get flat() {
        if (!this._flat) {
            this._flat = new ReportTree(
                ReportNode.createRoot(
                    this._initialList.map(
                        node => new ReportNode(node.path, node.fileCoverage)
                    )
                )
            );
        ***REMOVED***

        return this._flat;
    ***REMOVED***

    _createPkg() {
        const dirParents = toDirParents(this._initialList);
        if (dirParents.length === 1) {
            return new ReportTree(dirParents[0]);
        ***REMOVED***

        return new ReportTree(
            ReportNode.createRoot(dirParents),
            pkgSummaryPrefix(dirParents, this._commonParent)
        );
    ***REMOVED***

    get pkg() {
        if (!this._pkg) {
            this._pkg = this._createPkg();
        ***REMOVED***

        return this._pkg;
    ***REMOVED***

    _createNested() {
        const nodeMap = Object.create(null);
        const topPaths = [];
        this._initialList.forEach(o => {
            const node = new ReportNode(o.path, o.fileCoverage);
            addAllPaths(topPaths, nodeMap, o.path, node);
        ***REMOVED***);

        const topNodes = topPaths.map(node => foldIntoOneDir(node));
        if (topNodes.length === 1) {
            return new ReportTree(topNodes[0]);
        ***REMOVED***

        return new ReportTree(ReportNode.createRoot(topNodes));
    ***REMOVED***

    get nested() {
        if (!this._nested) {
            this._nested = this._createNested();
        ***REMOVED***

        return this._nested;
    ***REMOVED***
***REMOVED***

module.exports = SummarizerFactory;
