/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra and Zackary Jackson @ScriptedAlchemy
*/

"use strict";

const WebpackError = require("../WebpackError");
const { parseOptions ***REMOVED*** = require("../container/options");
const createSchemaValidation = require("../util/create-schema-validation");
const ProvideForSharedDependency = require("./ProvideForSharedDependency");
const ProvideSharedDependency = require("./ProvideSharedDependency");
const ProvideSharedModuleFactory = require("./ProvideSharedModuleFactory");

/** @typedef {import("../../declarations/plugins/sharing/ProvideSharedPlugin").ProvideSharedPluginOptions***REMOVED*** ProvideSharedPluginOptions */
/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../NormalModuleFactory").NormalModuleCreateData***REMOVED*** NormalModuleCreateData */

const validate = createSchemaValidation(
	require("../../schemas/plugins/sharing/ProvideSharedPlugin.check.js"),
	() => require("../../schemas/plugins/sharing/ProvideSharedPlugin.json"),
	{
		name: "Provide Shared Plugin",
		baseDataPath: "options"
	***REMOVED***
);

/**
 * @typedef {object***REMOVED*** ProvideOptions
 * @property {string***REMOVED*** shareKey
 * @property {string***REMOVED*** shareScope
 * @property {string | undefined | false***REMOVED*** version
 * @property {boolean***REMOVED*** eager
 */

/** @typedef {Map<string, { config: ProvideOptions, version: string | undefined | false ***REMOVED***>***REMOVED*** ResolvedProvideMap */

const PLUGIN_NAME = "ProvideSharedPlugin";

class ProvideSharedPlugin {
	/**
	 * @param {ProvideSharedPluginOptions***REMOVED*** options options
	 */
	constructor(options) {
		validate(options);

		this._provides = /** @type {[string, ProvideOptions][]***REMOVED*** */ (
			parseOptions(
				options.provides,
				item => {
					if (Array.isArray(item))
						throw new Error("Unexpected array of provides");
					/** @type {ProvideOptions***REMOVED*** */
					const result = {
						shareKey: item,
						version: undefined,
						shareScope: options.shareScope || "default",
						eager: false
					***REMOVED***;
					return result;
				***REMOVED***,
				item => ({
					shareKey: item.shareKey,
					version: item.version,
					shareScope: item.shareScope || options.shareScope || "default",
					eager: Boolean(item.eager)
				***REMOVED***)
			)
		);
		this._provides.sort(([a], [b]) => {
			if (a < b) return -1;
			if (b < a) return 1;
			return 0;
		***REMOVED***);
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		/** @type {WeakMap<Compilation, ResolvedProvideMap>***REMOVED*** */
		const compilationData = new WeakMap();

		compiler.hooks.compilation.tap(
			PLUGIN_NAME,
			(compilation, { normalModuleFactory ***REMOVED***) => {
				/** @type {ResolvedProvideMap***REMOVED*** */
				const resolvedProvideMap = new Map();
				/** @type {Map<string, ProvideOptions>***REMOVED*** */
				const matchProvides = new Map();
				/** @type {Map<string, ProvideOptions>***REMOVED*** */
				const prefixMatchProvides = new Map();
				for (const [request, config] of this._provides) {
					if (/^(\/|[A-Za-z]:\\|\\\\|\.\.?(\/|$))/.test(request)) {
						// relative request
						resolvedProvideMap.set(request, {
							config,
							version: config.version
						***REMOVED***);
					***REMOVED*** else if (/^(\/|[A-Za-z]:\\|\\\\)/.test(request)) {
						// absolute path
						resolvedProvideMap.set(request, {
							config,
							version: config.version
						***REMOVED***);
					***REMOVED*** else if (request.endsWith("/")) {
						// module request prefix
						prefixMatchProvides.set(request, config);
					***REMOVED*** else {
						// module request
						matchProvides.set(request, config);
					***REMOVED***
				***REMOVED***
				compilationData.set(compilation, resolvedProvideMap);
				/**
				 * @param {string***REMOVED*** key key
				 * @param {ProvideOptions***REMOVED*** config config
				 * @param {NormalModuleCreateData["resource"]***REMOVED*** resource resource
				 * @param {NormalModuleCreateData["resourceResolveData"]***REMOVED*** resourceResolveData resource resolve data
				 */
				const provideSharedModule = (
					key,
					config,
					resource,
					resourceResolveData
				) => {
					let version = config.version;
					if (version === undefined) {
						let details = "";
						if (!resourceResolveData) {
							details = "No resolve data provided from resolver.";
						***REMOVED*** else {
							const descriptionFileData =
								resourceResolveData.descriptionFileData;
							if (!descriptionFileData) {
								details =
									"No description file (usually package.json) found. Add description file with name and version, or manually specify version in shared config.";
							***REMOVED*** else if (!descriptionFileData.version) {
								details = `No version in description file (usually package.json). Add version to description file ${resourceResolveData.descriptionFilePath***REMOVED***, or manually specify version in shared config.`;
							***REMOVED*** else {
								version = descriptionFileData.version;
							***REMOVED***
						***REMOVED***
						if (!version) {
							const error = new WebpackError(
								`No version specified and unable to automatically determine one. ${details***REMOVED***`
							);
							error.file = `shared module ${key***REMOVED*** -> ${resource***REMOVED***`;
							compilation.warnings.push(error);
						***REMOVED***
					***REMOVED***
					resolvedProvideMap.set(resource, {
						config,
						version
					***REMOVED***);
				***REMOVED***;
				normalModuleFactory.hooks.module.tap(
					PLUGIN_NAME,
					(module, { resource, resourceResolveData ***REMOVED***, resolveData) => {
						if (resolvedProvideMap.has(/** @type {string***REMOVED*** */ (resource))) {
							return module;
						***REMOVED***
						const { request ***REMOVED*** = resolveData;
						{
							const config = matchProvides.get(request);
							if (config !== undefined) {
								provideSharedModule(
									request,
									config,
									/** @type {string***REMOVED*** */ (resource),
									resourceResolveData
								);
								resolveData.cacheable = false;
							***REMOVED***
						***REMOVED***
						for (const [prefix, config] of prefixMatchProvides) {
							if (request.startsWith(prefix)) {
								const remainder = request.slice(prefix.length);
								provideSharedModule(
									/** @type {string***REMOVED*** */ (resource),
									{
										...config,
										shareKey: config.shareKey + remainder
									***REMOVED***,
									/** @type {string***REMOVED*** */ (resource),
									resourceResolveData
								);
								resolveData.cacheable = false;
							***REMOVED***
						***REMOVED***
						return module;
					***REMOVED***
				);
			***REMOVED***
		);
		compiler.hooks.finishMake.tapPromise(PLUGIN_NAME, compilation => {
			const resolvedProvideMap = compilationData.get(compilation);
			if (!resolvedProvideMap) return Promise.resolve();
			return Promise.all(
				Array.from(
					resolvedProvideMap,
					([resource, { config, version ***REMOVED***]) =>
						new Promise((resolve, reject) => {
							compilation.addInclude(
								compiler.context,
								new ProvideSharedDependency(
									config.shareScope,
									config.shareKey,
									version || false,
									resource,
									config.eager
								),
								{
									name: undefined
								***REMOVED***,
								err => {
									if (err) return reject(err);
									resolve(null);
								***REMOVED***
							);
						***REMOVED***)
				)
			).then(() => {***REMOVED***);
		***REMOVED***);

		compiler.hooks.compilation.tap(
			PLUGIN_NAME,
			(compilation, { normalModuleFactory ***REMOVED***) => {
				compilation.dependencyFactories.set(
					ProvideForSharedDependency,
					normalModuleFactory
				);

				compilation.dependencyFactories.set(
					ProvideSharedDependency,
					new ProvideSharedModuleFactory()
				);
			***REMOVED***
		);
	***REMOVED***
***REMOVED***

module.exports = ProvideSharedPlugin;
