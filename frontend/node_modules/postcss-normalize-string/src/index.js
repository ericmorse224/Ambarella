'use strict';
const valueParser = require('postcss-value-parser');

/*
 * Constants (parser usage)
 */

const SINGLE_QUOTE = "'".charCodeAt(0);
const DOUBLE_QUOTE = '"'.charCodeAt(0);
const BACKSLASH = '\\'.charCodeAt(0);
const NEWLINE = '\n'.charCodeAt(0);
const SPACE = ' '.charCodeAt(0);
const FEED = '\f'.charCodeAt(0);
const TAB = '\t'.charCodeAt(0);
const CR = '\r'.charCodeAt(0);

const WORD_END = /[ \n\t\r\f'"\\]/g;

/*
 * Constants (node type strings)
 */

const C_STRING = 'string';
const C_ESCAPED_SINGLE_QUOTE = 'escapedSingleQuote';
const C_ESCAPED_DOUBLE_QUOTE = 'escapedDoubleQuote';
const C_SINGLE_QUOTE = 'singleQuote';
const C_DOUBLE_QUOTE = 'doubleQuote';
const C_NEWLINE = 'newline';
const C_SINGLE = 'single';

/*
 * Literals
 */

const L_SINGLE_QUOTE = `'`;
const L_DOUBLE_QUOTE = `"`;
const L_NEWLINE = `\\\n`;

/*
 * Parser nodes
 */

const T_ESCAPED_SINGLE_QUOTE = { type: C_ESCAPED_SINGLE_QUOTE, value: `\\'` ***REMOVED***;
const T_ESCAPED_DOUBLE_QUOTE = { type: C_ESCAPED_DOUBLE_QUOTE, value: `\\"` ***REMOVED***;
const T_SINGLE_QUOTE = { type: C_SINGLE_QUOTE, value: L_SINGLE_QUOTE ***REMOVED***;
const T_DOUBLE_QUOTE = { type: C_DOUBLE_QUOTE, value: L_DOUBLE_QUOTE ***REMOVED***;
const T_NEWLINE = { type: C_NEWLINE, value: L_NEWLINE ***REMOVED***;

/** @typedef {T_ESCAPED_SINGLE_QUOTE | T_ESCAPED_DOUBLE_QUOTE | T_SINGLE_QUOTE | T_NEWLINE***REMOVED*** StringAstNode */
/**
 * @typedef {{nodes: StringAstNode[],
 *            types: {escapedSingleQuote: number, escapedDoubleQuote: number, singleQuote: number, doubleQuote: number***REMOVED***,
 *            quotes: boolean***REMOVED******REMOVED*** StringAst
 */

/**
 * @param {StringAst***REMOVED*** ast
 * @return {string***REMOVED***
 */
function stringify(ast) {
  return ast.nodes.reduce((str, { value ***REMOVED***) => {
    // Collapse multiple line strings automatically
    if (value === L_NEWLINE) {
      return str;
    ***REMOVED***

    return str + value;
  ***REMOVED***, '');
***REMOVED***

/**
 * @param {string***REMOVED*** str
 * @return {StringAst***REMOVED***
 */
function parse(str) {
  let code, next, value;
  let pos = 0;
  let len = str.length;

  /** @type StringAst */
  const ast = {
    nodes: [],
    types: {
      escapedSingleQuote: 0,
      escapedDoubleQuote: 0,
      singleQuote: 0,
      doubleQuote: 0,
    ***REMOVED***,
    quotes: false,
  ***REMOVED***;

  while (pos < len) {
    code = str.charCodeAt(pos);

    switch (code) {
      case SPACE:
      case TAB:
      case CR:
      case FEED:
        next = pos;

        do {
          next += 1;
          code = str.charCodeAt(next);
        ***REMOVED*** while (
          code === SPACE ||
          code === NEWLINE ||
          code === TAB ||
          code === CR ||
          code === FEED
        );

        ast.nodes.push({
          type: 'space',
          value: str.slice(pos, next),
        ***REMOVED***);
        pos = next - 1;
        break;
      case SINGLE_QUOTE:
        ast.nodes.push(T_SINGLE_QUOTE);
        ast.types[C_SINGLE_QUOTE]++;
        ast.quotes = true;
        break;
      case DOUBLE_QUOTE:
        ast.nodes.push(T_DOUBLE_QUOTE);
        ast.types[C_DOUBLE_QUOTE]++;
        ast.quotes = true;
        break;
      case BACKSLASH:
        next = pos + 1;

        if (str.charCodeAt(next) === SINGLE_QUOTE) {
          ast.nodes.push(T_ESCAPED_SINGLE_QUOTE);
          ast.types[C_ESCAPED_SINGLE_QUOTE]++;
          ast.quotes = true;
          pos = next;
          break;
        ***REMOVED*** else if (str.charCodeAt(next) === DOUBLE_QUOTE) {
          ast.nodes.push(T_ESCAPED_DOUBLE_QUOTE);
          ast.types[C_ESCAPED_DOUBLE_QUOTE]++;
          ast.quotes = true;
          pos = next;
          break;
        ***REMOVED*** else if (str.charCodeAt(next) === NEWLINE) {
          ast.nodes.push(T_NEWLINE);
          pos = next;
          break;
        ***REMOVED***
      /*
       * We need to fall through here to handle the token as
       * a whole word. The missing 'break' is intentional.
       */
      default:
        WORD_END.lastIndex = pos + 1;
        WORD_END.test(str);

        if (WORD_END.lastIndex === 0) {
          next = len - 1;
        ***REMOVED*** else {
          next = WORD_END.lastIndex - 2;
        ***REMOVED***

        value = str.slice(pos, next + 1);

        ast.nodes.push({
          type: C_STRING,
          value,
        ***REMOVED***);

        pos = next;
    ***REMOVED***
    pos++;
  ***REMOVED***

  return ast;
***REMOVED***

/**
 * @param {valueParser.StringNode***REMOVED*** node
 * @param {StringAst***REMOVED*** ast
 * @return {void***REMOVED***
 */
function changeWrappingQuotes(node, ast) {
  const { types ***REMOVED*** = ast;

  if (types[C_SINGLE_QUOTE] || types[C_DOUBLE_QUOTE]) {
    return;
  ***REMOVED***

  if (
    node.quote === L_SINGLE_QUOTE &&
    types[C_ESCAPED_SINGLE_QUOTE] > 0 &&
    !types[C_ESCAPED_DOUBLE_QUOTE]
  ) {
    node.quote = L_DOUBLE_QUOTE;
  ***REMOVED***

  if (
    node.quote === L_DOUBLE_QUOTE &&
    types[C_ESCAPED_DOUBLE_QUOTE] > 0 &&
    !types[C_ESCAPED_SINGLE_QUOTE]
  ) {
    node.quote = L_SINGLE_QUOTE;
  ***REMOVED***

  ast.nodes = changeChildQuotes(ast.nodes, node.quote);
***REMOVED***
/**
 * @param {StringAstNode[]***REMOVED*** childNodes
 * @param {string***REMOVED*** parentQuote
 * @return {StringAstNode[]***REMOVED***
 */
function changeChildQuotes(childNodes, parentQuote) {
  const updatedChildren = [];
  for (const child of childNodes) {
    if (
      child.type === C_ESCAPED_DOUBLE_QUOTE &&
      parentQuote === L_SINGLE_QUOTE
    ) {
      updatedChildren.push(T_DOUBLE_QUOTE);
    ***REMOVED*** else if (
      child.type === C_ESCAPED_SINGLE_QUOTE &&
      parentQuote === L_DOUBLE_QUOTE
    ) {
      updatedChildren.push(T_SINGLE_QUOTE);
    ***REMOVED*** else {
      updatedChildren.push(child);
    ***REMOVED***
  ***REMOVED***
  return updatedChildren;
***REMOVED***

/**
 * @param {string***REMOVED*** value
 * @param {'single' | 'double'***REMOVED*** preferredQuote
 * @return {string***REMOVED***
 */
function normalize(value, preferredQuote) {
  if (!value || !value.length) {
    return value;
  ***REMOVED***

  return valueParser(value)
    .walk((child) => {
      if (child.type !== C_STRING) {
        return;
      ***REMOVED***

      const ast = parse(child.value);

      if (ast.quotes) {
        changeWrappingQuotes(child, ast);
      ***REMOVED*** else if (preferredQuote === C_SINGLE) {
        child.quote = L_SINGLE_QUOTE;
      ***REMOVED*** else {
        child.quote = L_DOUBLE_QUOTE;
      ***REMOVED***

      child.value = stringify(ast);
    ***REMOVED***)
    .toString();
***REMOVED***

/**
 * @param {string***REMOVED*** original
 * @param {Map<string, string>***REMOVED*** cache
 * @param {'single' | 'double'***REMOVED*** preferredQuote
 * @return {string***REMOVED***
 */
function minify(original, cache, preferredQuote) {
  const key = original + '|' + preferredQuote;
  if (cache.has(key)) {
    return /** @type {string***REMOVED*** */ (cache.get(key));
  ***REMOVED***
  const newValue = normalize(original, preferredQuote);
  cache.set(key, newValue);
  return newValue;
***REMOVED***

/** @typedef {{preferredQuote?: 'double' | 'single'***REMOVED******REMOVED*** Options */
/**
 * @type {import('postcss').PluginCreator<Options>***REMOVED***
 * @param {Options***REMOVED*** opts
 * @return {import('postcss').Plugin***REMOVED***
 */
function pluginCreator(opts) {
  const { preferredQuote ***REMOVED*** = Object.assign(
    {***REMOVED***,
    {
      preferredQuote: 'double',
    ***REMOVED***,
    opts
  );

  return {
    postcssPlugin: 'postcss-normalize-string',

    OnceExit(css) {
      const cache = new Map();

      css.walk((node) => {
        switch (node.type) {
          case 'rule':
            node.selector = minify(node.selector, cache, preferredQuote);
            break;
          case 'decl':
            node.value = minify(node.value, cache, preferredQuote);
            break;
          case 'atrule':
            node.params = minify(node.params, cache, preferredQuote);
            break;
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***,
  ***REMOVED***;
***REMOVED***

pluginCreator.postcss = true;
module.exports = pluginCreator;
