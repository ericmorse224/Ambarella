// Generated by LiveScript 1.6.0
(function(){
  var parsedTypeCheck, types, toString$ = {***REMOVED***.toString;
  parsedTypeCheck = require('type-check').parsedTypeCheck;
  types = {
    '*': function(value, options){
      switch (toString$.call(value).slice(8, -1)) {
      case 'Array':
        return typeCast(value, {
          type: 'Array'
        ***REMOVED***, options);
      case 'Object':
        return typeCast(value, {
          type: 'Object'
        ***REMOVED***, options);
      default:
        return {
          type: 'Just',
          value: typesCast(value, [
            {
              type: 'Undefined'
            ***REMOVED***, {
              type: 'Null'
            ***REMOVED***, {
              type: 'NaN'
            ***REMOVED***, {
              type: 'Boolean'
            ***REMOVED***, {
              type: 'Number'
            ***REMOVED***, {
              type: 'Date'
            ***REMOVED***, {
              type: 'RegExp'
            ***REMOVED***, {
              type: 'Array'
            ***REMOVED***, {
              type: 'Object'
            ***REMOVED***, {
              type: 'String'
            ***REMOVED***
          ], (options.explicit = true, options))
        ***REMOVED***;
      ***REMOVED***
    ***REMOVED***,
    Undefined: function(it){
      if (it === 'undefined' || it === void 8) {
        return {
          type: 'Just',
          value: void 8
        ***REMOVED***;
      ***REMOVED*** else {
        return {
          type: 'Nothing'
        ***REMOVED***;
      ***REMOVED***
    ***REMOVED***,
    Null: function(it){
      if (it === 'null') {
        return {
          type: 'Just',
          value: null
        ***REMOVED***;
      ***REMOVED*** else {
        return {
          type: 'Nothing'
        ***REMOVED***;
      ***REMOVED***
    ***REMOVED***,
    NaN: function(it){
      if (it === 'NaN') {
        return {
          type: 'Just',
          value: NaN
        ***REMOVED***;
      ***REMOVED*** else {
        return {
          type: 'Nothing'
        ***REMOVED***;
      ***REMOVED***
    ***REMOVED***,
    Boolean: function(it){
      if (it === 'true') {
        return {
          type: 'Just',
          value: true
        ***REMOVED***;
      ***REMOVED*** else if (it === 'false') {
        return {
          type: 'Just',
          value: false
        ***REMOVED***;
      ***REMOVED*** else {
        return {
          type: 'Nothing'
        ***REMOVED***;
      ***REMOVED***
    ***REMOVED***,
    Number: function(it){
      return {
        type: 'Just',
        value: +it
      ***REMOVED***;
    ***REMOVED***,
    Int: function(it){
      return {
        type: 'Just',
        value: +it
      ***REMOVED***;
    ***REMOVED***,
    Float: function(it){
      return {
        type: 'Just',
        value: +it
      ***REMOVED***;
    ***REMOVED***,
    Date: function(value, options){
      var that;
      if (that = /^\#([\s\S]*)\#$/.exec(value)) {
        return {
          type: 'Just',
          value: new Date(+that[1] || that[1])
        ***REMOVED***;
      ***REMOVED*** else if (options.explicit) {
        return {
          type: 'Nothing'
        ***REMOVED***;
      ***REMOVED*** else {
        return {
          type: 'Just',
          value: new Date(+value || value)
        ***REMOVED***;
      ***REMOVED***
    ***REMOVED***,
    RegExp: function(value, options){
      var that;
      if (that = /^\/([\s\S]*)\/([gimy]*)$/.exec(value)) {
        return {
          type: 'Just',
          value: new RegExp(that[1], that[2])
        ***REMOVED***;
      ***REMOVED*** else if (options.explicit) {
        return {
          type: 'Nothing'
        ***REMOVED***;
      ***REMOVED*** else {
        return {
          type: 'Just',
          value: new RegExp(value)
        ***REMOVED***;
      ***REMOVED***
    ***REMOVED***,
    Array: function(value, options){
      return castArray(value, {
        of: [{
          type: '*'
        ***REMOVED***]
      ***REMOVED***, options);
    ***REMOVED***,
    Object: function(value, options){
      return castFields(value, {
        of: {***REMOVED***
      ***REMOVED***, options);
    ***REMOVED***,
    String: function(it){
      var replace, that;
      if (toString$.call(it).slice(8, -1) !== 'String') {
        return {
          type: 'Nothing'
        ***REMOVED***;
      ***REMOVED***
      replace = function(value, quote){
        return value.replace(/\\([^u]|u[0-9a-fA-F]{4***REMOVED***)/g, function(all, escaped){
          switch (escaped[0]) {
          case quote:
            return quote;
          case '\\':
            return '\\';
          case 'b':
            return '\b';
          case 'f':
            return '\f';
          case 'n':
            return '\n';
          case 'r':
            return '\r';
          case 't':
            return '\t';
          case 'u':
            return JSON.parse("\"" + all + "\"");
          default:
            return escaped;
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***;
      if (that = it.match(/^'([\s\S]*)'$/)) {
        return {
          type: 'Just',
          value: replace(that[1], "'")
        ***REMOVED***;
      ***REMOVED*** else if (that = it.match(/^"([\s\S]*)"$/)) {
        return {
          type: 'Just',
          value: replace(that[1], '"')
        ***REMOVED***;
      ***REMOVED*** else {
        return {
          type: 'Just',
          value: it
        ***REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;
  function castArray(node, type, options){
    var typeOf, element;
    if (toString$.call(node).slice(8, -1) !== 'Array') {
      return {
        type: 'Nothing'
      ***REMOVED***;
    ***REMOVED***
    typeOf = type.of;
    return {
      type: 'Just',
      value: (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = node).length; i$ < len$; ++i$) {
          element = ref$[i$];
          results$.push(typesCast(element, typeOf, options));
        ***REMOVED***
        return results$;
      ***REMOVED***())
    ***REMOVED***;
  ***REMOVED***
  function castTuple(node, type, options){
    var result, i, i$, ref$, len$, types, cast;
    if (toString$.call(node).slice(8, -1) !== 'Array') {
      return {
        type: 'Nothing'
      ***REMOVED***;
    ***REMOVED***
    result = [];
    i = 0;
    for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
      types = ref$[i$];
      cast = typesCast(node[i], types, options);
      if (toString$.call(cast).slice(8, -1) !== 'Undefined') {
        result.push(cast);
      ***REMOVED***
      i++;
    ***REMOVED***
    if (node.length <= i) {
      return {
        type: 'Just',
        value: result
      ***REMOVED***;
    ***REMOVED*** else {
      return {
        type: 'Nothing'
      ***REMOVED***;
    ***REMOVED***
  ***REMOVED***
  function castFields(node, type, options){
    var typeOf, key, value;
    if (toString$.call(node).slice(8, -1) !== 'Object') {
      return {
        type: 'Nothing'
      ***REMOVED***;
    ***REMOVED***
    typeOf = type.of;
    return {
      type: 'Just',
      value: (function(){
        var ref$, resultObj$ = {***REMOVED***;
        for (key in ref$ = node) {
          value = ref$[key];
          resultObj$[typesCast(key, [{
            type: 'String'
          ***REMOVED***], options)] = typesCast(value, typeOf[key] || [{
            type: '*'
          ***REMOVED***], options);
        ***REMOVED***
        return resultObj$;
      ***REMOVED***())
    ***REMOVED***;
  ***REMOVED***
  function typeCast(node, typeObj, options){
    var type, structure, castFunc, ref$;
    type = typeObj.type, structure = typeObj.structure;
    if (type) {
      castFunc = ((ref$ = options.customTypes[type]) != null ? ref$.cast : void 8) || types[type];
      if (!castFunc) {
        throw new Error("Type not defined: " + type + ".");
      ***REMOVED***
      return castFunc(node, options, typesCast);
    ***REMOVED*** else {
      switch (structure) {
      case 'array':
        return castArray(node, typeObj, options);
      case 'tuple':
        return castTuple(node, typeObj, options);
      case 'fields':
        return castFields(node, typeObj, options);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  function typesCast(node, types, options){
    var i$, len$, type, ref$, valueType, value;
    for (i$ = 0, len$ = types.length; i$ < len$; ++i$) {
      type = types[i$];
      ref$ = typeCast(node, type, options), valueType = ref$.type, value = ref$.value;
      if (valueType === 'Nothing') {
        continue;
      ***REMOVED***
      if (parsedTypeCheck([type], value, {
        customTypes: options.customTypes
      ***REMOVED***)) {
        return value;
      ***REMOVED***
    ***REMOVED***
    throw new Error("Value " + JSON.stringify(node) + " does not type check against " + JSON.stringify(types) + ".");
  ***REMOVED***
  module.exports = function(node, types, options){
    if (!options.explicit && types.length === 1 && types[0].type === 'String') {
      return node;
    ***REMOVED***
    return typesCast(node, types, options);
  ***REMOVED***;
***REMOVED***).call(this);
