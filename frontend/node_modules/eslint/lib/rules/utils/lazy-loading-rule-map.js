/**
 * @fileoverview `Map` to load rules lazily.
 * @author Toru Nagashima <https://github.com/mysticatea>
 */
"use strict";

const debug = require("debug")("eslint:rules");

/** @typedef {import("../../types").Rule.RuleModule***REMOVED*** Rule */

/**
 * The `Map` object that loads each rule when it's accessed.
 * @example
 * const rules = new LazyLoadingRuleMap([
 *     ["eqeqeq", () => require("eqeqeq")],
 *     ["semi", () => require("semi")],
 *     ["no-unused-vars", () => require("no-unused-vars")]
 * ]);
 *
 * rules.get("semi"); // call `() => require("semi")` here.
 *
 * @extends {Map<string, Rule>***REMOVED***
 */
class LazyLoadingRuleMap extends Map {
	/**
	 * Initialize this map.
	 * @param {Array<[string, function(): Rule]>***REMOVED*** loaders The rule loaders.
	 */
	constructor(loaders) {
		let remaining = loaders.length;

		super(
			debug.enabled
				? loaders.map(([ruleId, load]) => {
						let cache = null;

						return [
							ruleId,
							() => {
								if (!cache) {
									debug(
										"Loading rule %o (remaining=%d)",
										ruleId,
										--remaining,
									);
									cache = load();
								***REMOVED***
								return cache;
							***REMOVED***,
						];
					***REMOVED***)
				: loaders,
		);

		// `super(...iterable)` uses `this.set()`, so disable it here.
		Object.defineProperty(LazyLoadingRuleMap.prototype, "set", {
			configurable: true,
			value: void 0,
		***REMOVED***);
	***REMOVED***

	/**
	 * Get a rule.
	 * Each rule will be loaded on the first access.
	 * @param {string***REMOVED*** ruleId The rule ID to get.
	 * @returns {Rule|undefined***REMOVED*** The rule.
	 */
	get(ruleId) {
		const load = super.get(ruleId);

		return load && load();
	***REMOVED***

	/**
	 * Iterate rules.
	 * @returns {IterableIterator<Rule>***REMOVED*** Rules.
	 */
	*values() {
		for (const load of super.values()) {
			yield load();
		***REMOVED***
	***REMOVED***

	/**
	 * Iterate rules.
	 * @returns {IterableIterator<[string, Rule]>***REMOVED*** Rules.
	 */
	*entries() {
		for (const [ruleId, load] of super.entries()) {
			yield [ruleId, load()];
		***REMOVED***
	***REMOVED***

	/**
	 * Call a function with each rule.
	 * @param {Function***REMOVED*** callbackFn The callback function.
	 * @param {any***REMOVED*** [thisArg] The object to pass to `this` of the callback function.
	 * @returns {void***REMOVED***
	 */
	forEach(callbackFn, thisArg) {
		for (const [ruleId, load] of super.entries()) {
			callbackFn.call(thisArg, load(), ruleId, this);
		***REMOVED***
	***REMOVED***
***REMOVED***

// Forbid mutation.
Object.defineProperties(LazyLoadingRuleMap.prototype, {
	clear: { configurable: true, value: void 0 ***REMOVED***,
	delete: { configurable: true, value: void 0 ***REMOVED***,
	[Symbol.iterator]: {
		configurable: true,
		writable: true,
		value: LazyLoadingRuleMap.prototype.entries,
	***REMOVED***,
***REMOVED***);

module.exports = { LazyLoadingRuleMap ***REMOVED***;
