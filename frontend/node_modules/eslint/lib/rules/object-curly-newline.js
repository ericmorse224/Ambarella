/**
 * @fileoverview Rule to require or disallow line breaks inside braces.
 * @author Toru Nagashima
 * @deprecated in ESLint v8.53.0
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

// Schema objects.
const OPTION_VALUE = {
    oneOf: [
        {
            enum: ["always", "never"]
        ***REMOVED***,
        {
            type: "object",
            properties: {
                multiline: {
                    type: "boolean"
                ***REMOVED***,
                minProperties: {
                    type: "integer",
                    minimum: 0
                ***REMOVED***,
                consistent: {
                    type: "boolean"
                ***REMOVED***
            ***REMOVED***,
            additionalProperties: false,
            minProperties: 1
        ***REMOVED***
    ]
***REMOVED***;

/**
 * Normalizes a given option value.
 * @param {string|Object|undefined***REMOVED*** value An option value to parse.
 * @returns {{multiline: boolean, minProperties: number, consistent: boolean***REMOVED******REMOVED*** Normalized option object.
 */
function normalizeOptionValue(value) {
    let multiline = false;
    let minProperties = Number.POSITIVE_INFINITY;
    let consistent = false;

    if (value) {
        if (value === "always") {
            minProperties = 0;
        ***REMOVED*** else if (value === "never") {
            minProperties = Number.POSITIVE_INFINITY;
        ***REMOVED*** else {
            multiline = Boolean(value.multiline);
            minProperties = value.minProperties || Number.POSITIVE_INFINITY;
            consistent = Boolean(value.consistent);
        ***REMOVED***
    ***REMOVED*** else {
        consistent = true;
    ***REMOVED***

    return { multiline, minProperties, consistent ***REMOVED***;
***REMOVED***

/**
 * Checks if a value is an object.
 * @param {any***REMOVED*** value The value to check
 * @returns {boolean***REMOVED*** `true` if the value is an object, otherwise `false`
 */
function isObject(value) {
    return typeof value === "object" && value !== null;
***REMOVED***

/**
 * Checks if an option is a node-specific option
 * @param {any***REMOVED*** option The option to check
 * @returns {boolean***REMOVED*** `true` if the option is node-specific, otherwise `false`
 */
function isNodeSpecificOption(option) {
    return isObject(option) || typeof option === "string";
***REMOVED***

/**
 * Normalizes a given option value.
 * @param {string|Object|undefined***REMOVED*** options An option value to parse.
 * @returns {{
 *   ObjectExpression: {multiline: boolean, minProperties: number, consistent: boolean***REMOVED***,
 *   ObjectPattern: {multiline: boolean, minProperties: number, consistent: boolean***REMOVED***,
 *   ImportDeclaration: {multiline: boolean, minProperties: number, consistent: boolean***REMOVED***,
 *   ExportNamedDeclaration : {multiline: boolean, minProperties: number, consistent: boolean***REMOVED***
 * ***REMOVED******REMOVED*** Normalized option object.
 */
function normalizeOptions(options) {
    if (isObject(options) && Object.values(options).some(isNodeSpecificOption)) {
        return {
            ObjectExpression: normalizeOptionValue(options.ObjectExpression),
            ObjectPattern: normalizeOptionValue(options.ObjectPattern),
            ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),
            ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)
        ***REMOVED***;
    ***REMOVED***

    const value = normalizeOptionValue(options);

    return { ObjectExpression: value, ObjectPattern: value, ImportDeclaration: value, ExportNamedDeclaration: value ***REMOVED***;
***REMOVED***

/**
 * Determines if ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration
 * node needs to be checked for missing line breaks
 * @param {ASTNode***REMOVED*** node Node under inspection
 * @param {Object***REMOVED*** options option specific to node type
 * @param {Token***REMOVED*** first First object property
 * @param {Token***REMOVED*** last Last object property
 * @returns {boolean***REMOVED*** `true` if node needs to be checked for missing line breaks
 */
function areLineBreaksRequired(node, options, first, last) {
    let objectProperties;

    if (node.type === "ObjectExpression" || node.type === "ObjectPattern") {
        objectProperties = node.properties;
    ***REMOVED*** else {

        // is ImportDeclaration or ExportNamedDeclaration
        objectProperties = node.specifiers
            .filter(s => s.type === "ImportSpecifier" || s.type === "ExportSpecifier");
    ***REMOVED***

    return objectProperties.length >= options.minProperties ||
        (
            options.multiline &&
            objectProperties.length > 0 &&
            first.loc.start.line !== last.loc.end.line
        );
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule***REMOVED*** */
module.exports = {
    meta: {
        deprecated: true,
        replacedBy: [],
        type: "layout",

        docs: {
            description: "Enforce consistent line breaks after opening and before closing braces",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/object-curly-newline"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            {
                oneOf: [
                    OPTION_VALUE,
                    {
                        type: "object",
                        properties: {
                            ObjectExpression: OPTION_VALUE,
                            ObjectPattern: OPTION_VALUE,
                            ImportDeclaration: OPTION_VALUE,
                            ExportDeclaration: OPTION_VALUE
                        ***REMOVED***,
                        additionalProperties: false,
                        minProperties: 1
                    ***REMOVED***
                ]
            ***REMOVED***
        ],

        messages: {
            unexpectedLinebreakBeforeClosingBrace: "Unexpected line break before this closing brace.",
            unexpectedLinebreakAfterOpeningBrace: "Unexpected line break after this opening brace.",
            expectedLinebreakBeforeClosingBrace: "Expected a line break before this closing brace.",
            expectedLinebreakAfterOpeningBrace: "Expected a line break after this opening brace."
        ***REMOVED***
    ***REMOVED***,

    create(context) {
        const sourceCode = context.sourceCode;
        const normalizedOptions = normalizeOptions(context.options[0]);

        /**
         * Reports a given node if it violated this rule.
         * @param {ASTNode***REMOVED*** node A node to check. This is an ObjectExpression, ObjectPattern, ImportDeclaration or ExportNamedDeclaration node.
         * @returns {void***REMOVED***
         */
        function check(node) {
            const options = normalizedOptions[node.type];

            if (
                (node.type === "ImportDeclaration" &&
                    !node.specifiers.some(specifier => specifier.type === "ImportSpecifier")) ||
                (node.type === "ExportNamedDeclaration" &&
                    !node.specifiers.some(specifier => specifier.type === "ExportSpecifier"))
            ) {
                return;
            ***REMOVED***

            const openBrace = sourceCode.getFirstToken(node, token => token.value === "{");

            let closeBrace;

            if (node.typeAnnotation) {
                closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);
            ***REMOVED*** else {
                closeBrace = sourceCode.getLastToken(node, token => token.value === "***REMOVED***");
            ***REMOVED***

            let first = sourceCode.getTokenAfter(openBrace, { includeComments: true ***REMOVED***);
            let last = sourceCode.getTokenBefore(closeBrace, { includeComments: true ***REMOVED***);

            const needsLineBreaks = areLineBreaksRequired(node, options, first, last);

            const hasCommentsFirstToken = astUtils.isCommentToken(first);
            const hasCommentsLastToken = astUtils.isCommentToken(last);

            /*
             * Use tokens or comments to check multiline or not.
             * But use only tokens to check whether line breaks are needed.
             * This allows:
             *     var obj = { // eslint-disable-line foo
             *         a: 1
             *     ***REMOVED***
             */
            first = sourceCode.getTokenAfter(openBrace);
            last = sourceCode.getTokenBefore(closeBrace);

            if (needsLineBreaks) {
                if (astUtils.isTokenOnSameLine(openBrace, first)) {
                    context.report({
                        messageId: "expectedLinebreakAfterOpeningBrace",
                        node,
                        loc: openBrace.loc,
                        fix(fixer) {
                            if (hasCommentsFirstToken) {
                                return null;
                            ***REMOVED***

                            return fixer.insertTextAfter(openBrace, "\n");
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
                if (astUtils.isTokenOnSameLine(last, closeBrace)) {
                    context.report({
                        messageId: "expectedLinebreakBeforeClosingBrace",
                        node,
                        loc: closeBrace.loc,
                        fix(fixer) {
                            if (hasCommentsLastToken) {
                                return null;
                            ***REMOVED***

                            return fixer.insertTextBefore(closeBrace, "\n");
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED*** else {
                const consistent = options.consistent;
                const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);
                const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);

                if (
                    (!consistent && hasLineBreakBetweenOpenBraceAndFirst) ||
                    (consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast)
                ) {
                    context.report({
                        messageId: "unexpectedLinebreakAfterOpeningBrace",
                        node,
                        loc: openBrace.loc,
                        fix(fixer) {
                            if (hasCommentsFirstToken) {
                                return null;
                            ***REMOVED***

                            return fixer.removeRange([
                                openBrace.range[1],
                                first.range[0]
                            ]);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
                if (
                    (!consistent && hasLineBreakBetweenCloseBraceAndLast) ||
                    (consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast)
                ) {
                    context.report({
                        messageId: "unexpectedLinebreakBeforeClosingBrace",
                        node,
                        loc: closeBrace.loc,
                        fix(fixer) {
                            if (hasCommentsLastToken) {
                                return null;
                            ***REMOVED***

                            return fixer.removeRange([
                                last.range[1],
                                closeBrace.range[0]
                            ]);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        return {
            ObjectExpression: check,
            ObjectPattern: check,
            ImportDeclaration: check,
            ExportNamedDeclaration: check
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
