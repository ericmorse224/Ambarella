"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.default = void 0;

var _isSimpleType = _interopRequireDefault(require("./isSimpleType"));

var _needWrap = _interopRequireDefault(require("./needWrap"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj ***REMOVED***; ***REMOVED***

const schema = [{
  enum: ['verbose', 'shorthand'],
  type: 'string'
***REMOVED***];

const inlineType = type => {
  const inlined = type.replace(/\s+/ug, ' ');

  if (inlined.length <= 50) {
    return inlined;
  ***REMOVED***

  return 'Type';
***REMOVED***;

var _default = (defaultConfig, simpleType) => {
  const create = context => {
    const verbose = (context.options[0] || defaultConfig) === 'verbose';
    return {
      // shorthand
      ArrayTypeAnnotation(node) {
        const rawElementType = context.getSourceCode().getText(node.elementType);
        const inlinedType = inlineType(rawElementType);
        const wrappedInlinedType = (0, _needWrap.default)(node.elementType) ? '(' + inlinedType + ')' : inlinedType;

        if ((0, _isSimpleType.default)(node.elementType) === simpleType && verbose) {
          context.report({
            data: {
              type: inlinedType,
              wrappedType: wrappedInlinedType
            ***REMOVED***,

            fix(fixer) {
              return fixer.replaceText(node, 'Array<' + rawElementType + '>');
            ***REMOVED***,

            message: 'Use "Array<{{ type ***REMOVED******REMOVED***>", not "{{ wrappedType ***REMOVED******REMOVED***[]"',
            node
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***,

      // verbose
      GenericTypeAnnotation(node) {
        // Don't report on un-parameterized Array annotations. There are valid cases for this,
        // but regardless, we must NOT crash when encountering them.
        if (node.id.name === 'Array' && node.typeParameters && node.typeParameters.params.length === 1) {
          const elementTypeNode = node.typeParameters.params[0];
          const rawElementType = context.getSourceCode().getText(elementTypeNode);
          const inlinedType = inlineType(rawElementType);
          const wrappedInlinedType = (0, _needWrap.default)(elementTypeNode) ? '(' + inlinedType + ')' : inlinedType;

          if ((0, _isSimpleType.default)(elementTypeNode) === simpleType && !verbose) {
            context.report({
              data: {
                type: inlinedType,
                wrappedType: wrappedInlinedType
              ***REMOVED***,

              fix(fixer) {
                if ((0, _needWrap.default)(elementTypeNode)) {
                  return fixer.replaceText(node, '(' + rawElementType + ')[]');
                ***REMOVED***

                return fixer.replaceText(node, rawElementType + '[]');
              ***REMOVED***,

              message: 'Use "{{ wrappedType ***REMOVED******REMOVED***[]", not "Array<{{ type ***REMOVED******REMOVED***>"',
              node
            ***REMOVED***);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

    ***REMOVED***;
  ***REMOVED***;

  return {
    create,
    meta: {
      fixable: 'code'
    ***REMOVED***,
    schema
  ***REMOVED***;
***REMOVED***;

exports.default = _default;
module.exports = exports.default;