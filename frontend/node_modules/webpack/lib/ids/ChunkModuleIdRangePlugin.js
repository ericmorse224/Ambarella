/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { find ***REMOVED*** = require("../util/SetHelpers");
const {
	compareModulesByPreOrderIndexOrIdentifier,
	compareModulesByPostOrderIndexOrIdentifier
***REMOVED*** = require("../util/comparators");

/** @typedef {import("../Compiler")***REMOVED*** Compiler */

/**
 * @typedef {object***REMOVED*** ChunkModuleIdRangePluginOptions
 * @property {string***REMOVED*** name the chunk name
 * @property {("index" | "index2" | "preOrderIndex" | "postOrderIndex")=***REMOVED*** order order
 * @property {number=***REMOVED*** start start id
 * @property {number=***REMOVED*** end end id
 */

const PLUGIN_NAME = "ChunkModuleIdRangePlugin";

class ChunkModuleIdRangePlugin {
	/**
	 * @param {ChunkModuleIdRangePluginOptions***REMOVED*** options options object
	 */
	constructor(options) {
		this.options = options;
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		const options = this.options;
		compiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {
			const moduleGraph = compilation.moduleGraph;
			compilation.hooks.moduleIds.tap(PLUGIN_NAME, modules => {
				const chunkGraph = compilation.chunkGraph;
				const chunk = find(
					compilation.chunks,
					chunk => chunk.name === options.name
				);
				if (!chunk) {
					throw new Error(
						`${PLUGIN_NAME***REMOVED***: Chunk with name '${options.name***REMOVED***"' was not found`
					);
				***REMOVED***

				let chunkModules;
				if (options.order) {
					let cmpFn;
					switch (options.order) {
						case "index":
						case "preOrderIndex":
							cmpFn = compareModulesByPreOrderIndexOrIdentifier(moduleGraph);
							break;
						case "index2":
						case "postOrderIndex":
							cmpFn = compareModulesByPostOrderIndexOrIdentifier(moduleGraph);
							break;
						default:
							throw new Error(`${PLUGIN_NAME***REMOVED***: unexpected value of order`);
					***REMOVED***
					chunkModules = chunkGraph.getOrderedChunkModules(chunk, cmpFn);
				***REMOVED*** else {
					chunkModules = Array.from(modules)
						.filter(m => chunkGraph.isModuleInChunk(m, chunk))
						.sort(compareModulesByPreOrderIndexOrIdentifier(moduleGraph));
				***REMOVED***

				let currentId = options.start || 0;
				for (let i = 0; i < chunkModules.length; i++) {
					const m = chunkModules[i];
					if (m.needId && chunkGraph.getModuleId(m) === null) {
						chunkGraph.setModuleId(m, currentId++);
					***REMOVED***
					if (options.end && currentId > options.end) break;
				***REMOVED***
			***REMOVED***);
		***REMOVED***);
	***REMOVED***
***REMOVED***
module.exports = ChunkModuleIdRangePlugin;
