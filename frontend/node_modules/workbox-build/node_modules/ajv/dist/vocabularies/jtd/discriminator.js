"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const codegen_1 = require("../../compile/codegen");
const metadata_1 = require("./metadata");
const nullable_1 = require("./nullable");
const error_1 = require("./error");
const types_1 = require("../discriminator/types");
const error = {
    message: (cxt) => {
        const { schema, params ***REMOVED*** = cxt;
        return params.discrError
            ? params.discrError === types_1.DiscrError.Tag
                ? `tag "${schema***REMOVED***" must be string`
                : `value of tag "${schema***REMOVED***" must be in mapping`
            : (0, error_1.typeErrorMessage)(cxt, "object");
    ***REMOVED***,
    params: (cxt) => {
        const { schema, params ***REMOVED*** = cxt;
        return params.discrError
            ? (0, codegen_1._) `{error: ${params.discrError***REMOVED***, tag: ${schema***REMOVED***, tagValue: ${params.tag***REMOVED******REMOVED***`
            : (0, error_1.typeErrorParams)(cxt, "object");
    ***REMOVED***,
***REMOVED***;
const def = {
    keyword: "discriminator",
    schemaType: "string",
    implements: ["mapping"],
    error,
    code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen, data, schema, parentSchema ***REMOVED*** = cxt;
        const [valid, cond] = (0, nullable_1.checkNullableObject)(cxt, data);
        gen.if(cond);
        validateDiscriminator();
        gen.elseIf((0, codegen_1.not)(valid));
        cxt.error();
        gen.endIf();
        cxt.ok(valid);
        function validateDiscriminator() {
            const tag = gen.const("tag", (0, codegen_1._) `${data***REMOVED***${(0, codegen_1.getProperty)(schema)***REMOVED***`);
            gen.if((0, codegen_1._) `${tag***REMOVED*** === undefined`);
            cxt.error(false, { discrError: types_1.DiscrError.Tag, tag ***REMOVED***);
            gen.elseIf((0, codegen_1._) `typeof ${tag***REMOVED*** == "string"`);
            validateMapping(tag);
            gen.else();
            cxt.error(false, { discrError: types_1.DiscrError.Tag, tag ***REMOVED***, { instancePath: schema ***REMOVED***);
            gen.endIf();
        ***REMOVED***
        function validateMapping(tag) {
            gen.if(false);
            for (const tagValue in parentSchema.mapping) {
                gen.elseIf((0, codegen_1._) `${tag***REMOVED*** === ${tagValue***REMOVED***`);
                gen.assign(valid, applyTagSchema(tagValue));
            ***REMOVED***
            gen.else();
            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag ***REMOVED***, { instancePath: schema, schemaPath: "mapping", parentSchema: true ***REMOVED***);
            gen.endIf();
        ***REMOVED***
        function applyTagSchema(schemaProp) {
            const _valid = gen.name("valid");
            cxt.subschema({
                keyword: "mapping",
                schemaProp,
                jtdDiscriminator: schema,
            ***REMOVED***, _valid);
            return _valid;
        ***REMOVED***
    ***REMOVED***,
***REMOVED***;
exports.default = def;
//# sourceMappingURL=discriminator.js.map