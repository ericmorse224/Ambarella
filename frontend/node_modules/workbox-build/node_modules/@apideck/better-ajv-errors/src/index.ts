import { DefinedError, ErrorObject ***REMOVED*** from 'ajv';
import type { JSONSchema6 ***REMOVED*** from 'json-schema';
import { ValidationError ***REMOVED*** from './types/ValidationError';
import { filterSingleErrorPerProperty ***REMOVED*** from './lib/filter';
import { getSuggestion ***REMOVED*** from './lib/suggestions';
import { cleanAjvMessage, getLastSegment, pointerToDotNotation, safeJsonPointer ***REMOVED*** from './lib/utils';

export interface BetterAjvErrorsOptions {
  errors: ErrorObject[] | null | undefined;
  data: any;
  schema: JSONSchema6;
  basePath?: string;
***REMOVED***

export const betterAjvErrors = ({
  errors,
  data,
  schema,
  basePath = '{base***REMOVED***',
***REMOVED***: BetterAjvErrorsOptions): ValidationError[] => {
  if (!Array.isArray(errors) || errors.length === 0) {
    return [];
  ***REMOVED***

  const definedErrors = filterSingleErrorPerProperty(errors as DefinedError[]);

  return definedErrors.map((error) => {
    const path = pointerToDotNotation(basePath + error.instancePath);
    const prop = getLastSegment(error.instancePath);
    const defaultContext = {
      errorType: error.keyword,
    ***REMOVED***;
    const defaultMessage = `${prop ? `property '${prop***REMOVED***'` : path***REMOVED*** ${cleanAjvMessage(error.message as string)***REMOVED***`;

    let validationError: ValidationError;

    switch (error.keyword) {
      case 'additionalProperties': {
        const additionalProp = error.params.additionalProperty;
        const suggestionPointer = error.schemaPath.replace('#', '').replace('/additionalProperties', '');
        const { properties ***REMOVED*** = safeJsonPointer({
          object: schema,
          pnter: suggestionPointer,
          fallback: { properties: {***REMOVED*** ***REMOVED***,
        ***REMOVED***);
        validationError = {
          message: `'${additionalProp***REMOVED***' property is not expected to be here`,
          suggestion: getSuggestion({
            value: additionalProp,
            suggestions: Object.keys(properties ?? {***REMOVED***),
            format: (suggestion) => `Did you mean property '${suggestion***REMOVED***'?`,
          ***REMOVED***),
          path,
          context: defaultContext,
        ***REMOVED***;
        break;
      ***REMOVED***
      case 'enum': {
        const suggestions = error.params.allowedValues.map((value) => value.toString());
        const prop = getLastSegment(error.instancePath);
        const value = safeJsonPointer({ object: data, pnter: error.instancePath, fallback: '' ***REMOVED***);
        validationError = {
          message: `'${prop***REMOVED***' property must be equal to one of the allowed values`,
          suggestion: getSuggestion({
            value,
            suggestions,
          ***REMOVED***),
          path,
          context: {
            ...defaultContext,
            allowedValues: error.params.allowedValues,
          ***REMOVED***,
        ***REMOVED***;
        break;
      ***REMOVED***
      case 'type': {
        const prop = getLastSegment(error.instancePath);
        const type = error.params.type;
        validationError = {
          message: `'${prop***REMOVED***' property type must be ${type***REMOVED***`,
          path,
          context: defaultContext,
        ***REMOVED***;
        break;
      ***REMOVED***
      case 'required': {
        validationError = {
          message: `${path***REMOVED*** must have required property '${error.params.missingProperty***REMOVED***'`,
          path,
          context: defaultContext,
        ***REMOVED***;
        break;
      ***REMOVED***
      case 'const': {
        return {
          message: `'${prop***REMOVED***' property must be equal to the allowed value`,
          path,
          context: {
            ...defaultContext,
            allowedValue: error.params.allowedValue,
          ***REMOVED***,
        ***REMOVED***;
      ***REMOVED***

      default:
        return { message: defaultMessage, path, context: defaultContext ***REMOVED***;
    ***REMOVED***

    // Remove empty properties
    const errorEntries = Object.entries(validationError);
    for (const [key, value] of errorEntries as [keyof ValidationError, unknown][]) {
      if (value === null || value === undefined || value === '') {
        delete validationError[key];
      ***REMOVED***
    ***REMOVED***

    return validationError;
  ***REMOVED***);
***REMOVED***;

export { ValidationError ***REMOVED***;
