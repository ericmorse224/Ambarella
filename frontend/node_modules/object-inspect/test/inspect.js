var test = require('tape');
var hasSymbols = require('has-symbols/shams')();
var utilInspect = require('../util.inspect');
var repeat = require('string.prototype.repeat');

var inspect = require('..');

test('inspect', function (t) {
    t.plan(5);

    var obj = [{ inspect: function xyzInspect() { return '!XYZ¡'; ***REMOVED*** ***REMOVED***, []];
    var stringResult = '[ !XYZ¡, [] ]';
    var falseResult = '[ { inspect: [Function: xyzInspect] ***REMOVED***, [] ]';

    t.equal(inspect(obj), stringResult);
    t.equal(inspect(obj, { customInspect: true ***REMOVED***), stringResult);
    t.equal(inspect(obj, { customInspect: 'symbol' ***REMOVED***), falseResult);
    t.equal(inspect(obj, { customInspect: false ***REMOVED***), falseResult);
    t['throws'](
        function () { inspect(obj, { customInspect: 'not a boolean or "symbol"' ***REMOVED***); ***REMOVED***,
        TypeError,
        '`customInspect` must be a boolean or the string "symbol"'
    );
***REMOVED***);

test('inspect custom symbol', { skip: !hasSymbols || !utilInspect || !utilInspect.custom ***REMOVED***, function (t) {
    t.plan(4);

    var obj = { inspect: function stringInspect() { return 'string'; ***REMOVED*** ***REMOVED***;
    obj[utilInspect.custom] = function custom() { return 'symbol'; ***REMOVED***;

    var symbolResult = '[ symbol, [] ]';
    var stringResult = '[ string, [] ]';
    var falseResult = '[ { inspect: [Function: stringInspect]' + (utilInspect.custom ? ', [' + inspect(utilInspect.custom) + ']: [Function: custom]' : '') + ' ***REMOVED***, [] ]';

    var symbolStringFallback = utilInspect.custom ? symbolResult : stringResult;
    var symbolFalseFallback = utilInspect.custom ? symbolResult : falseResult;

    t.equal(inspect([obj, []]), symbolStringFallback);
    t.equal(inspect([obj, []], { customInspect: true ***REMOVED***), symbolStringFallback);
    t.equal(inspect([obj, []], { customInspect: 'symbol' ***REMOVED***), symbolFalseFallback);
    t.equal(inspect([obj, []], { customInspect: false ***REMOVED***), falseResult);
***REMOVED***);

test('symbols', { skip: !hasSymbols ***REMOVED***, function (t) {
    t.plan(2);

    var obj = { a: 1 ***REMOVED***;
    obj[Symbol('test')] = 2;
    obj[Symbol.iterator] = 3;
    Object.defineProperty(obj, Symbol('non-enum'), {
        enumerable: false,
        value: 4
    ***REMOVED***);

    if (typeof Symbol.iterator === 'symbol') {
        t.equal(inspect(obj), '{ a: 1, [Symbol(test)]: 2, [Symbol(Symbol.iterator)]: 3 ***REMOVED***', 'object with symbols');
        t.equal(inspect([obj, []]), '[ { a: 1, [Symbol(test)]: 2, [Symbol(Symbol.iterator)]: 3 ***REMOVED***, [] ]', 'object with symbols in array');
    ***REMOVED*** else {
        // symbol sham key ordering is unreliable
        t.match(
            inspect(obj),
            /^(?:{ a: 1, \[Symbol\(test\)\]: 2, \[Symbol\(Symbol.iterator\)\]: 3 ***REMOVED***|{ a: 1, \[Symbol\(Symbol.iterator\)\]: 3, \[Symbol\(test\)\]: 2 ***REMOVED***)$/,
            'object with symbols (nondeterministic symbol sham key ordering)'
        );
        t.match(
            inspect([obj, []]),
            /^\[ (?:{ a: 1, \[Symbol\(test\)\]: 2, \[Symbol\(Symbol.iterator\)\]: 3 ***REMOVED***|{ a: 1, \[Symbol\(Symbol.iterator\)\]: 3, \[Symbol\(test\)\]: 2 ***REMOVED***), \[\] \]$/,
            'object with symbols in array (nondeterministic symbol sham key ordering)'
        );
    ***REMOVED***
***REMOVED***);

test('maxStringLength', function (t) {
    t['throws'](
        function () { inspect('', { maxStringLength: -1 ***REMOVED***); ***REMOVED***,
        TypeError,
        'maxStringLength must be >= 0, or Infinity, not negative'
    );

    var str = repeat('a', 1e8);

    t.equal(
        inspect([str], { maxStringLength: 10 ***REMOVED***),
        '[ \'aaaaaaaaaa\'... 99999990 more characters ]',
        'maxStringLength option limits output'
    );

    t.equal(
        inspect(['f'], { maxStringLength: null ***REMOVED***),
        '[ \'\'... 1 more character ]',
        'maxStringLength option accepts `null`'
    );

    t.equal(
        inspect([str], { maxStringLength: Infinity ***REMOVED***),
        '[ \'' + str + '\' ]',
        'maxStringLength option accepts ∞'
    );

    t.end();
***REMOVED***);

test('inspect options', { skip: !utilInspect.custom ***REMOVED***, function (t) {
    var obj = {***REMOVED***;
    obj[utilInspect.custom] = function () {
        return JSON.stringify(arguments);
    ***REMOVED***;
    t.equal(
        inspect(obj),
        utilInspect(obj, { depth: 5 ***REMOVED***),
        'custom symbols will use node\'s inspect'
    );
    t.equal(
        inspect(obj, { depth: 2 ***REMOVED***),
        utilInspect(obj, { depth: 2 ***REMOVED***),
        'a reduced depth will be passed to node\'s inspect'
    );
    t.equal(
        inspect({ d1: obj ***REMOVED***, { depth: 3 ***REMOVED***),
        '{ d1: ' + utilInspect(obj, { depth: 2 ***REMOVED***) + ' ***REMOVED***',
        'deep objects will receive a reduced depth'
    );
    t.equal(
        inspect({ d1: obj ***REMOVED***, { depth: 1 ***REMOVED***),
        '{ d1: [Object] ***REMOVED***',
        'unlike nodejs inspect, customInspect will not be used once the depth is exceeded.'
    );
    t.end();
***REMOVED***);

test('inspect URL', { skip: typeof URL === 'undefined' ***REMOVED***, function (t) {
    t.match(
        inspect(new URL('https://nodejs.org')),
        /nodejs\.org/, // Different environments stringify it differently
        'url can be inspected'
    );
    t.end();
***REMOVED***);
