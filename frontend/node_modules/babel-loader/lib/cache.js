"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; ***REMOVED*** catch (error) { reject(error); return; ***REMOVED*** if (info.done) { resolve(value); ***REMOVED*** else { Promise.resolve(value).then(_next, _throw); ***REMOVED*** ***REMOVED***
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); ***REMOVED*** function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); ***REMOVED*** _next(undefined); ***REMOVED***); ***REMOVED***; ***REMOVED***
/**
 * Filesystem Cache
 *
 * Given a file and a transform function, cache the result into files
 * or retrieve the previously cached files if the given file is already known.
 *
 * @see https://github.com/babel/babel-loader/issues/34
 * @see https://github.com/babel/babel-loader/pull/41
 */
const fs = require("fs");
const os = require("os");
const path = require("path");
const zlib = require("zlib");
const crypto = require("crypto");
const findCacheDir = require("find-cache-dir");
const {
  promisify
***REMOVED*** = require("util");
const transform = require("./transform");
// Lazily instantiated when needed
let defaultCacheDirectory = null;
let hashType = "sha256";
// use md5 hashing if sha256 is not available
try {
  crypto.createHash(hashType);
***REMOVED*** catch (err) {
  hashType = "md5";
***REMOVED***
const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);
const gunzip = promisify(zlib.gunzip);
const gzip = promisify(zlib.gzip);
const makeDir = require("make-dir");

/**
 * Read the contents from the compressed file.
 *
 * @async
 * @params {String***REMOVED*** filename
 * @params {Boolean***REMOVED*** compress
 */
const read = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (filename, compress) {
    const data = yield readFile(filename + (compress ? ".gz" : ""));
    const content = compress ? yield gunzip(data) : data;
    return JSON.parse(content.toString());
  ***REMOVED***);
  return function read(_x, _x2) {
    return _ref.apply(this, arguments);
  ***REMOVED***;
***REMOVED***();

/**
 * Write contents into a compressed file.
 *
 * @async
 * @params {String***REMOVED*** filename
 * @params {Boolean***REMOVED*** compress
 * @params {String***REMOVED*** result
 */
const write = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(function* (filename, compress, result) {
    const content = JSON.stringify(result);
    const data = compress ? yield gzip(content) : content;
    return yield writeFile(filename + (compress ? ".gz" : ""), data);
  ***REMOVED***);
  return function write(_x3, _x4, _x5) {
    return _ref2.apply(this, arguments);
  ***REMOVED***;
***REMOVED***();

/**
 * Build the filename for the cached file
 *
 * @params {String***REMOVED*** source  File source code
 * @params {Object***REMOVED*** options Options used
 *
 * @return {String***REMOVED***
 */
const filename = function (source, identifier, options) {
  const hash = crypto.createHash(hashType);
  const contents = JSON.stringify({
    source,
    options,
    identifier
  ***REMOVED***);
  hash.update(contents);
  return hash.digest("hex") + ".json";
***REMOVED***;

/**
 * Handle the cache
 *
 * @params {String***REMOVED*** directory
 * @params {Object***REMOVED*** params
 */
const handleCache = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator(function* (directory, params) {
    const {
      source,
      options = {***REMOVED***,
      cacheIdentifier,
      cacheDirectory,
      cacheCompression,
      logger
    ***REMOVED*** = params;
    const file = path.join(directory, filename(source, cacheIdentifier, options));
    try {
      // No errors mean that the file was previously cached
      // we just need to return it
      logger.debug(`reading cache file '${file***REMOVED***'`);
      return yield read(file, cacheCompression);
    ***REMOVED*** catch (err) {
      // conitnue if cache can't be read
      logger.debug(`discarded cache as it can not be read`);
    ***REMOVED***
    const fallback = typeof cacheDirectory !== "string" && directory !== os.tmpdir();

    // Make sure the directory exists.
    try {
      logger.debug(`creating cache folder '${directory***REMOVED***'`);
      yield makeDir(directory);
    ***REMOVED*** catch (err) {
      if (fallback) {
        return handleCache(os.tmpdir(), params);
      ***REMOVED***
      throw err;
    ***REMOVED***

    // Otherwise just transform the file
    // return it to the user asap and write it in cache
    logger.debug(`applying Babel transform`);
    const result = yield transform(source, options);

    // Do not cache if there are external dependencies,
    // since they might change and we cannot control it.
    if (!result.externalDependencies.length) {
      try {
        logger.debug(`writing result to cache file '${file***REMOVED***'`);
        yield write(file, cacheCompression, result);
      ***REMOVED*** catch (err) {
        if (fallback) {
          // Fallback to tmpdir if node_modules folder not writable
          return handleCache(os.tmpdir(), params);
        ***REMOVED***
        throw err;
      ***REMOVED***
    ***REMOVED***
    return result;
  ***REMOVED***);
  return function handleCache(_x6, _x7) {
    return _ref3.apply(this, arguments);
  ***REMOVED***;
***REMOVED***();

/**
 * Retrieve file from cache, or create a new one for future reads
 *
 * @async
 * @param  {Object***REMOVED***   params
 * @param  {String***REMOVED***   params.cacheDirectory   Directory to store cached files
 * @param  {String***REMOVED***   params.cacheIdentifier  Unique identifier to bust cache
 * @param  {Boolean***REMOVED***  params.cacheCompression Whether compressing cached files
 * @param  {String***REMOVED***   params.source   Original contents of the file to be cached
 * @param  {Object***REMOVED***   params.options  Options to be given to the transform fn
 *
 * @example
 *
 *   const result = await cache({
 *     cacheDirectory: '.tmp/cache',
 *     cacheIdentifier: 'babel-loader-cachefile',
 *     cacheCompression: false,
 *     source: *source code from file*,
 *     options: {
 *       experimental: true,
 *       runtime: true
 *     ***REMOVED***,
 *   ***REMOVED***);
 */

module.exports = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(function* (params) {
    let directory;
    if (typeof params.cacheDirectory === "string") {
      directory = params.cacheDirectory;
    ***REMOVED*** else {
      if (defaultCacheDirectory === null) {
        defaultCacheDirectory = findCacheDir({
          name: "babel-loader"
        ***REMOVED***) || os.tmpdir();
      ***REMOVED***
      directory = defaultCacheDirectory;
    ***REMOVED***
    return yield handleCache(directory, params);
  ***REMOVED***);
  return function (_x8) {
    return _ref4.apply(this, arguments);
  ***REMOVED***;
***REMOVED***();