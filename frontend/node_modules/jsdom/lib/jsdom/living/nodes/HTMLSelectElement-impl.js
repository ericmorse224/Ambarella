"use strict";

const conversions = require("webidl-conversions");

const idlUtils = require("../generated/utils.js");
const ValidityState = require("../generated/ValidityState");
const DefaultConstraintValidationImpl =
  require("../constraint-validation/DefaultConstraintValidation-impl").implementation;
const { mixin ***REMOVED*** = require("../../utils");
const HTMLElementImpl = require("./HTMLElement-impl").implementation;
const NODE_TYPE = require("../node-type");
const HTMLCollection = require("../generated/HTMLCollection");
const HTMLOptionsCollection = require("../generated/HTMLOptionsCollection");
const { domSymbolTree ***REMOVED*** = require("../helpers/internal-constants");
const { getLabelsForLabelable, formOwner, isDisabled ***REMOVED*** = require("../helpers/form-controls");
const { parseNonNegativeInteger ***REMOVED*** = require("../helpers/strings");

class HTMLSelectElementImpl extends HTMLElementImpl {
  constructor(globalObject, args, privateData) {
    super(globalObject, args, privateData);
    this._options = HTMLOptionsCollection.createImpl(this._globalObject, [], {
      element: this,
      query: () => {
        // Customized domSymbolTree.treeToArray() clone.
        const array = [];
        for (const child of domSymbolTree.childrenIterator(this)) {
          if (child._localName === "option") {
            array.push(child);
          ***REMOVED*** else if (child._localName === "optgroup") {
            for (const childOfGroup of domSymbolTree.childrenIterator(child)) {
              if (childOfGroup._localName === "option") {
                array.push(childOfGroup);
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
        return array;
      ***REMOVED***
    ***REMOVED***);
    this._selectedOptions = null; // lazy

    this._customValidityErrorMessage = "";

    this._labels = null;
  ***REMOVED***

  _formReset() {
    for (const option of this.options) {
      option._selectedness = option.hasAttributeNS(null, "selected");
      option._dirtyness = false;
    ***REMOVED***
    this._askedForAReset();
  ***REMOVED***

  _askedForAReset() {
    if (this.hasAttributeNS(null, "multiple")) {
      return;
    ***REMOVED***

    const selected = this.options.filter(opt => opt._selectedness);

    const size = this._displaySize;
    if (size === 1 && !selected.length) {
      // select the first option that is not disabled
      for (const option of this.options) {
        let disabled = option.hasAttributeNS(null, "disabled");
        const parentNode = domSymbolTree.parent(option);
        if (parentNode &&
          parentNode.nodeName.toUpperCase() === "OPTGROUP" &&
          parentNode.hasAttributeNS(null, "disabled")) {
          disabled = true;
        ***REMOVED***

        if (!disabled) {
          // (do not set dirty)
          option._selectedness = true;
          break;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else if (selected.length >= 2) {
      // select the last selected option
      selected.forEach((option, index) => {
        option._selectedness = index === selected.length - 1;
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  _descendantAdded(parent, child) {
    if (child.nodeType === NODE_TYPE.ELEMENT_NODE) {
      this._askedForAReset();
    ***REMOVED***

    super._descendantAdded(parent, child);
  ***REMOVED***

  _descendantRemoved(parent, child) {
    if (child.nodeType === NODE_TYPE.ELEMENT_NODE) {
      this._askedForAReset();
    ***REMOVED***

    super._descendantRemoved(parent, child);
  ***REMOVED***

  _attrModified(name, value, oldValue) {
    if (name === "multiple" || name === "size") {
      this._askedForAReset();
    ***REMOVED***
    super._attrModified(name, value, oldValue);
  ***REMOVED***

  get _displaySize() {
    if (this.hasAttributeNS(null, "size")) {
      const size = parseNonNegativeInteger(this.getAttributeNS(null, "size"));
      if (size !== null) {
        return size;
      ***REMOVED***
    ***REMOVED***
    return this.hasAttributeNS(null, "multiple") ? 4 : 1;
  ***REMOVED***

  get _mutable() {
    return !isDisabled(this);
  ***REMOVED***

  get options() {
    return this._options;
  ***REMOVED***

  get selectedOptions() {
    return HTMLCollection.createImpl(this._globalObject, [], {
      element: this,
      query: () => domSymbolTree.treeToArray(this, {
        filter: node => node._localName === "option" && node._selectedness === true
      ***REMOVED***)
    ***REMOVED***);
  ***REMOVED***

  get selectedIndex() {
    for (let i = 0; i < this.options.length; i++) {
      if (this.options.item(i)._selectedness) {
        return i;
      ***REMOVED***
    ***REMOVED***
    return -1;
  ***REMOVED***

  set selectedIndex(index) {
    for (let i = 0; i < this.options.length; i++) {
      this.options.item(i)._selectedness = false;
    ***REMOVED***

    const selectedOption = this.options.item(index);
    if (selectedOption) {
      selectedOption._selectedness = true;
      selectedOption._dirtyness = true;
    ***REMOVED***
  ***REMOVED***

  get labels() {
    return getLabelsForLabelable(this);
  ***REMOVED***

  get value() {
    for (const option of this.options) {
      if (option._selectedness) {
        return option.value;
      ***REMOVED***
    ***REMOVED***

    return "";
  ***REMOVED***

  set value(val) {
    for (const option of this.options) {
      if (option.value === val) {
        option._selectedness = true;
        option._dirtyness = true;
      ***REMOVED*** else {
        option._selectedness = false;
      ***REMOVED***

      option._modified();
    ***REMOVED***
  ***REMOVED***

  get form() {
    return formOwner(this);
  ***REMOVED***

  get type() {
    return this.hasAttributeNS(null, "multiple") ? "select-multiple" : "select-one";
  ***REMOVED***

  get [idlUtils.supportedPropertyIndices]() {
    return this.options[idlUtils.supportedPropertyIndices];
  ***REMOVED***

  get length() {
    return this.options.length;
  ***REMOVED***

  set length(value) {
    this.options.length = value;
  ***REMOVED***

  item(index) {
    return this.options.item(index);
  ***REMOVED***

  namedItem(name) {
    return this.options.namedItem(name);
  ***REMOVED***

  [idlUtils.indexedSetNew](index, value) {
    return this.options[idlUtils.indexedSetNew](index, value);
  ***REMOVED***

  [idlUtils.indexedSetExisting](index, value) {
    return this.options[idlUtils.indexedSetExisting](index, value);
  ***REMOVED***

  add(opt, before) {
    this.options.add(opt, before);
  ***REMOVED***

  remove(index) {
    if (arguments.length > 0) {
      index = conversions.long(index, {
        context: "Failed to execute 'remove' on 'HTMLSelectElement': parameter 1"
      ***REMOVED***);
      this.options.remove(index);
    ***REMOVED*** else {
      super.remove();
    ***REMOVED***
  ***REMOVED***

  _barredFromConstraintValidationSpecialization() {
    return this.hasAttributeNS(null, "readonly");
  ***REMOVED***

  // Constraint validation: If the element has its required attribute specified,
  // and either none of the option elements in the select element's list of options
  // have their selectedness set to true, or the only option element in the select
  // element's list of options with its selectedness set to true is the placeholder
  // label option, then the element is suffering from being missing.
  get validity() {
    if (!this._validity) {
      const state = {
        valueMissing: () => {
          if (!this.hasAttributeNS(null, "required")) {
            return false;
          ***REMOVED***
          const selectedOptionIndex = this.selectedIndex;
          return selectedOptionIndex < 0 || (selectedOptionIndex === 0 && this._hasPlaceholderOption);
        ***REMOVED***
      ***REMOVED***;

      this._validity = ValidityState.createImpl(this._globalObject, [], {
        element: this,
        state
      ***REMOVED***);
    ***REMOVED***
    return this._validity;
  ***REMOVED***

  // If a select element has a required attribute specified, does not have a multiple attribute
  // specified, and has a display size of 1; and if the value of the first option element in the
  // select element's list of options (if any) is the empty string, and that option element's parent
  // node is the select element(and not an optgroup element), then that option is the select
  // element's placeholder label option.
  // https://html.spec.whatwg.org/multipage/form-elements.html#placeholder-label-option
  get _hasPlaceholderOption() {
    return this.hasAttributeNS(null, "required") && !this.hasAttributeNS(null, "multiple") &&
      this._displaySize === 1 && this.options.length > 0 && this.options.item(0).value === "" &&
      this.options.item(0).parentNode._localName !== "optgroup";
  ***REMOVED***
***REMOVED***

mixin(HTMLSelectElementImpl.prototype, DefaultConstraintValidationImpl.prototype);

module.exports = {
  implementation: HTMLSelectElementImpl
***REMOVED***;
