'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
***REMOVED***);
exports.default = void 0;

function _mergeStream() {
  const data = _interopRequireDefault(require('merge-stream'));

  _mergeStream = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

var _types = require('../types');

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj***REMOVED***;
***REMOVED***

/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// How long to wait for the child process to terminate
// after CHILD_MESSAGE_END before sending force exiting.
const FORCE_EXIT_DELAY = 500;
/* istanbul ignore next */
// eslint-disable-next-line @typescript-eslint/no-empty-function

const emptyMethod = () => {***REMOVED***;

class BaseWorkerPool {
  _stderr;
  _stdout;
  _options;
  _workers;

  constructor(workerPath, options) {
    this._options = options;
    this._workers = new Array(options.numWorkers);
    const stdout = (0, _mergeStream().default)();
    const stderr = (0, _mergeStream().default)();
    const {forkOptions, maxRetries, resourceLimits, setupArgs***REMOVED*** = options;

    for (let i = 0; i < options.numWorkers; i++) {
      const workerOptions = {
        forkOptions,
        maxRetries,
        resourceLimits,
        setupArgs,
        workerId: i,
        workerPath
      ***REMOVED***;
      const worker = this.createWorker(workerOptions);
      const workerStdout = worker.getStdout();
      const workerStderr = worker.getStderr();

      if (workerStdout) {
        stdout.add(workerStdout);
      ***REMOVED***

      if (workerStderr) {
        stderr.add(workerStderr);
      ***REMOVED***

      this._workers[i] = worker;
    ***REMOVED***

    this._stdout = stdout;
    this._stderr = stderr;
  ***REMOVED***

  getStderr() {
    return this._stderr;
  ***REMOVED***

  getStdout() {
    return this._stdout;
  ***REMOVED***

  getWorkers() {
    return this._workers;
  ***REMOVED***

  getWorkerById(workerId) {
    return this._workers[workerId];
  ***REMOVED***

  createWorker(_workerOptions) {
    throw Error('Missing method createWorker in WorkerPool');
  ***REMOVED***

  async end() {
    // We do not cache the request object here. If so, it would only be only
    // processed by one of the workers, and we want them all to close.
    const workerExitPromises = this._workers.map(async worker => {
      worker.send(
        [_types.CHILD_MESSAGE_END, false],
        emptyMethod,
        emptyMethod,
        emptyMethod
      ); // Schedule a force exit in case worker fails to exit gracefully so
      // await worker.waitForExit() never takes longer than FORCE_EXIT_DELAY

      let forceExited = false;
      const forceExitTimeout = setTimeout(() => {
        worker.forceExit();
        forceExited = true;
      ***REMOVED***, FORCE_EXIT_DELAY);
      await worker.waitForExit(); // Worker ideally exited gracefully, don't send force exit then

      clearTimeout(forceExitTimeout);
      return forceExited;
    ***REMOVED***);

    const workerExits = await Promise.all(workerExitPromises);
    return workerExits.reduce(
      (result, forceExited) => ({
        forceExited: result.forceExited || forceExited
      ***REMOVED***),
      {
        forceExited: false
      ***REMOVED***
    );
  ***REMOVED***
***REMOVED***

exports.default = BaseWorkerPool;
