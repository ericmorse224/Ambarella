/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { compareRuntime ***REMOVED*** = require("./runtime");

/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../Chunk").ChunkId***REMOVED*** ChunkId */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../ChunkGraph").ModuleId***REMOVED*** ModuleId */
/** @typedef {import("../ChunkGroup")***REMOVED*** ChunkGroup */
/** @typedef {import("../Dependency").DependencyLocation***REMOVED*** DependencyLocation */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../ModuleGraph")***REMOVED*** ModuleGraph */

/**
 * @template T
 * @typedef {(a: T, b: T) => -1 | 0 | 1***REMOVED*** Comparator
 */
/**
 * @template {object***REMOVED*** TArg
 * @template T
 * @typedef {(tArg: TArg, a: T, b: T) => -1 | 0 | 1***REMOVED*** RawParameterizedComparator
 */
/**
 * @template {object***REMOVED*** TArg
 * @template T
 * @typedef {(tArg: TArg) => Comparator<T>***REMOVED*** ParameterizedComparator
 */

/**
 * @template {object***REMOVED*** TArg
 * @template {object***REMOVED*** T
 * @param {RawParameterizedComparator<TArg, T>***REMOVED*** fn comparator with argument
 * @returns {ParameterizedComparator<TArg, T>***REMOVED*** comparator
 */
const createCachedParameterizedComparator = fn => {
	/** @type {WeakMap<EXPECTED_OBJECT, Comparator<T>>***REMOVED*** */
	const map = new WeakMap();
	return arg => {
		const cachedResult = map.get(/** @type {EXPECTED_OBJECT***REMOVED*** */ (arg));
		if (cachedResult !== undefined) return cachedResult;
		/**
		 * @param {T***REMOVED*** a first item
		 * @param {T***REMOVED*** b second item
		 * @returns {-1|0|1***REMOVED*** compare result
		 */
		const result = fn.bind(null, arg);
		map.set(/** @type {EXPECTED_OBJECT***REMOVED*** */ (arg), result);
		return result;
	***REMOVED***;
***REMOVED***;

/**
 * @param {Chunk***REMOVED*** a chunk
 * @param {Chunk***REMOVED*** b chunk
 * @returns {-1|0|1***REMOVED*** compare result
 */
module.exports.compareChunksById = (a, b) =>
	compareIds(/** @type {ChunkId***REMOVED*** */ (a.id), /** @type {ChunkId***REMOVED*** */ (b.id));

/**
 * @param {Module***REMOVED*** a module
 * @param {Module***REMOVED*** b module
 * @returns {-1|0|1***REMOVED*** compare result
 */
module.exports.compareModulesByIdentifier = (a, b) =>
	compareIds(a.identifier(), b.identifier());

/**
 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @param {Module***REMOVED*** a module
 * @param {Module***REMOVED*** b module
 * @returns {-1|0|1***REMOVED*** compare result
 */
const compareModulesById = (chunkGraph, a, b) =>
	compareIds(
		/** @type {ModuleId***REMOVED*** */ (chunkGraph.getModuleId(a)),
		/** @type {ModuleId***REMOVED*** */ (chunkGraph.getModuleId(b))
	);
/** @type {ParameterizedComparator<ChunkGraph, Module>***REMOVED*** */
module.exports.compareModulesById =
	createCachedParameterizedComparator(compareModulesById);

/**
 * @param {number***REMOVED*** a number
 * @param {number***REMOVED*** b number
 * @returns {-1|0|1***REMOVED*** compare result
 */
const compareNumbers = (a, b) => {
	if (typeof a !== typeof b) {
		return typeof a < typeof b ? -1 : 1;
	***REMOVED***
	if (a < b) return -1;
	if (a > b) return 1;
	return 0;
***REMOVED***;
module.exports.compareNumbers = compareNumbers;

/**
 * @param {string***REMOVED*** a string
 * @param {string***REMOVED*** b string
 * @returns {-1|0|1***REMOVED*** compare result
 */
const compareStringsNumeric = (a, b) => {
	const aLength = a.length;
	const bLength = b.length;

	let aChar = 0;
	let bChar = 0;

	let aIsDigit = false;
	let bIsDigit = false;
	let i = 0;
	let j = 0;
	while (i < aLength && j < bLength) {
		aChar = a.charCodeAt(i);
		bChar = b.charCodeAt(j);

		aIsDigit = aChar >= 48 && aChar <= 57;
		bIsDigit = bChar >= 48 && bChar <= 57;

		if (!aIsDigit && !bIsDigit) {
			if (aChar < bChar) return -1;
			if (aChar > bChar) return 1;
			i++;
			j++;
		***REMOVED*** else if (aIsDigit && !bIsDigit) {
			// This segment of a is shorter than in b
			return 1;
		***REMOVED*** else if (!aIsDigit && bIsDigit) {
			// This segment of b is shorter than in a
			return -1;
		***REMOVED*** else {
			let aNumber = aChar - 48;
			let bNumber = bChar - 48;

			while (++i < aLength) {
				aChar = a.charCodeAt(i);
				if (aChar < 48 || aChar > 57) break;
				aNumber = aNumber * 10 + aChar - 48;
			***REMOVED***

			while (++j < bLength) {
				bChar = b.charCodeAt(j);
				if (bChar < 48 || bChar > 57) break;
				bNumber = bNumber * 10 + bChar - 48;
			***REMOVED***

			if (aNumber < bNumber) return -1;
			if (aNumber > bNumber) return 1;
		***REMOVED***
	***REMOVED***

	if (j < bLength) {
		// a is shorter than b
		bChar = b.charCodeAt(j);
		bIsDigit = bChar >= 48 && bChar <= 57;
		return bIsDigit ? -1 : 1;
	***REMOVED***
	if (i < aLength) {
		// b is shorter than a
		aChar = a.charCodeAt(i);
		aIsDigit = aChar >= 48 && aChar <= 57;
		return aIsDigit ? 1 : -1;
	***REMOVED***

	return 0;
***REMOVED***;
module.exports.compareStringsNumeric = compareStringsNumeric;

/**
 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
 * @param {Module***REMOVED*** a module
 * @param {Module***REMOVED*** b module
 * @returns {-1|0|1***REMOVED*** compare result
 */
const compareModulesByPostOrderIndexOrIdentifier = (moduleGraph, a, b) => {
	const cmp = compareNumbers(
		/** @type {number***REMOVED*** */ (moduleGraph.getPostOrderIndex(a)),
		/** @type {number***REMOVED*** */ (moduleGraph.getPostOrderIndex(b))
	);
	if (cmp !== 0) return cmp;
	return compareIds(a.identifier(), b.identifier());
***REMOVED***;
/** @type {ParameterizedComparator<ModuleGraph, Module>***REMOVED*** */
module.exports.compareModulesByPostOrderIndexOrIdentifier =
	createCachedParameterizedComparator(
		compareModulesByPostOrderIndexOrIdentifier
	);

/**
 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
 * @param {Module***REMOVED*** a module
 * @param {Module***REMOVED*** b module
 * @returns {-1|0|1***REMOVED*** compare result
 */
const compareModulesByPreOrderIndexOrIdentifier = (moduleGraph, a, b) => {
	const cmp = compareNumbers(
		/** @type {number***REMOVED*** */ (moduleGraph.getPreOrderIndex(a)),
		/** @type {number***REMOVED*** */ (moduleGraph.getPreOrderIndex(b))
	);
	if (cmp !== 0) return cmp;
	return compareIds(a.identifier(), b.identifier());
***REMOVED***;
/** @type {ParameterizedComparator<ModuleGraph, Module>***REMOVED*** */
module.exports.compareModulesByPreOrderIndexOrIdentifier =
	createCachedParameterizedComparator(
		compareModulesByPreOrderIndexOrIdentifier
	);

/**
 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @param {Module***REMOVED*** a module
 * @param {Module***REMOVED*** b module
 * @returns {-1|0|1***REMOVED*** compare result
 */
const compareModulesByIdOrIdentifier = (chunkGraph, a, b) => {
	const cmp = compareIds(
		/** @type {ModuleId***REMOVED*** */ (chunkGraph.getModuleId(a)),
		/** @type {ModuleId***REMOVED*** */ (chunkGraph.getModuleId(b))
	);
	if (cmp !== 0) return cmp;
	return compareIds(a.identifier(), b.identifier());
***REMOVED***;
/** @type {ParameterizedComparator<ChunkGraph, Module>***REMOVED*** */
module.exports.compareModulesByIdOrIdentifier =
	createCachedParameterizedComparator(compareModulesByIdOrIdentifier);

/**
 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @param {Chunk***REMOVED*** a chunk
 * @param {Chunk***REMOVED*** b chunk
 * @returns {-1 | 0 | 1***REMOVED*** compare result
 */
const compareChunks = (chunkGraph, a, b) => chunkGraph.compareChunks(a, b);
/** @type {ParameterizedComparator<ChunkGraph, Chunk>***REMOVED*** */
module.exports.compareChunks =
	createCachedParameterizedComparator(compareChunks);

/**
 * @param {string | number***REMOVED*** a first id
 * @param {string | number***REMOVED*** b second id
 * @returns {-1 | 0 | 1***REMOVED*** compare result
 */
const compareIds = (a, b) => {
	if (typeof a !== typeof b) {
		return typeof a < typeof b ? -1 : 1;
	***REMOVED***
	if (a < b) return -1;
	if (a > b) return 1;
	return 0;
***REMOVED***;

module.exports.compareIds = compareIds;

/**
 * @param {string***REMOVED*** a first string
 * @param {string***REMOVED*** b second string
 * @returns {-1|0|1***REMOVED*** compare result
 */
const compareStrings = (a, b) => {
	if (a < b) return -1;
	if (a > b) return 1;
	return 0;
***REMOVED***;

module.exports.compareStrings = compareStrings;

/**
 * @param {ChunkGroup***REMOVED*** a first chunk group
 * @param {ChunkGroup***REMOVED*** b second chunk group
 * @returns {-1 | 0 | 1***REMOVED*** compare result
 */
const compareChunkGroupsByIndex = (a, b) =>
	/** @type {number***REMOVED*** */ (a.index) < /** @type {number***REMOVED*** */ (b.index) ? -1 : 1;
module.exports.compareChunkGroupsByIndex = compareChunkGroupsByIndex;

/**
 * @template {EXPECTED_OBJECT***REMOVED*** K1
 * @template {EXPECTED_OBJECT***REMOVED*** K2
 * @template T
 */
class TwoKeyWeakMap {
	constructor() {
		/**
		 * @private
		 * @type {WeakMap<K1, WeakMap<K2, T | undefined>>***REMOVED***
		 */
		this._map = new WeakMap();
	***REMOVED***

	/**
	 * @param {K1***REMOVED*** key1 first key
	 * @param {K2***REMOVED*** key2 second key
	 * @returns {T | undefined***REMOVED*** value
	 */
	get(key1, key2) {
		const childMap = this._map.get(key1);
		if (childMap === undefined) {
			return;
		***REMOVED***
		return childMap.get(key2);
	***REMOVED***

	/**
	 * @param {K1***REMOVED*** key1 first key
	 * @param {K2***REMOVED*** key2 second key
	 * @param {T | undefined***REMOVED*** value new value
	 * @returns {void***REMOVED***
	 */
	set(key1, key2, value) {
		let childMap = this._map.get(key1);
		if (childMap === undefined) {
			childMap = new WeakMap();
			this._map.set(key1, childMap);
		***REMOVED***
		childMap.set(key2, value);
	***REMOVED***
***REMOVED***

/** @type {TwoKeyWeakMap<Comparator<EXPECTED_ANY>, Comparator<EXPECTED_ANY>, Comparator<EXPECTED_ANY>>***REMOVED******REMOVED*** */
const concatComparatorsCache = new TwoKeyWeakMap();

/**
 * @template T
 * @param {Comparator<T>***REMOVED*** c1 comparator
 * @param {Comparator<T>***REMOVED*** c2 comparator
 * @param {Comparator<T>[]***REMOVED*** cRest comparators
 * @returns {Comparator<T>***REMOVED*** comparator
 */
const concatComparators = (c1, c2, ...cRest) => {
	if (cRest.length > 0) {
		const [c3, ...cRest2] = cRest;
		return concatComparators(c1, concatComparators(c2, c3, ...cRest2));
	***REMOVED***
	const cacheEntry = /** @type {Comparator<T>***REMOVED*** */ (
		concatComparatorsCache.get(c1, c2)
	);
	if (cacheEntry !== undefined) return cacheEntry;
	/**
	 * @param {T***REMOVED*** a first value
	 * @param {T***REMOVED*** b second value
	 * @returns {-1|0|1***REMOVED*** compare result
	 */
	const result = (a, b) => {
		const res = c1(a, b);
		if (res !== 0) return res;
		return c2(a, b);
	***REMOVED***;
	concatComparatorsCache.set(c1, c2, result);
	return result;
***REMOVED***;
module.exports.concatComparators = concatComparators;

/**
 * @template A, B
 * @typedef {(input: A) => B | undefined | null***REMOVED*** Selector
 */

/** @type {TwoKeyWeakMap<Selector<EXPECTED_ANY, EXPECTED_ANY>, Comparator<EXPECTED_ANY>, Comparator<EXPECTED_ANY>>***REMOVED******REMOVED*** */
const compareSelectCache = new TwoKeyWeakMap();

/**
 * @template T
 * @template R
 * @param {Selector<T, R>***REMOVED*** getter getter for value
 * @param {Comparator<R>***REMOVED*** comparator comparator
 * @returns {Comparator<T>***REMOVED*** comparator
 */
const compareSelect = (getter, comparator) => {
	const cacheEntry = compareSelectCache.get(getter, comparator);
	if (cacheEntry !== undefined) return cacheEntry;
	/**
	 * @param {T***REMOVED*** a first value
	 * @param {T***REMOVED*** b second value
	 * @returns {-1|0|1***REMOVED*** compare result
	 */
	const result = (a, b) => {
		const aValue = getter(a);
		const bValue = getter(b);
		if (aValue !== undefined && aValue !== null) {
			if (bValue !== undefined && bValue !== null) {
				return comparator(aValue, bValue);
			***REMOVED***
			return -1;
		***REMOVED***
		if (bValue !== undefined && bValue !== null) {
			return 1;
		***REMOVED***
		return 0;
	***REMOVED***;
	compareSelectCache.set(getter, comparator, result);
	return result;
***REMOVED***;
module.exports.compareSelect = compareSelect;

/** @type {WeakMap<Comparator<EXPECTED_ANY>, Comparator<Iterable<EXPECTED_ANY>>>***REMOVED*** */
const compareIteratorsCache = new WeakMap();

/**
 * @template T
 * @param {Comparator<T>***REMOVED*** elementComparator comparator for elements
 * @returns {Comparator<Iterable<T>>***REMOVED*** comparator for iterables of elements
 */
const compareIterables = elementComparator => {
	const cacheEntry = compareIteratorsCache.get(elementComparator);
	if (cacheEntry !== undefined) return cacheEntry;
	/**
	 * @param {Iterable<T>***REMOVED*** a first value
	 * @param {Iterable<T>***REMOVED*** b second value
	 * @returns {-1|0|1***REMOVED*** compare result
	 */
	const result = (a, b) => {
		const aI = a[Symbol.iterator]();
		const bI = b[Symbol.iterator]();
		while (true) {
			const aItem = aI.next();
			const bItem = bI.next();
			if (aItem.done) {
				return bItem.done ? 0 : -1;
			***REMOVED*** else if (bItem.done) {
				return 1;
			***REMOVED***
			const res = elementComparator(aItem.value, bItem.value);
			if (res !== 0) return res;
		***REMOVED***
	***REMOVED***;
	compareIteratorsCache.set(elementComparator, result);
	return result;
***REMOVED***;
module.exports.compareIterables = compareIterables;

// TODO this is no longer needed when minimum node.js version is >= 12
// since these versions ship with a stable sort function
/**
 * @template T
 * @param {Iterable<T>***REMOVED*** iterable original ordered list
 * @returns {Comparator<T>***REMOVED*** comparator
 */
module.exports.keepOriginalOrder = iterable => {
	/** @type {Map<T, number>***REMOVED*** */
	const map = new Map();
	let i = 0;
	for (const item of iterable) {
		map.set(item, i++);
	***REMOVED***
	return (a, b) =>
		compareNumbers(
			/** @type {number***REMOVED*** */ (map.get(a)),
			/** @type {number***REMOVED*** */ (map.get(b))
		);
***REMOVED***;

/**
 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @returns {Comparator<Chunk>***REMOVED*** comparator
 */
module.exports.compareChunksNatural = chunkGraph => {
	const cmpFn = module.exports.compareModulesById(chunkGraph);
	const cmpIterableFn = compareIterables(cmpFn);
	return concatComparators(
		compareSelect(
			chunk => /** @type {string|number***REMOVED*** */ (chunk.name),
			compareIds
		),
		compareSelect(chunk => chunk.runtime, compareRuntime),
		compareSelect(
			/**
			 * @param {Chunk***REMOVED*** chunk a chunk
			 * @returns {Iterable<Module>***REMOVED*** modules
			 */
			chunk => chunkGraph.getOrderedChunkModulesIterable(chunk, cmpFn),
			cmpIterableFn
		)
	);
***REMOVED***;

/**
 * Compare two locations
 * @param {DependencyLocation***REMOVED*** a A location node
 * @param {DependencyLocation***REMOVED*** b A location node
 * @returns {-1|0|1***REMOVED*** sorting comparator value
 */
module.exports.compareLocations = (a, b) => {
	const isObjectA = typeof a === "object" && a !== null;
	const isObjectB = typeof b === "object" && b !== null;
	if (!isObjectA || !isObjectB) {
		if (isObjectA) return 1;
		if (isObjectB) return -1;
		return 0;
	***REMOVED***
	if ("start" in a) {
		if ("start" in b) {
			const ap = a.start;
			const bp = b.start;
			if (ap.line < bp.line) return -1;
			if (ap.line > bp.line) return 1;
			if (/** @type {number***REMOVED*** */ (ap.column) < /** @type {number***REMOVED*** */ (bp.column))
				return -1;
			if (/** @type {number***REMOVED*** */ (ap.column) > /** @type {number***REMOVED*** */ (bp.column))
				return 1;
		***REMOVED*** else return -1;
	***REMOVED*** else if ("start" in b) return 1;
	if ("name" in a) {
		if ("name" in b) {
			if (a.name < b.name) return -1;
			if (a.name > b.name) return 1;
		***REMOVED*** else return -1;
	***REMOVED*** else if ("name" in b) return 1;
	if ("index" in a) {
		if ("index" in b) {
			if (/** @type {number***REMOVED*** */ (a.index) < /** @type {number***REMOVED*** */ (b.index))
				return -1;
			if (/** @type {number***REMOVED*** */ (a.index) > /** @type {number***REMOVED*** */ (b.index))
				return 1;
		***REMOVED*** else return -1;
	***REMOVED*** else if ("index" in b) return 1;
	return 0;
***REMOVED***;
