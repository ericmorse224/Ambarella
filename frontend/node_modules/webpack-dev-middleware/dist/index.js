"use strict";

const {
  validate
***REMOVED*** = require("schema-utils");

const mime = require("mime-types");

const middleware = require("./middleware");

const getFilenameFromUrl = require("./utils/getFilenameFromUrl");

const setupHooks = require("./utils/setupHooks");

const setupWriteToDisk = require("./utils/setupWriteToDisk");

const setupOutputFileSystem = require("./utils/setupOutputFileSystem");

const ready = require("./utils/ready");

const schema = require("./options.json");

const noop = () => {***REMOVED***;
/** @typedef {import("schema-utils/declarations/validate").Schema***REMOVED*** Schema */

/** @typedef {import("webpack").Compiler***REMOVED*** Compiler */

/** @typedef {import("webpack").MultiCompiler***REMOVED*** MultiCompiler */

/** @typedef {import("webpack").Configuration***REMOVED*** Configuration */

/** @typedef {import("webpack").Stats***REMOVED*** Stats */

/** @typedef {import("webpack").MultiStats***REMOVED*** MultiStats */

/**
 * @typedef {Object***REMOVED*** ExtendedServerResponse
 * @property {{ webpack?: { devMiddleware?: Context<IncomingMessage, ServerResponse> ***REMOVED*** ***REMOVED******REMOVED*** [locals]
 */

/** @typedef {import("http").IncomingMessage***REMOVED*** IncomingMessage */

/** @typedef {import("http").ServerResponse & ExtendedServerResponse***REMOVED*** ServerResponse */

/**
 * @callback NextFunction
 * @param {any***REMOVED*** [err]
 * @return {void***REMOVED***
 */

/**
 * @typedef {NonNullable<Configuration["watchOptions"]>***REMOVED*** WatchOptions
 */

/**
 * @typedef {Compiler["watching"]***REMOVED*** Watching
 */

/**
 * @typedef {ReturnType<Compiler["watch"]>***REMOVED*** MultiWatching
 */

/**
 * @typedef {Compiler["outputFileSystem"] & { createReadStream?: import("fs").createReadStream, statSync?: import("fs").statSync, lstat?: import("fs").lstat, readFileSync?: import("fs").readFileSync ***REMOVED******REMOVED*** OutputFileSystem
 */

/** @typedef {ReturnType<Compiler["getInfrastructureLogger"]>***REMOVED*** Logger */

/**
 * @callback Callback
 * @param {Stats | MultiStats***REMOVED*** [stats]
 */

/**
 * @template {IncomingMessage***REMOVED*** Request
 * @template {ServerResponse***REMOVED*** Response
 * @typedef {Object***REMOVED*** Context
 * @property {boolean***REMOVED*** state
 * @property {Stats | MultiStats | undefined***REMOVED*** stats
 * @property {Callback[]***REMOVED*** callbacks
 * @property {Options<Request, Response>***REMOVED*** options
 * @property {Compiler | MultiCompiler***REMOVED*** compiler
 * @property {Watching | MultiWatching***REMOVED*** watching
 * @property {Logger***REMOVED*** logger
 * @property {OutputFileSystem***REMOVED*** outputFileSystem
 */

/**
 * @template {IncomingMessage***REMOVED*** Request
 * @template {ServerResponse***REMOVED*** Response
 * @typedef {Record<string, string | number> | Array<{ key: string, value: number | string ***REMOVED***> | ((req: Request, res: Response, context: Context<Request, Response>) =>  void | undefined | Record<string, string | number>) | undefined***REMOVED*** Headers
 */

/**
 * @template {IncomingMessage***REMOVED*** Request
 * @template {ServerResponse***REMOVED*** Response
 * @typedef {Object***REMOVED*** Options
 * @property {{[key: string]: string***REMOVED******REMOVED*** [mimeTypes]
 * @property {boolean | ((targetPath: string) => boolean)***REMOVED*** [writeToDisk]
 * @property {string***REMOVED*** [methods]
 * @property {Headers<Request, Response>***REMOVED*** [headers]
 * @property {NonNullable<Configuration["output"]>["publicPath"]***REMOVED*** [publicPath]
 * @property {Configuration["stats"]***REMOVED*** [stats]
 * @property {boolean***REMOVED*** [serverSideRender]
 * @property {OutputFileSystem***REMOVED*** [outputFileSystem]
 * @property {boolean | string***REMOVED*** [index]
 */

/**
 * @template {IncomingMessage***REMOVED*** Request
 * @template {ServerResponse***REMOVED*** Response
 * @callback Middleware
 * @param {Request***REMOVED*** req
 * @param {Response***REMOVED*** res
 * @param {NextFunction***REMOVED*** next
 * @return {Promise<void>***REMOVED***
 */

/**
 * @callback GetFilenameFromUrl
 * @param {string***REMOVED*** url
 * @returns {string | undefined***REMOVED***
 */

/**
 * @callback WaitUntilValid
 * @param {Callback***REMOVED*** callback
 */

/**
 * @callback Invalidate
 * @param {Callback***REMOVED*** callback
 */

/**
 * @callback Close
 * @param {(err: Error | null | undefined) => void***REMOVED*** callback
 */

/**
 * @template {IncomingMessage***REMOVED*** Request
 * @template {ServerResponse***REMOVED*** Response
 * @typedef {Object***REMOVED*** AdditionalMethods
 * @property {GetFilenameFromUrl***REMOVED*** getFilenameFromUrl
 * @property {WaitUntilValid***REMOVED*** waitUntilValid
 * @property {Invalidate***REMOVED*** invalidate
 * @property {Close***REMOVED*** close
 * @property {Context<Request, Response>***REMOVED*** context
 */

/**
 * @template {IncomingMessage***REMOVED*** Request
 * @template {ServerResponse***REMOVED*** Response
 * @typedef {Middleware<Request, Response> & AdditionalMethods<Request, Response>***REMOVED*** API
 */

/**
 * @template {IncomingMessage***REMOVED*** Request
 * @template {ServerResponse***REMOVED*** Response
 * @param {Compiler | MultiCompiler***REMOVED*** compiler
 * @param {Options<Request, Response>***REMOVED*** [options]
 * @returns {API<Request, Response>***REMOVED***
 */


function wdm(compiler, options = {***REMOVED***) {
  validate(
  /** @type {Schema***REMOVED*** */
  schema, options, {
    name: "Dev Middleware",
    baseDataPath: "options"
  ***REMOVED***);
  const {
    mimeTypes
  ***REMOVED*** = options;

  if (mimeTypes) {
    const {
      types
    ***REMOVED*** = mime; // mimeTypes from user provided options should take priority
    // over existing, known types
    // @ts-ignore

    mime.types = { ...types,
      ...mimeTypes
    ***REMOVED***;
  ***REMOVED***
  /**
   * @type {Context<Request, Response>***REMOVED***
   */


  const context = {
    state: false,
    // eslint-disable-next-line no-undefined
    stats: undefined,
    callbacks: [],
    options,
    compiler,
    // @ts-ignore
    // eslint-disable-next-line no-undefined
    watching: undefined,
    logger: compiler.getInfrastructureLogger("webpack-dev-middleware"),
    // @ts-ignore
    // eslint-disable-next-line no-undefined
    outputFileSystem: undefined
  ***REMOVED***;
  setupHooks(context);

  if (options.writeToDisk) {
    setupWriteToDisk(context);
  ***REMOVED***

  setupOutputFileSystem(context); // Start watching

  if (
  /** @type {Compiler***REMOVED*** */
  context.compiler.watching) {
    context.watching =
    /** @type {Compiler***REMOVED*** */
    context.compiler.watching;
  ***REMOVED*** else {
    /**
     * @type {WatchOptions | WatchOptions[]***REMOVED***
     */
    let watchOptions;
    /**
     * @param {Error | null | undefined***REMOVED*** error
     */

    const errorHandler = error => {
      if (error) {
        // TODO: improve that in future
        // For example - `writeToDisk` can throw an error and right now it is ends watching.
        // We can improve that and keep watching active, but it is require API on webpack side.
        // Let's implement that in webpack@5 because it is rare case.
        context.logger.error(error);
      ***REMOVED***
    ***REMOVED***;

    if (Array.isArray(
    /** @type {MultiCompiler***REMOVED*** */
    context.compiler.compilers)) {
      watchOptions =
      /** @type {MultiCompiler***REMOVED*** */
      context.compiler.compilers.map(
      /**
       * @param {Compiler***REMOVED*** childCompiler
       * @returns {WatchOptions***REMOVED***
       */
      childCompiler => childCompiler.options.watchOptions || {***REMOVED***);
      context.watching =
      /** @type {MultiWatching***REMOVED*** */
      context.compiler.watch(
      /** @type {WatchOptions***REMOVED******REMOVED*** */
      watchOptions, errorHandler);
    ***REMOVED*** else {
      watchOptions =
      /** @type {Compiler***REMOVED*** */
      context.compiler.options.watchOptions || {***REMOVED***;
      context.watching =
      /** @type {Watching***REMOVED*** */
      context.compiler.watch(watchOptions, errorHandler);
    ***REMOVED***
  ***REMOVED***

  const instance =
  /** @type {API<Request, Response>***REMOVED*** */
  middleware(context); // API

  /** @type {API<Request, Response>***REMOVED*** */

  instance.getFilenameFromUrl =
  /**
   * @param {string***REMOVED*** url
   * @returns {string|undefined***REMOVED***
   */
  url => getFilenameFromUrl(context, url);
  /** @type {API<Request, Response>***REMOVED*** */


  instance.waitUntilValid = (callback = noop) => {
    ready(context, callback);
  ***REMOVED***;
  /** @type {API<Request, Response>***REMOVED*** */


  instance.invalidate = (callback = noop) => {
    ready(context, callback);
    context.watching.invalidate();
  ***REMOVED***;
  /** @type {API<Request, Response>***REMOVED*** */


  instance.close = (callback = noop) => {
    context.watching.close(callback);
  ***REMOVED***;
  /** @type {API<Request, Response>***REMOVED*** */


  instance.context = context;
  return instance;
***REMOVED***

module.exports = wdm;