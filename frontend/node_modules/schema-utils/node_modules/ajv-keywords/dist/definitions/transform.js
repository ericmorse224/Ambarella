"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const codegen_1 = require("ajv/dist/compile/codegen");
const transform = {
    trimStart: (s) => s.trimStart(),
    trimEnd: (s) => s.trimEnd(),
    trimLeft: (s) => s.trimStart(),
    trimRight: (s) => s.trimEnd(),
    trim: (s) => s.trim(),
    toLowerCase: (s) => s.toLowerCase(),
    toUpperCase: (s) => s.toUpperCase(),
    toEnumCase: (s, cfg) => (cfg === null || cfg === void 0 ? void 0 : cfg.hash[configKey(s)]) || s,
***REMOVED***;
const getDef = Object.assign(_getDef, { transform ***REMOVED***);
function _getDef() {
    return {
        keyword: "transform",
        schemaType: "array",
        before: "enum",
        code(cxt) {
            const { gen, data, schema, parentSchema, it ***REMOVED*** = cxt;
            const { parentData, parentDataProperty ***REMOVED*** = it;
            const tNames = schema;
            if (!tNames.length)
                return;
            let cfg;
            if (tNames.includes("toEnumCase")) {
                const config = getEnumCaseCfg(parentSchema);
                cfg = gen.scopeValue("obj", { ref: config, code: (0, codegen_1.stringify)(config) ***REMOVED***);
            ***REMOVED***
            gen.if((0, codegen_1._) `typeof ${data***REMOVED*** == "string" && ${parentData***REMOVED*** !== undefined`, () => {
                gen.assign(data, transformExpr(tNames.slice()));
                gen.assign((0, codegen_1._) `${parentData***REMOVED***[${parentDataProperty***REMOVED***]`, data);
            ***REMOVED***);
            function transformExpr(ts) {
                if (!ts.length)
                    return data;
                const t = ts.pop();
                if (!(t in transform))
                    throw new Error(`transform: unknown transformation ${t***REMOVED***`);
                const func = gen.scopeValue("func", {
                    ref: transform[t],
                    code: (0, codegen_1._) `require("ajv-keywords/dist/definitions/transform").transform${(0, codegen_1.getProperty)(t)***REMOVED***`,
                ***REMOVED***);
                const arg = transformExpr(ts);
                return cfg && t === "toEnumCase" ? (0, codegen_1._) `${func***REMOVED***(${arg***REMOVED***, ${cfg***REMOVED***)` : (0, codegen_1._) `${func***REMOVED***(${arg***REMOVED***)`;
            ***REMOVED***
        ***REMOVED***,
        metaSchema: {
            type: "array",
            items: { type: "string", enum: Object.keys(transform) ***REMOVED***,
        ***REMOVED***,
    ***REMOVED***;
***REMOVED***
function getEnumCaseCfg(parentSchema) {
    // build hash table to enum values
    const cfg = { hash: {***REMOVED*** ***REMOVED***;
    // requires `enum` in the same schema as transform
    if (!parentSchema.enum)
        throw new Error('transform: "toEnumCase" requires "enum"');
    for (const v of parentSchema.enum) {
        if (typeof v !== "string")
            continue;
        const k = configKey(v);
        // requires all `enum` values have unique keys
        if (cfg.hash[k]) {
            throw new Error('transform: "toEnumCase" requires all lowercased "enum" values to be unique');
        ***REMOVED***
        cfg.hash[k] = v;
    ***REMOVED***
    return cfg;
***REMOVED***
function configKey(s) {
    return s.toLowerCase();
***REMOVED***
exports.default = getDef;
module.exports = getDef;
//# sourceMappingURL=transform.js.map