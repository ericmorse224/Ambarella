/**
 * @fileoverview Restrict usage of duplicate imports.
 * @author Simen Bekkhus
 */
"use strict";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const NAMED_TYPES = ["ImportSpecifier", "ExportSpecifier"];
const NAMESPACE_TYPES = [
    "ImportNamespaceSpecifier",
    "ExportNamespaceSpecifier"
];

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/**
 * Check if an import/export type belongs to (ImportSpecifier|ExportSpecifier) or (ImportNamespaceSpecifier|ExportNamespaceSpecifier).
 * @param {string***REMOVED*** importExportType An import/export type to check.
 * @param {string***REMOVED*** type Can be "named" or "namespace"
 * @returns {boolean***REMOVED*** True if import/export type belongs to (ImportSpecifier|ExportSpecifier) or (ImportNamespaceSpecifier|ExportNamespaceSpecifier) and false if it doesn't.
 */
function isImportExportSpecifier(importExportType, type) {
    const arrayToCheck = type === "named" ? NAMED_TYPES : NAMESPACE_TYPES;

    return arrayToCheck.includes(importExportType);
***REMOVED***

/**
 * Return the type of (import|export).
 * @param {ASTNode***REMOVED*** node A node to get.
 * @returns {string***REMOVED*** The type of the (import|export).
 */
function getImportExportType(node) {
    if (node.specifiers && node.specifiers.length > 0) {
        const nodeSpecifiers = node.specifiers;
        const index = nodeSpecifiers.findIndex(
            ({ type ***REMOVED***) =>
                isImportExportSpecifier(type, "named") ||
                isImportExportSpecifier(type, "namespace")
        );
        const i = index > -1 ? index : 0;

        return nodeSpecifiers[i].type;
    ***REMOVED***
    if (node.type === "ExportAllDeclaration") {
        if (node.exported) {
            return "ExportNamespaceSpecifier";
        ***REMOVED***
        return "ExportAll";
    ***REMOVED***
    return "SideEffectImport";
***REMOVED***

/**
 * Returns a boolean indicates if two (import|export) can be merged
 * @param {ASTNode***REMOVED*** node1 A node to check.
 * @param {ASTNode***REMOVED*** node2 A node to check.
 * @returns {boolean***REMOVED*** True if two (import|export) can be merged, false if they can't.
 */
function isImportExportCanBeMerged(node1, node2) {
    const importExportType1 = getImportExportType(node1);
    const importExportType2 = getImportExportType(node2);

    if (
        (importExportType1 === "ExportAll" &&
            importExportType2 !== "ExportAll" &&
            importExportType2 !== "SideEffectImport") ||
        (importExportType1 !== "ExportAll" &&
            importExportType1 !== "SideEffectImport" &&
            importExportType2 === "ExportAll")
    ) {
        return false;
    ***REMOVED***
    if (
        (isImportExportSpecifier(importExportType1, "namespace") &&
            isImportExportSpecifier(importExportType2, "named")) ||
        (isImportExportSpecifier(importExportType2, "namespace") &&
            isImportExportSpecifier(importExportType1, "named"))
    ) {
        return false;
    ***REMOVED***
    return true;
***REMOVED***

/**
 * Returns a boolean if we should report (import|export).
 * @param {ASTNode***REMOVED*** node A node to be reported or not.
 * @param {[ASTNode]***REMOVED*** previousNodes An array contains previous nodes of the module imported or exported.
 * @returns {boolean***REMOVED*** True if the (import|export) should be reported.
 */
function shouldReportImportExport(node, previousNodes) {
    let i = 0;

    while (i < previousNodes.length) {
        if (isImportExportCanBeMerged(node, previousNodes[i])) {
            return true;
        ***REMOVED***
        i++;
    ***REMOVED***
    return false;
***REMOVED***

/**
 * Returns array contains only nodes with declarations types equal to type.
 * @param {[{node: ASTNode, declarationType: string***REMOVED***]***REMOVED*** nodes An array contains objects, each object contains a node and a declaration type.
 * @param {string***REMOVED*** type Declaration type.
 * @returns {[ASTNode]***REMOVED*** An array contains only nodes with declarations types equal to type.
 */
function getNodesByDeclarationType(nodes, type) {
    return nodes
        .filter(({ declarationType ***REMOVED***) => declarationType === type)
        .map(({ node ***REMOVED***) => node);
***REMOVED***

/**
 * Returns the name of the module imported or re-exported.
 * @param {ASTNode***REMOVED*** node A node to get.
 * @returns {string***REMOVED*** The name of the module, or empty string if no name.
 */
function getModule(node) {
    if (node && node.source && node.source.value) {
        return node.source.value.trim();
    ***REMOVED***
    return "";
***REMOVED***

/**
 * Checks if the (import|export) can be merged with at least one import or one export, and reports if so.
 * @param {RuleContext***REMOVED*** context The ESLint rule context object.
 * @param {ASTNode***REMOVED*** node A node to get.
 * @param {Map***REMOVED*** modules A Map object contains as a key a module name and as value an array contains objects, each object contains a node and a declaration type.
 * @param {string***REMOVED*** declarationType A declaration type can be an import or export.
 * @param {boolean***REMOVED*** includeExports Whether or not to check for exports in addition to imports.
 * @returns {void***REMOVED*** No return value.
 */
function checkAndReport(
    context,
    node,
    modules,
    declarationType,
    includeExports
) {
    const module = getModule(node);

    if (modules.has(module)) {
        const previousNodes = modules.get(module);
        const messagesIds = [];
        const importNodes = getNodesByDeclarationType(previousNodes, "import");
        let exportNodes;

        if (includeExports) {
            exportNodes = getNodesByDeclarationType(previousNodes, "export");
        ***REMOVED***
        if (declarationType === "import") {
            if (shouldReportImportExport(node, importNodes)) {
                messagesIds.push("import");
            ***REMOVED***
            if (includeExports) {
                if (shouldReportImportExport(node, exportNodes)) {
                    messagesIds.push("importAs");
                ***REMOVED***
            ***REMOVED***
        ***REMOVED*** else if (declarationType === "export") {
            if (shouldReportImportExport(node, exportNodes)) {
                messagesIds.push("export");
            ***REMOVED***
            if (shouldReportImportExport(node, importNodes)) {
                messagesIds.push("exportAs");
            ***REMOVED***
        ***REMOVED***
        messagesIds.forEach(messageId =>
            context.report({
                node,
                messageId,
                data: {
                    module
                ***REMOVED***
            ***REMOVED***));
    ***REMOVED***
***REMOVED***

/**
 * @callback nodeCallback
 * @param {ASTNode***REMOVED*** node A node to handle.
 */

/**
 * Returns a function handling the (imports|exports) of a given file
 * @param {RuleContext***REMOVED*** context The ESLint rule context object.
 * @param {Map***REMOVED*** modules A Map object contains as a key a module name and as value an array contains objects, each object contains a node and a declaration type.
 * @param {string***REMOVED*** declarationType A declaration type can be an import or export.
 * @param {boolean***REMOVED*** includeExports Whether or not to check for exports in addition to imports.
 * @returns {nodeCallback***REMOVED*** A function passed to ESLint to handle the statement.
 */
function handleImportsExports(
    context,
    modules,
    declarationType,
    includeExports
) {
    return function(node) {
        const module = getModule(node);

        if (module) {
            checkAndReport(
                context,
                node,
                modules,
                declarationType,
                includeExports
            );
            const currentNode = { node, declarationType ***REMOVED***;
            let nodes = [currentNode];

            if (modules.has(module)) {
                const previousNodes = modules.get(module);

                nodes = [...previousNodes, currentNode];
            ***REMOVED***
            modules.set(module, nodes);
        ***REMOVED***
    ***REMOVED***;
***REMOVED***

module.exports = {
    meta: {
        type: "problem",

        docs: {
            description: "disallow duplicate module imports",
            category: "ECMAScript 6",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-duplicate-imports"
        ***REMOVED***,

        schema: [
            {
                type: "object",
                properties: {
                    includeExports: {
                        type: "boolean",
                        default: false
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],

        messages: {
            import: "'{{module***REMOVED******REMOVED***' import is duplicated.",
            importAs: "'{{module***REMOVED******REMOVED***' import is duplicated as export.",
            export: "'{{module***REMOVED******REMOVED***' export is duplicated.",
            exportAs: "'{{module***REMOVED******REMOVED***' export is duplicated as import."
        ***REMOVED***
    ***REMOVED***,

    create(context) {
        const includeExports = (context.options[0] || {***REMOVED***).includeExports,
            modules = new Map();
        const handlers = {
            ImportDeclaration: handleImportsExports(
                context,
                modules,
                "import",
                includeExports
            )
        ***REMOVED***;

        if (includeExports) {
            handlers.ExportNamedDeclaration = handleImportsExports(
                context,
                modules,
                "export",
                includeExports
            );
            handlers.ExportAllDeclaration = handleImportsExports(
                context,
                modules,
                "export",
                includeExports
            );
        ***REMOVED***
        return handlers;
    ***REMOVED***
***REMOVED***;
