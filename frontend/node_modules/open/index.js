const path = require('path');
const childProcess = require('child_process');
const {promises: fs, constants: fsConstants***REMOVED*** = require('fs');
const isWsl = require('is-wsl');
const isDocker = require('is-docker');
const defineLazyProperty = require('define-lazy-prop');

// Path to included `xdg-open`.
const localXdgOpenPath = path.join(__dirname, 'xdg-open');

const {platform, arch***REMOVED*** = process;

// Podman detection
const hasContainerEnv = () => {
	try {
		fs.statSync('/run/.containerenv');
		return true;
	***REMOVED*** catch {
		return false;
	***REMOVED***
***REMOVED***;

let cachedResult;
function isInsideContainer() {
	if (cachedResult === undefined) {
		cachedResult = hasContainerEnv() || isDocker();
	***REMOVED***

	return cachedResult;
***REMOVED***

/**
Get the mount point for fixed drives in WSL.

@inner
@returns {string***REMOVED*** The mount point.
*/
const getWslDrivesMountPoint = (() => {
	// Default value for "root" param
	// according to https://docs.microsoft.com/en-us/windows/wsl/wsl-config
	const defaultMountPoint = '/mnt/';

	let mountPoint;

	return async function () {
		if (mountPoint) {
			// Return memoized mount point value
			return mountPoint;
		***REMOVED***

		const configFilePath = '/etc/wsl.conf';

		let isConfigFileExists = false;
		try {
			await fs.access(configFilePath, fsConstants.F_OK);
			isConfigFileExists = true;
		***REMOVED*** catch {***REMOVED***

		if (!isConfigFileExists) {
			return defaultMountPoint;
		***REMOVED***

		const configContent = await fs.readFile(configFilePath, {encoding: 'utf8'***REMOVED***);
		const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);

		if (!configMountPoint) {
			return defaultMountPoint;
		***REMOVED***

		mountPoint = configMountPoint.groups.mountPoint.trim();
		mountPoint = mountPoint.endsWith('/') ? mountPoint : `${mountPoint***REMOVED***/`;

		return mountPoint;
	***REMOVED***;
***REMOVED***)();

const pTryEach = async (array, mapper) => {
	let latestError;

	for (const item of array) {
		try {
			return await mapper(item); // eslint-disable-line no-await-in-loop
		***REMOVED*** catch (error) {
			latestError = error;
		***REMOVED***
	***REMOVED***

	throw latestError;
***REMOVED***;

const baseOpen = async options => {
	options = {
		wait: false,
		background: false,
		newInstance: false,
		allowNonzeroExitCode: false,
		...options
	***REMOVED***;

	if (Array.isArray(options.app)) {
		return pTryEach(options.app, singleApp => baseOpen({
			...options,
			app: singleApp
		***REMOVED***));
	***REMOVED***

	let {name: app, arguments: appArguments = []***REMOVED*** = options.app || {***REMOVED***;
	appArguments = [...appArguments];

	if (Array.isArray(app)) {
		return pTryEach(app, appName => baseOpen({
			...options,
			app: {
				name: appName,
				arguments: appArguments
			***REMOVED***
		***REMOVED***));
	***REMOVED***

	let command;
	const cliArguments = [];
	const childProcessOptions = {***REMOVED***;

	if (platform === 'darwin') {
		command = 'open';

		if (options.wait) {
			cliArguments.push('--wait-apps');
		***REMOVED***

		if (options.background) {
			cliArguments.push('--background');
		***REMOVED***

		if (options.newInstance) {
			cliArguments.push('--new');
		***REMOVED***

		if (app) {
			cliArguments.push('-a', app);
		***REMOVED***
	***REMOVED*** else if (platform === 'win32' || (isWsl && !isInsideContainer() && !app)) {
		const mountPoint = await getWslDrivesMountPoint();

		command = isWsl ?
			`${mountPoint***REMOVED***c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` :
			`${process.env.SYSTEMROOT***REMOVED***\\System32\\WindowsPowerShell\\v1.0\\powershell`;

		cliArguments.push(
			'-NoProfile',
			'-NonInteractive',
			'â€“ExecutionPolicy',
			'Bypass',
			'-EncodedCommand'
		);

		if (!isWsl) {
			childProcessOptions.windowsVerbatimArguments = true;
		***REMOVED***

		const encodedArguments = ['Start'];

		if (options.wait) {
			encodedArguments.push('-Wait');
		***REMOVED***

		if (app) {
			// Double quote with double quotes to ensure the inner quotes are passed through.
			// Inner quotes are delimited for PowerShell interpretation with backticks.
			encodedArguments.push(`"\`"${app***REMOVED***\`""`, '-ArgumentList');
			if (options.target) {
				appArguments.unshift(options.target);
			***REMOVED***
		***REMOVED*** else if (options.target) {
			encodedArguments.push(`"${options.target***REMOVED***"`);
		***REMOVED***

		if (appArguments.length > 0) {
			appArguments = appArguments.map(arg => `"\`"${arg***REMOVED***\`""`);
			encodedArguments.push(appArguments.join(','));
		***REMOVED***

		// Using Base64-encoded command, accepted by PowerShell, to allow special characters.
		options.target = Buffer.from(encodedArguments.join(' '), 'utf16le').toString('base64');
	***REMOVED*** else {
		if (app) {
			command = app;
		***REMOVED*** else {
			// When bundled by Webpack, there's no actual package file path and no local `xdg-open`.
			const isBundled = !__dirname || __dirname === '/';

			// Check if local `xdg-open` exists and is executable.
			let exeLocalXdgOpen = false;
			try {
				await fs.access(localXdgOpenPath, fsConstants.X_OK);
				exeLocalXdgOpen = true;
			***REMOVED*** catch {***REMOVED***

			const useSystemXdgOpen = process.versions.electron ||
				platform === 'android' || isBundled || !exeLocalXdgOpen;
			command = useSystemXdgOpen ? 'xdg-open' : localXdgOpenPath;
		***REMOVED***

		if (appArguments.length > 0) {
			cliArguments.push(...appArguments);
		***REMOVED***

		if (!options.wait) {
			// `xdg-open` will block the process unless stdio is ignored
			// and it's detached from the parent even if it's unref'd.
			childProcessOptions.stdio = 'ignore';
			childProcessOptions.detached = true;
		***REMOVED***
	***REMOVED***

	if (options.target) {
		cliArguments.push(options.target);
	***REMOVED***

	if (platform === 'darwin' && appArguments.length > 0) {
		cliArguments.push('--args', ...appArguments);
	***REMOVED***

	const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);

	if (options.wait) {
		return new Promise((resolve, reject) => {
			subprocess.once('error', reject);

			subprocess.once('close', exitCode => {
				if (!options.allowNonzeroExitCode && exitCode > 0) {
					reject(new Error(`Exited with code ${exitCode***REMOVED***`));
					return;
				***REMOVED***

				resolve(subprocess);
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	subprocess.unref();

	return subprocess;
***REMOVED***;

const open = (target, options) => {
	if (typeof target !== 'string') {
		throw new TypeError('Expected a `target`');
	***REMOVED***

	return baseOpen({
		...options,
		target
	***REMOVED***);
***REMOVED***;

const openApp = (name, options) => {
	if (typeof name !== 'string') {
		throw new TypeError('Expected a `name`');
	***REMOVED***

	const {arguments: appArguments = []***REMOVED*** = options || {***REMOVED***;
	if (appArguments !== undefined && appArguments !== null && !Array.isArray(appArguments)) {
		throw new TypeError('Expected `appArguments` as Array type');
	***REMOVED***

	return baseOpen({
		...options,
		app: {
			name,
			arguments: appArguments
		***REMOVED***
	***REMOVED***);
***REMOVED***;

function detectArchBinary(binary) {
	if (typeof binary === 'string' || Array.isArray(binary)) {
		return binary;
	***REMOVED***

	const {[arch]: archBinary***REMOVED*** = binary;

	if (!archBinary) {
		throw new Error(`${arch***REMOVED*** is not supported`);
	***REMOVED***

	return archBinary;
***REMOVED***

function detectPlatformBinary({[platform]: platformBinary***REMOVED***, {wsl***REMOVED***) {
	if (wsl && isWsl) {
		return detectArchBinary(wsl);
	***REMOVED***

	if (!platformBinary) {
		throw new Error(`${platform***REMOVED*** is not supported`);
	***REMOVED***

	return detectArchBinary(platformBinary);
***REMOVED***

const apps = {***REMOVED***;

defineLazyProperty(apps, 'chrome', () => detectPlatformBinary({
	darwin: 'google chrome',
	win32: 'chrome',
	linux: ['google-chrome', 'google-chrome-stable', 'chromium']
***REMOVED***, {
	wsl: {
		ia32: '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',
		x64: ['/mnt/c/Program Files/Google/Chrome/Application/chrome.exe', '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe']
	***REMOVED***
***REMOVED***));

defineLazyProperty(apps, 'firefox', () => detectPlatformBinary({
	darwin: 'firefox',
	win32: 'C:\\Program Files\\Mozilla Firefox\\firefox.exe',
	linux: 'firefox'
***REMOVED***, {
	wsl: '/mnt/c/Program Files/Mozilla Firefox/firefox.exe'
***REMOVED***));

defineLazyProperty(apps, 'edge', () => detectPlatformBinary({
	darwin: 'microsoft edge',
	win32: 'msedge',
	linux: ['microsoft-edge', 'microsoft-edge-dev']
***REMOVED***, {
	wsl: '/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe'
***REMOVED***));

open.apps = apps;
open.openApp = openApp;

module.exports = open;
