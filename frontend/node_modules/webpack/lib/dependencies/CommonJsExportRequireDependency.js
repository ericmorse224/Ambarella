/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const Dependency = require("../Dependency");
const { UsageState ***REMOVED*** = require("../ExportsInfo");
const Template = require("../Template");
const { equals ***REMOVED*** = require("../util/ArrayHelpers");
const makeSerializable = require("../util/makeSerializable");
const propertyAccess = require("../util/propertyAccess");
const { handleDependencyBase ***REMOVED*** = require("./CommonJsDependencyHelpers");
const ModuleDependency = require("./ModuleDependency");
const processExportInfo = require("./processExportInfo");

/** @typedef {import("webpack-sources").ReplaceSource***REMOVED*** ReplaceSource */
/** @typedef {import("../Dependency").ExportsSpec***REMOVED*** ExportsSpec */
/** @typedef {import("../Dependency").ReferencedExport***REMOVED*** ReferencedExport */
/** @typedef {import("../Dependency").TRANSITIVE***REMOVED*** TRANSITIVE */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext***REMOVED*** DependencyTemplateContext */
/** @typedef {import("../ExportsInfo")***REMOVED*** ExportsInfo */
/** @typedef {import("../ExportsInfo").ExportInfo***REMOVED*** ExportInfo */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../ModuleGraph")***REMOVED*** ModuleGraph */
/** @typedef {import("../javascript/JavascriptParser").Range***REMOVED*** Range */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext***REMOVED*** ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext***REMOVED*** ObjectSerializerContext */
/** @typedef {import("../util/runtime").RuntimeSpec***REMOVED*** RuntimeSpec */
/** @typedef {import("./CommonJsDependencyHelpers").CommonJSDependencyBaseKeywords***REMOVED*** CommonJSDependencyBaseKeywords */

const idsSymbol = Symbol("CommonJsExportRequireDependency.ids");

const EMPTY_OBJECT = {***REMOVED***;

class CommonJsExportRequireDependency extends ModuleDependency {
	/**
	 * @param {Range***REMOVED*** range range
	 * @param {Range | null***REMOVED*** valueRange value range
	 * @param {CommonJSDependencyBaseKeywords***REMOVED*** base base
	 * @param {string[]***REMOVED*** names names
	 * @param {string***REMOVED*** request request
	 * @param {string[]***REMOVED*** ids ids
	 * @param {boolean***REMOVED*** resultUsed true, when the result is used
	 */
	constructor(range, valueRange, base, names, request, ids, resultUsed) {
		super(request);
		this.range = range;
		this.valueRange = valueRange;
		this.base = base;
		this.names = names;
		this.ids = ids;
		this.resultUsed = resultUsed;
		this.asiSafe = undefined;
	***REMOVED***

	get type() {
		return "cjs export require";
	***REMOVED***

	/**
	 * @returns {boolean | TRANSITIVE***REMOVED*** true, when changes to the referenced module could affect the referencing module; TRANSITIVE, when changes to the referenced module could affect referencing modules of the referencing module
	 */
	couldAffectReferencingModule() {
		return Dependency.TRANSITIVE;
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @returns {string[]***REMOVED*** the imported id
	 */
	getIds(moduleGraph) {
		return moduleGraph.getMeta(this)[idsSymbol] || this.ids;
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @param {string[]***REMOVED*** ids the imported ids
	 * @returns {void***REMOVED***
	 */
	setIds(moduleGraph, ids) {
		moduleGraph.getMeta(this)[idsSymbol] = ids;
	***REMOVED***

	/**
	 * Returns list of exports referenced by this dependency
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime for which the module is analysed
	 * @returns {(string[] | ReferencedExport)[]***REMOVED*** referenced exports
	 */
	getReferencedExports(moduleGraph, runtime) {
		const ids = this.getIds(moduleGraph);
		const getFullResult = () => {
			if (ids.length === 0) {
				return Dependency.EXPORTS_OBJECT_REFERENCED;
			***REMOVED***
			return [
				{
					name: ids,
					canMangle: false
				***REMOVED***
			];
		***REMOVED***;
		if (this.resultUsed) return getFullResult();
		/** @type {ExportsInfo | undefined***REMOVED*** */
		let exportsInfo = moduleGraph.getExportsInfo(
			/** @type {Module***REMOVED*** */ (moduleGraph.getParentModule(this))
		);
		for (const name of this.names) {
			const exportInfo = /** @type {ExportInfo***REMOVED*** */ (
				exportsInfo.getReadOnlyExportInfo(name)
			);
			const used = exportInfo.getUsed(runtime);
			if (used === UsageState.Unused) return Dependency.NO_EXPORTS_REFERENCED;
			if (used !== UsageState.OnlyPropertiesUsed) return getFullResult();
			exportsInfo = exportInfo.exportsInfo;
			if (!exportsInfo) return getFullResult();
		***REMOVED***
		if (exportsInfo.otherExportsInfo.getUsed(runtime) !== UsageState.Unused) {
			return getFullResult();
		***REMOVED***
		/** @type {string[][]***REMOVED*** */
		const referencedExports = [];
		for (const exportInfo of exportsInfo.orderedExports) {
			processExportInfo(
				runtime,
				referencedExports,
				ids.concat(exportInfo.name),
				exportInfo,
				false
			);
		***REMOVED***
		return referencedExports.map(name => ({
			name,
			canMangle: false
		***REMOVED***));
	***REMOVED***

	/**
	 * Returns the exported names
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @returns {ExportsSpec | undefined***REMOVED*** export names
	 */
	getExports(moduleGraph) {
		if (this.names.length === 1) {
			const ids = this.getIds(moduleGraph);
			const name = this.names[0];
			const from = moduleGraph.getConnection(this);
			if (!from) return;
			return {
				exports: [
					{
						name,
						from,
						export: ids.length === 0 ? null : ids,
						// we can't mangle names that are in an empty object
						// because one could access the prototype property
						// when export isn't set yet
						canMangle: !(name in EMPTY_OBJECT) && false
					***REMOVED***
				],
				dependencies: [from.module]
			***REMOVED***;
		***REMOVED*** else if (this.names.length > 0) {
			const name = this.names[0];
			return {
				exports: [
					{
						name,
						// we can't mangle names that are in an empty object
						// because one could access the prototype property
						// when export isn't set yet
						canMangle: !(name in EMPTY_OBJECT) && false
					***REMOVED***
				],
				dependencies: undefined
			***REMOVED***;
		***REMOVED***
		const from = moduleGraph.getConnection(this);
		if (!from) return;
		const reexportInfo = this.getStarReexports(
			moduleGraph,
			undefined,
			from.module
		);
		const ids = this.getIds(moduleGraph);
		if (reexportInfo) {
			return {
				exports: Array.from(
					/** @type {Set<string>***REMOVED*** */
					(reexportInfo.exports),
					name => ({
						name,
						from,
						export: ids.concat(name),
						canMangle: !(name in EMPTY_OBJECT) && false
					***REMOVED***)
				),
				// TODO handle deep reexports
				dependencies: [from.module]
			***REMOVED***;
		***REMOVED***
		return {
			exports: true,
			from: ids.length === 0 ? from : undefined,
			canMangle: false,
			dependencies: [from.module]
		***REMOVED***;
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @param {Module***REMOVED*** importedModule the imported module (optional)
	 * @returns {{exports?: Set<string>, checked?: Set<string>***REMOVED*** | undefined***REMOVED*** information
	 */
	getStarReexports(
		moduleGraph,
		runtime,
		importedModule = /** @type {Module***REMOVED*** */ (moduleGraph.getModule(this))
	) {
		/** @type {ExportsInfo | undefined***REMOVED*** */
		let importedExportsInfo = moduleGraph.getExportsInfo(importedModule);
		const ids = this.getIds(moduleGraph);
		if (ids.length > 0)
			importedExportsInfo = importedExportsInfo.getNestedExportsInfo(ids);
		/** @type {ExportsInfo | undefined***REMOVED*** */
		let exportsInfo = moduleGraph.getExportsInfo(
			/** @type {Module***REMOVED*** */ (moduleGraph.getParentModule(this))
		);
		if (this.names.length > 0)
			exportsInfo = exportsInfo.getNestedExportsInfo(this.names);

		const noExtraExports =
			importedExportsInfo &&
			importedExportsInfo.otherExportsInfo.provided === false;
		const noExtraImports =
			exportsInfo &&
			exportsInfo.otherExportsInfo.getUsed(runtime) === UsageState.Unused;

		if (!noExtraExports && !noExtraImports) {
			return;
		***REMOVED***

		const isNamespaceImport =
			importedModule.getExportsType(moduleGraph, false) === "namespace";

		/** @type {Set<string>***REMOVED*** */
		const exports = new Set();
		/** @type {Set<string>***REMOVED*** */
		const checked = new Set();

		if (noExtraImports) {
			for (const exportInfo of /** @type {ExportsInfo***REMOVED*** */ (exportsInfo)
				.orderedExports) {
				const name = exportInfo.name;
				if (exportInfo.getUsed(runtime) === UsageState.Unused) continue;
				if (name === "__esModule" && isNamespaceImport) {
					exports.add(name);
				***REMOVED*** else if (importedExportsInfo) {
					const importedExportInfo =
						importedExportsInfo.getReadOnlyExportInfo(name);
					if (importedExportInfo.provided === false) continue;
					exports.add(name);
					if (importedExportInfo.provided === true) continue;
					checked.add(name);
				***REMOVED*** else {
					exports.add(name);
					checked.add(name);
				***REMOVED***
			***REMOVED***
		***REMOVED*** else if (noExtraExports) {
			for (const importedExportInfo of /** @type {ExportsInfo***REMOVED*** */ (
				importedExportsInfo
			).orderedExports) {
				const name = importedExportInfo.name;
				if (importedExportInfo.provided === false) continue;
				if (exportsInfo) {
					const exportInfo = exportsInfo.getReadOnlyExportInfo(name);
					if (exportInfo.getUsed(runtime) === UsageState.Unused) continue;
				***REMOVED***
				exports.add(name);
				if (importedExportInfo.provided === true) continue;
				checked.add(name);
			***REMOVED***
			if (isNamespaceImport) {
				exports.add("__esModule");
				checked.delete("__esModule");
			***REMOVED***
		***REMOVED***

		return { exports, checked ***REMOVED***;
	***REMOVED***

	/**
	 * @param {ObjectSerializerContext***REMOVED*** context context
	 */
	serialize(context) {
		const { write ***REMOVED*** = context;
		write(this.asiSafe);
		write(this.range);
		write(this.valueRange);
		write(this.base);
		write(this.names);
		write(this.ids);
		write(this.resultUsed);
		super.serialize(context);
	***REMOVED***

	/**
	 * @param {ObjectDeserializerContext***REMOVED*** context context
	 */
	deserialize(context) {
		const { read ***REMOVED*** = context;
		this.asiSafe = read();
		this.range = read();
		this.valueRange = read();
		this.base = read();
		this.names = read();
		this.ids = read();
		this.resultUsed = read();
		super.deserialize(context);
	***REMOVED***
***REMOVED***

makeSerializable(
	CommonJsExportRequireDependency,
	"webpack/lib/dependencies/CommonJsExportRequireDependency"
);

CommonJsExportRequireDependency.Template = class CommonJsExportRequireDependencyTemplate extends (
	ModuleDependency.Template
) {
	/**
	 * @param {Dependency***REMOVED*** dependency the dependency for which the template should be applied
	 * @param {ReplaceSource***REMOVED*** source the current replace source which can be modified
	 * @param {DependencyTemplateContext***REMOVED*** templateContext the context object
	 * @returns {void***REMOVED***
	 */
	apply(
		dependency,
		source,
		{
			module,
			runtimeTemplate,
			chunkGraph,
			moduleGraph,
			runtimeRequirements,
			runtime
		***REMOVED***
	) {
		const dep = /** @type {CommonJsExportRequireDependency***REMOVED*** */ (dependency);
		const used = moduleGraph
			.getExportsInfo(module)
			.getUsedName(dep.names, runtime);

		const [type, base] = handleDependencyBase(
			dep.base,
			module,
			runtimeRequirements
		);

		const importedModule = moduleGraph.getModule(dep);
		let requireExpr = runtimeTemplate.moduleExports({
			module: importedModule,
			chunkGraph,
			request: dep.request,
			weak: dep.weak,
			runtimeRequirements
		***REMOVED***);
		if (importedModule) {
			const ids = dep.getIds(moduleGraph);
			const usedImported = moduleGraph
				.getExportsInfo(importedModule)
				.getUsedName(ids, runtime);
			if (usedImported) {
				const comment = equals(usedImported, ids)
					? ""
					: `${Template.toNormalComment(propertyAccess(ids))***REMOVED*** `;
				requireExpr += `${comment***REMOVED***${propertyAccess(usedImported)***REMOVED***`;
			***REMOVED***
		***REMOVED***

		switch (type) {
			case "expression":
				source.replace(
					dep.range[0],
					dep.range[1] - 1,
					used
						? `${base***REMOVED***${propertyAccess(used)***REMOVED*** = ${requireExpr***REMOVED***`
						: `/* unused reexport */ ${requireExpr***REMOVED***`
				);
				return;
			case "Object.defineProperty":
				throw new Error("TODO");
			default:
				throw new Error("Unexpected type");
		***REMOVED***
	***REMOVED***
***REMOVED***;

module.exports = CommonJsExportRequireDependency;
