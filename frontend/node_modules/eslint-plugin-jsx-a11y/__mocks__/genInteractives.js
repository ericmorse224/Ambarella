/**
 * @flow
 */

import { dom, roles ***REMOVED*** from 'aria-query';
import includes from 'array-includes';
import fromEntries from 'object.fromentries';

import JSXAttributeMock from './JSXAttributeMock';
import JSXElementMock from './JSXElementMock';

import type { JSXAttributeMockType ***REMOVED*** from './JSXAttributeMock';
import type { JSXElementMockType ***REMOVED*** from './JSXElementMock';

const domElements = dom.keys();
const roleNames = roles.keys();

const interactiveElementsMap = {
  a: [{ prop: 'href', value: '#' ***REMOVED***],
  area: [{ prop: 'href', value: '#' ***REMOVED***],
  audio: [],
  button: [],
  canvas: [],
  datalist: [],
  embed: [],
  input: [],
  'input[type="button"]': [{ prop: 'type', value: 'button' ***REMOVED***],
  'input[type="checkbox"]': [{ prop: 'type', value: 'checkbox' ***REMOVED***],
  'input[type="color"]': [{ prop: 'type', value: 'color' ***REMOVED***],
  'input[type="date"]': [{ prop: 'type', value: 'date' ***REMOVED***],
  'input[type="datetime"]': [{ prop: 'type', value: 'datetime' ***REMOVED***],
  'input[type="email"]': [{ prop: 'type', value: 'email' ***REMOVED***],
  'input[type="file"]': [{ prop: 'type', value: 'file' ***REMOVED***],
  'input[type="image"]': [{ prop: 'type', value: 'image' ***REMOVED***],
  'input[type="month"]': [{ prop: 'type', value: 'month' ***REMOVED***],
  'input[type="number"]': [{ prop: 'type', value: 'number' ***REMOVED***],
  'input[type="password"]': [{ prop: 'type', value: 'password' ***REMOVED***],
  'input[type="radio"]': [{ prop: 'type', value: 'radio' ***REMOVED***],
  'input[type="range"]': [{ prop: 'type', value: 'range' ***REMOVED***],
  'input[type="reset"]': [{ prop: 'type', value: 'reset' ***REMOVED***],
  'input[type="search"]': [{ prop: 'type', value: 'search' ***REMOVED***],
  'input[type="submit"]': [{ prop: 'type', value: 'submit' ***REMOVED***],
  'input[type="tel"]': [{ prop: 'type', value: 'tel' ***REMOVED***],
  'input[type="text"]': [{ prop: 'type', value: 'text' ***REMOVED***],
  'input[type="time"]': [{ prop: 'type', value: 'time' ***REMOVED***],
  'input[type="url"]': [{ prop: 'type', value: 'url' ***REMOVED***],
  'input[type="week"]': [{ prop: 'type', value: 'week' ***REMOVED***],
  menuitem: [],
  option: [],
  select: [],
  summary: [],
  // Whereas ARIA makes a distinction between cell and gridcell, the AXObject
  // treats them both as CellRole and since gridcell is interactive, we consider
  // cell interactive as well.
  td: [],
  th: [],
  tr: [],
  textarea: [],
  video: [],
***REMOVED***;

const nonInteractiveElementsMap: {[string]: Array<{[string]: string***REMOVED***>***REMOVED*** = {
  abbr: [],
  address: [],
  article: [],
  aside: [],
  blockquote: [],
  br: [],
  caption: [],
  code: [],
  dd: [],
  del: [],
  details: [],
  dfn: [],
  dialog: [],
  dir: [],
  dl: [],
  dt: [],
  em: [],
  fieldset: [],
  figcaption: [],
  figure: [],
  footer: [],
  form: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  hr: [],
  html: [],
  iframe: [],
  img: [],
  ins: [],
  label: [],
  legend: [],
  li: [],
  main: [],
  mark: [],
  marquee: [],
  menu: [],
  meter: [],
  nav: [],
  ol: [],
  optgroup: [],
  output: [],
  p: [],
  pre: [],
  progress: [],
  ruby: [],
  'section[aria-label]': [{ prop: 'aria-label' ***REMOVED***],
  'section[aria-labelledby]': [{ prop: 'aria-labelledby' ***REMOVED***],
  strong: [],
  sub: [],
  sup: [],
  table: [],
  tbody: [],
  tfoot: [],
  thead: [],
  time: [],
  ul: [],
***REMOVED***;

const indeterminantInteractiveElementsMap: { [key: string]: Array<any> ***REMOVED*** = fromEntries(domElements.map((name) => [name, []]));

Object.keys(interactiveElementsMap)
  .concat(Object.keys(nonInteractiveElementsMap))
  .forEach((name) => delete indeterminantInteractiveElementsMap[name]);

const abstractRoles = roleNames.filter((role) => roles.get(role).abstract);

const nonAbstractRoles = roleNames.filter((role) => !roles.get(role).abstract);

const interactiveRoles = []
  .concat(
    roleNames,
    // 'toolbar' does not descend from widget, but it does support
    // aria-activedescendant, thus in practice we treat it as a widget.
    'toolbar',
  )
  .filter((role) => (
    !roles.get(role).abstract
    && roles.get(role).superClass.some((klasses) => includes(klasses, 'widget'))
  ));

const nonInteractiveRoles = roleNames
  .filter((role) => (
    !roles.get(role).abstract
    && !roles.get(role).superClass.some((klasses) => includes(klasses, 'widget'))

    // 'toolbar' does not descend from widget, but it does support
    // aria-activedescendant, thus in practice we treat it as a widget.
    && !includes(['toolbar'], role)
  ));

export function genElementSymbol(openingElement: Object): string {
  return (
    openingElement.name.name + (openingElement.attributes.length > 0
      ? `${openingElement.attributes.map((attr) => `[${attr.name.name***REMOVED***="${attr.value.value***REMOVED***"]`).join('')***REMOVED***`
      : ''
    )
  );
***REMOVED***

export function genInteractiveElements(): Array<JSXElementMockType> {
  return Object.keys(interactiveElementsMap).map((elementSymbol: string): JSXElementMockType => {
    const bracketIndex = elementSymbol.indexOf('[');
    let name = elementSymbol;
    if (bracketIndex > -1) {
      name = elementSymbol.slice(0, bracketIndex);
    ***REMOVED***
    const attributes = interactiveElementsMap[elementSymbol].map(({ prop, value ***REMOVED***) => JSXAttributeMock(prop, value));
    return JSXElementMock(name, attributes);
  ***REMOVED***);
***REMOVED***

export function genInteractiveRoleElements(): Array<JSXElementMockType> {
  return interactiveRoles.concat('button article', 'fakerole button article').map((value): JSXElementMockType => JSXElementMock(
    'div',
    [JSXAttributeMock('role', value)],
  ));
***REMOVED***

export function genNonInteractiveElements(): Array<JSXElementMockType> {
  return Object.keys(nonInteractiveElementsMap).map((elementSymbol): JSXElementMockType => {
    const bracketIndex = elementSymbol.indexOf('[');
    let name = elementSymbol;
    if (bracketIndex > -1) {
      name = elementSymbol.slice(0, bracketIndex);
    ***REMOVED***
    const attributes = nonInteractiveElementsMap[elementSymbol].map(({ prop, value ***REMOVED***) => JSXAttributeMock(prop, value));
    return JSXElementMock(name, attributes);
  ***REMOVED***);
***REMOVED***

export function genNonInteractiveRoleElements(): Array<JSXElementMockType> {
  return [
    ...nonInteractiveRoles,
    'article button',
    'fakerole article button',
  ].map((value) => JSXElementMock('div', [JSXAttributeMock('role', value)]));
***REMOVED***

export function genAbstractRoleElements(): Array<JSXElementMockType> {
  return abstractRoles.map((value) => JSXElementMock('div', [JSXAttributeMock('role', value)]));
***REMOVED***

export function genNonAbstractRoleElements(): Array<JSXElementMockType> {
  return nonAbstractRoles.map((value) => JSXElementMock('div', [JSXAttributeMock('role', value)]));
***REMOVED***

export function genIndeterminantInteractiveElements(): Array<JSXElementMockType> {
  return Object.keys(indeterminantInteractiveElementsMap).map((name) => {
    const attributes = indeterminantInteractiveElementsMap[name].map(({ prop, value ***REMOVED***): JSXAttributeMockType => JSXAttributeMock(prop, value));
    return JSXElementMock(name, attributes);
  ***REMOVED***);
***REMOVED***
