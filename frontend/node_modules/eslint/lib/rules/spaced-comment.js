/**
 * @fileoverview Source code for spaced-comments rule
 * @author Gyandeep Singh
 * @deprecated in ESLint v8.53.0
 */
"use strict";

const escapeRegExp = require("escape-string-regexp");
const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Escapes the control characters of a given string.
 * @param {string***REMOVED*** s A string to escape.
 * @returns {string***REMOVED*** An escaped string.
 */
function escape(s) {
	return `(?:${escapeRegExp(s)***REMOVED***)`;
***REMOVED***

/**
 * Escapes the control characters of a given string.
 * And adds a repeat flag.
 * @param {string***REMOVED*** s A string to escape.
 * @returns {string***REMOVED*** An escaped string.
 */
function escapeAndRepeat(s) {
	return `${escape(s)***REMOVED***+`;
***REMOVED***

/**
 * Parses `markers` option.
 * If markers don't include `"*"`, this adds `"*"` to allow JSDoc comments.
 * @param {string[]***REMOVED*** [markers] A marker list.
 * @returns {string[]***REMOVED*** A marker list.
 */
function parseMarkersOption(markers) {
	// `*` is a marker for JSDoc comments.
	if (!markers.includes("*")) {
		return markers.concat("*");
	***REMOVED***

	return markers;
***REMOVED***

/**
 * Creates string pattern for exceptions.
 * Generated pattern:
 *
 * 1. A space or an exception pattern sequence.
 * @param {string[]***REMOVED*** exceptions An exception pattern list.
 * @returns {string***REMOVED*** A regular expression string for exceptions.
 */
function createExceptionsPattern(exceptions) {
	let pattern = "";

	/*
	 * A space or an exception pattern sequence.
	 * []                 ==> "\s"
	 * ["-"]              ==> "(?:\s|\-+$)"
	 * ["-", "="]         ==> "(?:\s|(?:\-+|=+)$)"
	 * ["-", "=", "--=="] ==> "(?:\s|(?:\-+|=+|(?:\-\-==)+)$)" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)
	 */
	if (exceptions.length === 0) {
		// a space.
		pattern += "\\s";
	***REMOVED*** else {
		// a space or...
		pattern += "(?:\\s|";

		if (exceptions.length === 1) {
			// a sequence of the exception pattern.
			pattern += escapeAndRepeat(exceptions[0]);
		***REMOVED*** else {
			// a sequence of one of the exception patterns.
			pattern += "(?:";
			pattern += exceptions.map(escapeAndRepeat).join("|");
			pattern += ")";
		***REMOVED***
		pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join("")***REMOVED***]))`;
	***REMOVED***

	return pattern;
***REMOVED***

/**
 * Creates RegExp object for `always` mode.
 * Generated pattern for beginning of comment:
 *
 * 1. First, a marker or nothing.
 * 2. Next, a space or an exception pattern sequence.
 * @param {string[]***REMOVED*** markers A marker list.
 * @param {string[]***REMOVED*** exceptions An exception pattern list.
 * @returns {RegExp***REMOVED*** A RegExp object for the beginning of a comment in `always` mode.
 */
function createAlwaysStylePattern(markers, exceptions) {
	let pattern = "^";

	/*
	 * A marker or nothing.
	 * ["*"]            ==> "\*?"
	 * ["*", "!"]       ==> "(?:\*|!)?"
	 * ["*", "/", "!<"] ==> "(?:\*|\/|(?:!<))?" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F
	 */
	if (markers.length === 1) {
		// the marker.
		pattern += escape(markers[0]);
	***REMOVED*** else {
		// one of markers.
		pattern += "(?:";
		pattern += markers.map(escape).join("|");
		pattern += ")";
	***REMOVED***

	pattern += "?"; // or nothing.
	pattern += createExceptionsPattern(exceptions);

	return new RegExp(pattern, "u");
***REMOVED***

/**
 * Creates RegExp object for `never` mode.
 * Generated pattern for beginning of comment:
 *
 * 1. First, a marker or nothing (captured).
 * 2. Next, a space or a tab.
 * @param {string[]***REMOVED*** markers A marker list.
 * @returns {RegExp***REMOVED*** A RegExp object for `never` mode.
 */
function createNeverStylePattern(markers) {
	const pattern = `^(${markers.map(escape).join("|")***REMOVED***)?[ \t]+`;

	return new RegExp(pattern, "u");
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		deprecated: {
			message: "Formatting rules are being moved out of ESLint core.",
			url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
			deprecatedSince: "8.53.0",
			availableUntil: "10.0.0",
			replacedBy: [
				{
					message:
						"ESLint Stylistic now maintains deprecated stylistic core rules.",
					url: "https://eslint.style/guide/migration",
					plugin: {
						name: "@stylistic/eslint-plugin-js",
						url: "https://eslint.style/packages/js",
					***REMOVED***,
					rule: {
						name: "spaced-comment",
						url: "https://eslint.style/rules/js/spaced-comment",
					***REMOVED***,
				***REMOVED***,
			],
		***REMOVED***,
		type: "suggestion",

		docs: {
			description:
				"Enforce consistent spacing after the `//` or `/*` in a comment",
			recommended: false,
			url: "https://eslint.org/docs/latest/rules/spaced-comment",
		***REMOVED***,

		fixable: "whitespace",

		schema: [
			{
				enum: ["always", "never"],
			***REMOVED***,
			{
				type: "object",
				properties: {
					exceptions: {
						type: "array",
						items: {
							type: "string",
						***REMOVED***,
					***REMOVED***,
					markers: {
						type: "array",
						items: {
							type: "string",
						***REMOVED***,
					***REMOVED***,
					line: {
						type: "object",
						properties: {
							exceptions: {
								type: "array",
								items: {
									type: "string",
								***REMOVED***,
							***REMOVED***,
							markers: {
								type: "array",
								items: {
									type: "string",
								***REMOVED***,
							***REMOVED***,
						***REMOVED***,
						additionalProperties: false,
					***REMOVED***,
					block: {
						type: "object",
						properties: {
							exceptions: {
								type: "array",
								items: {
									type: "string",
								***REMOVED***,
							***REMOVED***,
							markers: {
								type: "array",
								items: {
									type: "string",
								***REMOVED***,
							***REMOVED***,
							balanced: {
								type: "boolean",
								default: false,
							***REMOVED***,
						***REMOVED***,
						additionalProperties: false,
					***REMOVED***,
				***REMOVED***,
				additionalProperties: false,
			***REMOVED***,
		],

		messages: {
			unexpectedSpaceAfterMarker:
				"Unexpected space or tab after marker ({{refChar***REMOVED******REMOVED***) in comment.",
			expectedExceptionAfter:
				"Expected exception block, space or tab after '{{refChar***REMOVED******REMOVED***' in comment.",
			unexpectedSpaceBefore:
				"Unexpected space or tab before '*/' in comment.",
			unexpectedSpaceAfter:
				"Unexpected space or tab after '{{refChar***REMOVED******REMOVED***' in comment.",
			expectedSpaceBefore:
				"Expected space or tab before '*/' in comment.",
			expectedSpaceAfter:
				"Expected space or tab after '{{refChar***REMOVED******REMOVED***' in comment.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const sourceCode = context.sourceCode;

		// Unless the first option is never, require a space
		const requireSpace = context.options[0] !== "never";

		/*
		 * Parse the second options.
		 * If markers don't include `"*"`, it's added automatically for JSDoc
		 * comments.
		 */
		const config = context.options[1] || {***REMOVED***;
		const balanced = config.block && config.block.balanced;

		const styleRules = ["block", "line"].reduce((rule, type) => {
			const markers = parseMarkersOption(
				(config[type] && config[type].markers) || config.markers || [],
			);
			const exceptions =
				(config[type] && config[type].exceptions) ||
				config.exceptions ||
				[];
			const endNeverPattern = "[ \t]+$";

			// Create RegExp object for valid patterns.
			rule[type] = {
				beginRegex: requireSpace
					? createAlwaysStylePattern(markers, exceptions)
					: createNeverStylePattern(markers),
				endRegex:
					balanced && requireSpace
						? new RegExp(
								`${createExceptionsPattern(exceptions)***REMOVED***$`,
								"u",
							)
						: new RegExp(endNeverPattern, "u"),
				hasExceptions: exceptions.length > 0,
				captureMarker: new RegExp(
					`^(${markers.map(escape).join("|")***REMOVED***)`,
					"u",
				),
				markers: new Set(markers),
			***REMOVED***;

			return rule;
		***REMOVED***, {***REMOVED***);

		/**
		 * Reports a beginning spacing error with an appropriate message.
		 * @param {ASTNode***REMOVED*** node A comment node to check.
		 * @param {string***REMOVED*** messageId An error message to report.
		 * @param {Array***REMOVED*** match An array of match results for markers.
		 * @param {string***REMOVED*** refChar Character used for reference in the error message.
		 * @returns {void***REMOVED***
		 */
		function reportBegin(node, messageId, match, refChar) {
			const type = node.type.toLowerCase(),
				commentIdentifier = type === "block" ? "/*" : "//";

			context.report({
				node,
				fix(fixer) {
					const start = node.range[0];
					let end = start + 2;

					if (requireSpace) {
						if (match) {
							end += match[0].length;
						***REMOVED***
						return fixer.insertTextAfterRange([start, end], " ");
					***REMOVED***
					end += match[0].length;
					return fixer.replaceTextRange(
						[start, end],
						commentIdentifier + (match[1] ? match[1] : ""),
					);
				***REMOVED***,
				messageId,
				data: { refChar ***REMOVED***,
			***REMOVED***);
		***REMOVED***

		/**
		 * Reports an ending spacing error with an appropriate message.
		 * @param {ASTNode***REMOVED*** node A comment node to check.
		 * @param {string***REMOVED*** messageId An error message to report.
		 * @param {string***REMOVED*** match An array of the matched whitespace characters.
		 * @returns {void***REMOVED***
		 */
		function reportEnd(node, messageId, match) {
			context.report({
				node,
				fix(fixer) {
					if (requireSpace) {
						return fixer.insertTextAfterRange(
							[node.range[0], node.range[1] - 2],
							" ",
						);
					***REMOVED***
					const end = node.range[1] - 2,
						start = end - match[0].length;

					return fixer.replaceTextRange([start, end], "");
				***REMOVED***,
				messageId,
			***REMOVED***);
		***REMOVED***

		/**
		 * Reports a given comment if it's invalid.
		 * @param {ASTNode***REMOVED*** node a comment node to check.
		 * @returns {void***REMOVED***
		 */
		function checkCommentForSpace(node) {
			const type = node.type.toLowerCase(),
				rule = styleRules[type],
				commentIdentifier = type === "block" ? "/*" : "//";

			// Ignores empty comments and comments that consist only of a marker.
			if (node.value.length === 0 || rule.markers.has(node.value)) {
				return;
			***REMOVED***

			const beginMatch = rule.beginRegex.exec(node.value);
			const endMatch = rule.endRegex.exec(node.value);

			// Checks.
			if (requireSpace) {
				if (!beginMatch) {
					const hasMarker = rule.captureMarker.exec(node.value);
					const marker = hasMarker
						? commentIdentifier + hasMarker[0]
						: commentIdentifier;

					if (rule.hasExceptions) {
						reportBegin(
							node,
							"expectedExceptionAfter",
							hasMarker,
							marker,
						);
					***REMOVED*** else {
						reportBegin(
							node,
							"expectedSpaceAfter",
							hasMarker,
							marker,
						);
					***REMOVED***
				***REMOVED***

				if (balanced && type === "block" && !endMatch) {
					reportEnd(node, "expectedSpaceBefore");
				***REMOVED***
			***REMOVED*** else {
				if (beginMatch) {
					if (!beginMatch[1]) {
						reportBegin(
							node,
							"unexpectedSpaceAfter",
							beginMatch,
							commentIdentifier,
						);
					***REMOVED*** else {
						reportBegin(
							node,
							"unexpectedSpaceAfterMarker",
							beginMatch,
							beginMatch[1],
						);
					***REMOVED***
				***REMOVED***

				if (balanced && type === "block" && endMatch) {
					reportEnd(node, "unexpectedSpaceBefore", endMatch);
				***REMOVED***
			***REMOVED***
		***REMOVED***

		return {
			Program() {
				const comments = sourceCode.getAllComments();

				comments
					.filter(token => token.type !== "Shebang")
					.forEach(checkCommentForSpace);
			***REMOVED***,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
