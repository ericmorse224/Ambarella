/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { DEFAULTS ***REMOVED*** = require("./config/defaults");
const { getOrInsert ***REMOVED*** = require("./util/MapHelpers");
const { first ***REMOVED*** = require("./util/SetHelpers");
const createHash = require("./util/createHash");
const { runtimeToString, RuntimeSpecMap ***REMOVED*** = require("./util/runtime");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("./Module")***REMOVED*** Module */
/** @typedef {import("./Module").CodeGenerationResult***REMOVED*** CodeGenerationResult */
/** @typedef {import("./Module").ReadOnlyRuntimeRequirements***REMOVED*** ReadOnlyRuntimeRequirements */
/** @typedef {typeof import("./util/Hash")***REMOVED*** Hash */
/** @typedef {import("./util/runtime").RuntimeSpec***REMOVED*** RuntimeSpec */

class CodeGenerationResults {
	/**
	 * @param {string | Hash***REMOVED*** hashFunction the hash function to use
	 */
	constructor(hashFunction = DEFAULTS.HASH_FUNCTION) {
		/** @type {Map<Module, RuntimeSpecMap<CodeGenerationResult>>***REMOVED*** */
		this.map = new Map();
		this._hashFunction = hashFunction;
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the module
	 * @param {RuntimeSpec***REMOVED*** runtime runtime(s)
	 * @returns {CodeGenerationResult***REMOVED*** the CodeGenerationResult
	 */
	get(module, runtime) {
		const entry = this.map.get(module);
		if (entry === undefined) {
			throw new Error(
				`No code generation entry for ${module.identifier()***REMOVED*** (existing entries: ${Array.from(
					this.map.keys(),
					m => m.identifier()
				).join(", ")***REMOVED***)`
			);
		***REMOVED***
		if (runtime === undefined) {
			if (entry.size > 1) {
				const results = new Set(entry.values());
				if (results.size !== 1) {
					throw new Error(
						`No unique code generation entry for unspecified runtime for ${module.identifier()***REMOVED*** (existing runtimes: ${Array.from(
							entry.keys(),
							r => runtimeToString(r)
						).join(", ")***REMOVED***).
Caller might not support runtime-dependent code generation (opt-out via optimization.usedExports: "global").`
					);
				***REMOVED***
				return /** @type {CodeGenerationResult***REMOVED*** */ (first(results));
			***REMOVED***
			return /** @type {CodeGenerationResult***REMOVED*** */ (entry.values().next().value);
		***REMOVED***
		const result = entry.get(runtime);
		if (result === undefined) {
			throw new Error(
				`No code generation entry for runtime ${runtimeToString(
					runtime
				)***REMOVED*** for ${module.identifier()***REMOVED*** (existing runtimes: ${Array.from(
					entry.keys(),
					r => runtimeToString(r)
				).join(", ")***REMOVED***)`
			);
		***REMOVED***
		return result;
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the module
	 * @param {RuntimeSpec***REMOVED*** runtime runtime(s)
	 * @returns {boolean***REMOVED*** true, when we have data for this
	 */
	has(module, runtime) {
		const entry = this.map.get(module);
		if (entry === undefined) {
			return false;
		***REMOVED***
		if (runtime !== undefined) {
			return entry.has(runtime);
		***REMOVED*** else if (entry.size > 1) {
			const results = new Set(entry.values());
			return results.size === 1;
		***REMOVED***
		return entry.size === 1;
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the module
	 * @param {RuntimeSpec***REMOVED*** runtime runtime(s)
	 * @param {string***REMOVED*** sourceType the source type
	 * @returns {Source***REMOVED*** a source
	 */
	getSource(module, runtime, sourceType) {
		return /** @type {Source***REMOVED*** */ (
			this.get(module, runtime).sources.get(sourceType)
		);
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the module
	 * @param {RuntimeSpec***REMOVED*** runtime runtime(s)
	 * @returns {ReadOnlyRuntimeRequirements | null***REMOVED*** runtime requirements
	 */
	getRuntimeRequirements(module, runtime) {
		return this.get(module, runtime).runtimeRequirements;
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the module
	 * @param {RuntimeSpec***REMOVED*** runtime runtime(s)
	 * @param {string***REMOVED*** key data key
	 * @returns {TODO | undefined***REMOVED*** data generated by code generation
	 */
	getData(module, runtime, key) {
		const data = this.get(module, runtime).data;
		return data === undefined ? undefined : data.get(key);
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the module
	 * @param {RuntimeSpec***REMOVED*** runtime runtime(s)
	 * @returns {string***REMOVED*** hash of the code generation
	 */
	getHash(module, runtime) {
		const info = this.get(module, runtime);
		if (info.hash !== undefined) return info.hash;
		const hash = createHash(this._hashFunction);
		for (const [type, source] of info.sources) {
			hash.update(type);
			source.updateHash(hash);
		***REMOVED***
		if (info.runtimeRequirements) {
			for (const rr of info.runtimeRequirements) hash.update(rr);
		***REMOVED***
		return (info.hash = /** @type {string***REMOVED*** */ (hash.digest("hex")));
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the module
	 * @param {RuntimeSpec***REMOVED*** runtime runtime(s)
	 * @param {CodeGenerationResult***REMOVED*** result result from module
	 * @returns {void***REMOVED***
	 */
	add(module, runtime, result) {
		const map = getOrInsert(this.map, module, () => new RuntimeSpecMap());
		map.set(runtime, result);
	***REMOVED***
***REMOVED***

module.exports = CodeGenerationResults;
