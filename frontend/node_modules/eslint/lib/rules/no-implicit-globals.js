/**
 * @fileoverview Rule to check for implicit global variables, functions and classes.
 * @author Joshua Peek
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "suggestion",

		defaultOptions: [
			{
				lexicalBindings: false,
			***REMOVED***,
		],

		docs: {
			description: "Disallow declarations in the global scope",
			recommended: false,
			url: "https://eslint.org/docs/latest/rules/no-implicit-globals",
		***REMOVED***,

		schema: [
			{
				type: "object",
				properties: {
					lexicalBindings: {
						type: "boolean",
					***REMOVED***,
				***REMOVED***,
				additionalProperties: false,
			***REMOVED***,
		],

		messages: {
			globalNonLexicalBinding:
				"Unexpected {{kind***REMOVED******REMOVED*** declaration in the global scope, wrap in an IIFE for a local variable, assign as global property for a global variable.",
			globalLexicalBinding:
				"Unexpected {{kind***REMOVED******REMOVED*** declaration in the global scope, wrap in a block or in an IIFE.",
			globalVariableLeak:
				"Global variable leak, declare the variable if it is intended to be local.",
			assignmentToReadonlyGlobal:
				"Unexpected assignment to read-only global variable.",
			redeclarationOfReadonlyGlobal:
				"Unexpected redeclaration of read-only global variable.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const [{ lexicalBindings: checkLexicalBindings ***REMOVED***] = context.options;
		const sourceCode = context.sourceCode;

		/**
		 * Reports the node.
		 * @param {ASTNode***REMOVED*** node Node to report.
		 * @param {string***REMOVED*** messageId Id of the message to report.
		 * @param {string|undefined***REMOVED*** kind Declaration kind, can be 'var', 'const', 'let', function or class.
		 * @returns {void***REMOVED***
		 */
		function report(node, messageId, kind) {
			context.report({
				node,
				messageId,
				data: {
					kind,
				***REMOVED***,
			***REMOVED***);
		***REMOVED***

		return {
			Program(node) {
				const scope = sourceCode.getScope(node);

				scope.variables.forEach(variable => {
					// Only ESLint global variables have the `writable` key.
					const isReadonlyEslintGlobalVariable =
						variable.writeable === false;
					const isWritableEslintGlobalVariable =
						variable.writeable === true;

					if (isWritableEslintGlobalVariable) {
						// Everything is allowed with writable ESLint global variables.
						return;
					***REMOVED***

					// Variables exported by "exported" block comments
					if (variable.eslintExported) {
						return;
					***REMOVED***

					variable.defs.forEach(def => {
						const defNode = def.node;

						if (
							def.type === "FunctionName" ||
							(def.type === "Variable" &&
								def.parent.kind === "var")
						) {
							if (isReadonlyEslintGlobalVariable) {
								report(
									defNode,
									"redeclarationOfReadonlyGlobal",
								);
							***REMOVED*** else {
								report(
									defNode,
									"globalNonLexicalBinding",
									def.type === "FunctionName"
										? "function"
										: `'${def.parent.kind***REMOVED***'`,
								);
							***REMOVED***
						***REMOVED***

						if (checkLexicalBindings) {
							if (
								def.type === "ClassName" ||
								(def.type === "Variable" &&
									(def.parent.kind === "let" ||
										def.parent.kind === "const"))
							) {
								if (isReadonlyEslintGlobalVariable) {
									report(
										defNode,
										"redeclarationOfReadonlyGlobal",
									);
								***REMOVED*** else {
									report(
										defNode,
										"globalLexicalBinding",
										def.type === "ClassName"
											? "class"
											: `'${def.parent.kind***REMOVED***'`,
									);
								***REMOVED***
							***REMOVED***
						***REMOVED***
					***REMOVED***);
				***REMOVED***);

				// Undeclared assigned variables.
				scope.implicit.variables.forEach(variable => {
					const scopeVariable = scope.set.get(variable.name);
					let messageId;

					if (scopeVariable) {
						// ESLint global variable
						if (scopeVariable.writeable) {
							return;
						***REMOVED***
						messageId = "assignmentToReadonlyGlobal";
					***REMOVED*** else {
						// Reference to an unknown variable, possible global leak.
						messageId = "globalVariableLeak";
					***REMOVED***

					// def.node is an AssignmentExpression, ForInStatement or ForOfStatement.
					variable.defs.forEach(def => {
						report(def.node, messageId);
					***REMOVED***);
				***REMOVED***);
			***REMOVED***,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
