/// <reference types="../types/index.d.ts" />

// (c) 2020-present Andrea Giammarchi

const {parse: $parse, stringify: $stringify***REMOVED*** = JSON;
const {keys***REMOVED*** = Object;

const Primitive = String;   // it could be Number
const primitive = 'string'; // it could be 'number'

const ignore = {***REMOVED***;
const object = 'object';

const noop = (_, value) => value;

const primitives = value => (
  value instanceof Primitive ? Primitive(value) : value
);

const Primitives = (_, value) => (
  typeof value === primitive ? new Primitive(value) : value
);

const revive = (input, parsed, output, $) => {
  const lazy = [];
  for (let ke = keys(output), {length***REMOVED*** = ke, y = 0; y < length; y++) {
    const k = ke[y];
    const value = output[k];
    if (value instanceof Primitive) {
      const tmp = input[value];
      if (typeof tmp === object && !parsed.has(tmp)) {
        parsed.add(tmp);
        output[k] = ignore;
        lazy.push({k, a: [input, parsed, tmp, $]***REMOVED***);
      ***REMOVED***
      else
        output[k] = $.call(output, k, tmp);
    ***REMOVED***
    else if (output[k] !== ignore)
      output[k] = $.call(output, k, value);
  ***REMOVED***
  for (let {length***REMOVED*** = lazy, i = 0; i < length; i++) {
    const {k, a***REMOVED*** = lazy[i];
    output[k] = $.call(output, k, revive.apply(null, a));
  ***REMOVED***
  return output;
***REMOVED***;

const set = (known, input, value) => {
  const index = Primitive(input.push(value) - 1);
  known.set(value, index);
  return index;
***REMOVED***;

/**
 * Converts a specialized flatted string into a JS value.
 * @param {string***REMOVED*** text
 * @param {(this: any, key: string, value: any) => any***REMOVED*** [reviver]
 * @returns {any***REMOVED***
 */
export const parse = (text, reviver) => {
  const input = $parse(text, Primitives).map(primitives);
  const value = input[0];
  const $ = reviver || noop;
  const tmp = typeof value === object && value ?
              revive(input, new Set, value, $) :
              value;
  return $.call({'': tmp***REMOVED***, '', tmp);
***REMOVED***;

/**
 * Converts a JS value into a specialized flatted string.
 * @param {any***REMOVED*** value
 * @param {((this: any, key: string, value: any) => any) | (string | number)[] | null | undefined***REMOVED*** [replacer]
 * @param {string | number | undefined***REMOVED*** [space]
 * @returns {string***REMOVED***
 */
export const stringify = (value, replacer, space) => {
  const $ = replacer && typeof replacer === object ?
            (k, v) => (k === '' || -1 < replacer.indexOf(k) ? v : void 0) :
            (replacer || noop);
  const known = new Map;
  const input = [];
  const output = [];
  let i = +set(known, input, $.call({'': value***REMOVED***, '', value));
  let firstRun = !i;
  while (i < input.length) {
    firstRun = true;
    output[i] = $stringify(input[i++], replace, space);
  ***REMOVED***
  return '[' + output.join(',') + ']';
  function replace(key, value) {
    if (firstRun) {
      firstRun = !firstRun;
      return value;
    ***REMOVED***
    const after = $.call(this, key, value);
    switch (typeof after) {
      case object:
        if (after === null) return after;
      case primitive:
        return known.get(after) || set(known, input, after);
    ***REMOVED***
    return after;
  ***REMOVED***
***REMOVED***;

/**
 * Converts a generic value into a JSON serializable object without losing recursion.
 * @param {any***REMOVED*** value
 * @returns {any***REMOVED***
 */
export const toJSON = value => $parse(stringify(value));

/**
 * Converts a previously serialized object with recursion into a recursive one.
 * @param {any***REMOVED*** value
 * @returns {any***REMOVED***
 */
export const fromJSON = value => parse($stringify(value));
