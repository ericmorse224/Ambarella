import {input, state***REMOVED*** from "../traverser/base";
import {charCodes***REMOVED*** from "../util/charcodes";
import {IS_IDENTIFIER_CHAR***REMOVED*** from "../util/identifier";
import {finishToken***REMOVED*** from "./index";
import {READ_WORD_TREE***REMOVED*** from "./readWordTree";
import {TokenType as tt***REMOVED*** from "./types";

/**
 * Read an identifier, producing either a name token or matching on one of the existing keywords.
 * For performance, we pre-generate big decision tree that we traverse. Each node represents a
 * prefix and has 27 values, where the first value is the token or contextual token, if any (-1 if
 * not), and the other 26 values are the transitions to other nodes, or -1 to stop.
 */
export default function readWord() {
  let treePos = 0;
  let code = 0;
  let pos = state.pos;
  while (pos < input.length) {
    code = input.charCodeAt(pos);
    if (code < charCodes.lowercaseA || code > charCodes.lowercaseZ) {
      break;
    ***REMOVED***
    const next = READ_WORD_TREE[treePos + (code - charCodes.lowercaseA) + 1];
    if (next === -1) {
      break;
    ***REMOVED*** else {
      treePos = next;
      pos++;
    ***REMOVED***
  ***REMOVED***

  const keywordValue = READ_WORD_TREE[treePos];
  if (keywordValue > -1 && !IS_IDENTIFIER_CHAR[code]) {
    state.pos = pos;
    if (keywordValue & 1) {
      finishToken(keywordValue >>> 1);
    ***REMOVED*** else {
      finishToken(tt.name, keywordValue >>> 1);
    ***REMOVED***
    return;
  ***REMOVED***

  while (pos < input.length) {
    const ch = input.charCodeAt(pos);
    if (IS_IDENTIFIER_CHAR[ch]) {
      pos++;
    ***REMOVED*** else if (ch === charCodes.backslash) {
      // \u
      pos += 2;
      if (input.charCodeAt(pos) === charCodes.leftCurlyBrace) {
        while (pos < input.length && input.charCodeAt(pos) !== charCodes.rightCurlyBrace) {
          pos++;
        ***REMOVED***
        pos++;
      ***REMOVED***
    ***REMOVED*** else if (ch === charCodes.atSign && input.charCodeAt(pos + 1) === charCodes.atSign) {
      pos += 2;
    ***REMOVED*** else {
      break;
    ***REMOVED***
  ***REMOVED***
  state.pos = pos;
  finishToken(tt.name);
***REMOVED***
