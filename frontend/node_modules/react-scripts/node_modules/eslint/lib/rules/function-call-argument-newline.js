/**
 * @fileoverview Rule to enforce line breaks between arguments of a function call
 * @author Alexey Gonchar <https://github.com/finico>
 * @deprecated in ESLint v8.53.0
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule***REMOVED*** */
module.exports = {
    meta: {
        deprecated: true,
        replacedBy: [],
        type: "layout",

        docs: {
            description: "Enforce line breaks between arguments of a function call",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/function-call-argument-newline"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            {
                enum: ["always", "never", "consistent"]
            ***REMOVED***
        ],

        messages: {
            unexpectedLineBreak: "There should be no line break here.",
            missingLineBreak: "There should be a line break after this argument."
        ***REMOVED***
    ***REMOVED***,

    create(context) {
        const sourceCode = context.sourceCode;

        const checkers = {
            unexpected: {
                messageId: "unexpectedLineBreak",
                check: (prevToken, currentToken) => prevToken.loc.end.line !== currentToken.loc.start.line,
                createFix: (token, tokenBefore) => fixer =>
                    fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], " ")
            ***REMOVED***,
            missing: {
                messageId: "missingLineBreak",
                check: (prevToken, currentToken) => prevToken.loc.end.line === currentToken.loc.start.line,
                createFix: (token, tokenBefore) => fixer =>
                    fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], "\n")
            ***REMOVED***
        ***REMOVED***;

        /**
         * Check all arguments for line breaks in the CallExpression
         * @param {CallExpression***REMOVED*** node node to evaluate
         * @param {{ messageId: string, check: Function ***REMOVED******REMOVED*** checker selected checker
         * @returns {void***REMOVED***
         * @private
         */
        function checkArguments(node, checker) {
            for (let i = 1; i < node.arguments.length; i++) {
                const prevArgToken = sourceCode.getLastToken(node.arguments[i - 1]);
                const currentArgToken = sourceCode.getFirstToken(node.arguments[i]);

                if (checker.check(prevArgToken, currentArgToken)) {
                    const tokenBefore = sourceCode.getTokenBefore(
                        currentArgToken,
                        { includeComments: true ***REMOVED***
                    );

                    const hasLineCommentBefore = tokenBefore.type === "Line";

                    context.report({
                        node,
                        loc: {
                            start: tokenBefore.loc.end,
                            end: currentArgToken.loc.start
                        ***REMOVED***,
                        messageId: checker.messageId,
                        fix: hasLineCommentBefore ? null : checker.createFix(currentArgToken, tokenBefore)
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Check if open space is present in a function name
         * @param {CallExpression***REMOVED*** node node to evaluate
         * @returns {void***REMOVED***
         * @private
         */
        function check(node) {
            if (node.arguments.length < 2) {
                return;
            ***REMOVED***

            const option = context.options[0] || "always";

            if (option === "never") {
                checkArguments(node, checkers.unexpected);
            ***REMOVED*** else if (option === "always") {
                checkArguments(node, checkers.missing);
            ***REMOVED*** else if (option === "consistent") {
                const firstArgToken = sourceCode.getLastToken(node.arguments[0]);
                const secondArgToken = sourceCode.getFirstToken(node.arguments[1]);

                if (firstArgToken.loc.end.line === secondArgToken.loc.start.line) {
                    checkArguments(node, checkers.unexpected);
                ***REMOVED*** else {
                    checkArguments(node, checkers.missing);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        return {
            CallExpression: check,
            NewExpression: check
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
