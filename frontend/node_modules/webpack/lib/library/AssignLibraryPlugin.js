/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { ConcatSource ***REMOVED*** = require("webpack-sources");
const { UsageState ***REMOVED*** = require("../ExportsInfo");
const RuntimeGlobals = require("../RuntimeGlobals");
const Template = require("../Template");
const propertyAccess = require("../util/propertyAccess");
const { getEntryRuntime ***REMOVED*** = require("../util/runtime");
const AbstractLibraryPlugin = require("./AbstractLibraryPlugin");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../../declarations/WebpackOptions").LibraryOptions***REMOVED*** LibraryOptions */
/** @typedef {import("../../declarations/WebpackOptions").LibraryType***REMOVED*** LibraryType */
/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("../Compilation").ChunkHashContext***REMOVED*** ChunkHashContext */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../javascript/JavascriptModulesPlugin").RenderContext***REMOVED*** RenderContext */
/** @typedef {import("../javascript/JavascriptModulesPlugin").StartupRenderContext***REMOVED*** StartupRenderContext */
/** @typedef {import("../util/Hash")***REMOVED*** Hash */
/** @template T @typedef {import("./AbstractLibraryPlugin").LibraryContext<T>***REMOVED*** LibraryContext<T> */

const KEYWORD_REGEX =
	/^(await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|false|finally|for|function|if|implements|import|in|instanceof|interface|let|new|null|package|private|protected|public|return|super|switch|static|this|throw|try|true|typeof|var|void|while|with|yield)$/;
const IDENTIFIER_REGEX =
	/^[\p{L***REMOVED***\p{Nl***REMOVED***$_][\p{L***REMOVED***\p{Nl***REMOVED***$\p{Mn***REMOVED***\p{Mc***REMOVED***\p{Nd***REMOVED***\p{Pc***REMOVED***]*$/iu;

/**
 * Validates the library name by checking for keywords and valid characters
 * @param {string***REMOVED*** name name to be validated
 * @returns {boolean***REMOVED*** true, when valid
 */
const isNameValid = name =>
	!KEYWORD_REGEX.test(name) && IDENTIFIER_REGEX.test(name);

/**
 * @param {string[]***REMOVED*** accessor variable plus properties
 * @param {number***REMOVED*** existingLength items of accessor that are existing already
 * @param {boolean=***REMOVED*** initLast if the last property should also be initialized to an object
 * @returns {string***REMOVED*** code to access the accessor while initializing
 */
const accessWithInit = (accessor, existingLength, initLast = false) => {
	// This generates for [a, b, c, d]:
	// (((a = typeof a === "undefined" ? {***REMOVED*** : a).b = a.b || {***REMOVED***).c = a.b.c || {***REMOVED***).d
	const base = accessor[0];
	if (accessor.length === 1 && !initLast) return base;
	let current =
		existingLength > 0
			? base
			: `(${base***REMOVED*** = typeof ${base***REMOVED*** === "undefined" ? {***REMOVED*** : ${base***REMOVED***)`;

	// i is the current position in accessor that has been printed
	let i = 1;

	// all properties printed so far (excluding base)
	/** @type {string[] | undefined***REMOVED*** */
	let propsSoFar;

	// if there is existingLength, print all properties until this position as property access
	if (existingLength > i) {
		propsSoFar = accessor.slice(1, existingLength);
		i = existingLength;
		current += propertyAccess(propsSoFar);
	***REMOVED*** else {
		propsSoFar = [];
	***REMOVED***

	// all remaining properties (except the last one when initLast is not set)
	// should be printed as initializer
	const initUntil = initLast ? accessor.length : accessor.length - 1;
	for (; i < initUntil; i++) {
		const prop = accessor[i];
		propsSoFar.push(prop);
		current = `(${current***REMOVED***${propertyAccess([prop])***REMOVED*** = ${base***REMOVED***${propertyAccess(
			propsSoFar
		)***REMOVED*** || {***REMOVED***)`;
	***REMOVED***

	// print the last property as property access if not yet printed
	if (i < accessor.length)
		current = `${current***REMOVED***${propertyAccess([accessor[accessor.length - 1]])***REMOVED***`;

	return current;
***REMOVED***;

/**
 * @typedef {object***REMOVED*** AssignLibraryPluginOptions
 * @property {LibraryType***REMOVED*** type
 * @property {string[] | "global"***REMOVED*** prefix name prefix
 * @property {string | false***REMOVED*** declare declare name as variable
 * @property {"error"|"static"|"copy"|"assign"***REMOVED*** unnamed behavior for unnamed library name
 * @property {"copy"|"assign"=***REMOVED*** named behavior for named library name
 */

/**
 * @typedef {object***REMOVED*** AssignLibraryPluginParsed
 * @property {string | string[]***REMOVED*** name
 * @property {string | string[] | undefined***REMOVED*** export
 */

/**
 * @typedef {AssignLibraryPluginParsed***REMOVED*** T
 * @extends {AbstractLibraryPlugin<AssignLibraryPluginParsed>***REMOVED***
 */
class AssignLibraryPlugin extends AbstractLibraryPlugin {
	/**
	 * @param {AssignLibraryPluginOptions***REMOVED*** options the plugin options
	 */
	constructor(options) {
		super({
			pluginName: "AssignLibraryPlugin",
			type: options.type
		***REMOVED***);
		this.prefix = options.prefix;
		this.declare = options.declare;
		this.unnamed = options.unnamed;
		this.named = options.named || "assign";
	***REMOVED***

	/**
	 * @param {LibraryOptions***REMOVED*** library normalized library option
	 * @returns {T | false***REMOVED*** preprocess as needed by overriding
	 */
	parseOptions(library) {
		const { name ***REMOVED*** = library;
		if (this.unnamed === "error") {
			if (typeof name !== "string" && !Array.isArray(name)) {
				throw new Error(
					`Library name must be a string or string array. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE***REMOVED***`
				);
			***REMOVED***
		***REMOVED*** else if (name && typeof name !== "string" && !Array.isArray(name)) {
			throw new Error(
				`Library name must be a string, string array or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE***REMOVED***`
			);
		***REMOVED***
		const _name = /** @type {string | string[]***REMOVED*** */ (name);
		return {
			name: _name,
			export: library.export
		***REMOVED***;
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the exporting entry module
	 * @param {string***REMOVED*** entryName the name of the entrypoint
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {void***REMOVED***
	 */
	finishEntryModule(
		module,
		entryName,
		{ options, compilation, compilation: { moduleGraph ***REMOVED*** ***REMOVED***
	) {
		const runtime = getEntryRuntime(compilation, entryName);
		if (options.export) {
			const exportsInfo = moduleGraph.getExportInfo(
				module,
				Array.isArray(options.export) ? options.export[0] : options.export
			);
			exportsInfo.setUsed(UsageState.Used, runtime);
			exportsInfo.canMangleUse = false;
		***REMOVED*** else {
			const exportsInfo = moduleGraph.getExportsInfo(module);
			exportsInfo.setUsedInUnknownWay(runtime);
		***REMOVED***
		moduleGraph.addExtraReason(module, "used as library export");
	***REMOVED***

	/**
	 * @param {Compilation***REMOVED*** compilation the compilation
	 * @returns {string[]***REMOVED*** the prefix
	 */
	_getPrefix(compilation) {
		return this.prefix === "global"
			? [compilation.runtimeTemplate.globalObject]
			: this.prefix;
	***REMOVED***

	/**
	 * @param {AssignLibraryPluginParsed***REMOVED*** options the library options
	 * @param {Chunk***REMOVED*** chunk the chunk
	 * @param {Compilation***REMOVED*** compilation the compilation
	 * @returns {Array<string>***REMOVED*** the resolved full name
	 */
	_getResolvedFullName(options, chunk, compilation) {
		const prefix = this._getPrefix(compilation);
		const fullName = options.name ? prefix.concat(options.name) : prefix;
		return fullName.map(n =>
			compilation.getPath(n, {
				chunk
			***REMOVED***)
		);
	***REMOVED***

	/**
	 * @param {Source***REMOVED*** source source
	 * @param {RenderContext***REMOVED*** renderContext render context
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {Source***REMOVED*** source with library export
	 */
	render(source, { chunk ***REMOVED***, { options, compilation ***REMOVED***) {
		const fullNameResolved = this._getResolvedFullName(
			options,
			chunk,
			compilation
		);
		if (this.declare) {
			const base = fullNameResolved[0];
			if (!isNameValid(base)) {
				throw new Error(
					`Library name base (${base***REMOVED***) must be a valid identifier when using a var declaring library type. Either use a valid identifier (e. g. ${Template.toIdentifier(
						base
					)***REMOVED***) or use a different library type (e. g. 'type: "global"', which assign a property on the global scope instead of declaring a variable). ${
						AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE
					***REMOVED***`
				);
			***REMOVED***
			source = new ConcatSource(`${this.declare***REMOVED*** ${base***REMOVED***;\n`, source);
		***REMOVED***
		return source;
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the exporting entry module
	 * @param {RenderContext***REMOVED*** renderContext render context
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {string | undefined***REMOVED*** bailout reason
	 */
	embedInRuntimeBailout(
		module,
		{ chunk, codeGenerationResults ***REMOVED***,
		{ options, compilation ***REMOVED***
	) {
		const { data ***REMOVED*** = codeGenerationResults.get(module, chunk.runtime);
		const topLevelDeclarations =
			(data && data.get("topLevelDeclarations")) ||
			(module.buildInfo && module.buildInfo.topLevelDeclarations);
		if (!topLevelDeclarations)
			return "it doesn't tell about top level declarations.";
		const fullNameResolved = this._getResolvedFullName(
			options,
			chunk,
			compilation
		);
		const base = fullNameResolved[0];
		if (topLevelDeclarations.has(base))
			return `it declares '${base***REMOVED***' on top-level, which conflicts with the current library output.`;
	***REMOVED***

	/**
	 * @param {RenderContext***REMOVED*** renderContext render context
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {string | undefined***REMOVED*** bailout reason
	 */
	strictRuntimeBailout({ chunk ***REMOVED***, { options, compilation ***REMOVED***) {
		if (
			this.declare ||
			this.prefix === "global" ||
			this.prefix.length > 0 ||
			!options.name
		) {
			return;
		***REMOVED***
		return "a global variable is assign and maybe created";
	***REMOVED***

	/**
	 * @param {Source***REMOVED*** source source
	 * @param {Module***REMOVED*** module module
	 * @param {StartupRenderContext***REMOVED*** renderContext render context
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {Source***REMOVED*** source with library export
	 */
	renderStartup(
		source,
		module,
		{ moduleGraph, chunk ***REMOVED***,
		{ options, compilation ***REMOVED***
	) {
		const fullNameResolved = this._getResolvedFullName(
			options,
			chunk,
			compilation
		);
		const staticExports = this.unnamed === "static";
		const exportAccess = options.export
			? propertyAccess(
					Array.isArray(options.export) ? options.export : [options.export]
				)
			: "";
		const result = new ConcatSource(source);
		if (staticExports) {
			const exportsInfo = moduleGraph.getExportsInfo(module);
			const exportTarget = accessWithInit(
				fullNameResolved,
				this._getPrefix(compilation).length,
				true
			);

			/** @type {string[]***REMOVED*** */
			const provided = [];
			for (const exportInfo of exportsInfo.orderedExports) {
				if (!exportInfo.provided) continue;
				const nameAccess = propertyAccess([exportInfo.name]);
				result.add(
					`${exportTarget***REMOVED***${nameAccess***REMOVED*** = ${RuntimeGlobals.exports***REMOVED***${exportAccess***REMOVED***${nameAccess***REMOVED***;\n`
				);
				provided.push(exportInfo.name);
			***REMOVED***

			const webpackExportTarget = accessWithInit(
				fullNameResolved,
				this._getPrefix(compilation).length,
				true
			);
			/** @type {string***REMOVED*** */
			let exports = RuntimeGlobals.exports;
			if (exportAccess) {
				result.add(
					`var __webpack_exports_export__ = ${RuntimeGlobals.exports***REMOVED***${exportAccess***REMOVED***;\n`
				);
				exports = "__webpack_exports_export__";
			***REMOVED***
			result.add(`for(var __webpack_i__ in ${exports***REMOVED***) {\n`);
			const hasProvided = provided.length > 0;
			if (hasProvided) {
				result.add(
					`  if (${JSON.stringify(provided)***REMOVED***.indexOf(__webpack_i__) === -1) {\n`
				);
			***REMOVED***
			result.add(
				`  ${hasProvided ? "  " : ""***REMOVED***${webpackExportTarget***REMOVED***[__webpack_i__] = ${exports***REMOVED***[__webpack_i__];\n`
			);
			result.add(hasProvided ? "  ***REMOVED***\n***REMOVED***\n" : "\n");
			result.add(
				`Object.defineProperty(${exportTarget***REMOVED***, "__esModule", { value: true ***REMOVED***);\n`
			);
		***REMOVED*** else if (options.name ? this.named === "copy" : this.unnamed === "copy") {
			result.add(
				`var __webpack_export_target__ = ${accessWithInit(
					fullNameResolved,
					this._getPrefix(compilation).length,
					true
				)***REMOVED***;\n`
			);
			/** @type {string***REMOVED*** */
			let exports = RuntimeGlobals.exports;
			if (exportAccess) {
				result.add(
					`var __webpack_exports_export__ = ${RuntimeGlobals.exports***REMOVED***${exportAccess***REMOVED***;\n`
				);
				exports = "__webpack_exports_export__";
			***REMOVED***
			result.add(
				`for(var __webpack_i__ in ${exports***REMOVED***) __webpack_export_target__[__webpack_i__] = ${exports***REMOVED***[__webpack_i__];\n`
			);
			result.add(
				`if(${exports***REMOVED***.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true ***REMOVED***);\n`
			);
		***REMOVED*** else {
			result.add(
				`${accessWithInit(
					fullNameResolved,
					this._getPrefix(compilation).length,
					false
				)***REMOVED*** = ${RuntimeGlobals.exports***REMOVED***${exportAccess***REMOVED***;\n`
			);
		***REMOVED***
		return result;
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk the chunk
	 * @param {Set<string>***REMOVED*** set runtime requirements
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {void***REMOVED***
	 */
	runtimeRequirements(chunk, set, libraryContext) {
		set.add(RuntimeGlobals.exports);
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk the chunk
	 * @param {Hash***REMOVED*** hash hash
	 * @param {ChunkHashContext***REMOVED*** chunkHashContext chunk hash context
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {void***REMOVED***
	 */
	chunkHash(chunk, hash, chunkHashContext, { options, compilation ***REMOVED***) {
		hash.update("AssignLibraryPlugin");
		const fullNameResolved = this._getResolvedFullName(
			options,
			chunk,
			compilation
		);
		if (options.name ? this.named === "copy" : this.unnamed === "copy") {
			hash.update("copy");
		***REMOVED***
		if (this.declare) {
			hash.update(this.declare);
		***REMOVED***
		hash.update(fullNameResolved.join("."));
		if (options.export) {
			hash.update(`${options.export***REMOVED***`);
		***REMOVED***
	***REMOVED***
***REMOVED***

module.exports = AssignLibraryPlugin;
