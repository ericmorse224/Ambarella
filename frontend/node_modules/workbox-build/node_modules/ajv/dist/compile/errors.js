"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
const codegen_1 = require("./codegen");
const util_1 = require("./util");
const names_1 = require("./names");
exports.keywordError = {
    message: ({ keyword ***REMOVED***) => (0, codegen_1.str) `must pass "${keyword***REMOVED***" keyword validation`,
***REMOVED***;
exports.keyword$DataError = {
    message: ({ keyword, schemaType ***REMOVED***) => schemaType
        ? (0, codegen_1.str) `"${keyword***REMOVED***" keyword must be ${schemaType***REMOVED*** ($data)`
        : (0, codegen_1.str) `"${keyword***REMOVED***" keyword is invalid ($data)`,
***REMOVED***;
function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
    const { it ***REMOVED*** = cxt;
    const { gen, compositeRule, allErrors ***REMOVED*** = it;
    const errObj = errorObjectCode(cxt, error, errorPaths);
    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {
        addError(gen, errObj);
    ***REMOVED***
    else {
        returnErrors(it, (0, codegen_1._) `[${errObj***REMOVED***]`);
    ***REMOVED***
***REMOVED***
exports.reportError = reportError;
function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
    const { it ***REMOVED*** = cxt;
    const { gen, compositeRule, allErrors ***REMOVED*** = it;
    const errObj = errorObjectCode(cxt, error, errorPaths);
    addError(gen, errObj);
    if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
    ***REMOVED***
***REMOVED***
exports.reportExtraError = reportExtraError;
function resetErrorsCount(gen, errsCount) {
    gen.assign(names_1.default.errors, errsCount);
    gen.if((0, codegen_1._) `${names_1.default.vErrors***REMOVED*** !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._) `${names_1.default.vErrors***REMOVED***.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
***REMOVED***
exports.resetErrorsCount = resetErrorsCount;
function extendErrors({ gen, keyword, schemaValue, data, errsCount, it, ***REMOVED***) {
    /* istanbul ignore if */
    if (errsCount === undefined)
        throw new Error("ajv implementation error");
    const err = gen.name("err");
    gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._) `${names_1.default.vErrors***REMOVED***[${i***REMOVED***]`);
        gen.if((0, codegen_1._) `${err***REMOVED***.instancePath === undefined`, () => gen.assign((0, codegen_1._) `${err***REMOVED***.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._) `${err***REMOVED***.schemaPath`, (0, codegen_1.str) `${it.errSchemaPath***REMOVED***/${keyword***REMOVED***`);
        if (it.opts.verbose) {
            gen.assign((0, codegen_1._) `${err***REMOVED***.schema`, schemaValue);
            gen.assign((0, codegen_1._) `${err***REMOVED***.data`, data);
        ***REMOVED***
    ***REMOVED***);
***REMOVED***
exports.extendErrors = extendErrors;
function addError(gen, errObj) {
    const err = gen.const("err", errObj);
    gen.if((0, codegen_1._) `${names_1.default.vErrors***REMOVED*** === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._) `[${err***REMOVED***]`), (0, codegen_1._) `${names_1.default.vErrors***REMOVED***.push(${err***REMOVED***)`);
    gen.code((0, codegen_1._) `${names_1.default.errors***REMOVED***++`);
***REMOVED***
function returnErrors(it, errs) {
    const { gen, validateName, schemaEnv ***REMOVED*** = it;
    if (schemaEnv.$async) {
        gen.throw((0, codegen_1._) `new ${it.ValidationError***REMOVED***(${errs***REMOVED***)`);
    ***REMOVED***
    else {
        gen.assign((0, codegen_1._) `${validateName***REMOVED***.errors`, errs);
        gen.return(false);
    ***REMOVED***
***REMOVED***
const E = {
    keyword: new codegen_1.Name("keyword"),
    schemaPath: new codegen_1.Name("schemaPath"), // also used in JTD errors
    params: new codegen_1.Name("params"),
    propertyName: new codegen_1.Name("propertyName"),
    message: new codegen_1.Name("message"),
    schema: new codegen_1.Name("schema"),
    parentSchema: new codegen_1.Name("parentSchema"),
***REMOVED***;
function errorObjectCode(cxt, error, errorPaths) {
    const { createErrors ***REMOVED*** = cxt.it;
    if (createErrors === false)
        return (0, codegen_1._) `{***REMOVED***`;
    return errorObject(cxt, error, errorPaths);
***REMOVED***
function errorObject(cxt, error, errorPaths = {***REMOVED***) {
    const { gen, it ***REMOVED*** = cxt;
    const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths),
    ];
    extraErrorProps(cxt, error, keyValues);
    return gen.object(...keyValues);
***REMOVED***
function errorInstancePath({ errorPath ***REMOVED***, { instancePath ***REMOVED***) {
    const instPath = instancePath
        ? (0, codegen_1.str) `${errorPath***REMOVED***${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)***REMOVED***`
        : errorPath;
    return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
***REMOVED***
function errorSchemaPath({ keyword, it: { errSchemaPath ***REMOVED*** ***REMOVED***, { schemaPath, parentSchema ***REMOVED***) {
    let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str) `${errSchemaPath***REMOVED***/${keyword***REMOVED***`;
    if (schemaPath) {
        schPath = (0, codegen_1.str) `${schPath***REMOVED***${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)***REMOVED***`;
    ***REMOVED***
    return [E.schemaPath, schPath];
***REMOVED***
function extraErrorProps(cxt, { params, message ***REMOVED***, keyValues) {
    const { keyword, data, schemaValue, it ***REMOVED*** = cxt;
    const { opts, propertyName, topSchemaRef, schemaPath ***REMOVED*** = it;
    keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._) `{***REMOVED***`]);
    if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
    ***REMOVED***
    if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._) `${topSchemaRef***REMOVED***${schemaPath***REMOVED***`], [names_1.default.data, data]);
    ***REMOVED***
    if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
***REMOVED***
//# sourceMappingURL=errors.js.map