/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const Cache = require("../Cache");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../Cache").Data***REMOVED*** Data */
/** @typedef {import("../Cache").Etag***REMOVED*** Etag */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../Module")***REMOVED*** Module */

/**
 * @typedef {object***REMOVED*** MemoryWithGcCachePluginOptions
 * @property {number***REMOVED*** maxGenerations max generations
 */

const PLUGIN_NAME = "MemoryWithGcCachePlugin";

class MemoryWithGcCachePlugin {
	/**
	 * @param {MemoryWithGcCachePluginOptions***REMOVED*** options options
	 */
	constructor({ maxGenerations ***REMOVED***) {
		this._maxGenerations = maxGenerations;
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		const maxGenerations = this._maxGenerations;
		/** @type {Map<string, { etag: Etag | null, data: Data ***REMOVED*** | undefined | null>***REMOVED*** */
		const cache = new Map();
		/** @type {Map<string, { entry: { etag: Etag | null, data: Data ***REMOVED*** | null, until: number ***REMOVED***>***REMOVED*** */
		const oldCache = new Map();
		let generation = 0;
		let cachePosition = 0;
		const logger = compiler.getInfrastructureLogger(PLUGIN_NAME);
		compiler.hooks.afterDone.tap(PLUGIN_NAME, () => {
			generation++;
			let clearedEntries = 0;
			let lastClearedIdentifier;
			// Avoid coverage problems due indirect changes
			/* istanbul ignore next */
			for (const [identifier, entry] of oldCache) {
				if (entry.until > generation) break;

				oldCache.delete(identifier);
				if (cache.get(identifier) === undefined) {
					cache.delete(identifier);
					clearedEntries++;
					lastClearedIdentifier = identifier;
				***REMOVED***
			***REMOVED***
			if (clearedEntries > 0 || oldCache.size > 0) {
				logger.log(
					`${cache.size - oldCache.size***REMOVED*** active entries, ${
						oldCache.size
					***REMOVED*** recently unused cached entries${
						clearedEntries > 0
							? `, ${clearedEntries***REMOVED*** old unused cache entries removed e. g. ${lastClearedIdentifier***REMOVED***`
							: ""
					***REMOVED***`
				);
			***REMOVED***
			let i = (cache.size / maxGenerations) | 0;
			let j = cachePosition >= cache.size ? 0 : cachePosition;
			cachePosition = j + i;
			for (const [identifier, entry] of cache) {
				if (j !== 0) {
					j--;
					continue;
				***REMOVED***
				if (entry !== undefined) {
					// We don't delete the cache entry, but set it to undefined instead
					// This reserves the location in the data table and avoids rehashing
					// when constantly adding and removing entries.
					// It will be deleted when removed from oldCache.
					cache.set(identifier, undefined);
					oldCache.delete(identifier);
					oldCache.set(identifier, {
						entry,
						until: generation + maxGenerations
					***REMOVED***);
					if (i-- === 0) break;
				***REMOVED***
			***REMOVED***
		***REMOVED***);
		compiler.cache.hooks.store.tap(
			{ name: PLUGIN_NAME, stage: Cache.STAGE_MEMORY ***REMOVED***,
			(identifier, etag, data) => {
				cache.set(identifier, { etag, data ***REMOVED***);
			***REMOVED***
		);
		compiler.cache.hooks.get.tap(
			{ name: PLUGIN_NAME, stage: Cache.STAGE_MEMORY ***REMOVED***,
			(identifier, etag, gotHandlers) => {
				const cacheEntry = cache.get(identifier);
				if (cacheEntry === null) {
					return null;
				***REMOVED*** else if (cacheEntry !== undefined) {
					return cacheEntry.etag === etag ? cacheEntry.data : null;
				***REMOVED***
				const oldCacheEntry = oldCache.get(identifier);
				if (oldCacheEntry !== undefined) {
					const cacheEntry = oldCacheEntry.entry;
					if (cacheEntry === null) {
						oldCache.delete(identifier);
						cache.set(identifier, cacheEntry);
						return null;
					***REMOVED***
					if (cacheEntry.etag !== etag) return null;
					oldCache.delete(identifier);
					cache.set(identifier, cacheEntry);
					return cacheEntry.data;
				***REMOVED***
				gotHandlers.push((result, callback) => {
					if (result === undefined) {
						cache.set(identifier, null);
					***REMOVED*** else {
						cache.set(identifier, { etag, data: result ***REMOVED***);
					***REMOVED***
					return callback();
				***REMOVED***);
			***REMOVED***
		);
		compiler.cache.hooks.shutdown.tap(
			{ name: PLUGIN_NAME, stage: Cache.STAGE_MEMORY ***REMOVED***,
			() => {
				cache.clear();
				oldCache.clear();
			***REMOVED***
		);
	***REMOVED***
***REMOVED***
module.exports = MemoryWithGcCachePlugin;
