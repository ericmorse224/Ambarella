import type {AnySchema, SchemaMap***REMOVED*** from "../types"
import type {SchemaCxt***REMOVED*** from "../compile"
import type {KeywordCxt***REMOVED*** from "../compile/validate"
import {CodeGen, _, and, or, not, nil, strConcat, getProperty, Code, Name***REMOVED*** from "../compile/codegen"
import {alwaysValidSchema, Type***REMOVED*** from "../compile/util"
import N from "../compile/names"
import {useFunc***REMOVED*** from "../compile/util"
export function checkReportMissingProp(cxt: KeywordCxt, prop: string): void {
  const {gen, data, it***REMOVED*** = cxt
  gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
    cxt.setParams({missingProperty: _`${prop***REMOVED***`***REMOVED***, true)
    cxt.error()
  ***REMOVED***)
***REMOVED***

export function checkMissingProp(
  {gen, data, it: {opts***REMOVED******REMOVED***: KeywordCxt,
  properties: string[],
  missing: Name
): Code {
  return or(
    ...properties.map((prop) =>
      and(noPropertyInData(gen, data, prop, opts.ownProperties), _`${missing***REMOVED*** = ${prop***REMOVED***`)
    )
  )
***REMOVED***

export function reportMissingProp(cxt: KeywordCxt, missing: Name): void {
  cxt.setParams({missingProperty: missing***REMOVED***, true)
  cxt.error()
***REMOVED***

export function hasPropFunc(gen: CodeGen): Name {
  return gen.scopeValue("func", {
    // eslint-disable-next-line @typescript-eslint/unbound-method
    ref: Object.prototype.hasOwnProperty,
    code: _`Object.prototype.hasOwnProperty`,
  ***REMOVED***)
***REMOVED***

export function isOwnProperty(gen: CodeGen, data: Name, property: Name | string): Code {
  return _`${hasPropFunc(gen)***REMOVED***.call(${data***REMOVED***, ${property***REMOVED***)`
***REMOVED***

export function propertyInData(
  gen: CodeGen,
  data: Name,
  property: Name | string,
  ownProperties?: boolean
): Code {
  const cond = _`${data***REMOVED***${getProperty(property)***REMOVED*** !== undefined`
  return ownProperties ? _`${cond***REMOVED*** && ${isOwnProperty(gen, data, property)***REMOVED***` : cond
***REMOVED***

export function noPropertyInData(
  gen: CodeGen,
  data: Name,
  property: Name | string,
  ownProperties?: boolean
): Code {
  const cond = _`${data***REMOVED***${getProperty(property)***REMOVED*** === undefined`
  return ownProperties ? or(cond, not(isOwnProperty(gen, data, property))) : cond
***REMOVED***

export function allSchemaProperties(schemaMap?: SchemaMap): string[] {
  return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : []
***REMOVED***

export function schemaProperties(it: SchemaCxt, schemaMap: SchemaMap): string[] {
  return allSchemaProperties(schemaMap).filter(
    (p) => !alwaysValidSchema(it, schemaMap[p] as AnySchema)
  )
***REMOVED***

export function callValidateCode(
  {schemaCode, data, it: {gen, topSchemaRef, schemaPath, errorPath***REMOVED***, it***REMOVED***: KeywordCxt,
  func: Code,
  context: Code,
  passSchema?: boolean
): Code {
  const dataAndSchema = passSchema ? _`${schemaCode***REMOVED***, ${data***REMOVED***, ${topSchemaRef***REMOVED***${schemaPath***REMOVED***` : data
  const valCxt: [Name, Code | number][] = [
    [N.instancePath, strConcat(N.instancePath, errorPath)],
    [N.parentData, it.parentData],
    [N.parentDataProperty, it.parentDataProperty],
    [N.rootData, N.rootData],
  ]
  if (it.opts.dynamicRef) valCxt.push([N.dynamicAnchors, N.dynamicAnchors])
  const args = _`${dataAndSchema***REMOVED***, ${gen.object(...valCxt)***REMOVED***`
  return context !== nil ? _`${func***REMOVED***.call(${context***REMOVED***, ${args***REMOVED***)` : _`${func***REMOVED***(${args***REMOVED***)`
***REMOVED***

const newRegExp = _`new RegExp`

export function usePattern({gen, it: {opts***REMOVED******REMOVED***: KeywordCxt, pattern: string): Name {
  const u = opts.unicodeRegExp ? "u" : ""
  const {regExp***REMOVED*** = opts.code
  const rx = regExp(pattern, u)

  return gen.scopeValue("pattern", {
    key: rx.toString(),
    ref: rx,
    code: _`${regExp.code === "new RegExp" ? newRegExp : useFunc(gen, regExp)***REMOVED***(${pattern***REMOVED***, ${u***REMOVED***)`,
  ***REMOVED***)
***REMOVED***

export function validateArray(cxt: KeywordCxt): Name {
  const {gen, data, keyword, it***REMOVED*** = cxt
  const valid = gen.name("valid")
  if (it.allErrors) {
    const validArr = gen.let("valid", true)
    validateItems(() => gen.assign(validArr, false))
    return validArr
  ***REMOVED***
  gen.var(valid, true)
  validateItems(() => gen.break())
  return valid

  function validateItems(notValid: () => void): void {
    const len = gen.const("len", _`${data***REMOVED***.length`)
    gen.forRange("i", 0, len, (i) => {
      cxt.subschema(
        {
          keyword,
          dataProp: i,
          dataPropType: Type.Num,
        ***REMOVED***,
        valid
      )
      gen.if(not(valid), notValid)
    ***REMOVED***)
  ***REMOVED***
***REMOVED***

export function validateUnion(cxt: KeywordCxt): void {
  const {gen, schema, keyword, it***REMOVED*** = cxt
  /* istanbul ignore if */
  if (!Array.isArray(schema)) throw new Error("ajv implementation error")
  const alwaysValid = schema.some((sch: AnySchema) => alwaysValidSchema(it, sch))
  if (alwaysValid && !it.opts.unevaluated) return

  const valid = gen.let("valid", false)
  const schValid = gen.name("_valid")

  gen.block(() =>
    schema.forEach((_sch: AnySchema, i: number) => {
      const schCxt = cxt.subschema(
        {
          keyword,
          schemaProp: i,
          compositeRule: true,
        ***REMOVED***,
        schValid
      )
      gen.assign(valid, _`${valid***REMOVED*** || ${schValid***REMOVED***`)
      const merged = cxt.mergeValidEvaluated(schCxt, schValid)
      // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
      // or if all properties and items were evaluated (it.props === true && it.items === true)
      if (!merged) gen.if(not(valid))
    ***REMOVED***)
  )

  cxt.result(
    valid,
    () => cxt.reset(),
    () => cxt.error(true)
  )
***REMOVED***
