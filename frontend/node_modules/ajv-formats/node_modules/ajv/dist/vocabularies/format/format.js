"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const codegen_1 = require("../../compile/codegen");
const error = {
    message: ({ schemaCode ***REMOVED***) => (0, codegen_1.str) `must match format "${schemaCode***REMOVED***"`,
    params: ({ schemaCode ***REMOVED***) => (0, codegen_1._) `{format: ${schemaCode***REMOVED******REMOVED***`,
***REMOVED***;
const def = {
    keyword: "format",
    type: ["number", "string"],
    schemaType: "string",
    $data: true,
    error,
    code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it ***REMOVED*** = cxt;
        const { opts, errSchemaPath, schemaEnv, self ***REMOVED*** = it;
        if (!opts.validateFormats)
            return;
        if ($data)
            validate$DataFormat();
        else
            validateFormat();
        function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
                ref: self.formats,
                code: opts.code.formats,
            ***REMOVED***);
            const fDef = gen.const("fDef", (0, codegen_1._) `${fmts***REMOVED***[${schemaCode***REMOVED***]`);
            const fType = gen.let("fType");
            const format = gen.let("format");
            // TODO simplify
            gen.if((0, codegen_1._) `typeof ${fDef***REMOVED*** == "object" && !(${fDef***REMOVED*** instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._) `${fDef***REMOVED***.type || "string"`).assign(format, (0, codegen_1._) `${fDef***REMOVED***.validate`), () => gen.assign(fType, (0, codegen_1._) `"string"`).assign(format, fDef));
            cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
            function unknownFmt() {
                if (opts.strictSchema === false)
                    return codegen_1.nil;
                return (0, codegen_1._) `${schemaCode***REMOVED*** && !${format***REMOVED***`;
            ***REMOVED***
            function invalidFmt() {
                const callFormat = schemaEnv.$async
                    ? (0, codegen_1._) `(${fDef***REMOVED***.async ? await ${format***REMOVED***(${data***REMOVED***) : ${format***REMOVED***(${data***REMOVED***))`
                    : (0, codegen_1._) `${format***REMOVED***(${data***REMOVED***)`;
                const validData = (0, codegen_1._) `(typeof ${format***REMOVED*** == "function" ? ${callFormat***REMOVED*** : ${format***REMOVED***.test(${data***REMOVED***))`;
                return (0, codegen_1._) `${format***REMOVED*** && ${format***REMOVED*** !== true && ${fType***REMOVED*** === ${ruleType***REMOVED*** && !${validData***REMOVED***`;
            ***REMOVED***
        ***REMOVED***
        function validateFormat() {
            const formatDef = self.formats[schema];
            if (!formatDef) {
                unknownFormat();
                return;
            ***REMOVED***
            if (formatDef === true)
                return;
            const [fmtType, format, fmtRef] = getFormat(formatDef);
            if (fmtType === ruleType)
                cxt.pass(validCondition());
            function unknownFormat() {
                if (opts.strictSchema === false) {
                    self.logger.warn(unknownMsg());
                    return;
                ***REMOVED***
                throw new Error(unknownMsg());
                function unknownMsg() {
                    return `unknown format "${schema***REMOVED***" ignored in schema at path "${errSchemaPath***REMOVED***"`;
                ***REMOVED***
            ***REMOVED***
            function getFormat(fmtDef) {
                const code = fmtDef instanceof RegExp
                    ? (0, codegen_1.regexpCode)(fmtDef)
                    : opts.code.formats
                        ? (0, codegen_1._) `${opts.code.formats***REMOVED***${(0, codegen_1.getProperty)(schema)***REMOVED***`
                        : undefined;
                const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code ***REMOVED***);
                if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
                    return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._) `${fmt***REMOVED***.validate`];
                ***REMOVED***
                return ["string", fmtDef, fmt];
            ***REMOVED***
            function validCondition() {
                if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
                    if (!schemaEnv.$async)
                        throw new Error("async format in sync schema");
                    return (0, codegen_1._) `await ${fmtRef***REMOVED***(${data***REMOVED***)`;
                ***REMOVED***
                return typeof format == "function" ? (0, codegen_1._) `${fmtRef***REMOVED***(${data***REMOVED***)` : (0, codegen_1._) `${fmtRef***REMOVED***.test(${data***REMOVED***)`;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***,
***REMOVED***;
exports.default = def;
//# sourceMappingURL=format.js.map