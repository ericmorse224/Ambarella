/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const ContextElementDependency = require("./dependencies/ContextElementDependency");
const { join ***REMOVED*** = require("./util/fs");

/** @typedef {import("./Compiler")***REMOVED*** Compiler */
/** @typedef {import("./ContextModule").ContextModuleOptions***REMOVED*** ContextModuleOptions */
/** @typedef {import("./util/fs").InputFileSystem***REMOVED*** InputFileSystem */

/** @typedef {Record<string, string>***REMOVED*** NewContentCreateContextMap */

const PLUGIN_NAME = "ContextReplacementPlugin";

class ContextReplacementPlugin {
	/**
	 * @param {RegExp***REMOVED*** resourceRegExp A regular expression that determines which files will be selected
	 * @param {(string | ((context: TODO) => void) | RegExp | boolean)=***REMOVED*** newContentResource A new resource to replace the match
	 * @param {(boolean | NewContentCreateContextMap | RegExp)=***REMOVED*** newContentRecursive If true, all subdirectories are searched for matches
	 * @param {RegExp=***REMOVED*** newContentRegExp A regular expression that determines which files will be selected
	 */
	constructor(
		resourceRegExp,
		newContentResource,
		newContentRecursive,
		newContentRegExp
	) {
		this.resourceRegExp = resourceRegExp;

		// new webpack.ContextReplacementPlugin(/selector/, (context) => { /* Logic */ ***REMOVED***);
		if (typeof newContentResource === "function") {
			this.newContentCallback = newContentResource;
		***REMOVED***
		// new ContextReplacementPlugin(/selector/, './folder', { './request': './request' ***REMOVED***);
		else if (
			typeof newContentResource === "string" &&
			typeof newContentRecursive === "object"
		) {
			this.newContentResource = newContentResource;
			/**
			 * @param {InputFileSystem***REMOVED*** fs input file system
			 * @param {(err: null | Error, newContentRecursive: NewContentCreateContextMap) => void***REMOVED*** callback callback
			 */
			this.newContentCreateContextMap = (fs, callback) => {
				callback(
					null,
					/** @type {NewContentCreateContextMap***REMOVED*** */ (newContentRecursive)
				);
			***REMOVED***;
		***REMOVED***
		// new ContextReplacementPlugin(/selector/, './folder', (context) => { /* Logic */ ***REMOVED***);
		else if (
			typeof newContentResource === "string" &&
			typeof newContentRecursive === "function"
		) {
			this.newContentResource = newContentResource;
			this.newContentCreateContextMap = newContentRecursive;
		***REMOVED*** else {
			// new webpack.ContextReplacementPlugin(/selector/, false, /reg-exp/);
			if (typeof newContentResource !== "string") {
				newContentRegExp = /** @type {RegExp***REMOVED*** */ (newContentRecursive);
				newContentRecursive = /** @type {boolean***REMOVED*** */ (newContentResource);
				newContentResource = undefined;
			***REMOVED***
			// new webpack.ContextReplacementPlugin(/selector/, /de|fr|hu/);
			if (typeof newContentRecursive !== "boolean") {
				newContentRegExp = /** @type {RegExp***REMOVED*** */ (newContentRecursive);
				newContentRecursive = undefined;
			***REMOVED***
			// new webpack.ContextReplacementPlugin(/selector/, './folder', false, /selector/);
			this.newContentResource =
				/** @type {string | undefined***REMOVED*** */
				(newContentResource);
			this.newContentRecursive =
				/** @type {boolean | undefined***REMOVED*** */
				(newContentRecursive);
			this.newContentRegExp =
				/** @type {RegExp | undefined***REMOVED*** */
				(newContentRegExp);
		***REMOVED***
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		const resourceRegExp = this.resourceRegExp;
		const newContentCallback = this.newContentCallback;
		const newContentResource = this.newContentResource;
		const newContentRecursive = this.newContentRecursive;
		const newContentRegExp = this.newContentRegExp;
		const newContentCreateContextMap = this.newContentCreateContextMap;

		compiler.hooks.contextModuleFactory.tap(PLUGIN_NAME, cmf => {
			cmf.hooks.beforeResolve.tap(PLUGIN_NAME, result => {
				if (!result) return;
				if (resourceRegExp.test(result.request)) {
					if (newContentResource !== undefined) {
						result.request = newContentResource;
					***REMOVED***
					if (newContentRecursive !== undefined) {
						result.recursive = newContentRecursive;
					***REMOVED***
					if (newContentRegExp !== undefined) {
						result.regExp = newContentRegExp;
					***REMOVED***
					if (typeof newContentCallback === "function") {
						newContentCallback(result);
					***REMOVED*** else {
						for (const d of result.dependencies) {
							if (d.critical) d.critical = false;
						***REMOVED***
					***REMOVED***
				***REMOVED***
				return result;
			***REMOVED***);
			cmf.hooks.afterResolve.tap(PLUGIN_NAME, result => {
				if (!result) return;
				if (resourceRegExp.test(result.resource)) {
					if (newContentResource !== undefined) {
						if (
							newContentResource.startsWith("/") ||
							(newContentResource.length > 1 && newContentResource[1] === ":")
						) {
							result.resource = newContentResource;
						***REMOVED*** else {
							result.resource = join(
								/** @type {InputFileSystem***REMOVED*** */ (compiler.inputFileSystem),
								result.resource,
								newContentResource
							);
						***REMOVED***
					***REMOVED***
					if (newContentRecursive !== undefined) {
						result.recursive = newContentRecursive;
					***REMOVED***
					if (newContentRegExp !== undefined) {
						result.regExp = newContentRegExp;
					***REMOVED***
					if (typeof newContentCreateContextMap === "function") {
						result.resolveDependencies =
							createResolveDependenciesFromContextMap(
								newContentCreateContextMap
							);
					***REMOVED***
					if (typeof newContentCallback === "function") {
						const origResource = result.resource;
						newContentCallback(result);
						if (
							result.resource !== origResource &&
							!result.resource.startsWith("/") &&
							(result.resource.length <= 1 || result.resource[1] !== ":")
						) {
							// When the function changed it to an relative path
							result.resource = join(
								/** @type {InputFileSystem***REMOVED*** */ (compiler.inputFileSystem),
								origResource,
								result.resource
							);
						***REMOVED***
					***REMOVED*** else {
						for (const d of result.dependencies) {
							if (d.critical) d.critical = false;
						***REMOVED***
					***REMOVED***
				***REMOVED***
				return result;
			***REMOVED***);
		***REMOVED***);
	***REMOVED***
***REMOVED***

/**
 * @param {(fs: InputFileSystem, callback: (err: null | Error, map: NewContentCreateContextMap) => void) => void***REMOVED*** createContextMap create context map function
 * @returns {(fs: InputFileSystem, options: ContextModuleOptions, callback: (err: null | Error, dependencies?: ContextElementDependency[]) => void) => void***REMOVED*** resolve resolve dependencies from context map function
 */
const createResolveDependenciesFromContextMap =
	createContextMap => (fs, options, callback) => {
		createContextMap(fs, (err, map) => {
			if (err) return callback(err);
			const dependencies = Object.keys(map).map(
				key =>
					new ContextElementDependency(
						map[key] + options.resourceQuery + options.resourceFragment,
						key,
						options.typePrefix,
						/** @type {string***REMOVED*** */
						(options.category),
						options.referencedExports
					)
			);
			callback(null, dependencies);
		***REMOVED***);
	***REMOVED***;

module.exports = ContextReplacementPlugin;
