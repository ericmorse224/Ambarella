/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/

"use strict";

const memoize = require("../util/memoize");

const LAZY_TARGET = Symbol("lazy serialization target");
const LAZY_SERIALIZED_VALUE = Symbol("lazy serialization data");

/** @typedef {SerializerMiddleware<EXPECTED_ANY, EXPECTED_ANY, Record<string, EXPECTED_ANY>>***REMOVED*** LazyTarget */
/** @typedef {Record<string, EXPECTED_ANY>***REMOVED*** LazyOptions */

/**
 * @template InputValue
 * @template OutputValue
 * @template {LazyTarget***REMOVED*** InternalLazyTarget
 * @template {LazyOptions | undefined***REMOVED*** InternalLazyOptions
 * @typedef {(() => InputValue | Promise<InputValue>) & Partial<{ [LAZY_TARGET]: InternalLazyTarget, options: InternalLazyOptions, [LAZY_SERIALIZED_VALUE]?: OutputValue | LazyFunction<OutputValue, InputValue, InternalLazyTarget, InternalLazyOptions> | undefined ***REMOVED***>***REMOVED*** LazyFunction
 */

/**
 * @template DeserializedType
 * @template SerializedType
 * @template Context
 */
class SerializerMiddleware {
	/* istanbul ignore next */
	/**
	 * @abstract
	 * @param {DeserializedType***REMOVED*** data data
	 * @param {Context***REMOVED*** context context object
	 * @returns {SerializedType | Promise<SerializedType> | null***REMOVED*** serialized data
	 */
	serialize(data, context) {
		const AbstractMethodError = require("../AbstractMethodError");
		throw new AbstractMethodError();
	***REMOVED***

	/* istanbul ignore next */
	/**
	 * @abstract
	 * @param {SerializedType***REMOVED*** data data
	 * @param {Context***REMOVED*** context context object
	 * @returns {DeserializedType | Promise<DeserializedType>***REMOVED*** deserialized data
	 */
	deserialize(data, context) {
		const AbstractMethodError = require("../AbstractMethodError");
		throw new AbstractMethodError();
	***REMOVED***

	/**
	 * @template TLazyInputValue
	 * @template TLazyOutputValue
	 * @template {LazyTarget***REMOVED*** TLazyTarget
	 * @template {LazyOptions | undefined***REMOVED*** TLazyOptions
	 * @param {TLazyInputValue | (() => TLazyInputValue)***REMOVED*** value contained value or function to value
	 * @param {TLazyTarget***REMOVED*** target target middleware
	 * @param {TLazyOptions=***REMOVED*** options lazy options
	 * @param {TLazyOutputValue=***REMOVED*** serializedValue serialized value
	 * @returns {LazyFunction<TLazyInputValue, TLazyOutputValue, TLazyTarget, TLazyOptions>***REMOVED*** lazy function
	 */
	static createLazy(
		value,
		target,
		options = /** @type {TLazyOptions***REMOVED*** */ ({***REMOVED***),
		serializedValue = undefined
	) {
		if (SerializerMiddleware.isLazy(value, target)) return value;
		const fn =
			/** @type {LazyFunction<TLazyInputValue, TLazyOutputValue, TLazyTarget, TLazyOptions>***REMOVED*** */
			(typeof value === "function" ? value : () => value);
		fn[LAZY_TARGET] = target;
		fn.options = options;
		fn[LAZY_SERIALIZED_VALUE] = serializedValue;
		return fn;
	***REMOVED***

	/**
	 * @template {LazyTarget***REMOVED*** TLazyTarget
	 * @param {EXPECTED_ANY***REMOVED*** fn lazy function
	 * @param {TLazyTarget=***REMOVED*** target target middleware
	 * @returns {fn is LazyFunction<EXPECTED_ANY, EXPECTED_ANY, TLazyTarget, EXPECTED_ANY>***REMOVED*** true, when fn is a lazy function (optionally of that target)
	 */
	static isLazy(fn, target) {
		if (typeof fn !== "function") return false;
		const t = fn[LAZY_TARGET];
		return target ? t === target : Boolean(t);
	***REMOVED***

	/**
	 * @template TLazyInputValue
	 * @template TLazyOutputValue
	 * @template {LazyTarget***REMOVED*** TLazyTarget
	 * @template {Record<string, EXPECTED_ANY>***REMOVED*** TLazyOptions
	 * @template TLazySerializedValue
	 * @param {LazyFunction<TLazyInputValue, TLazyOutputValue, TLazyTarget, TLazyOptions>***REMOVED*** fn lazy function
	 * @returns {LazyOptions | undefined***REMOVED*** options
	 */
	static getLazyOptions(fn) {
		if (typeof fn !== "function") return;
		return fn.options;
	***REMOVED***

	/**
	 * @template TLazyInputValue
	 * @template TLazyOutputValue
	 * @template {LazyTarget***REMOVED*** TLazyTarget
	 * @template {LazyOptions***REMOVED*** TLazyOptions
	 * @param {LazyFunction<TLazyInputValue, TLazyOutputValue, TLazyTarget, TLazyOptions> | EXPECTED_ANY***REMOVED*** fn lazy function
	 * @returns {TLazyOutputValue | undefined***REMOVED*** serialized value
	 */
	static getLazySerializedValue(fn) {
		if (typeof fn !== "function") return;
		return fn[LAZY_SERIALIZED_VALUE];
	***REMOVED***

	/**
	 * @template TLazyInputValue
	 * @template TLazyOutputValue
	 * @template {LazyTarget***REMOVED*** TLazyTarget
	 * @template {LazyOptions***REMOVED*** TLazyOptions
	 * @param {LazyFunction<TLazyInputValue, TLazyOutputValue, LazyTarget, LazyOptions>***REMOVED*** fn lazy function
	 * @param {TLazyOutputValue***REMOVED*** value serialized value
	 * @returns {void***REMOVED***
	 */
	static setLazySerializedValue(fn, value) {
		fn[LAZY_SERIALIZED_VALUE] = value;
	***REMOVED***

	/**
	 * @template TLazyInputValue DeserializedValue
	 * @template TLazyOutputValue SerializedValue
	 * @template {LazyTarget***REMOVED*** TLazyTarget
	 * @template {LazyOptions | undefined***REMOVED*** TLazyOptions
	 * @param {LazyFunction<TLazyInputValue, TLazyOutputValue, TLazyTarget, TLazyOptions>***REMOVED*** lazy lazy function
	 * @param {(value: TLazyInputValue) => TLazyOutputValue***REMOVED*** serialize serialize function
	 * @returns {LazyFunction<TLazyOutputValue, TLazyInputValue, TLazyTarget, TLazyOptions>***REMOVED*** new lazy
	 */
	static serializeLazy(lazy, serialize) {
		const fn =
			/** @type {LazyFunction<TLazyOutputValue, TLazyInputValue, TLazyTarget, TLazyOptions>***REMOVED*** */
			(
				memoize(() => {
					const r = lazy();
					if (
						r &&
						typeof (/** @type {Promise<TLazyInputValue>***REMOVED*** */ (r).then) ===
							"function"
					) {
						return (
							/** @type {Promise<TLazyInputValue>***REMOVED*** */
							(r).then(data => data && serialize(data))
						);
					***REMOVED***
					return serialize(/** @type {TLazyInputValue***REMOVED*** */ (r));
				***REMOVED***)
			);
		fn[LAZY_TARGET] = lazy[LAZY_TARGET];
		fn.options = lazy.options;
		lazy[LAZY_SERIALIZED_VALUE] = fn;
		return fn;
	***REMOVED***

	/**
	 * @template TLazyInputValue SerializedValue
	 * @template TLazyOutputValue DeserializedValue
	 * @template SerializedValue
	 * @template {LazyTarget***REMOVED*** TLazyTarget
	 * @template {LazyOptions | undefined***REMOVED*** TLazyOptions
	 * @param {LazyFunction<TLazyInputValue, TLazyOutputValue, TLazyTarget, TLazyOptions>***REMOVED*** lazy lazy function
	 * @param {(data: TLazyInputValue) => TLazyOutputValue***REMOVED*** deserialize deserialize function
	 * @returns {LazyFunction<TLazyOutputValue, TLazyInputValue, TLazyTarget, TLazyOptions>***REMOVED*** new lazy
	 */
	static deserializeLazy(lazy, deserialize) {
		const fn =
			/** @type {LazyFunction<TLazyOutputValue, TLazyInputValue, TLazyTarget, TLazyOptions>***REMOVED*** */ (
				memoize(() => {
					const r = lazy();
					if (
						r &&
						typeof (/** @type {Promise<TLazyInputValue>***REMOVED*** */ (r).then) ===
							"function"
					) {
						return (
							/** @type {Promise<TLazyInputValue>***REMOVED*** */
							(r).then(data => deserialize(data))
						);
					***REMOVED***
					return deserialize(/** @type {TLazyInputValue***REMOVED*** */ (r));
				***REMOVED***)
			);
		fn[LAZY_TARGET] = lazy[LAZY_TARGET];
		fn.options = lazy.options;
		fn[LAZY_SERIALIZED_VALUE] = lazy;
		return fn;
	***REMOVED***

	/**
	 * @template TLazyInputValue
	 * @template TLazyOutputValue
	 * @template {LazyTarget***REMOVED*** TLazyTarget
	 * @template {LazyOptions***REMOVED*** TLazyOptions
	 * @param {LazyFunction<TLazyInputValue | TLazyOutputValue, TLazyInputValue | TLazyOutputValue, TLazyTarget, TLazyOptions> | undefined***REMOVED*** lazy lazy function
	 * @returns {LazyFunction<TLazyInputValue | TLazyOutputValue, TLazyInputValue | TLazyOutputValue, TLazyTarget, TLazyOptions> | undefined***REMOVED*** new lazy
	 */
	static unMemoizeLazy(lazy) {
		if (!SerializerMiddleware.isLazy(lazy)) return lazy;
		/** @type {LazyFunction<TLazyInputValue | TLazyOutputValue, TLazyInputValue | TLazyOutputValue, TLazyTarget, TLazyOptions>***REMOVED*** */
		const fn = () => {
			throw new Error(
				"A lazy value that has been unmemorized can't be called again"
			);
		***REMOVED***;
		fn[LAZY_SERIALIZED_VALUE] = SerializerMiddleware.unMemoizeLazy(
			/** @type {LazyFunction<TLazyInputValue | TLazyOutputValue, TLazyInputValue | TLazyOutputValue, TLazyTarget, TLazyOptions>***REMOVED*** */
			(lazy[LAZY_SERIALIZED_VALUE])
		);
		fn[LAZY_TARGET] = lazy[LAZY_TARGET];
		fn.options = lazy.options;
		return fn;
	***REMOVED***
***REMOVED***

module.exports = SerializerMiddleware;
