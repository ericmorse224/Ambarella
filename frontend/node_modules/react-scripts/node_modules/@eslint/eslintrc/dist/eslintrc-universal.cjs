'use strict';

Object.defineProperty(exports, '__esModule', { value: true ***REMOVED***);

var util = require('util');
var path = require('path');
var Ajv = require('ajv');
var globals = require('globals');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e ***REMOVED***; ***REMOVED***

var util__default = /*#__PURE__*/_interopDefaultLegacy(util);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var Ajv__default = /*#__PURE__*/_interopDefaultLegacy(Ajv);
var globals__default = /*#__PURE__*/_interopDefaultLegacy(globals);

/**
 * @fileoverview Config file operations. This file must be usable in the browser,
 * so no Node-specific code can be here.
 * @author Nicholas C. Zakas
 */

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

const RULE_SEVERITY_STRINGS = ["off", "warn", "error"],
    RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce((map, value, index) => {
        map[value] = index;
        return map;
    ***REMOVED***, {***REMOVED***),
    VALID_SEVERITIES = [0, 1, 2, "off", "warn", "error"];

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * Normalizes the severity value of a rule's configuration to a number
 * @param {(number|string|[number, ...*]|[string, ...*])***REMOVED*** ruleConfig A rule's configuration value, generally
 * received from the user. A valid config value is either 0, 1, 2, the string "off" (treated the same as 0),
 * the string "warn" (treated the same as 1), the string "error" (treated the same as 2), or an array
 * whose first element is one of the above values. Strings are matched case-insensitively.
 * @returns {(0|1|2)***REMOVED*** The numeric severity value if the config value was valid, otherwise 0.
 */
function getRuleSeverity(ruleConfig) {
    const severityValue = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;

    if (severityValue === 0 || severityValue === 1 || severityValue === 2) {
        return severityValue;
    ***REMOVED***

    if (typeof severityValue === "string") {
        return RULE_SEVERITY[severityValue.toLowerCase()] || 0;
    ***REMOVED***

    return 0;
***REMOVED***

/**
 * Converts old-style severity settings (0, 1, 2) into new-style
 * severity settings (off, warn, error) for all rules. Assumption is that severity
 * values have already been validated as correct.
 * @param {Object***REMOVED*** config The config object to normalize.
 * @returns {void***REMOVED***
 */
function normalizeToStrings(config) {

    if (config.rules) {
        Object.keys(config.rules).forEach(ruleId => {
            const ruleConfig = config.rules[ruleId];

            if (typeof ruleConfig === "number") {
                config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];
            ***REMOVED*** else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === "number") {
                ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
***REMOVED***

/**
 * Determines if the severity for the given rule configuration represents an error.
 * @param {int|string|Array***REMOVED*** ruleConfig The configuration for an individual rule.
 * @returns {boolean***REMOVED*** True if the rule represents an error, false if not.
 */
function isErrorSeverity(ruleConfig) {
    return getRuleSeverity(ruleConfig) === 2;
***REMOVED***

/**
 * Checks whether a given config has valid severity or not.
 * @param {number|string|Array***REMOVED*** ruleConfig The configuration for an individual rule.
 * @returns {boolean***REMOVED*** `true` if the configuration has valid severity.
 */
function isValidSeverity(ruleConfig) {
    let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;

    if (typeof severity === "string") {
        severity = severity.toLowerCase();
    ***REMOVED***
    return VALID_SEVERITIES.indexOf(severity) !== -1;
***REMOVED***

/**
 * Checks whether every rule of a given config has valid severity or not.
 * @param {Object***REMOVED*** config The configuration for rules.
 * @returns {boolean***REMOVED*** `true` if the configuration has valid severity.
 */
function isEverySeverityValid(config) {
    return Object.keys(config).every(ruleId => isValidSeverity(config[ruleId]));
***REMOVED***

/**
 * Normalizes a value for a global in a config
 * @param {(boolean|string|null)***REMOVED*** configuredValue The value given for a global in configuration or in
 * a global directive comment
 * @returns {("readable"|"writeable"|"off")***REMOVED*** The value normalized as a string
 * @throws Error if global value is invalid
 */
function normalizeConfigGlobal(configuredValue) {
    switch (configuredValue) {
        case "off":
            return "off";

        case true:
        case "true":
        case "writeable":
        case "writable":
            return "writable";

        case null:
        case false:
        case "false":
        case "readable":
        case "readonly":
            return "readonly";

        default:
            throw new Error(`'${configuredValue***REMOVED***' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`);
    ***REMOVED***
***REMOVED***

var ConfigOps = {
    __proto__: null,
    getRuleSeverity: getRuleSeverity,
    normalizeToStrings: normalizeToStrings,
    isErrorSeverity: isErrorSeverity,
    isValidSeverity: isValidSeverity,
    isEverySeverityValid: isEverySeverityValid,
    normalizeConfigGlobal: normalizeConfigGlobal
***REMOVED***;

/**
 * @fileoverview Provide the function that emits deprecation warnings.
 * @author Toru Nagashima <http://github.com/mysticatea>
 */

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------

// Defitions for deprecation warnings.
const deprecationWarningMessages = {
    ESLINT_LEGACY_ECMAFEATURES:
        "The 'ecmaFeatures' config file property is deprecated and has no effect.",
    ESLINT_PERSONAL_CONFIG_LOAD:
        "'~/.eslintrc.*' config files have been deprecated. " +
        "Please use a config file per project or the '--config' option.",
    ESLINT_PERSONAL_CONFIG_SUPPRESS:
        "'~/.eslintrc.*' config files have been deprecated. " +
        "Please remove it or add 'root:true' to the config files in your " +
        "projects in order to avoid loading '~/.eslintrc.*' accidentally."
***REMOVED***;

const sourceFileErrorCache = new Set();

/**
 * Emits a deprecation warning containing a given filepath. A new deprecation warning is emitted
 * for each unique file path, but repeated invocations with the same file path have no effect.
 * No warnings are emitted if the `--no-deprecation` or `--no-warnings` Node runtime flags are active.
 * @param {string***REMOVED*** source The name of the configuration source to report the warning for.
 * @param {string***REMOVED*** errorCode The warning message to show.
 * @returns {void***REMOVED***
 */
function emitDeprecationWarning(source, errorCode) {
    const cacheKey = JSON.stringify({ source, errorCode ***REMOVED***);

    if (sourceFileErrorCache.has(cacheKey)) {
        return;
    ***REMOVED***
    sourceFileErrorCache.add(cacheKey);

    const rel = path__default["default"].relative(process.cwd(), source);
    const message = deprecationWarningMessages[errorCode];

    process.emitWarning(
        `${message***REMOVED*** (found in "${rel***REMOVED***")`,
        "DeprecationWarning",
        errorCode
    );
***REMOVED***

/**
 * @fileoverview The instance of Ajv validator.
 * @author Evgeny Poberezkin
 */

//-----------------------------------------------------------------------------
// Helpers
//-----------------------------------------------------------------------------

/*
 * Copied from ajv/lib/refs/json-schema-draft-04.json
 * The MIT License (MIT)
 * Copyright (c) 2015-2017 Evgeny Poberezkin
 */
const metaSchema = {
    id: "http://json-schema.org/draft-04/schema#",
    $schema: "http://json-schema.org/draft-04/schema#",
    description: "Core schema meta-schema",
    definitions: {
        schemaArray: {
            type: "array",
            minItems: 1,
            items: { $ref: "#" ***REMOVED***
        ***REMOVED***,
        positiveInteger: {
            type: "integer",
            minimum: 0
        ***REMOVED***,
        positiveIntegerDefault0: {
            allOf: [{ $ref: "#/definitions/positiveInteger" ***REMOVED***, { default: 0 ***REMOVED***]
        ***REMOVED***,
        simpleTypes: {
            enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        ***REMOVED***,
        stringArray: {
            type: "array",
            items: { type: "string" ***REMOVED***,
            minItems: 1,
            uniqueItems: true
        ***REMOVED***
    ***REMOVED***,
    type: "object",
    properties: {
        id: {
            type: "string"
        ***REMOVED***,
        $schema: {
            type: "string"
        ***REMOVED***,
        title: {
            type: "string"
        ***REMOVED***,
        description: {
            type: "string"
        ***REMOVED***,
        default: { ***REMOVED***,
        multipleOf: {
            type: "number",
            minimum: 0,
            exclusiveMinimum: true
        ***REMOVED***,
        maximum: {
            type: "number"
        ***REMOVED***,
        exclusiveMaximum: {
            type: "boolean",
            default: false
        ***REMOVED***,
        minimum: {
            type: "number"
        ***REMOVED***,
        exclusiveMinimum: {
            type: "boolean",
            default: false
        ***REMOVED***,
        maxLength: { $ref: "#/definitions/positiveInteger" ***REMOVED***,
        minLength: { $ref: "#/definitions/positiveIntegerDefault0" ***REMOVED***,
        pattern: {
            type: "string",
            format: "regex"
        ***REMOVED***,
        additionalItems: {
            anyOf: [
                { type: "boolean" ***REMOVED***,
                { $ref: "#" ***REMOVED***
            ],
            default: { ***REMOVED***
        ***REMOVED***,
        items: {
            anyOf: [
                { $ref: "#" ***REMOVED***,
                { $ref: "#/definitions/schemaArray" ***REMOVED***
            ],
            default: { ***REMOVED***
        ***REMOVED***,
        maxItems: { $ref: "#/definitions/positiveInteger" ***REMOVED***,
        minItems: { $ref: "#/definitions/positiveIntegerDefault0" ***REMOVED***,
        uniqueItems: {
            type: "boolean",
            default: false
        ***REMOVED***,
        maxProperties: { $ref: "#/definitions/positiveInteger" ***REMOVED***,
        minProperties: { $ref: "#/definitions/positiveIntegerDefault0" ***REMOVED***,
        required: { $ref: "#/definitions/stringArray" ***REMOVED***,
        additionalProperties: {
            anyOf: [
                { type: "boolean" ***REMOVED***,
                { $ref: "#" ***REMOVED***
            ],
            default: { ***REMOVED***
        ***REMOVED***,
        definitions: {
            type: "object",
            additionalProperties: { $ref: "#" ***REMOVED***,
            default: { ***REMOVED***
        ***REMOVED***,
        properties: {
            type: "object",
            additionalProperties: { $ref: "#" ***REMOVED***,
            default: { ***REMOVED***
        ***REMOVED***,
        patternProperties: {
            type: "object",
            additionalProperties: { $ref: "#" ***REMOVED***,
            default: { ***REMOVED***
        ***REMOVED***,
        dependencies: {
            type: "object",
            additionalProperties: {
                anyOf: [
                    { $ref: "#" ***REMOVED***,
                    { $ref: "#/definitions/stringArray" ***REMOVED***
                ]
            ***REMOVED***
        ***REMOVED***,
        enum: {
            type: "array",
            minItems: 1,
            uniqueItems: true
        ***REMOVED***,
        type: {
            anyOf: [
                { $ref: "#/definitions/simpleTypes" ***REMOVED***,
                {
                    type: "array",
                    items: { $ref: "#/definitions/simpleTypes" ***REMOVED***,
                    minItems: 1,
                    uniqueItems: true
                ***REMOVED***
            ]
        ***REMOVED***,
        format: { type: "string" ***REMOVED***,
        allOf: { $ref: "#/definitions/schemaArray" ***REMOVED***,
        anyOf: { $ref: "#/definitions/schemaArray" ***REMOVED***,
        oneOf: { $ref: "#/definitions/schemaArray" ***REMOVED***,
        not: { $ref: "#" ***REMOVED***
    ***REMOVED***,
    dependencies: {
        exclusiveMaximum: ["maximum"],
        exclusiveMinimum: ["minimum"]
    ***REMOVED***,
    default: { ***REMOVED***
***REMOVED***;

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

var ajvOrig = (additionalOptions = {***REMOVED***) => {
    const ajv = new Ajv__default["default"]({
        meta: false,
        useDefaults: true,
        validateSchema: false,
        missingRefs: "ignore",
        verbose: true,
        schemaId: "auto",
        ...additionalOptions
    ***REMOVED***);

    ajv.addMetaSchema(metaSchema);
    // eslint-disable-next-line no-underscore-dangle
    ajv._opts.defaultMeta = metaSchema.id;

    return ajv;
***REMOVED***;

/**
 * @fileoverview Defines a schema for configs.
 * @author Sylvan Mably
 */

const baseConfigProperties = {
    $schema: { type: "string" ***REMOVED***,
    env: { type: "object" ***REMOVED***,
    extends: { $ref: "#/definitions/stringOrStrings" ***REMOVED***,
    globals: { type: "object" ***REMOVED***,
    overrides: {
        type: "array",
        items: { $ref: "#/definitions/overrideConfig" ***REMOVED***,
        additionalItems: false
    ***REMOVED***,
    parser: { type: ["string", "null"] ***REMOVED***,
    parserOptions: { type: "object" ***REMOVED***,
    plugins: { type: "array" ***REMOVED***,
    processor: { type: "string" ***REMOVED***,
    rules: { type: "object" ***REMOVED***,
    settings: { type: "object" ***REMOVED***,
    noInlineConfig: { type: "boolean" ***REMOVED***,
    reportUnusedDisableDirectives: { type: "boolean" ***REMOVED***,

    ecmaFeatures: { type: "object" ***REMOVED*** // deprecated; logs a warning when used
***REMOVED***;

const configSchema = {
    definitions: {
        stringOrStrings: {
            oneOf: [
                { type: "string" ***REMOVED***,
                {
                    type: "array",
                    items: { type: "string" ***REMOVED***,
                    additionalItems: false
                ***REMOVED***
            ]
        ***REMOVED***,
        stringOrStringsRequired: {
            oneOf: [
                { type: "string" ***REMOVED***,
                {
                    type: "array",
                    items: { type: "string" ***REMOVED***,
                    additionalItems: false,
                    minItems: 1
                ***REMOVED***
            ]
        ***REMOVED***,

        // Config at top-level.
        objectConfig: {
            type: "object",
            properties: {
                root: { type: "boolean" ***REMOVED***,
                ignorePatterns: { $ref: "#/definitions/stringOrStrings" ***REMOVED***,
                ...baseConfigProperties
            ***REMOVED***,
            additionalProperties: false
        ***REMOVED***,

        // Config in `overrides`.
        overrideConfig: {
            type: "object",
            properties: {
                excludedFiles: { $ref: "#/definitions/stringOrStrings" ***REMOVED***,
                files: { $ref: "#/definitions/stringOrStringsRequired" ***REMOVED***,
                ...baseConfigProperties
            ***REMOVED***,
            required: ["files"],
            additionalProperties: false
        ***REMOVED***
    ***REMOVED***,

    $ref: "#/definitions/objectConfig"
***REMOVED***;

/**
 * @fileoverview Defines environment settings and globals.
 * @author Elan Shanker
 */

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Get the object that has difference.
 * @param {Record<string,boolean>***REMOVED*** current The newer object.
 * @param {Record<string,boolean>***REMOVED*** prev The older object.
 * @returns {Record<string,boolean>***REMOVED*** The difference object.
 */
function getDiff(current, prev) {
    const retv = {***REMOVED***;

    for (const [key, value] of Object.entries(current)) {
        if (!Object.hasOwnProperty.call(prev, key)) {
            retv[key] = value;
        ***REMOVED***
    ***REMOVED***

    return retv;
***REMOVED***

const newGlobals2015 = getDiff(globals__default["default"].es2015, globals__default["default"].es5); // 19 variables such as Promise, Map, ...
const newGlobals2017 = {
    Atomics: false,
    SharedArrayBuffer: false
***REMOVED***;
const newGlobals2020 = {
    BigInt: false,
    BigInt64Array: false,
    BigUint64Array: false,
    globalThis: false
***REMOVED***;

const newGlobals2021 = {
    AggregateError: false,
    FinalizationRegistry: false,
    WeakRef: false
***REMOVED***;

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/** @type {Map<string, import("../lib/shared/types").Environment>***REMOVED*** */
var environments = new Map(Object.entries({

    // Language
    builtin: {
        globals: globals__default["default"].es5
    ***REMOVED***,
    es6: {
        globals: newGlobals2015,
        parserOptions: {
            ecmaVersion: 6
        ***REMOVED***
    ***REMOVED***,
    es2015: {
        globals: newGlobals2015,
        parserOptions: {
            ecmaVersion: 6
        ***REMOVED***
    ***REMOVED***,
    es2016: {
        globals: newGlobals2015,
        parserOptions: {
            ecmaVersion: 7
        ***REMOVED***
    ***REMOVED***,
    es2017: {
        globals: { ...newGlobals2015, ...newGlobals2017 ***REMOVED***,
        parserOptions: {
            ecmaVersion: 8
        ***REMOVED***
    ***REMOVED***,
    es2018: {
        globals: { ...newGlobals2015, ...newGlobals2017 ***REMOVED***,
        parserOptions: {
            ecmaVersion: 9
        ***REMOVED***
    ***REMOVED***,
    es2019: {
        globals: { ...newGlobals2015, ...newGlobals2017 ***REMOVED***,
        parserOptions: {
            ecmaVersion: 10
        ***REMOVED***
    ***REMOVED***,
    es2020: {
        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020 ***REMOVED***,
        parserOptions: {
            ecmaVersion: 11
        ***REMOVED***
    ***REMOVED***,
    es2021: {
        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 ***REMOVED***,
        parserOptions: {
            ecmaVersion: 12
        ***REMOVED***
    ***REMOVED***,
    es2022: {
        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 ***REMOVED***,
        parserOptions: {
            ecmaVersion: 13
        ***REMOVED***
    ***REMOVED***,
    es2023: {
        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 ***REMOVED***,
        parserOptions: {
            ecmaVersion: 14
        ***REMOVED***
    ***REMOVED***,
    es2024: {
        globals: { ...newGlobals2015, ...newGlobals2017, ...newGlobals2020, ...newGlobals2021 ***REMOVED***,
        parserOptions: {
            ecmaVersion: 15
        ***REMOVED***
    ***REMOVED***,

    // Platforms
    browser: {
        globals: globals__default["default"].browser
    ***REMOVED***,
    node: {
        globals: globals__default["default"].node,
        parserOptions: {
            ecmaFeatures: {
                globalReturn: true
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***,
    "shared-node-browser": {
        globals: globals__default["default"]["shared-node-browser"]
    ***REMOVED***,
    worker: {
        globals: globals__default["default"].worker
    ***REMOVED***,
    serviceworker: {
        globals: globals__default["default"].serviceworker
    ***REMOVED***,

    // Frameworks
    commonjs: {
        globals: globals__default["default"].commonjs,
        parserOptions: {
            ecmaFeatures: {
                globalReturn: true
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***,
    amd: {
        globals: globals__default["default"].amd
    ***REMOVED***,
    mocha: {
        globals: globals__default["default"].mocha
    ***REMOVED***,
    jasmine: {
        globals: globals__default["default"].jasmine
    ***REMOVED***,
    jest: {
        globals: globals__default["default"].jest
    ***REMOVED***,
    phantomjs: {
        globals: globals__default["default"].phantomjs
    ***REMOVED***,
    jquery: {
        globals: globals__default["default"].jquery
    ***REMOVED***,
    qunit: {
        globals: globals__default["default"].qunit
    ***REMOVED***,
    prototypejs: {
        globals: globals__default["default"].prototypejs
    ***REMOVED***,
    shelljs: {
        globals: globals__default["default"].shelljs
    ***REMOVED***,
    meteor: {
        globals: globals__default["default"].meteor
    ***REMOVED***,
    mongo: {
        globals: globals__default["default"].mongo
    ***REMOVED***,
    protractor: {
        globals: globals__default["default"].protractor
    ***REMOVED***,
    applescript: {
        globals: globals__default["default"].applescript
    ***REMOVED***,
    nashorn: {
        globals: globals__default["default"].nashorn
    ***REMOVED***,
    atomtest: {
        globals: globals__default["default"].atomtest
    ***REMOVED***,
    embertest: {
        globals: globals__default["default"].embertest
    ***REMOVED***,
    webextensions: {
        globals: globals__default["default"].webextensions
    ***REMOVED***,
    greasemonkey: {
        globals: globals__default["default"].greasemonkey
    ***REMOVED***
***REMOVED***));

/**
 * @fileoverview Validates configs.
 * @author Brandon Mills
 */

const ajv = ajvOrig();

const ruleValidators = new WeakMap();
const noop = Function.prototype;

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------
let validateSchema;
const severityMap = {
    error: 2,
    warn: 1,
    off: 0
***REMOVED***;

const validated = new WeakSet();

//-----------------------------------------------------------------------------
// Exports
//-----------------------------------------------------------------------------

class ConfigValidator {
    constructor({ builtInRules = new Map() ***REMOVED*** = {***REMOVED***) {
        this.builtInRules = builtInRules;
    ***REMOVED***

    /**
     * Gets a complete options schema for a rule.
     * @param {{create: Function, schema: (Array|null)***REMOVED******REMOVED*** rule A new-style rule object
     * @returns {Object***REMOVED*** JSON Schema for the rule's options.
     */
    getRuleOptionsSchema(rule) {
        if (!rule) {
            return null;
        ***REMOVED***

        const schema = rule.schema || rule.meta && rule.meta.schema;

        // Given a tuple of schemas, insert warning level at the beginning
        if (Array.isArray(schema)) {
            if (schema.length) {
                return {
                    type: "array",
                    items: schema,
                    minItems: 0,
                    maxItems: schema.length
                ***REMOVED***;
            ***REMOVED***
            return {
                type: "array",
                minItems: 0,
                maxItems: 0
            ***REMOVED***;

        ***REMOVED***

        // Given a full schema, leave it alone
        return schema || null;
    ***REMOVED***

    /**
     * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.
     * @param {options***REMOVED*** options The given options for the rule.
     * @returns {number|string***REMOVED*** The rule's severity value
     */
    validateRuleSeverity(options) {
        const severity = Array.isArray(options) ? options[0] : options;
        const normSeverity = typeof severity === "string" ? severityMap[severity.toLowerCase()] : severity;

        if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {
            return normSeverity;
        ***REMOVED***

        throw new Error(`\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util__default["default"].inspect(severity).replace(/'/gu, "\"").replace(/\n/gu, "")***REMOVED***').\n`);

    ***REMOVED***

    /**
     * Validates the non-severity options passed to a rule, based on its schema.
     * @param {{create: Function***REMOVED******REMOVED*** rule The rule to validate
     * @param {Array***REMOVED*** localOptions The options for the rule, excluding severity
     * @returns {void***REMOVED***
     */
    validateRuleSchema(rule, localOptions) {
        if (!ruleValidators.has(rule)) {
            const schema = this.getRuleOptionsSchema(rule);

            if (schema) {
                ruleValidators.set(rule, ajv.compile(schema));
            ***REMOVED***
        ***REMOVED***

        const validateRule = ruleValidators.get(rule);

        if (validateRule) {
            validateRule(localOptions);
            if (validateRule.errors) {
                throw new Error(validateRule.errors.map(
                    error => `\tValue ${JSON.stringify(error.data)***REMOVED*** ${error.message***REMOVED***.\n`
                ).join(""));
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    /**
     * Validates a rule's options against its schema.
     * @param {{create: Function***REMOVED***|null***REMOVED*** rule The rule that the config is being validated for
     * @param {string***REMOVED*** ruleId The rule's unique name.
     * @param {Array|number***REMOVED*** options The given options for the rule.
     * @param {string|null***REMOVED*** source The name of the configuration source to report in any errors. If null or undefined,
     * no source is prepended to the message.
     * @returns {void***REMOVED***
     */
    validateRuleOptions(rule, ruleId, options, source = null) {
        try {
            const severity = this.validateRuleSeverity(options);

            if (severity !== 0) {
                this.validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);
            ***REMOVED***
        ***REMOVED*** catch (err) {
            const enhancedMessage = `Configuration for rule "${ruleId***REMOVED***" is invalid:\n${err.message***REMOVED***`;

            if (typeof source === "string") {
                throw new Error(`${source***REMOVED***:\n\t${enhancedMessage***REMOVED***`);
            ***REMOVED*** else {
                throw new Error(enhancedMessage);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    /**
     * Validates an environment object
     * @param {Object***REMOVED*** environment The environment config object to validate.
     * @param {string***REMOVED*** source The name of the configuration source to report in any errors.
     * @param {function(envId:string): Object***REMOVED*** [getAdditionalEnv] A map from strings to loaded environments.
     * @returns {void***REMOVED***
     */
    validateEnvironment(
        environment,
        source,
        getAdditionalEnv = noop
    ) {

        // not having an environment is ok
        if (!environment) {
            return;
        ***REMOVED***

        Object.keys(environment).forEach(id => {
            const env = getAdditionalEnv(id) || environments.get(id) || null;

            if (!env) {
                const message = `${source***REMOVED***:\n\tEnvironment key "${id***REMOVED***" is unknown\n`;

                throw new Error(message);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***

    /**
     * Validates a rules config object
     * @param {Object***REMOVED*** rulesConfig The rules config object to validate.
     * @param {string***REMOVED*** source The name of the configuration source to report in any errors.
     * @param {function(ruleId:string): Object***REMOVED*** getAdditionalRule A map from strings to loaded rules
     * @returns {void***REMOVED***
     */
    validateRules(
        rulesConfig,
        source,
        getAdditionalRule = noop
    ) {
        if (!rulesConfig) {
            return;
        ***REMOVED***

        Object.keys(rulesConfig).forEach(id => {
            const rule = getAdditionalRule(id) || this.builtInRules.get(id) || null;

            this.validateRuleOptions(rule, id, rulesConfig[id], source);
        ***REMOVED***);
    ***REMOVED***

    /**
     * Validates a `globals` section of a config file
     * @param {Object***REMOVED*** globalsConfig The `globals` section
     * @param {string|null***REMOVED*** source The name of the configuration source to report in the event of an error.
     * @returns {void***REMOVED***
     */
    validateGlobals(globalsConfig, source = null) {
        if (!globalsConfig) {
            return;
        ***REMOVED***

        Object.entries(globalsConfig)
            .forEach(([configuredGlobal, configuredValue]) => {
                try {
                    normalizeConfigGlobal(configuredValue);
                ***REMOVED*** catch (err) {
                    throw new Error(`ESLint configuration of global '${configuredGlobal***REMOVED***' in ${source***REMOVED*** is invalid:\n${err.message***REMOVED***`);
                ***REMOVED***
            ***REMOVED***);
    ***REMOVED***

    /**
     * Validate `processor` configuration.
     * @param {string|undefined***REMOVED*** processorName The processor name.
     * @param {string***REMOVED*** source The name of config file.
     * @param {function(id:string): Processor***REMOVED*** getProcessor The getter of defined processors.
     * @returns {void***REMOVED***
     */
    validateProcessor(processorName, source, getProcessor) {
        if (processorName && !getProcessor(processorName)) {
            throw new Error(`ESLint configuration of processor in '${source***REMOVED***' is invalid: '${processorName***REMOVED***' was not found.`);
        ***REMOVED***
    ***REMOVED***

    /**
     * Formats an array of schema validation errors.
     * @param {Array***REMOVED*** errors An array of error messages to format.
     * @returns {string***REMOVED*** Formatted error message
     */
    formatErrors(errors) {
        return errors.map(error => {
            if (error.keyword === "additionalProperties") {
                const formattedPropertyPath = error.dataPath.length ? `${error.dataPath.slice(1)***REMOVED***.${error.params.additionalProperty***REMOVED***` : error.params.additionalProperty;

                return `Unexpected top-level property "${formattedPropertyPath***REMOVED***"`;
            ***REMOVED***
            if (error.keyword === "type") {
                const formattedField = error.dataPath.slice(1);
                const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join("/") : error.schema;
                const formattedValue = JSON.stringify(error.data);

                return `Property "${formattedField***REMOVED***" is the wrong type (expected ${formattedExpectedType***REMOVED*** but got \`${formattedValue***REMOVED***\`)`;
            ***REMOVED***

            const field = error.dataPath[0] === "." ? error.dataPath.slice(1) : error.dataPath;

            return `"${field***REMOVED***" ${error.message***REMOVED***. Value: ${JSON.stringify(error.data)***REMOVED***`;
        ***REMOVED***).map(message => `\t- ${message***REMOVED***.\n`).join("");
    ***REMOVED***

    /**
     * Validates the top level properties of the config object.
     * @param {Object***REMOVED*** config The config object to validate.
     * @param {string***REMOVED*** source The name of the configuration source to report in any errors.
     * @returns {void***REMOVED***
     */
    validateConfigSchema(config, source = null) {
        validateSchema = validateSchema || ajv.compile(configSchema);

        if (!validateSchema(config)) {
            throw new Error(`ESLint configuration in ${source***REMOVED*** is invalid:\n${this.formatErrors(validateSchema.errors)***REMOVED***`);
        ***REMOVED***

        if (Object.hasOwnProperty.call(config, "ecmaFeatures")) {
            emitDeprecationWarning(source, "ESLINT_LEGACY_ECMAFEATURES");
        ***REMOVED***
    ***REMOVED***

    /**
     * Validates an entire config object.
     * @param {Object***REMOVED*** config The config object to validate.
     * @param {string***REMOVED*** source The name of the configuration source to report in any errors.
     * @param {function(ruleId:string): Object***REMOVED*** [getAdditionalRule] A map from strings to loaded rules.
     * @param {function(envId:string): Object***REMOVED*** [getAdditionalEnv] A map from strings to loaded envs.
     * @returns {void***REMOVED***
     */
    validate(config, source, getAdditionalRule, getAdditionalEnv) {
        this.validateConfigSchema(config, source);
        this.validateRules(config.rules, source, getAdditionalRule);
        this.validateEnvironment(config.env, source, getAdditionalEnv);
        this.validateGlobals(config.globals, source);

        for (const override of config.overrides || []) {
            this.validateRules(override.rules, source, getAdditionalRule);
            this.validateEnvironment(override.env, source, getAdditionalEnv);
            this.validateGlobals(config.globals, source);
        ***REMOVED***
    ***REMOVED***

    /**
     * Validate config array object.
     * @param {ConfigArray***REMOVED*** configArray The config array to validate.
     * @returns {void***REMOVED***
     */
    validateConfigArray(configArray) {
        const getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);
        const getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);
        const getPluginRule = Map.prototype.get.bind(configArray.pluginRules);

        // Validate.
        for (const element of configArray) {
            if (validated.has(element)) {
                continue;
            ***REMOVED***
            validated.add(element);

            this.validateEnvironment(element.env, element.name, getPluginEnv);
            this.validateGlobals(element.globals, element.name);
            this.validateProcessor(element.processor, element.name, getPluginProcessor);
            this.validateRules(element.rules, element.name, getPluginRule);
        ***REMOVED***
    ***REMOVED***

***REMOVED***

/**
 * @fileoverview Common helpers for naming of plugins, formatters and configs
 */

const NAMESPACE_REGEX = /^@.*\//iu;

/**
 * Brings package name to correct format based on prefix
 * @param {string***REMOVED*** name The name of the package.
 * @param {string***REMOVED*** prefix Can be either "eslint-plugin", "eslint-config" or "eslint-formatter"
 * @returns {string***REMOVED*** Normalized name of the package
 * @private
 */
function normalizePackageName(name, prefix) {
    let normalizedName = name;

    /**
     * On Windows, name can come in with Windows slashes instead of Unix slashes.
     * Normalize to Unix first to avoid errors later on.
     * https://github.com/eslint/eslint/issues/5644
     */
    if (normalizedName.includes("\\")) {
        normalizedName = normalizedName.replace(/\\/gu, "/");
    ***REMOVED***

    if (normalizedName.charAt(0) === "@") {

        /**
         * it's a scoped package
         * package name is the prefix, or just a username
         */
        const scopedPackageShortcutRegex = new RegExp(`^(@[^/]+)(?:/(?:${prefix***REMOVED***)?)?$`, "u"),
            scopedPackageNameRegex = new RegExp(`^${prefix***REMOVED***(-|$)`, "u");

        if (scopedPackageShortcutRegex.test(normalizedName)) {
            normalizedName = normalizedName.replace(scopedPackageShortcutRegex, `$1/${prefix***REMOVED***`);
        ***REMOVED*** else if (!scopedPackageNameRegex.test(normalizedName.split("/")[1])) {

            /**
             * for scoped packages, insert the prefix after the first / unless
             * the path is already @scope/eslint or @scope/eslint-xxx-yyy
             */
            normalizedName = normalizedName.replace(/^@([^/]+)\/(.*)$/u, `@$1/${prefix***REMOVED***-$2`);
        ***REMOVED***
    ***REMOVED*** else if (!normalizedName.startsWith(`${prefix***REMOVED***-`)) {
        normalizedName = `${prefix***REMOVED***-${normalizedName***REMOVED***`;
    ***REMOVED***

    return normalizedName;
***REMOVED***

/**
 * Removes the prefix from a fullname.
 * @param {string***REMOVED*** fullname The term which may have the prefix.
 * @param {string***REMOVED*** prefix The prefix to remove.
 * @returns {string***REMOVED*** The term without prefix.
 */
function getShorthandName(fullname, prefix) {
    if (fullname[0] === "@") {
        let matchResult = new RegExp(`^(@[^/]+)/${prefix***REMOVED***$`, "u").exec(fullname);

        if (matchResult) {
            return matchResult[1];
        ***REMOVED***

        matchResult = new RegExp(`^(@[^/]+)/${prefix***REMOVED***-(.+)$`, "u").exec(fullname);
        if (matchResult) {
            return `${matchResult[1]***REMOVED***/${matchResult[2]***REMOVED***`;
        ***REMOVED***
    ***REMOVED*** else if (fullname.startsWith(`${prefix***REMOVED***-`)) {
        return fullname.slice(prefix.length + 1);
    ***REMOVED***

    return fullname;
***REMOVED***

/**
 * Gets the scope (namespace) of a term.
 * @param {string***REMOVED*** term The term which may have the namespace.
 * @returns {string***REMOVED*** The namespace of the term if it has one.
 */
function getNamespaceFromTerm(term) {
    const match = term.match(NAMESPACE_REGEX);

    return match ? match[0] : "";
***REMOVED***

var naming = {
    __proto__: null,
    normalizePackageName: normalizePackageName,
    getShorthandName: getShorthandName,
    getNamespaceFromTerm: getNamespaceFromTerm
***REMOVED***;

/**
 * @fileoverview Package exports for @eslint/eslintrc
 * @author Nicholas C. Zakas
 */

//-----------------------------------------------------------------------------
// Exports
//-----------------------------------------------------------------------------

const Legacy = {
    environments,

    // shared
    ConfigOps,
    ConfigValidator,
    naming
***REMOVED***;

exports.Legacy = Legacy;
//# sourceMappingURL=eslintrc-universal.cjs.map
