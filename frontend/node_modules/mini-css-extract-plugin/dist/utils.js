"use strict";

const NativeModule = require("module");
const path = require("path");

/** @typedef {import("webpack").Compilation***REMOVED*** Compilation */
/** @typedef {import("webpack").Module***REMOVED*** Module */
/** @typedef {import("webpack").LoaderContext<any>***REMOVED*** LoaderContext */

/**
 * @returns {boolean***REMOVED***
 */
function trueFn() {
  return true;
***REMOVED***

/**
 * @param {Compilation***REMOVED*** compilation
 * @param {string | number***REMOVED*** id
 * @returns {null | Module***REMOVED***
 */
function findModuleById(compilation, id) {
  const {
    modules,
    chunkGraph
  ***REMOVED*** = compilation;
  for (const module of modules) {
    const moduleId = typeof chunkGraph !== "undefined" ? chunkGraph.getModuleId(module) : module.id;
    if (moduleId === id) {
      return module;
    ***REMOVED***
  ***REMOVED***
  return null;
***REMOVED***

/**
 * @param {LoaderContext***REMOVED*** loaderContext
 * @param {string | Buffer***REMOVED*** code
 * @param {string***REMOVED*** filename
 * @returns {object***REMOVED***
 */
function evalModuleCode(loaderContext, code, filename) {
  // @ts-ignore
  const module = new NativeModule(filename, loaderContext);

  // @ts-ignore
  module.paths = NativeModule._nodeModulePaths(loaderContext.context); // eslint-disable-line no-underscore-dangle
  module.filename = filename;
  // @ts-ignore
  module._compile(code, filename); // eslint-disable-line no-underscore-dangle

  return module.exports;
***REMOVED***

/**
 * @param {string***REMOVED*** a
 * @param {string***REMOVED*** b
 * @returns {0 | 1 | -1***REMOVED***
 */
function compareIds(a, b) {
  if (typeof a !== typeof b) {
    return typeof a < typeof b ? -1 : 1;
  ***REMOVED***
  if (a < b) {
    return -1;
  ***REMOVED***
  if (a > b) {
    return 1;
  ***REMOVED***
  return 0;
***REMOVED***

/**
 * @param {Module***REMOVED*** a
 * @param {Module***REMOVED*** b
 * @returns {0 | 1 | -1***REMOVED***
 */
function compareModulesByIdentifier(a, b) {
  return compareIds(a.identifier(), b.identifier());
***REMOVED***
const MODULE_TYPE = "css/mini-extract";
const AUTO_PUBLIC_PATH = "__mini_css_extract_plugin_public_path_auto__";
const ABSOLUTE_PUBLIC_PATH = "webpack:///mini-css-extract-plugin/";
const BASE_URI = "webpack://";
const SINGLE_DOT_PATH_SEGMENT = "__mini_css_extract_plugin_single_dot_path_segment__";

/**
 * @param {string***REMOVED*** str
 * @returns {boolean***REMOVED***
 */
function isAbsolutePath(str) {
  return path.posix.isAbsolute(str) || path.win32.isAbsolute(str);
***REMOVED***
const RELATIVE_PATH_REGEXP = /^\.\.?[/\\]/;

/**
 * @param {string***REMOVED*** str
 * @returns {boolean***REMOVED***
 */
function isRelativePath(str) {
  return RELATIVE_PATH_REGEXP.test(str);
***REMOVED***

// TODO simplify for the next major release
/**
 * @param {LoaderContext***REMOVED*** loaderContext
 * @param {string***REMOVED*** request
 * @returns {string***REMOVED***
 */
function stringifyRequest(loaderContext, request) {
  if (typeof loaderContext.utils !== "undefined" && typeof loaderContext.utils.contextify === "function") {
    return JSON.stringify(loaderContext.utils.contextify(loaderContext.context || loaderContext.rootContext, request));
  ***REMOVED***
  const splitted = request.split("!");
  const {
    context
  ***REMOVED*** = loaderContext;
  return JSON.stringify(splitted.map(part => {
    // First, separate singlePath from query, because the query might contain paths again
    const splittedPart = part.match(/^(.*?)(\?.*)/);
    const query = splittedPart ? splittedPart[2] : "";
    let singlePath = splittedPart ? splittedPart[1] : part;
    if (isAbsolutePath(singlePath) && context) {
      singlePath = path.relative(context, singlePath);
      if (isAbsolutePath(singlePath)) {
        // If singlePath still matches an absolute path, singlePath was on a different drive than context.
        // In this case, we leave the path platform-specific without replacing any separators.
        // @see https://github.com/webpack/loader-utils/pull/14
        return singlePath + query;
      ***REMOVED***
      if (isRelativePath(singlePath) === false) {
        // Ensure that the relative path starts at least with ./ otherwise it would be a request into the modules directory (like node_modules).
        singlePath = `./${singlePath***REMOVED***`;
      ***REMOVED***
    ***REMOVED***
    return singlePath.replace(/\\/g, "/") + query;
  ***REMOVED***).join("!"));
***REMOVED***

/**
 * @param {string***REMOVED*** filename
 * @param {string***REMOVED*** outputPath
 * @param {boolean***REMOVED*** enforceRelative
 * @returns {string***REMOVED***
 */
function getUndoPath(filename, outputPath, enforceRelative) {
  let depth = -1;
  let append = "";

  // eslint-disable-next-line no-param-reassign
  outputPath = outputPath.replace(/[\\/]$/, "");
  for (const part of filename.split(/[/\\]+/)) {
    if (part === "..") {
      if (depth > -1) {
        // eslint-disable-next-line no-plusplus
        depth--;
      ***REMOVED*** else {
        const i = outputPath.lastIndexOf("/");
        const j = outputPath.lastIndexOf("\\");
        const pos = i < 0 ? j : j < 0 ? i : Math.max(i, j);
        if (pos < 0) {
          return `${outputPath***REMOVED***/`;
        ***REMOVED***
        append = `${outputPath.slice(pos + 1)***REMOVED***/${append***REMOVED***`;

        // eslint-disable-next-line no-param-reassign
        outputPath = outputPath.slice(0, pos);
      ***REMOVED***
    ***REMOVED*** else if (part !== ".") {
      // eslint-disable-next-line no-plusplus
      depth++;
    ***REMOVED***
  ***REMOVED***
  return depth > 0 ? `${"../".repeat(depth)***REMOVED***${append***REMOVED***` : enforceRelative ? `./${append***REMOVED***` : append;
***REMOVED***

/**
 *
 * @param {string | function***REMOVED*** value
 * @returns {string***REMOVED***
 */
function stringifyLocal(value) {
  return typeof value === "function" ? value.toString() : JSON.stringify(value);
***REMOVED***

/**
 * @param {string***REMOVED*** str string
 * @returns {string***REMOVED*** string
 */
const toSimpleString = str => {
  if (`${+str***REMOVED***` === str) {
    return str;
  ***REMOVED***
  return JSON.stringify(str);
***REMOVED***;

/**
 * @param {string***REMOVED*** str string
 * @returns {string***REMOVED*** quoted meta
 */
const quoteMeta = str => str.replace(/[-[\]\\/{***REMOVED***()*+?.^$|]/g, "\\$&");

/**
 * @param {Array<string>***REMOVED*** items items
 * @returns {string***REMOVED*** common prefix
 */
const getCommonPrefix = items => {
  let prefix = items[0];
  for (let i = 1; i < items.length; i++) {
    const item = items[i];
    for (let p = 0; p < prefix.length; p++) {
      if (item[p] !== prefix[p]) {
        prefix = prefix.slice(0, p);
        break;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return prefix;
***REMOVED***;

/**
 * @param {Array<string>***REMOVED*** items items
 * @returns {string***REMOVED*** common suffix
 */
const getCommonSuffix = items => {
  let suffix = items[0];
  for (let i = 1; i < items.length; i++) {
    const item = items[i];
    for (let p = item.length - 1, s = suffix.length - 1; s >= 0; p--, s--) {
      if (item[p] !== suffix[s]) {
        suffix = suffix.slice(s + 1);
        break;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return suffix;
***REMOVED***;

/**
 * @param {Set<string>***REMOVED*** itemsSet items set
 * @param {(str: string) => string | false***REMOVED*** getKey get key function
 * @param {(str: Array<string>) => boolean***REMOVED*** condition condition
 * @returns {Array<Array<string>>***REMOVED*** list of common items
 */
const popCommonItems = (itemsSet, getKey, condition) => {
  /** @type {Map<string, Array<string>>***REMOVED*** */
  const map = new Map();
  for (const item of itemsSet) {
    const key = getKey(item);
    if (key) {
      let list = map.get(key);
      if (list === undefined) {
        /** @type {Array<string>***REMOVED*** */
        list = [];
        map.set(key, list);
      ***REMOVED***
      list.push(item);
    ***REMOVED***
  ***REMOVED***

  /** @type {Array<Array<string>>***REMOVED*** */
  const result = [];
  for (const list of map.values()) {
    if (condition(list)) {
      for (const item of list) {
        itemsSet.delete(item);
      ***REMOVED***
      result.push(list);
    ***REMOVED***
  ***REMOVED***
  return result;
***REMOVED***;

/**
 * @param {Array<string>***REMOVED*** itemsArr array of items
 * @returns {string***REMOVED*** regexp
 */
const itemsToRegexp = itemsArr => {
  if (itemsArr.length === 1) {
    return quoteMeta(itemsArr[0]);
  ***REMOVED***

  /** @type {Array<string>***REMOVED*** */
  const finishedItems = [];

  // merge single char items: (a|b|c|d|ef) => ([abcd]|ef)
  let countOfSingleCharItems = 0;
  for (const item of itemsArr) {
    if (item.length === 1) {
      // eslint-disable-next-line no-plusplus
      countOfSingleCharItems++;
    ***REMOVED***
  ***REMOVED***

  // special case for only single char items
  if (countOfSingleCharItems === itemsArr.length) {
    return `[${quoteMeta(itemsArr.sort().join(""))***REMOVED***]`;
  ***REMOVED***
  const items = new Set(itemsArr.sort());
  if (countOfSingleCharItems > 2) {
    let singleCharItems = "";
    for (const item of items) {
      if (item.length === 1) {
        singleCharItems += item;
        items.delete(item);
      ***REMOVED***
    ***REMOVED***
    finishedItems.push(`[${quoteMeta(singleCharItems)***REMOVED***]`);
  ***REMOVED***

  // special case for 2 items with common prefix/suffix
  if (finishedItems.length === 0 && items.size === 2) {
    const prefix = getCommonPrefix(itemsArr);
    const suffix = getCommonSuffix(itemsArr.map(item => item.slice(prefix.length)));
    if (prefix.length > 0 || suffix.length > 0) {
      return `${quoteMeta(prefix)***REMOVED***${itemsToRegexp(itemsArr.map(i => i.slice(prefix.length, -suffix.length || undefined)))***REMOVED***${quoteMeta(suffix)***REMOVED***`;
    ***REMOVED***
  ***REMOVED***

  // special case for 2 items with common suffix
  if (finishedItems.length === 0 && items.size === 2) {
    /** @type {Iterator<string>***REMOVED*** */
    const it = items[Symbol.iterator]();
    const a = it.next().value;
    const b = it.next().value;
    if (a.length > 0 && b.length > 0 && a.slice(-1) === b.slice(-1)) {
      return `${itemsToRegexp([a.slice(0, -1), b.slice(0, -1)])***REMOVED***${quoteMeta(a.slice(-1))***REMOVED***`;
    ***REMOVED***
  ***REMOVED***

  // find common prefix: (a1|a2|a3|a4|b5) => (a(1|2|3|4)|b5)
  const prefixed = popCommonItems(items, item => item.length >= 1 ? item[0] : false, list => {
    if (list.length >= 3) return true;
    if (list.length <= 1) return false;
    return list[0][1] === list[1][1];
  ***REMOVED***);
  for (const prefixedItems of prefixed) {
    const prefix = getCommonPrefix(prefixedItems);
    finishedItems.push(`${quoteMeta(prefix)***REMOVED***${itemsToRegexp(prefixedItems.map(i => i.slice(prefix.length)))***REMOVED***`);
  ***REMOVED***

  // find common suffix: (a1|b1|c1|d1|e2) => ((a|b|c|d)1|e2)
  const suffixed = popCommonItems(items, item => item.length >= 1 ? item.slice(-1) : false, list => {
    if (list.length >= 3) return true;
    if (list.length <= 1) return false;
    return list[0].slice(-2) === list[1].slice(-2);
  ***REMOVED***);
  for (const suffixedItems of suffixed) {
    const suffix = getCommonSuffix(suffixedItems);
    finishedItems.push(`${itemsToRegexp(suffixedItems.map(i => i.slice(0, -suffix.length)))***REMOVED***${quoteMeta(suffix)***REMOVED***`);
  ***REMOVED***

  // TODO further optimize regexp, i. e.
  // use ranges: (1|2|3|4|a) => [1-4a]
  const conditional = finishedItems.concat(Array.from(items, quoteMeta));
  if (conditional.length === 1) return conditional[0];
  return `(${conditional.join("|")***REMOVED***)`;
***REMOVED***;

/**
 * @param {string[]***REMOVED*** positiveItems positive items
 * @param {string[]***REMOVED*** negativeItems negative items
 * @returns {function(string): string***REMOVED*** a template function to determine the value at runtime
 */
const compileBooleanMatcherFromLists = (positiveItems, negativeItems) => {
  if (positiveItems.length === 0) {
    return () => "false";
  ***REMOVED***
  if (negativeItems.length === 0) {
    return () => "true";
  ***REMOVED***
  if (positiveItems.length === 1) {
    return value => `${toSimpleString(positiveItems[0])***REMOVED*** == ${value***REMOVED***`;
  ***REMOVED***
  if (negativeItems.length === 1) {
    return value => `${toSimpleString(negativeItems[0])***REMOVED*** != ${value***REMOVED***`;
  ***REMOVED***
  const positiveRegexp = itemsToRegexp(positiveItems);
  const negativeRegexp = itemsToRegexp(negativeItems);
  if (positiveRegexp.length <= negativeRegexp.length) {
    return value => `/^${positiveRegexp***REMOVED***$/.test(${value***REMOVED***)`;
  ***REMOVED***
  return value => `!/^${negativeRegexp***REMOVED***$/.test(${value***REMOVED***)`;
***REMOVED***;

// TODO simplify in the next major release and use it from webpack
/**
 * @param {Record<string|number, boolean>***REMOVED*** map value map
 * @returns {boolean|(function(string): string)***REMOVED*** true/false, when unconditionally true/false, or a template function to determine the value at runtime
 */
const compileBooleanMatcher = map => {
  const positiveItems = Object.keys(map).filter(i => map[i]);
  const negativeItems = Object.keys(map).filter(i => !map[i]);
  if (positiveItems.length === 0) {
    return false;
  ***REMOVED***
  if (negativeItems.length === 0) {
    return true;
  ***REMOVED***
  return compileBooleanMatcherFromLists(positiveItems, negativeItems);
***REMOVED***;
module.exports = {
  trueFn,
  findModuleById,
  evalModuleCode,
  compareModulesByIdentifier,
  MODULE_TYPE,
  AUTO_PUBLIC_PATH,
  ABSOLUTE_PUBLIC_PATH,
  BASE_URI,
  SINGLE_DOT_PATH_SEGMENT,
  stringifyRequest,
  stringifyLocal,
  getUndoPath,
  compileBooleanMatcher
***REMOVED***;