/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const Template = require("../Template");

/** @typedef {import("eslint-scope").Scope***REMOVED*** Scope */
/** @typedef {import("eslint-scope").Reference***REMOVED*** Reference */
/** @typedef {import("eslint-scope").Variable***REMOVED*** Variable */
/** @typedef {import("estree").Node***REMOVED*** Node */
/** @typedef {import("../javascript/JavascriptParser").Range***REMOVED*** Range */
/** @typedef {import("../javascript/JavascriptParser").Program***REMOVED*** Program */
/** @typedef {Set<string>***REMOVED*** UsedNames */

const DEFAULT_EXPORT = "__WEBPACK_DEFAULT_EXPORT__";
const NAMESPACE_OBJECT_EXPORT = "__WEBPACK_NAMESPACE_OBJECT__";

/**
 * @param {Variable***REMOVED*** variable variable
 * @returns {Reference[]***REMOVED*** references
 */
const getAllReferences = variable => {
	let set = variable.references;
	// Look for inner scope variables too (like in class Foo { t() { Foo ***REMOVED*** ***REMOVED***)
	const identifiers = new Set(variable.identifiers);
	for (const scope of variable.scope.childScopes) {
		for (const innerVar of scope.variables) {
			if (innerVar.identifiers.some(id => identifiers.has(id))) {
				set = set.concat(innerVar.references);
				break;
			***REMOVED***
		***REMOVED***
	***REMOVED***
	return set;
***REMOVED***;

/**
 * @param {Node | Node[]***REMOVED*** ast ast
 * @param {Node***REMOVED*** node node
 * @returns {undefined | Node[]***REMOVED*** result
 */
const getPathInAst = (ast, node) => {
	if (ast === node) {
		return [];
	***REMOVED***

	const nr = /** @type {Range***REMOVED*** */ (node.range);

	/**
	 * @param {Node***REMOVED*** n node
	 * @returns {Node[] | undefined***REMOVED*** result
	 */
	const enterNode = n => {
		if (!n) return;
		const r = n.range;
		if (r && r[0] <= nr[0] && r[1] >= nr[1]) {
			const path = getPathInAst(n, node);
			if (path) {
				path.push(n);
				return path;
			***REMOVED***
		***REMOVED***
	***REMOVED***;

	if (Array.isArray(ast)) {
		for (let i = 0; i < ast.length; i++) {
			const enterResult = enterNode(ast[i]);
			if (enterResult !== undefined) return enterResult;
		***REMOVED***
	***REMOVED*** else if (ast && typeof ast === "object") {
		const keys =
			/** @type {Array<keyof Node>***REMOVED*** */
			(Object.keys(ast));
		for (let i = 0; i < keys.length; i++) {
			// We are making the faster check in `enterNode` using `n.range`
			const value =
				ast[
					/** @type {Exclude<keyof Node, "range" | "loc" | "leadingComments" | "trailingComments">***REMOVED*** */
					(keys[i])
				];
			if (Array.isArray(value)) {
				const pathResult = getPathInAst(value, node);
				if (pathResult !== undefined) return pathResult;
			***REMOVED*** else if (value && typeof value === "object") {
				const enterResult = enterNode(value);
				if (enterResult !== undefined) return enterResult;
			***REMOVED***
		***REMOVED***
	***REMOVED***
***REMOVED***;

/**
 * @param {string***REMOVED*** oldName old name
 * @param {UsedNames***REMOVED*** usedNamed1 used named 1
 * @param {UsedNames***REMOVED*** usedNamed2 used named 2
 * @param {string***REMOVED*** extraInfo extra info
 * @returns {string***REMOVED*** found new name
 */
function findNewName(oldName, usedNamed1, usedNamed2, extraInfo) {
	let name = oldName;

	if (name === DEFAULT_EXPORT) {
		name = "";
	***REMOVED***
	if (name === NAMESPACE_OBJECT_EXPORT) {
		name = "namespaceObject";
	***REMOVED***

	// Remove uncool stuff
	extraInfo = extraInfo.replace(
		/\.+\/|(\/index)?\.([a-zA-Z0-9]{1,4***REMOVED***)($|\s|\?)|\s*\+\s*\d+\s*modules/g,
		""
	);

	const splittedInfo = extraInfo.split("/");
	while (splittedInfo.length) {
		name = splittedInfo.pop() + (name ? `_${name***REMOVED***` : "");
		const nameIdent = Template.toIdentifier(name);
		if (
			!usedNamed1.has(nameIdent) &&
			(!usedNamed2 || !usedNamed2.has(nameIdent))
		)
			return nameIdent;
	***REMOVED***

	let i = 0;
	let nameWithNumber = Template.toIdentifier(`${name***REMOVED***_${i***REMOVED***`);
	while (
		usedNamed1.has(nameWithNumber) ||
		// eslint-disable-next-line no-unmodified-loop-condition
		(usedNamed2 && usedNamed2.has(nameWithNumber))
	) {
		i++;
		nameWithNumber = Template.toIdentifier(`${name***REMOVED***_${i***REMOVED***`);
	***REMOVED***
	return nameWithNumber;
***REMOVED***

/** @typedef {Set<Scope>***REMOVED*** ScopeSet */

/**
 * @param {Scope | null***REMOVED*** s scope
 * @param {UsedNames***REMOVED*** nameSet name set
 * @param {ScopeSet***REMOVED*** scopeSet1 scope set 1
 * @param {ScopeSet***REMOVED*** scopeSet2 scope set 2
 */
const addScopeSymbols = (s, nameSet, scopeSet1, scopeSet2) => {
	let scope = s;
	while (scope) {
		if (scopeSet1.has(scope)) break;
		if (scopeSet2.has(scope)) break;
		scopeSet1.add(scope);
		for (const variable of scope.variables) {
			nameSet.add(variable.name);
		***REMOVED***
		scope = scope.upper;
	***REMOVED***
***REMOVED***;

const RESERVED_NAMES = new Set(
	[
		// internal names (should always be renamed)
		DEFAULT_EXPORT,
		NAMESPACE_OBJECT_EXPORT,

		// keywords
		"abstract,arguments,async,await,boolean,break,byte,case,catch,char,class,const,continue",
		"debugger,default,delete,do,double,else,enum,eval,export,extends,false,final,finally,float",
		"for,function,goto,if,implements,import,in,instanceof,int,interface,let,long,native,new,null",
		"package,private,protected,public,return,short,static,super,switch,synchronized,this,throw",
		"throws,transient,true,try,typeof,var,void,volatile,while,with,yield",

		// commonjs/amd
		"module,__dirname,__filename,exports,require,define",

		// js globals
		"Array,Date,eval,function,hasOwnProperty,Infinity,isFinite,isNaN,isPrototypeOf,length,Math",
		"NaN,name,Number,Object,prototype,String,Symbol,toString,undefined,valueOf",

		// browser globals
		"alert,all,anchor,anchors,area,assign,blur,button,checkbox,clearInterval,clearTimeout",
		"clientInformation,close,closed,confirm,constructor,crypto,decodeURI,decodeURIComponent",
		"defaultStatus,document,element,elements,embed,embeds,encodeURI,encodeURIComponent,escape",
		"event,fileUpload,focus,form,forms,frame,innerHeight,innerWidth,layer,layers,link,location",
		"mimeTypes,navigate,navigator,frames,frameRate,hidden,history,image,images,offscreenBuffering",
		"open,opener,option,outerHeight,outerWidth,packages,pageXOffset,pageYOffset,parent,parseFloat",
		"parseInt,password,pkcs11,plugin,prompt,propertyIsEnum,radio,reset,screenX,screenY,scroll",
		"secure,select,self,setInterval,setTimeout,status,submit,taint,text,textarea,top,unescape",
		"untaint,window",

		// window events
		"onblur,onclick,onerror,onfocus,onkeydown,onkeypress,onkeyup,onmouseover,onload,onmouseup,onmousedown,onsubmit"
	]
		.join(",")
		.split(",")
);

/** @typedef {{ usedNames: UsedNames, alreadyCheckedScopes: ScopeSet ***REMOVED******REMOVED*** ScopeInfo */

/**
 * @param {Map<string, ScopeInfo>***REMOVED*** usedNamesInScopeInfo used names in scope info
 * @param {string***REMOVED*** module module identifier
 * @param {string***REMOVED*** id export id
 * @returns {ScopeInfo***REMOVED*** info
 */
const getUsedNamesInScopeInfo = (usedNamesInScopeInfo, module, id) => {
	const key = `${module***REMOVED***-${id***REMOVED***`;
	let info = usedNamesInScopeInfo.get(key);
	if (info === undefined) {
		info = {
			usedNames: new Set(),
			alreadyCheckedScopes: new Set()
		***REMOVED***;
		usedNamesInScopeInfo.set(key, info);
	***REMOVED***
	return info;
***REMOVED***;

module.exports = {
	getUsedNamesInScopeInfo,
	findNewName,
	getAllReferences,
	getPathInAst,
	NAMESPACE_OBJECT_EXPORT,
	DEFAULT_EXPORT,
	RESERVED_NAMES,
	addScopeSymbols
***REMOVED***;
