'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
***REMOVED***);
exports.default = void 0;

var _CallTracker = _interopRequireDefault(require('./CallTracker'));

var _SpyStrategy = _interopRequireDefault(require('./SpyStrategy'));

var _createSpy = _interopRequireDefault(require('./createSpy'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj***REMOVED***;
***REMOVED***

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    ***REMOVED***);
  ***REMOVED*** else {
    obj[key] = value;
  ***REMOVED***
  return obj;
***REMOVED***

const formatErrorMsg = (domain, usage) => {
  const usageDefinition = usage ? '\nUsage: ' + usage : '';
  return msg => domain + ' : ' + msg + usageDefinition;
***REMOVED***;

function isSpy(putativeSpy) {
  if (!putativeSpy) {
    return false;
  ***REMOVED***

  return (
    putativeSpy.and instanceof _SpyStrategy.default &&
    putativeSpy.calls instanceof _CallTracker.default
  );
***REMOVED***

const getErrorMsg = formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');

class SpyRegistry {
  constructor({currentSpies = () => []***REMOVED*** = {***REMOVED***) {
    _defineProperty(this, 'allowRespy', void 0);

    _defineProperty(this, 'spyOn', void 0);

    _defineProperty(this, 'clearSpies', void 0);

    _defineProperty(this, 'respy', void 0);

    _defineProperty(this, '_spyOnProperty', void 0);

    this.allowRespy = function (allow) {
      this.respy = allow;
    ***REMOVED***;

    this.spyOn = (obj, methodName, accessType) => {
      if (accessType) {
        return this._spyOnProperty(obj, methodName, accessType);
      ***REMOVED***

      if (obj === void 0) {
        throw new Error(
          getErrorMsg(
            'could not find an object to spy upon for ' + methodName + '()'
          )
        );
      ***REMOVED***

      if (methodName === void 0) {
        throw new Error(getErrorMsg('No method name supplied'));
      ***REMOVED***

      if (obj[methodName] === void 0) {
        throw new Error(getErrorMsg(methodName + '() method does not exist'));
      ***REMOVED***

      if (obj[methodName] && isSpy(obj[methodName])) {
        if (this.respy) {
          return obj[methodName];
        ***REMOVED*** else {
          throw new Error(
            getErrorMsg(methodName + ' has already been spied upon')
          );
        ***REMOVED***
      ***REMOVED***

      let descriptor;

      try {
        descriptor = Object.getOwnPropertyDescriptor(obj, methodName);
      ***REMOVED*** catch {
        // IE 8 doesn't support `definePropery` on non-DOM nodes
      ***REMOVED***

      if (descriptor && !(descriptor.writable || descriptor.set)) {
        throw new Error(
          getErrorMsg(methodName + ' is not declared writable or has no setter')
        );
      ***REMOVED***

      const originalMethod = obj[methodName];
      const spiedMethod = (0, _createSpy.default)(methodName, originalMethod);
      let restoreStrategy;

      if (Object.prototype.hasOwnProperty.call(obj, methodName)) {
        restoreStrategy = function () {
          obj[methodName] = originalMethod;
        ***REMOVED***;
      ***REMOVED*** else {
        restoreStrategy = function () {
          if (!delete obj[methodName]) {
            obj[methodName] = originalMethod;
          ***REMOVED***
        ***REMOVED***;
      ***REMOVED***

      currentSpies().push({
        restoreObjectToOriginalState: restoreStrategy
      ***REMOVED***);
      obj[methodName] = spiedMethod;
      return spiedMethod;
    ***REMOVED***;

    this._spyOnProperty = function (obj, propertyName, accessType = 'get') {
      if (!obj) {
        throw new Error(
          getErrorMsg(
            'could not find an object to spy upon for ' + propertyName
          )
        );
      ***REMOVED***

      if (!propertyName) {
        throw new Error(getErrorMsg('No property name supplied'));
      ***REMOVED***

      let descriptor;

      try {
        descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
      ***REMOVED*** catch {
        // IE 8 doesn't support `definePropery` on non-DOM nodes
      ***REMOVED***

      if (!descriptor) {
        throw new Error(getErrorMsg(propertyName + ' property does not exist'));
      ***REMOVED***

      if (!descriptor.configurable) {
        throw new Error(
          getErrorMsg(propertyName + ' is not declared configurable')
        );
      ***REMOVED***

      if (!descriptor[accessType]) {
        throw new Error(
          getErrorMsg(
            'Property ' +
              propertyName +
              ' does not have access type ' +
              accessType
          )
        );
      ***REMOVED***

      if (obj[propertyName] && isSpy(obj[propertyName])) {
        if (this.respy) {
          return obj[propertyName];
        ***REMOVED*** else {
          throw new Error(
            getErrorMsg(propertyName + ' has already been spied upon')
          );
        ***REMOVED***
      ***REMOVED***

      const originalDescriptor = descriptor;
      const spiedProperty = (0, _createSpy.default)(
        propertyName,
        descriptor[accessType]
      );
      let restoreStrategy;

      if (Object.prototype.hasOwnProperty.call(obj, propertyName)) {
        restoreStrategy = function () {
          Object.defineProperty(obj, propertyName, originalDescriptor);
        ***REMOVED***;
      ***REMOVED*** else {
        restoreStrategy = function () {
          delete obj[propertyName];
        ***REMOVED***;
      ***REMOVED***

      currentSpies().push({
        restoreObjectToOriginalState: restoreStrategy
      ***REMOVED***);
      const spiedDescriptor = {...descriptor, [accessType]: spiedProperty***REMOVED***;
      Object.defineProperty(obj, propertyName, spiedDescriptor);
      return spiedProperty;
    ***REMOVED***;

    this.clearSpies = function () {
      const spies = currentSpies();

      for (let i = spies.length - 1; i >= 0; i--) {
        const spyEntry = spies[i];
        spyEntry.restoreObjectToOriginalState();
      ***REMOVED***
    ***REMOVED***;
  ***REMOVED***
***REMOVED***

exports.default = SpyRegistry;
