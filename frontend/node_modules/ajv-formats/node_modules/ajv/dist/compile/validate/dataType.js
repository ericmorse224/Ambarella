"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
const rules_1 = require("../rules");
const applicability_1 = require("./applicability");
const errors_1 = require("../errors");
const codegen_1 = require("../codegen");
const util_1 = require("../util");
var DataType;
(function (DataType) {
    DataType[DataType["Correct"] = 0] = "Correct";
    DataType[DataType["Wrong"] = 1] = "Wrong";
***REMOVED***)(DataType || (exports.DataType = DataType = {***REMOVED***));
function getSchemaTypes(schema) {
    const types = getJSONTypes(schema.type);
    const hasNull = types.includes("null");
    if (hasNull) {
        if (schema.nullable === false)
            throw new Error("type: null contradicts nullable: false");
    ***REMOVED***
    else {
        if (!types.length && schema.nullable !== undefined) {
            throw new Error('"nullable" cannot be used without "type"');
        ***REMOVED***
        if (schema.nullable === true)
            types.push("null");
    ***REMOVED***
    return types;
***REMOVED***
exports.getSchemaTypes = getSchemaTypes;
// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
function getJSONTypes(ts) {
    const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
    if (types.every(rules_1.isJSONType))
        return types;
    throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
***REMOVED***
exports.getJSONTypes = getJSONTypes;
function coerceAndCheckDataType(it, types) {
    const { gen, data, opts ***REMOVED*** = it;
    const coerceTo = coerceToTypes(types, opts.coerceTypes);
    const checkTypes = types.length > 0 &&
        !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
    if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
            if (coerceTo.length)
                coerceData(it, types, coerceTo);
            else
                reportTypeError(it);
        ***REMOVED***);
    ***REMOVED***
    return checkTypes;
***REMOVED***
exports.coerceAndCheckDataType = coerceAndCheckDataType;
const COERCIBLE = new Set(["string", "number", "integer", "boolean", "null"]);
function coerceToTypes(types, coerceTypes) {
    return coerceTypes
        ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
        : [];
***REMOVED***
function coerceData(it, types, coerceTo) {
    const { gen, data, opts ***REMOVED*** = it;
    const dataType = gen.let("dataType", (0, codegen_1._) `typeof ${data***REMOVED***`);
    const coerced = gen.let("coerced", (0, codegen_1._) `undefined`);
    if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._) `${dataType***REMOVED*** == 'object' && Array.isArray(${data***REMOVED***) && ${data***REMOVED***.length == 1`, () => gen
            .assign(data, (0, codegen_1._) `${data***REMOVED***[0]`)
            .assign(dataType, (0, codegen_1._) `typeof ${data***REMOVED***`)
            .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
    ***REMOVED***
    gen.if((0, codegen_1._) `${coerced***REMOVED*** !== undefined`);
    for (const t of coerceTo) {
        if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
            coerceSpecificType(t);
        ***REMOVED***
    ***REMOVED***
    gen.else();
    reportTypeError(it);
    gen.endIf();
    gen.if((0, codegen_1._) `${coerced***REMOVED*** !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
    ***REMOVED***);
    function coerceSpecificType(t) {
        switch (t) {
            case "string":
                gen
                    .elseIf((0, codegen_1._) `${dataType***REMOVED*** == "number" || ${dataType***REMOVED*** == "boolean"`)
                    .assign(coerced, (0, codegen_1._) `"" + ${data***REMOVED***`)
                    .elseIf((0, codegen_1._) `${data***REMOVED*** === null`)
                    .assign(coerced, (0, codegen_1._) `""`);
                return;
            case "number":
                gen
                    .elseIf((0, codegen_1._) `${dataType***REMOVED*** == "boolean" || ${data***REMOVED*** === null
              || (${dataType***REMOVED*** == "string" && ${data***REMOVED*** && ${data***REMOVED*** == +${data***REMOVED***)`)
                    .assign(coerced, (0, codegen_1._) `+${data***REMOVED***`);
                return;
            case "integer":
                gen
                    .elseIf((0, codegen_1._) `${dataType***REMOVED*** === "boolean" || ${data***REMOVED*** === null
              || (${dataType***REMOVED*** === "string" && ${data***REMOVED*** && ${data***REMOVED*** == +${data***REMOVED*** && !(${data***REMOVED*** % 1))`)
                    .assign(coerced, (0, codegen_1._) `+${data***REMOVED***`);
                return;
            case "boolean":
                gen
                    .elseIf((0, codegen_1._) `${data***REMOVED*** === "false" || ${data***REMOVED*** === 0 || ${data***REMOVED*** === null`)
                    .assign(coerced, false)
                    .elseIf((0, codegen_1._) `${data***REMOVED*** === "true" || ${data***REMOVED*** === 1`)
                    .assign(coerced, true);
                return;
            case "null":
                gen.elseIf((0, codegen_1._) `${data***REMOVED*** === "" || ${data***REMOVED*** === 0 || ${data***REMOVED*** === false`);
                gen.assign(coerced, null);
                return;
            case "array":
                gen
                    .elseIf((0, codegen_1._) `${dataType***REMOVED*** === "string" || ${dataType***REMOVED*** === "number"
              || ${dataType***REMOVED*** === "boolean" || ${data***REMOVED*** === null`)
                    .assign(coerced, (0, codegen_1._) `[${data***REMOVED***]`);
        ***REMOVED***
    ***REMOVED***
***REMOVED***
function assignParentData({ gen, parentData, parentDataProperty ***REMOVED***, expr) {
    // TODO use gen.property
    gen.if((0, codegen_1._) `${parentData***REMOVED*** !== undefined`, () => gen.assign((0, codegen_1._) `${parentData***REMOVED***[${parentDataProperty***REMOVED***]`, expr));
***REMOVED***
function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
    const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
    let cond;
    switch (dataType) {
        case "null":
            return (0, codegen_1._) `${data***REMOVED*** ${EQ***REMOVED*** null`;
        case "array":
            cond = (0, codegen_1._) `Array.isArray(${data***REMOVED***)`;
            break;
        case "object":
            cond = (0, codegen_1._) `${data***REMOVED*** && typeof ${data***REMOVED*** == "object" && !Array.isArray(${data***REMOVED***)`;
            break;
        case "integer":
            cond = numCond((0, codegen_1._) `!(${data***REMOVED*** % 1) && !isNaN(${data***REMOVED***)`);
            break;
        case "number":
            cond = numCond();
            break;
        default:
            return (0, codegen_1._) `typeof ${data***REMOVED*** ${EQ***REMOVED*** ${dataType***REMOVED***`;
    ***REMOVED***
    return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
    function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._) `typeof ${data***REMOVED*** == "number"`, _cond, strictNums ? (0, codegen_1._) `isFinite(${data***REMOVED***)` : codegen_1.nil);
    ***REMOVED***
***REMOVED***
exports.checkDataType = checkDataType;
function checkDataTypes(dataTypes, data, strictNums, correct) {
    if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
    ***REMOVED***
    let cond;
    const types = (0, util_1.toHash)(dataTypes);
    if (types.array && types.object) {
        const notObj = (0, codegen_1._) `typeof ${data***REMOVED*** != "object"`;
        cond = types.null ? notObj : (0, codegen_1._) `!${data***REMOVED*** || ${notObj***REMOVED***`;
        delete types.null;
        delete types.array;
        delete types.object;
    ***REMOVED***
    else {
        cond = codegen_1.nil;
    ***REMOVED***
    if (types.number)
        delete types.integer;
    for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
    return cond;
***REMOVED***
exports.checkDataTypes = checkDataTypes;
const typeError = {
    message: ({ schema ***REMOVED***) => `must be ${schema***REMOVED***`,
    params: ({ schema, schemaValue ***REMOVED***) => typeof schema == "string" ? (0, codegen_1._) `{type: ${schema***REMOVED******REMOVED***` : (0, codegen_1._) `{type: ${schemaValue***REMOVED******REMOVED***`,
***REMOVED***;
function reportTypeError(it) {
    const cxt = getTypeErrorContext(it);
    (0, errors_1.reportError)(cxt, typeError);
***REMOVED***
exports.reportTypeError = reportTypeError;
function getTypeErrorContext(it) {
    const { gen, data, schema ***REMOVED*** = it;
    const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
    return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {***REMOVED***,
        it,
    ***REMOVED***;
***REMOVED***
//# sourceMappingURL=dataType.js.map