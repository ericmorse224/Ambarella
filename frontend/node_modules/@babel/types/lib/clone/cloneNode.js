"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.default = cloneNode;
var _index = require("../definitions/index.js");
var _index2 = require("../validators/generated/index.js");
const {
  hasOwn
***REMOVED*** = {
  hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
***REMOVED***;
function cloneIfNode(obj, deep, withoutLoc, commentsCache) {
  if (obj && typeof obj.type === "string") {
    return cloneNodeInternal(obj, deep, withoutLoc, commentsCache);
  ***REMOVED***
  return obj;
***REMOVED***
function cloneIfNodeOrArray(obj, deep, withoutLoc, commentsCache) {
  if (Array.isArray(obj)) {
    return obj.map(node => cloneIfNode(node, deep, withoutLoc, commentsCache));
  ***REMOVED***
  return cloneIfNode(obj, deep, withoutLoc, commentsCache);
***REMOVED***
function cloneNode(node, deep = true, withoutLoc = false) {
  return cloneNodeInternal(node, deep, withoutLoc, new Map());
***REMOVED***
function cloneNodeInternal(node, deep = true, withoutLoc = false, commentsCache) {
  if (!node) return node;
  const {
    type
  ***REMOVED*** = node;
  const newNode = {
    type: node.type
  ***REMOVED***;
  if ((0, _index2.isIdentifier)(node)) {
    newNode.name = node.name;
    if (hasOwn(node, "optional") && typeof node.optional === "boolean") {
      newNode.optional = node.optional;
    ***REMOVED***
    if (hasOwn(node, "typeAnnotation")) {
      newNode.typeAnnotation = deep ? cloneIfNodeOrArray(node.typeAnnotation, true, withoutLoc, commentsCache) : node.typeAnnotation;
    ***REMOVED***
    if (hasOwn(node, "decorators")) {
      newNode.decorators = deep ? cloneIfNodeOrArray(node.decorators, true, withoutLoc, commentsCache) : node.decorators;
    ***REMOVED***
  ***REMOVED*** else if (!hasOwn(_index.NODE_FIELDS, type)) {
    throw new Error(`Unknown node type: "${type***REMOVED***"`);
  ***REMOVED*** else {
    for (const field of Object.keys(_index.NODE_FIELDS[type])) {
      if (hasOwn(node, field)) {
        if (deep) {
          newNode[field] = (0, _index2.isFile)(node) && field === "comments" ? maybeCloneComments(node.comments, deep, withoutLoc, commentsCache) : cloneIfNodeOrArray(node[field], true, withoutLoc, commentsCache);
        ***REMOVED*** else {
          newNode[field] = node[field];
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  if (hasOwn(node, "loc")) {
    if (withoutLoc) {
      newNode.loc = null;
    ***REMOVED*** else {
      newNode.loc = node.loc;
    ***REMOVED***
  ***REMOVED***
  if (hasOwn(node, "leadingComments")) {
    newNode.leadingComments = maybeCloneComments(node.leadingComments, deep, withoutLoc, commentsCache);
  ***REMOVED***
  if (hasOwn(node, "innerComments")) {
    newNode.innerComments = maybeCloneComments(node.innerComments, deep, withoutLoc, commentsCache);
  ***REMOVED***
  if (hasOwn(node, "trailingComments")) {
    newNode.trailingComments = maybeCloneComments(node.trailingComments, deep, withoutLoc, commentsCache);
  ***REMOVED***
  if (hasOwn(node, "extra")) {
    newNode.extra = Object.assign({***REMOVED***, node.extra);
  ***REMOVED***
  return newNode;
***REMOVED***
function maybeCloneComments(comments, deep, withoutLoc, commentsCache) {
  if (!comments || !deep) {
    return comments;
  ***REMOVED***
  return comments.map(comment => {
    const cache = commentsCache.get(comment);
    if (cache) return cache;
    const {
      type,
      value,
      loc
    ***REMOVED*** = comment;
    const ret = {
      type,
      value,
      loc
    ***REMOVED***;
    if (withoutLoc) {
      ret.loc = null;
    ***REMOVED***
    commentsCache.set(comment, ret);
    return ret;
  ***REMOVED***);
***REMOVED***

//# sourceMappingURL=cloneNode.js.map
