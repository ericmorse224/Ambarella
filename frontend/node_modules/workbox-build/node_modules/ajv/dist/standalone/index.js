"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const scope_1 = require("../compile/codegen/scope");
const code_1 = require("../compile/codegen/code");
function standaloneCode(ajv, refsOrFunc) {
    if (!ajv.opts.code.source) {
        throw new Error("moduleCode: ajv instance must have code.source option");
    ***REMOVED***
    const { _n ***REMOVED*** = ajv.scope.opts;
    return typeof refsOrFunc == "function"
        ? funcExportCode(refsOrFunc.source)
        : refsOrFunc !== undefined
            ? multiExportsCode(refsOrFunc, getValidate)
            : multiExportsCode(ajv.schemas, (sch) => sch.meta ? undefined : ajv.compile(sch.schema));
    function getValidate(id) {
        const v = ajv.getSchema(id);
        if (!v)
            throw new Error(`moduleCode: no schema with id ${id***REMOVED***`);
        return v;
    ***REMOVED***
    function funcExportCode(source) {
        const usedValues = {***REMOVED***;
        const n = source === null || source === void 0 ? void 0 : source.validateName;
        const vCode = validateCode(usedValues, source);
        if (ajv.opts.code.esm) {
            // Always do named export as `validate` rather than the variable `n` which is `validateXX` for known export value
            return `"use strict";${_n***REMOVED***export const validate = ${n***REMOVED***;${_n***REMOVED***export default ${n***REMOVED***;${_n***REMOVED***${vCode***REMOVED***`;
        ***REMOVED***
        return `"use strict";${_n***REMOVED***module.exports = ${n***REMOVED***;${_n***REMOVED***module.exports.default = ${n***REMOVED***;${_n***REMOVED***${vCode***REMOVED***`;
    ***REMOVED***
    function multiExportsCode(schemas, getValidateFunc) {
        var _a;
        const usedValues = {***REMOVED***;
        let code = (0, code_1._) `"use strict";`;
        for (const name in schemas) {
            const v = getValidateFunc(schemas[name]);
            if (v) {
                const vCode = validateCode(usedValues, v.source);
                const exportSyntax = ajv.opts.code.esm
                    ? (0, code_1._) `export const ${(0, code_1.getEsmExportName)(name)***REMOVED***`
                    : (0, code_1._) `exports${(0, code_1.getProperty)(name)***REMOVED***`;
                code = (0, code_1._) `${code***REMOVED***${_n***REMOVED***${exportSyntax***REMOVED*** = ${(_a = v.source) === null || _a === void 0 ? void 0 : _a.validateName***REMOVED***;${_n***REMOVED***${vCode***REMOVED***`;
            ***REMOVED***
        ***REMOVED***
        return `${code***REMOVED***`;
    ***REMOVED***
    function validateCode(usedValues, s) {
        if (!s)
            throw new Error('moduleCode: function does not have "source" property');
        if (usedState(s.validateName) === scope_1.UsedValueState.Completed)
            return code_1.nil;
        setUsedState(s.validateName, scope_1.UsedValueState.Started);
        const scopeCode = ajv.scope.scopeCode(s.scopeValues, usedValues, refValidateCode);
        const code = new code_1._Code(`${scopeCode***REMOVED***${_n***REMOVED***${s.validateCode***REMOVED***`);
        return s.evaluated ? (0, code_1._) `${code***REMOVED***${s.validateName***REMOVED***.evaluated = ${s.evaluated***REMOVED***;${_n***REMOVED***` : code;
        function refValidateCode(n) {
            var _a;
            const vRef = (_a = n.value) === null || _a === void 0 ? void 0 : _a.ref;
            if (n.prefix === "validate" && typeof vRef == "function") {
                const v = vRef;
                return validateCode(usedValues, v.source);
            ***REMOVED***
            else if ((n.prefix === "root" || n.prefix === "wrapper") && typeof vRef == "object") {
                const { validate, validateName ***REMOVED*** = vRef;
                if (!validateName)
                    throw new Error("ajv internal error");
                const def = ajv.opts.code.es5 ? scope_1.varKinds.var : scope_1.varKinds.const;
                const wrapper = (0, code_1._) `${def***REMOVED*** ${n***REMOVED*** = {validate: ${validateName***REMOVED******REMOVED***;`;
                if (usedState(validateName) === scope_1.UsedValueState.Started)
                    return wrapper;
                const vCode = validateCode(usedValues, validate === null || validate === void 0 ? void 0 : validate.source);
                return (0, code_1._) `${wrapper***REMOVED***${_n***REMOVED***${vCode***REMOVED***`;
            ***REMOVED***
            return undefined;
        ***REMOVED***
        function usedState(name) {
            var _a;
            return (_a = usedValues[name.prefix]) === null || _a === void 0 ? void 0 : _a.get(name);
        ***REMOVED***
        function setUsedState(name, state) {
            const { prefix ***REMOVED*** = name;
            const names = (usedValues[prefix] = usedValues[prefix] || new Map());
            names.set(name, state);
        ***REMOVED***
    ***REMOVED***
***REMOVED***
module.exports = exports = standaloneCode;
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
exports.default = standaloneCode;
//# sourceMappingURL=index.js.map