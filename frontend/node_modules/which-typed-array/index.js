'use strict';

var forEach = require('for-each');
var availableTypedArrays = require('available-typed-arrays');
var callBind = require('call-bind');
var callBound = require('call-bound');
var gOPD = require('gopd');
var getProto = require('get-proto');

var $toString = callBound('Object.prototype.toString');
var hasToStringTag = require('has-tostringtag/shams')();

var g = typeof globalThis === 'undefined' ? global : globalThis;
var typedArrays = availableTypedArrays();

var $slice = callBound('String.prototype.slice');

/** @type {<T = unknown>(array: readonly T[], value: unknown) => number***REMOVED*** */
var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
	for (var i = 0; i < array.length; i += 1) {
		if (array[i] === value) {
			return i;
		***REMOVED***
	***REMOVED***
	return -1;
***REMOVED***;

/** @typedef {import('./types').Getter***REMOVED*** Getter */
/** @type {import('./types').Cache***REMOVED*** */
var cache = { __proto__: null ***REMOVED***;
if (hasToStringTag && gOPD && getProto) {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		if (Symbol.toStringTag in arr && getProto) {
			var proto = getProto(arr);
			// @ts-expect-error TS won't narrow inside a closure
			var descriptor = gOPD(proto, Symbol.toStringTag);
			if (!descriptor && proto) {
				var superProto = getProto(proto);
				// @ts-expect-error TS won't narrow inside a closure
				descriptor = gOPD(superProto, Symbol.toStringTag);
			***REMOVED***
			// @ts-expect-error TODO: fix
			cache['$' + typedArray] = callBind(descriptor.get);
		***REMOVED***
	***REMOVED***);
***REMOVED*** else {
	forEach(typedArrays, function (typedArray) {
		var arr = new g[typedArray]();
		var fn = arr.slice || arr.set;
		if (fn) {
			cache[
				/** @type {`$${import('.').TypedArrayName***REMOVED***`***REMOVED*** */ ('$' + typedArray)
			] = /** @type {import('./types').BoundSlice | import('./types').BoundSet***REMOVED*** */ (
				// @ts-expect-error TODO FIXME
				callBind(fn)
			);
		***REMOVED***
	***REMOVED***);
***REMOVED***

/** @type {(value: object) => false | import('.').TypedArrayName***REMOVED*** */
var tryTypedArrays = function tryAllTypedArrays(value) {
	/** @type {ReturnType<typeof tryAllTypedArrays>***REMOVED*** */ var found = false;
	forEach(
		/** @type {Record<`\$${import('.').TypedArrayName***REMOVED***`, Getter>***REMOVED*** */ (cache),
		/** @type {(getter: Getter, name: `\$${import('.').TypedArrayName***REMOVED***`) => void***REMOVED*** */
		function (getter, typedArray) {
			if (!found) {
				try {
					// @ts-expect-error a throw is fine here
					if ('$' + getter(value) === typedArray) {
						found = /** @type {import('.').TypedArrayName***REMOVED*** */ ($slice(typedArray, 1));
					***REMOVED***
				***REMOVED*** catch (e) { /**/ ***REMOVED***
			***REMOVED***
		***REMOVED***
	);
	return found;
***REMOVED***;

/** @type {(value: object) => false | import('.').TypedArrayName***REMOVED*** */
var trySlices = function tryAllSlices(value) {
	/** @type {ReturnType<typeof tryAllSlices>***REMOVED*** */ var found = false;
	forEach(
		/** @type {Record<`\$${import('.').TypedArrayName***REMOVED***`, Getter>***REMOVED*** */(cache),
		/** @type {(getter: Getter, name: `\$${import('.').TypedArrayName***REMOVED***`) => void***REMOVED*** */ function (getter, name) {
			if (!found) {
				try {
					// @ts-expect-error a throw is fine here
					getter(value);
					found = /** @type {import('.').TypedArrayName***REMOVED*** */ ($slice(name, 1));
				***REMOVED*** catch (e) { /**/ ***REMOVED***
			***REMOVED***
		***REMOVED***
	);
	return found;
***REMOVED***;

/** @type {import('.')***REMOVED*** */
module.exports = function whichTypedArray(value) {
	if (!value || typeof value !== 'object') { return false; ***REMOVED***
	if (!hasToStringTag) {
		/** @type {string***REMOVED*** */
		var tag = $slice($toString(value), 8, -1);
		if ($indexOf(typedArrays, tag) > -1) {
			return tag;
		***REMOVED***
		if (tag !== 'Object') {
			return false;
		***REMOVED***
		// node < 0.6 hits here on real Typed Arrays
		return trySlices(value);
	***REMOVED***
	if (!gOPD) { return null; ***REMOVED*** // unknown engine
	return tryTypedArrays(value);
***REMOVED***;
