import type {CodeKeywordDefinition***REMOVED*** from "../../types"
import type {KeywordCxt***REMOVED*** from "../../compile/validate"
import {allSchemaProperties, usePattern***REMOVED*** from "../code"
import {_, not, Name***REMOVED*** from "../../compile/codegen"
import {alwaysValidSchema, checkStrictMode***REMOVED*** from "../../compile/util"
import {evaluatedPropsToName, Type***REMOVED*** from "../../compile/util"
import {AnySchema***REMOVED*** from "../../types"

const def: CodeKeywordDefinition = {
  keyword: "patternProperties",
  type: "object",
  schemaType: "object",
  code(cxt: KeywordCxt) {
    const {gen, schema, data, parentSchema, it***REMOVED*** = cxt
    const {opts***REMOVED*** = it
    const patterns = allSchemaProperties(schema)
    const alwaysValidPatterns = patterns.filter((p) =>
      alwaysValidSchema(it, schema[p] as AnySchema)
    )

    if (
      patterns.length === 0 ||
      (alwaysValidPatterns.length === patterns.length &&
        (!it.opts.unevaluated || it.props === true))
    ) {
      return
    ***REMOVED***

    const checkProperties =
      opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties
    const valid = gen.name("valid")
    if (it.props !== true && !(it.props instanceof Name)) {
      it.props = evaluatedPropsToName(gen, it.props)
    ***REMOVED***
    const {props***REMOVED*** = it
    validatePatternProperties()

    function validatePatternProperties(): void {
      for (const pat of patterns) {
        if (checkProperties) checkMatchingProperties(pat)
        if (it.allErrors) {
          validateProperties(pat)
        ***REMOVED*** else {
          gen.var(valid, true) // TODO var
          validateProperties(pat)
          gen.if(valid)
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    function checkMatchingProperties(pat: string): void {
      for (const prop in checkProperties) {
        if (new RegExp(pat).test(prop)) {
          checkStrictMode(
            it,
            `property ${prop***REMOVED*** matches pattern ${pat***REMOVED*** (use allowMatchingProperties)`
          )
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    function validateProperties(pat: string): void {
      gen.forIn("key", data, (key) => {
        gen.if(_`${usePattern(cxt, pat)***REMOVED***.test(${key***REMOVED***)`, () => {
          const alwaysValid = alwaysValidPatterns.includes(pat)
          if (!alwaysValid) {
            cxt.subschema(
              {
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: Type.Str,
              ***REMOVED***,
              valid
            )
          ***REMOVED***

          if (it.opts.unevaluated && props !== true) {
            gen.assign(_`${props***REMOVED***[${key***REMOVED***]`, true)
          ***REMOVED*** else if (!alwaysValid && !it.allErrors) {
            // can short-circuit if `unevaluatedProperties` is not supported (opts.next === false)
            // or if all properties were evaluated (props === true)
            gen.if(not(valid), () => gen.break())
          ***REMOVED***
        ***REMOVED***)
      ***REMOVED***)
    ***REMOVED***
  ***REMOVED***,
***REMOVED***

export default def
