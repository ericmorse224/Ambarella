/**
 * @fileoverview Restrict usage of specified node imports.
 * @author Guy Ellis
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const ignore = require("ignore");

const arrayOfStringsOrObjects = {
	type: "array",
	items: {
		anyOf: [
			{ type: "string" ***REMOVED***,
			{
				type: "object",
				properties: {
					name: { type: "string" ***REMOVED***,
					message: {
						type: "string",
						minLength: 1,
					***REMOVED***,
					importNames: {
						type: "array",
						items: {
							type: "string",
						***REMOVED***,
					***REMOVED***,
					allowImportNames: {
						type: "array",
						items: {
							type: "string",
						***REMOVED***,
					***REMOVED***,
				***REMOVED***,
				additionalProperties: false,
				required: ["name"],
				not: { required: ["importNames", "allowImportNames"] ***REMOVED***,
			***REMOVED***,
		],
	***REMOVED***,
	uniqueItems: true,
***REMOVED***;

const arrayOfStringsOrObjectPatterns = {
	anyOf: [
		{
			type: "array",
			items: {
				type: "string",
			***REMOVED***,
			uniqueItems: true,
		***REMOVED***,
		{
			type: "array",
			items: {
				type: "object",
				properties: {
					importNames: {
						type: "array",
						items: {
							type: "string",
						***REMOVED***,
						minItems: 1,
						uniqueItems: true,
					***REMOVED***,
					allowImportNames: {
						type: "array",
						items: {
							type: "string",
						***REMOVED***,
						minItems: 1,
						uniqueItems: true,
					***REMOVED***,
					group: {
						type: "array",
						items: {
							type: "string",
						***REMOVED***,
						minItems: 1,
						uniqueItems: true,
					***REMOVED***,
					regex: {
						type: "string",
					***REMOVED***,
					importNamePattern: {
						type: "string",
					***REMOVED***,
					allowImportNamePattern: {
						type: "string",
					***REMOVED***,
					message: {
						type: "string",
						minLength: 1,
					***REMOVED***,
					caseSensitive: {
						type: "boolean",
					***REMOVED***,
				***REMOVED***,
				additionalProperties: false,
				not: {
					anyOf: [
						{ required: ["importNames", "allowImportNames"] ***REMOVED***,
						{
							required: [
								"importNamePattern",
								"allowImportNamePattern",
							],
						***REMOVED***,
						{ required: ["importNames", "allowImportNamePattern"] ***REMOVED***,
						{ required: ["importNamePattern", "allowImportNames"] ***REMOVED***,
						{
							required: [
								"allowImportNames",
								"allowImportNamePattern",
							],
						***REMOVED***,
					],
				***REMOVED***,
				oneOf: [{ required: ["group"] ***REMOVED***, { required: ["regex"] ***REMOVED***],
			***REMOVED***,
			uniqueItems: true,
		***REMOVED***,
	],
***REMOVED***;

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "suggestion",

		docs: {
			description: "Disallow specified modules when loaded by `import`",
			recommended: false,
			url: "https://eslint.org/docs/latest/rules/no-restricted-imports",
		***REMOVED***,

		messages: {
			path: "'{{importSource***REMOVED******REMOVED***' import is restricted from being used.",
			pathWithCustomMessage:
				// eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
				"'{{importSource***REMOVED******REMOVED***' import is restricted from being used. {{customMessage***REMOVED******REMOVED***",

			patterns:
				"'{{importSource***REMOVED******REMOVED***' import is restricted from being used by a pattern.",
			patternWithCustomMessage:
				// eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
				"'{{importSource***REMOVED******REMOVED***' import is restricted from being used by a pattern. {{customMessage***REMOVED******REMOVED***",

			patternAndImportName:
				"'{{importName***REMOVED******REMOVED***' import from '{{importSource***REMOVED******REMOVED***' is restricted from being used by a pattern.",
			patternAndImportNameWithCustomMessage:
				// eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
				"'{{importName***REMOVED******REMOVED***' import from '{{importSource***REMOVED******REMOVED***' is restricted from being used by a pattern. {{customMessage***REMOVED******REMOVED***",

			patternAndEverything:
				"* import is invalid because '{{importNames***REMOVED******REMOVED***' from '{{importSource***REMOVED******REMOVED***' is restricted from being used by a pattern.",

			patternAndEverythingWithRegexImportName:
				"* import is invalid because import name matching '{{importNames***REMOVED******REMOVED***' pattern from '{{importSource***REMOVED******REMOVED***' is restricted from being used.",
			patternAndEverythingWithCustomMessage:
				// eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
				"* import is invalid because '{{importNames***REMOVED******REMOVED***' from '{{importSource***REMOVED******REMOVED***' is restricted from being used by a pattern. {{customMessage***REMOVED******REMOVED***",
			patternAndEverythingWithRegexImportNameAndCustomMessage:
				// eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
				"* import is invalid because import name matching '{{importNames***REMOVED******REMOVED***' pattern from '{{importSource***REMOVED******REMOVED***' is restricted from being used. {{customMessage***REMOVED******REMOVED***",

			everything:
				"* import is invalid because '{{importNames***REMOVED******REMOVED***' from '{{importSource***REMOVED******REMOVED***' is restricted.",
			everythingWithCustomMessage:
				// eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
				"* import is invalid because '{{importNames***REMOVED******REMOVED***' from '{{importSource***REMOVED******REMOVED***' is restricted. {{customMessage***REMOVED******REMOVED***",

			importName:
				"'{{importName***REMOVED******REMOVED***' import from '{{importSource***REMOVED******REMOVED***' is restricted.",
			importNameWithCustomMessage:
				// eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
				"'{{importName***REMOVED******REMOVED***' import from '{{importSource***REMOVED******REMOVED***' is restricted. {{customMessage***REMOVED******REMOVED***",

			allowedImportName:
				"'{{importName***REMOVED******REMOVED***' import from '{{importSource***REMOVED******REMOVED***' is restricted because only '{{allowedImportNames***REMOVED******REMOVED***' import(s) is/are allowed.",
			allowedImportNameWithCustomMessage:
				// eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
				"'{{importName***REMOVED******REMOVED***' import from '{{importSource***REMOVED******REMOVED***' is restricted because only '{{allowedImportNames***REMOVED******REMOVED***' import(s) is/are allowed. {{customMessage***REMOVED******REMOVED***",

			everythingWithAllowImportNames:
				"* import is invalid because only '{{allowedImportNames***REMOVED******REMOVED***' from '{{importSource***REMOVED******REMOVED***' is/are allowed.",
			everythingWithAllowImportNamesAndCustomMessage:
				// eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
				"* import is invalid because only '{{allowedImportNames***REMOVED******REMOVED***' from '{{importSource***REMOVED******REMOVED***' is/are allowed. {{customMessage***REMOVED******REMOVED***",

			allowedImportNamePattern:
				"'{{importName***REMOVED******REMOVED***' import from '{{importSource***REMOVED******REMOVED***' is restricted because only imports that match the pattern '{{allowedImportNamePattern***REMOVED******REMOVED***' are allowed from '{{importSource***REMOVED******REMOVED***'.",
			allowedImportNamePatternWithCustomMessage:
				// eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
				"'{{importName***REMOVED******REMOVED***' import from '{{importSource***REMOVED******REMOVED***' is restricted because only imports that match the pattern '{{allowedImportNamePattern***REMOVED******REMOVED***' are allowed from '{{importSource***REMOVED******REMOVED***'. {{customMessage***REMOVED******REMOVED***",

			everythingWithAllowedImportNamePattern:
				"* import is invalid because only imports that match the pattern '{{allowedImportNamePattern***REMOVED******REMOVED***' from '{{importSource***REMOVED******REMOVED***' are allowed.",
			everythingWithAllowedImportNamePatternWithCustomMessage:
				// eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
				"* import is invalid because only imports that match the pattern '{{allowedImportNamePattern***REMOVED******REMOVED***' from '{{importSource***REMOVED******REMOVED***' are allowed. {{customMessage***REMOVED******REMOVED***",
		***REMOVED***,

		schema: {
			anyOf: [
				arrayOfStringsOrObjects,
				{
					type: "array",
					items: [
						{
							type: "object",
							properties: {
								paths: arrayOfStringsOrObjects,
								patterns: arrayOfStringsOrObjectPatterns,
							***REMOVED***,
							additionalProperties: false,
						***REMOVED***,
					],
					additionalItems: false,
				***REMOVED***,
			],
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const sourceCode = context.sourceCode;
		const options = Array.isArray(context.options) ? context.options : [];
		const isPathAndPatternsObject =
			typeof options[0] === "object" &&
			(Object.hasOwn(options[0], "paths") ||
				Object.hasOwn(options[0], "patterns"));

		const restrictedPaths =
			(isPathAndPatternsObject ? options[0].paths : context.options) ||
			[];
		const groupedRestrictedPaths = restrictedPaths.reduce(
			(memo, importSource) => {
				const path =
					typeof importSource === "string"
						? importSource
						: importSource.name;

				if (!memo[path]) {
					memo[path] = [];
				***REMOVED***

				if (typeof importSource === "string") {
					memo[path].push({***REMOVED***);
				***REMOVED*** else {
					memo[path].push({
						message: importSource.message,
						importNames: importSource.importNames,
						allowImportNames: importSource.allowImportNames,
					***REMOVED***);
				***REMOVED***
				return memo;
			***REMOVED***,
			Object.create(null),
		);

		// Handle patterns too, either as strings or groups
		let restrictedPatterns =
			(isPathAndPatternsObject ? options[0].patterns : []) || [];

		// standardize to array of objects if we have an array of strings
		if (
			restrictedPatterns.length > 0 &&
			typeof restrictedPatterns[0] === "string"
		) {
			restrictedPatterns = [{ group: restrictedPatterns ***REMOVED***];
		***REMOVED***

		// relative paths are supported for this rule
		const restrictedPatternGroups = restrictedPatterns.map(
			({
				group,
				regex,
				message,
				caseSensitive,
				importNames,
				importNamePattern,
				allowImportNames,
				allowImportNamePattern,
			***REMOVED***) => ({
				...(group
					? {
							matcher: ignore({
								allowRelativePaths: true,
								ignorecase: !caseSensitive,
							***REMOVED***).add(group),
						***REMOVED***
					: {***REMOVED***),
				...(typeof regex === "string"
					? {
							regexMatcher: new RegExp(
								regex,
								caseSensitive ? "u" : "iu",
							),
						***REMOVED***
					: {***REMOVED***),
				customMessage: message,
				importNames,
				importNamePattern,
				allowImportNames,
				allowImportNamePattern,
			***REMOVED***),
		);

		// if no imports are restricted we don't need to check
		if (
			Object.keys(restrictedPaths).length === 0 &&
			restrictedPatternGroups.length === 0
		) {
			return {***REMOVED***;
		***REMOVED***

		/**
		 * Report a restricted path.
		 * @param {string***REMOVED*** importSource path of the import
		 * @param {Map<string,Object[]>***REMOVED*** importNames Map of import names that are being imported
		 * @param {node***REMOVED*** node representing the restricted path reference
		 * @returns {void***REMOVED***
		 * @private
		 */
		function checkRestrictedPathAndReport(importSource, importNames, node) {
			if (!Object.hasOwn(groupedRestrictedPaths, importSource)) {
				return;
			***REMOVED***

			groupedRestrictedPaths[importSource].forEach(
				restrictedPathEntry => {
					const customMessage = restrictedPathEntry.message;
					const restrictedImportNames =
						restrictedPathEntry.importNames;
					const allowedImportNames =
						restrictedPathEntry.allowImportNames;

					if (!restrictedImportNames && !allowedImportNames) {
						context.report({
							node,
							messageId: customMessage
								? "pathWithCustomMessage"
								: "path",
							data: {
								importSource,
								customMessage,
							***REMOVED***,
						***REMOVED***);

						return;
					***REMOVED***

					importNames.forEach((specifiers, importName) => {
						if (importName === "*") {
							const [specifier] = specifiers;

							if (restrictedImportNames) {
								context.report({
									node,
									messageId: customMessage
										? "everythingWithCustomMessage"
										: "everything",
									loc: specifier.loc,
									data: {
										importSource,
										importNames: restrictedImportNames,
										customMessage,
									***REMOVED***,
								***REMOVED***);
							***REMOVED*** else if (allowedImportNames) {
								context.report({
									node,
									messageId: customMessage
										? "everythingWithAllowImportNamesAndCustomMessage"
										: "everythingWithAllowImportNames",
									loc: specifier.loc,
									data: {
										importSource,
										allowedImportNames,
										customMessage,
									***REMOVED***,
								***REMOVED***);
							***REMOVED***

							return;
						***REMOVED***

						if (
							restrictedImportNames &&
							restrictedImportNames.includes(importName)
						) {
							specifiers.forEach(specifier => {
								context.report({
									node,
									messageId: customMessage
										? "importNameWithCustomMessage"
										: "importName",
									loc: specifier.loc,
									data: {
										importSource,
										customMessage,
										importName,
									***REMOVED***,
								***REMOVED***);
							***REMOVED***);
						***REMOVED***

						if (
							allowedImportNames &&
							!allowedImportNames.includes(importName)
						) {
							specifiers.forEach(specifier => {
								context.report({
									node,
									loc: specifier.loc,
									messageId: customMessage
										? "allowedImportNameWithCustomMessage"
										: "allowedImportName",
									data: {
										importSource,
										customMessage,
										importName,
										allowedImportNames,
									***REMOVED***,
								***REMOVED***);
							***REMOVED***);
						***REMOVED***
					***REMOVED***);
				***REMOVED***,
			);
		***REMOVED***

		/**
		 * Report a restricted path specifically for patterns.
		 * @param {node***REMOVED*** node representing the restricted path reference
		 * @param {Object***REMOVED*** group contains an Ignore instance for paths, the customMessage to show on failure,
		 * and any restricted import names that have been specified in the config
		 * @param {Map<string,Object[]>***REMOVED*** importNames Map of import names that are being imported
		 * @returns {void***REMOVED***
		 * @private
		 */
		function reportPathForPatterns(node, group, importNames) {
			const importSource = node.source.value.trim();

			const customMessage = group.customMessage;
			const restrictedImportNames = group.importNames;
			const restrictedImportNamePattern = group.importNamePattern
				? new RegExp(group.importNamePattern, "u")
				: null;
			const allowedImportNames = group.allowImportNames;
			const allowedImportNamePattern = group.allowImportNamePattern
				? new RegExp(group.allowImportNamePattern, "u")
				: null;

			/**
			 * If we are not restricting to any specific import names and just the pattern itself,
			 * report the error and move on
			 */
			if (
				!restrictedImportNames &&
				!allowedImportNames &&
				!restrictedImportNamePattern &&
				!allowedImportNamePattern
			) {
				context.report({
					node,
					messageId: customMessage
						? "patternWithCustomMessage"
						: "patterns",
					data: {
						importSource,
						customMessage,
					***REMOVED***,
				***REMOVED***);
				return;
			***REMOVED***

			importNames.forEach((specifiers, importName) => {
				if (importName === "*") {
					const [specifier] = specifiers;

					if (restrictedImportNames) {
						context.report({
							node,
							messageId: customMessage
								? "patternAndEverythingWithCustomMessage"
								: "patternAndEverything",
							loc: specifier.loc,
							data: {
								importSource,
								importNames: restrictedImportNames,
								customMessage,
							***REMOVED***,
						***REMOVED***);
					***REMOVED*** else if (allowedImportNames) {
						context.report({
							node,
							messageId: customMessage
								? "everythingWithAllowImportNamesAndCustomMessage"
								: "everythingWithAllowImportNames",
							loc: specifier.loc,
							data: {
								importSource,
								allowedImportNames,
								customMessage,
							***REMOVED***,
						***REMOVED***);
					***REMOVED*** else if (allowedImportNamePattern) {
						context.report({
							node,
							messageId: customMessage
								? "everythingWithAllowedImportNamePatternWithCustomMessage"
								: "everythingWithAllowedImportNamePattern",
							loc: specifier.loc,
							data: {
								importSource,
								allowedImportNamePattern,
								customMessage,
							***REMOVED***,
						***REMOVED***);
					***REMOVED*** else {
						context.report({
							node,
							messageId: customMessage
								? "patternAndEverythingWithRegexImportNameAndCustomMessage"
								: "patternAndEverythingWithRegexImportName",
							loc: specifier.loc,
							data: {
								importSource,
								importNames: restrictedImportNamePattern,
								customMessage,
							***REMOVED***,
						***REMOVED***);
					***REMOVED***

					return;
				***REMOVED***

				if (
					(restrictedImportNames &&
						restrictedImportNames.includes(importName)) ||
					(restrictedImportNamePattern &&
						restrictedImportNamePattern.test(importName))
				) {
					specifiers.forEach(specifier => {
						context.report({
							node,
							messageId: customMessage
								? "patternAndImportNameWithCustomMessage"
								: "patternAndImportName",
							loc: specifier.loc,
							data: {
								importSource,
								customMessage,
								importName,
							***REMOVED***,
						***REMOVED***);
					***REMOVED***);
				***REMOVED***

				if (
					allowedImportNames &&
					!allowedImportNames.includes(importName)
				) {
					specifiers.forEach(specifier => {
						context.report({
							node,
							messageId: customMessage
								? "allowedImportNameWithCustomMessage"
								: "allowedImportName",
							loc: specifier.loc,
							data: {
								importSource,
								customMessage,
								importName,
								allowedImportNames,
							***REMOVED***,
						***REMOVED***);
					***REMOVED***);
				***REMOVED*** else if (
					allowedImportNamePattern &&
					!allowedImportNamePattern.test(importName)
				) {
					specifiers.forEach(specifier => {
						context.report({
							node,
							messageId: customMessage
								? "allowedImportNamePatternWithCustomMessage"
								: "allowedImportNamePattern",
							loc: specifier.loc,
							data: {
								importSource,
								customMessage,
								importName,
								allowedImportNamePattern,
							***REMOVED***,
						***REMOVED***);
					***REMOVED***);
				***REMOVED***
			***REMOVED***);
		***REMOVED***

		/**
		 * Check if the given importSource is restricted by a pattern.
		 * @param {string***REMOVED*** importSource path of the import
		 * @param {Object***REMOVED*** group contains a Ignore instance for paths, and the customMessage to show if it fails
		 * @returns {boolean***REMOVED*** whether the variable is a restricted pattern or not
		 * @private
		 */
		function isRestrictedPattern(importSource, group) {
			return group.regexMatcher
				? group.regexMatcher.test(importSource)
				: group.matcher.ignores(importSource);
		***REMOVED***

		/**
		 * Checks a node to see if any problems should be reported.
		 * @param {ASTNode***REMOVED*** node The node to check.
		 * @returns {void***REMOVED***
		 * @private
		 */
		function checkNode(node) {
			const importSource = node.source.value.trim();
			const importNames = new Map();

			if (node.type === "ExportAllDeclaration") {
				const starToken = sourceCode.getFirstToken(node, 1);

				importNames.set("*", [{ loc: starToken.loc ***REMOVED***]);
			***REMOVED*** else if (node.specifiers) {
				for (const specifier of node.specifiers) {
					let name;
					const specifierData = { loc: specifier.loc ***REMOVED***;

					if (specifier.type === "ImportDefaultSpecifier") {
						name = "default";
					***REMOVED*** else if (specifier.type === "ImportNamespaceSpecifier") {
						name = "*";
					***REMOVED*** else if (specifier.imported) {
						name = astUtils.getModuleExportName(specifier.imported);
					***REMOVED*** else if (specifier.local) {
						name = astUtils.getModuleExportName(specifier.local);
					***REMOVED***

					if (typeof name === "string") {
						if (importNames.has(name)) {
							importNames.get(name).push(specifierData);
						***REMOVED*** else {
							importNames.set(name, [specifierData]);
						***REMOVED***
					***REMOVED***
				***REMOVED***
			***REMOVED***

			checkRestrictedPathAndReport(importSource, importNames, node);
			restrictedPatternGroups.forEach(group => {
				if (isRestrictedPattern(importSource, group)) {
					reportPathForPatterns(node, group, importNames);
				***REMOVED***
			***REMOVED***);
		***REMOVED***

		return {
			ImportDeclaration: checkNode,
			ExportNamedDeclaration(node) {
				if (node.source) {
					checkNode(node);
				***REMOVED***
			***REMOVED***,
			ExportAllDeclaration: checkNode,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
