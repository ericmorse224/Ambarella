/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const UnsupportedFeatureWarning = require("../UnsupportedFeatureWarning");
const ConstDependency = require("../dependencies/ConstDependency");
const BasicEvaluatedExpression = require("./BasicEvaluatedExpression");

/** @typedef {import("estree").Expression***REMOVED*** Expression */
/** @typedef {import("estree").Node***REMOVED*** Node */
/** @typedef {import("estree").SourceLocation***REMOVED*** SourceLocation */
/** @typedef {import("./JavascriptParser")***REMOVED*** JavascriptParser */
/** @typedef {import("./JavascriptParser").Range***REMOVED*** Range */

/**
 * @param {JavascriptParser***REMOVED*** parser the parser
 * @param {string***REMOVED*** value the const value
 * @param {(string[] | null)=***REMOVED*** runtimeRequirements runtime requirements
 * @returns {(expression: Expression) => true***REMOVED*** plugin function
 */
module.exports.toConstantDependency = (parser, value, runtimeRequirements) =>
	function constDependency(expr) {
		const dep = new ConstDependency(
			value,
			/** @type {Range***REMOVED*** */
			(expr.range),
			runtimeRequirements
		);
		dep.loc = /** @type {SourceLocation***REMOVED*** */ (expr.loc);
		parser.state.module.addPresentationalDependency(dep);
		return true;
	***REMOVED***;

/**
 * @param {string***REMOVED*** value the string value
 * @returns {(expression: Expression) => BasicEvaluatedExpression***REMOVED*** plugin function
 */
module.exports.evaluateToString = value =>
	function stringExpression(expr) {
		return new BasicEvaluatedExpression()
			.setString(value)
			.setRange(/** @type {Range***REMOVED*** */ (expr.range));
	***REMOVED***;

/**
 * @param {number***REMOVED*** value the number value
 * @returns {(expression: Expression) => BasicEvaluatedExpression***REMOVED*** plugin function
 */
module.exports.evaluateToNumber = value =>
	function stringExpression(expr) {
		return new BasicEvaluatedExpression()
			.setNumber(value)
			.setRange(/** @type {Range***REMOVED*** */ (expr.range));
	***REMOVED***;

/**
 * @param {boolean***REMOVED*** value the boolean value
 * @returns {(expression: Expression) => BasicEvaluatedExpression***REMOVED*** plugin function
 */
module.exports.evaluateToBoolean = value =>
	function booleanExpression(expr) {
		return new BasicEvaluatedExpression()
			.setBoolean(value)
			.setRange(/** @type {Range***REMOVED*** */ (expr.range));
	***REMOVED***;

/**
 * @param {string***REMOVED*** identifier identifier
 * @param {string***REMOVED*** rootInfo rootInfo
 * @param {() => string[]***REMOVED*** getMembers getMembers
 * @param {boolean | null=***REMOVED*** truthy is truthy, null if nullish
 * @returns {(expression: Expression) => BasicEvaluatedExpression***REMOVED*** callback
 */
module.exports.evaluateToIdentifier = (
	identifier,
	rootInfo,
	getMembers,
	truthy
) =>
	function identifierExpression(expr) {
		const evaluatedExpression = new BasicEvaluatedExpression()
			.setIdentifier(identifier, rootInfo, getMembers)
			.setSideEffects(false)
			.setRange(/** @type {Range***REMOVED*** */ (expr.range));
		switch (truthy) {
			case true:
				evaluatedExpression.setTruthy();
				break;
			case null:
				evaluatedExpression.setNullish(true);
				break;
			case false:
				evaluatedExpression.setFalsy();
				break;
		***REMOVED***

		return evaluatedExpression;
	***REMOVED***;

/**
 * @param {JavascriptParser***REMOVED*** parser the parser
 * @param {string***REMOVED*** message the message
 * @returns {(expression: Expression) => boolean | undefined***REMOVED*** callback to handle unsupported expression
 */
module.exports.expressionIsUnsupported = (parser, message) =>
	function unsupportedExpression(expr) {
		const dep = new ConstDependency(
			"(void 0)",
			/** @type {Range***REMOVED*** */ (expr.range),
			null
		);
		dep.loc = /** @type {SourceLocation***REMOVED*** */ (expr.loc);
		parser.state.module.addPresentationalDependency(dep);
		if (!parser.state.module) return;
		parser.state.module.addWarning(
			new UnsupportedFeatureWarning(
				message,
				/** @type {SourceLocation***REMOVED*** */ (expr.loc)
			)
		);
		return true;
	***REMOVED***;

module.exports.skipTraversal = () => true;

module.exports.approve = () => true;
