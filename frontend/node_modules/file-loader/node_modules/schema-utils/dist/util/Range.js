"use strict";

/**
 * @typedef {[number, boolean]***REMOVED*** RangeValue
 */

/**
 * @callback RangeValueCallback
 * @param {RangeValue***REMOVED*** rangeValue
 * @returns {boolean***REMOVED***
 */
class Range {
  /**
   * @param {"left" | "right"***REMOVED*** side
   * @param {boolean***REMOVED*** exclusive
   * @returns {">" | ">=" | "<" | "<="***REMOVED***
   */
  static getOperator(side, exclusive) {
    if (side === "left") {
      return exclusive ? ">" : ">=";
    ***REMOVED***

    return exclusive ? "<" : "<=";
  ***REMOVED***
  /**
   * @param {number***REMOVED*** value
   * @param {boolean***REMOVED*** logic is not logic applied
   * @param {boolean***REMOVED*** exclusive is range exclusive
   * @returns {string***REMOVED***
   */


  static formatRight(value, logic, exclusive) {
    if (logic === false) {
      return Range.formatLeft(value, !logic, !exclusive);
    ***REMOVED***

    return `should be ${Range.getOperator("right", exclusive)***REMOVED*** ${value***REMOVED***`;
  ***REMOVED***
  /**
   * @param {number***REMOVED*** value
   * @param {boolean***REMOVED*** logic is not logic applied
   * @param {boolean***REMOVED*** exclusive is range exclusive
   * @returns {string***REMOVED***
   */


  static formatLeft(value, logic, exclusive) {
    if (logic === false) {
      return Range.formatRight(value, !logic, !exclusive);
    ***REMOVED***

    return `should be ${Range.getOperator("left", exclusive)***REMOVED*** ${value***REMOVED***`;
  ***REMOVED***
  /**
   * @param {number***REMOVED*** start left side value
   * @param {number***REMOVED*** end right side value
   * @param {boolean***REMOVED*** startExclusive is range exclusive from left side
   * @param {boolean***REMOVED*** endExclusive is range exclusive from right side
   * @param {boolean***REMOVED*** logic is not logic applied
   * @returns {string***REMOVED***
   */


  static formatRange(start, end, startExclusive, endExclusive, logic) {
    let result = "should be";
    result += ` ${Range.getOperator(logic ? "left" : "right", logic ? startExclusive : !startExclusive)***REMOVED*** ${start***REMOVED*** `;
    result += logic ? "and" : "or";
    result += ` ${Range.getOperator(logic ? "right" : "left", logic ? endExclusive : !endExclusive)***REMOVED*** ${end***REMOVED***`;
    return result;
  ***REMOVED***
  /**
   * @param {Array<RangeValue>***REMOVED*** values
   * @param {boolean***REMOVED*** logic is not logic applied
   * @return {RangeValue***REMOVED*** computed value and it's exclusive flag
   */


  static getRangeValue(values, logic) {
    let minMax = logic ? Infinity : -Infinity;
    let j = -1;
    const predicate = logic ?
    /** @type {RangeValueCallback***REMOVED*** */
    ([value]) => value <= minMax :
    /** @type {RangeValueCallback***REMOVED*** */
    ([value]) => value >= minMax;

    for (let i = 0; i < values.length; i++) {
      if (predicate(values[i])) {
        [minMax] = values[i];
        j = i;
      ***REMOVED***
    ***REMOVED***

    if (j > -1) {
      return values[j];
    ***REMOVED***

    return [Infinity, true];
  ***REMOVED***

  constructor() {
    /** @type {Array<RangeValue>***REMOVED*** */
    this._left = [];
    /** @type {Array<RangeValue>***REMOVED*** */

    this._right = [];
  ***REMOVED***
  /**
   * @param {number***REMOVED*** value
   * @param {boolean=***REMOVED*** exclusive
   */


  left(value, exclusive = false) {
    this._left.push([value, exclusive]);
  ***REMOVED***
  /**
   * @param {number***REMOVED*** value
   * @param {boolean=***REMOVED*** exclusive
   */


  right(value, exclusive = false) {
    this._right.push([value, exclusive]);
  ***REMOVED***
  /**
   * @param {boolean***REMOVED*** logic is not logic applied
   * @return {string***REMOVED*** "smart" range string representation
   */


  format(logic = true) {
    const [start, leftExclusive] = Range.getRangeValue(this._left, logic);
    const [end, rightExclusive] = Range.getRangeValue(this._right, !logic);

    if (!Number.isFinite(start) && !Number.isFinite(end)) {
      return "";
    ***REMOVED***

    const realStart = leftExclusive ? start + 1 : start;
    const realEnd = rightExclusive ? end - 1 : end; // e.g. 5 < x < 7, 5 < x <= 6, 6 <= x <= 6

    if (realStart === realEnd) {
      return `should be ${logic ? "" : "!"***REMOVED***= ${realStart***REMOVED***`;
    ***REMOVED*** // e.g. 4 < x < ∞


    if (Number.isFinite(start) && !Number.isFinite(end)) {
      return Range.formatLeft(start, logic, leftExclusive);
    ***REMOVED*** // e.g. ∞ < x < 4


    if (!Number.isFinite(start) && Number.isFinite(end)) {
      return Range.formatRight(end, logic, rightExclusive);
    ***REMOVED***

    return Range.formatRange(start, end, leftExclusive, rightExclusive, logic);
  ***REMOVED***

***REMOVED***

module.exports = Range;