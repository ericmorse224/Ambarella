/**
 * @fileoverview Define utility functions for token store.
 * @author Toru Nagashima
 */
"use strict";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Gets `token.range[0]` from the given token.
 * @param {Node|Token|Comment***REMOVED*** token The token to get.
 * @returns {number***REMOVED*** The start location.
 * @private
 */
function getStartLocation(token) {
    return token.range[0];
***REMOVED***

//------------------------------------------------------------------------------
// Exports
//------------------------------------------------------------------------------

/**
 * Finds the index of the first token which is after the given location.
 * If it was not found, this returns `tokens.length`.
 * @param {(Token|Comment)[]***REMOVED*** tokens It searches the token in this list.
 * @param {number***REMOVED*** location The location to search.
 * @returns {number***REMOVED*** The found index or `tokens.length`.
 */
exports.search = function search(tokens, location) {
    const index = tokens.findIndex(el => location <= getStartLocation(el));

    return index === -1 ? tokens.length : index;
***REMOVED***;

/**
 * Gets the index of the `startLoc` in `tokens`.
 * `startLoc` can be the value of `node.range[1]`, so this checks about `startLoc - 1` as well.
 * @param {(Token|Comment)[]***REMOVED*** tokens The tokens to find an index.
 * @param {Object***REMOVED*** indexMap The map from locations to indices.
 * @param {number***REMOVED*** startLoc The location to get an index.
 * @returns {number***REMOVED*** The index.
 */
exports.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {
    if (startLoc in indexMap) {
        return indexMap[startLoc];
    ***REMOVED***
    if ((startLoc - 1) in indexMap) {
        const index = indexMap[startLoc - 1];
        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;

        /*
         * For the map of "comment's location -> token's index", it points the next token of a comment.
         * In that case, +1 is unnecessary.
         */
        if (token && token.range[0] >= startLoc) {
            return index;
        ***REMOVED***
        return index + 1;
    ***REMOVED***
    return 0;
***REMOVED***;

/**
 * Gets the index of the `endLoc` in `tokens`.
 * The information of end locations are recorded at `endLoc - 1` in `indexMap`, so this checks about `endLoc - 1` as well.
 * @param {(Token|Comment)[]***REMOVED*** tokens The tokens to find an index.
 * @param {Object***REMOVED*** indexMap The map from locations to indices.
 * @param {number***REMOVED*** endLoc The location to get an index.
 * @returns {number***REMOVED*** The index.
 */
exports.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {
    if (endLoc in indexMap) {
        return indexMap[endLoc] - 1;
    ***REMOVED***
    if ((endLoc - 1) in indexMap) {
        const index = indexMap[endLoc - 1];
        const token = (index >= 0 && index < tokens.length) ? tokens[index] : null;

        /*
         * For the map of "comment's location -> token's index", it points the next token of a comment.
         * In that case, -1 is necessary.
         */
        if (token && token.range[1] > endLoc) {
            return index - 1;
        ***REMOVED***
        return index;
    ***REMOVED***
    return tokens.length - 1;
***REMOVED***;
