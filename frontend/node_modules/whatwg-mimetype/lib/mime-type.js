"use strict";
const parse = require("./parser.js");
const serialize = require("./serializer.js");
const {
  asciiLowercase,
  solelyContainsHTTPTokenCodePoints,
  soleyContainsHTTPQuotedStringTokenCodePoints
***REMOVED*** = require("./utils.js");

module.exports = class MIMEType {
  constructor(string) {
    string = String(string);
    const result = parse(string);
    if (result === null) {
      throw new Error(`Could not parse MIME type string "${string***REMOVED***"`);
    ***REMOVED***

    this._type = result.type;
    this._subtype = result.subtype;
    this._parameters = new MIMETypeParameters(result.parameters);
  ***REMOVED***

  static parse(string) {
    try {
      return new this(string);
    ***REMOVED*** catch (e) {
      return null;
    ***REMOVED***
  ***REMOVED***

  get essence() {
    return `${this.type***REMOVED***/${this.subtype***REMOVED***`;
  ***REMOVED***

  get type() {
    return this._type;
  ***REMOVED***

  set type(value) {
    value = asciiLowercase(String(value));

    if (value.length === 0) {
      throw new Error("Invalid type: must be a non-empty string");
    ***REMOVED***
    if (!solelyContainsHTTPTokenCodePoints(value)) {
      throw new Error(`Invalid type ${value***REMOVED***: must contain only HTTP token code points`);
    ***REMOVED***

    this._type = value;
  ***REMOVED***

  get subtype() {
    return this._subtype;
  ***REMOVED***

  set subtype(value) {
    value = asciiLowercase(String(value));

    if (value.length === 0) {
      throw new Error("Invalid subtype: must be a non-empty string");
    ***REMOVED***
    if (!solelyContainsHTTPTokenCodePoints(value)) {
      throw new Error(`Invalid subtype ${value***REMOVED***: must contain only HTTP token code points`);
    ***REMOVED***

    this._subtype = value;
  ***REMOVED***

  get parameters() {
    return this._parameters;
  ***REMOVED***

  toString() {
    // The serialize function works on both "MIME type records" (i.e. the results of parse) and on this class, since
    // this class's interface is identical.
    return serialize(this);
  ***REMOVED***

  isJavaScript({ allowParameters = false ***REMOVED*** = {***REMOVED***) {
    switch (this._type) {
      case "text": {
        switch (this._subtype) {
          case "ecmascript":
          case "javascript":
          case "javascript1.0":
          case "javascript1.1":
          case "javascript1.2":
          case "javascript1.3":
          case "javascript1.4":
          case "javascript1.5":
          case "jscript":
          case "livescript":
          case "x-ecmascript":
          case "x-javascript": {
            return allowParameters || this._parameters.size === 0;
          ***REMOVED***
          default: {
            return false;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      case "application": {
        switch (this._subtype) {
          case "ecmascript":
          case "javascript":
          case "x-ecmascript":
          case "x-javascript": {
            return allowParameters || this._parameters.size === 0;
          ***REMOVED***
          default: {
            return false;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      default: {
        return false;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  isXML() {
    return (this._subtype === "xml" && (this._type === "text" || this._type === "application")) ||
           this._subtype.endsWith("+xml");
  ***REMOVED***
  isHTML() {
    return this._subtype === "html" && this._type === "text";
  ***REMOVED***
***REMOVED***;

class MIMETypeParameters {
  constructor(map) {
    this._map = map;
  ***REMOVED***

  get size() {
    return this._map.size;
  ***REMOVED***

  get(name) {
    name = asciiLowercase(String(name));
    return this._map.get(name);
  ***REMOVED***

  has(name) {
    name = asciiLowercase(String(name));
    return this._map.has(name);
  ***REMOVED***

  set(name, value) {
    name = asciiLowercase(String(name));
    value = String(value);

    if (!solelyContainsHTTPTokenCodePoints(name)) {
      throw new Error(`Invalid MIME type parameter name "${name***REMOVED***": only HTTP token code points are valid.`);
    ***REMOVED***
    if (!soleyContainsHTTPQuotedStringTokenCodePoints(value)) {
      throw new Error(`Invalid MIME type parameter value "${value***REMOVED***": only HTTP quoted-string token code points are ` +
                      `valid.`);
    ***REMOVED***

    return this._map.set(name, value);
  ***REMOVED***

  clear() {
    this._map.clear();
  ***REMOVED***

  delete(name) {
    name = asciiLowercase(String(name));
    return this._map.delete(name);
  ***REMOVED***

  forEach(callbackFn, thisArg) {
    this._map.forEach(callbackFn, thisArg);
  ***REMOVED***

  keys() {
    return this._map.keys();
  ***REMOVED***

  values() {
    return this._map.values();
  ***REMOVED***

  entries() {
    return this._map.entries();
  ***REMOVED***

  [Symbol.iterator]() {
    return this._map[Symbol.iterator]();
  ***REMOVED***
***REMOVED***
