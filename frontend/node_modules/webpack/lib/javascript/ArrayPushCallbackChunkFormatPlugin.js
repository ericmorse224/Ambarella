/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { ConcatSource, PrefixSource, RawSource ***REMOVED*** = require("webpack-sources");
const { RuntimeGlobals ***REMOVED*** = require("..");
const HotUpdateChunk = require("../HotUpdateChunk");
const Template = require("../Template");
const { getCompilationHooks ***REMOVED*** = require("./JavascriptModulesPlugin");
const {
	generateEntryStartup,
	updateHashForEntryStartup
***REMOVED*** = require("./StartupHelpers");

/** @typedef {import("../Compiler")***REMOVED*** Compiler */

class ArrayPushCallbackChunkFormatPlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		compiler.hooks.thisCompilation.tap(
			"ArrayPushCallbackChunkFormatPlugin",
			compilation => {
				compilation.hooks.additionalChunkRuntimeRequirements.tap(
					"ArrayPushCallbackChunkFormatPlugin",
					(chunk, set, { chunkGraph ***REMOVED***) => {
						if (chunk.hasRuntime()) return;
						if (chunkGraph.getNumberOfEntryModules(chunk) > 0) {
							set.add(RuntimeGlobals.onChunksLoaded);
							set.add(RuntimeGlobals.exports);
							set.add(RuntimeGlobals.require);
						***REMOVED***
						set.add(RuntimeGlobals.chunkCallback);
					***REMOVED***
				);
				const hooks = getCompilationHooks(compilation);
				hooks.renderChunk.tap(
					"ArrayPushCallbackChunkFormatPlugin",
					(modules, renderContext) => {
						const { chunk, chunkGraph, runtimeTemplate ***REMOVED*** = renderContext;
						const hotUpdateChunk =
							chunk instanceof HotUpdateChunk ? chunk : null;
						const globalObject = runtimeTemplate.globalObject;
						const source = new ConcatSource();
						const runtimeModules =
							chunkGraph.getChunkRuntimeModulesInOrder(chunk);
						if (hotUpdateChunk) {
							const hotUpdateGlobal =
								runtimeTemplate.outputOptions.hotUpdateGlobal;
							source.add(
								`${globalObject***REMOVED***[${JSON.stringify(hotUpdateGlobal)***REMOVED***](`
							);
							source.add(`${JSON.stringify(chunk.id)***REMOVED***,`);
							source.add(modules);
							if (runtimeModules.length > 0) {
								source.add(",\n");
								const runtimePart = Template.renderChunkRuntimeModules(
									runtimeModules,
									renderContext
								);
								source.add(runtimePart);
							***REMOVED***
							source.add(")");
						***REMOVED*** else {
							const chunkLoadingGlobal =
								runtimeTemplate.outputOptions.chunkLoadingGlobal;
							source.add(
								`(${globalObject***REMOVED***[${JSON.stringify(
									chunkLoadingGlobal
								)***REMOVED***] = ${globalObject***REMOVED***[${JSON.stringify(
									chunkLoadingGlobal
								)***REMOVED***] || []).push([`
							);
							source.add(`${JSON.stringify(chunk.ids)***REMOVED***,`);
							source.add(modules);
							const entries = Array.from(
								chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk)
							);
							if (runtimeModules.length > 0 || entries.length > 0) {
								const runtime = new ConcatSource(
									`${
										runtimeTemplate.supportsArrowFunction()
											? `${RuntimeGlobals.require***REMOVED*** =>`
											: `function(${RuntimeGlobals.require***REMOVED***)`
									***REMOVED*** { // webpackRuntimeModules\n`
								);
								if (runtimeModules.length > 0) {
									runtime.add(
										Template.renderRuntimeModules(runtimeModules, {
											...renderContext,
											codeGenerationResults: compilation.codeGenerationResults
										***REMOVED***)
									);
								***REMOVED***
								if (entries.length > 0) {
									const startupSource = new RawSource(
										generateEntryStartup(
											chunkGraph,
											runtimeTemplate,
											entries,
											chunk,
											true
										)
									);
									runtime.add(
										hooks.renderStartup.call(
											startupSource,
											entries[entries.length - 1][0],
											{
												...renderContext,
												inlined: false
											***REMOVED***
										)
									);
									if (
										chunkGraph
											.getChunkRuntimeRequirements(chunk)
											.has(RuntimeGlobals.returnExportsFromRuntime)
									) {
										runtime.add(`return ${RuntimeGlobals.exports***REMOVED***;\n`);
									***REMOVED***
								***REMOVED***
								runtime.add("***REMOVED***\n");
								source.add(",\n");
								source.add(new PrefixSource("/******/ ", runtime));
							***REMOVED***
							source.add("])");
						***REMOVED***
						return source;
					***REMOVED***
				);
				hooks.chunkHash.tap(
					"ArrayPushCallbackChunkFormatPlugin",
					(chunk, hash, { chunkGraph, runtimeTemplate ***REMOVED***) => {
						if (chunk.hasRuntime()) return;
						hash.update(
							`ArrayPushCallbackChunkFormatPlugin1${runtimeTemplate.outputOptions.chunkLoadingGlobal***REMOVED***${runtimeTemplate.outputOptions.hotUpdateGlobal***REMOVED***${runtimeTemplate.globalObject***REMOVED***`
						);
						const entries = Array.from(
							chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk)
						);
						updateHashForEntryStartup(hash, chunkGraph, entries, chunk);
					***REMOVED***
				);
			***REMOVED***
		);
	***REMOVED***
***REMOVED***

module.exports = ArrayPushCallbackChunkFormatPlugin;
