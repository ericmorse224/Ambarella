/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
import { BackgroundSyncPlugin ***REMOVED*** from 'workbox-background-sync/BackgroundSyncPlugin.js';
import { cacheNames ***REMOVED*** from 'workbox-core/_private/cacheNames.js';
import { getFriendlyURL ***REMOVED*** from 'workbox-core/_private/getFriendlyURL.js';
import { logger ***REMOVED*** from 'workbox-core/_private/logger.js';
import { Route ***REMOVED*** from 'workbox-routing/Route.js';
import { Router ***REMOVED*** from 'workbox-routing/Router.js';
import { NetworkFirst ***REMOVED*** from 'workbox-strategies/NetworkFirst.js';
import { NetworkOnly ***REMOVED*** from 'workbox-strategies/NetworkOnly.js';
import { QUEUE_NAME, MAX_RETENTION_TIME, GOOGLE_ANALYTICS_HOST, GTM_HOST, ANALYTICS_JS_PATH, GTAG_JS_PATH, GTM_JS_PATH, COLLECT_PATHS_REGEX, ***REMOVED*** from './utils/constants.js';
import './_version.js';
/**
 * Creates the requestWillDequeue callback to be used with the background
 * sync plugin. The callback takes the failed request and adds the
 * `qt` param based on the current time, as well as applies any other
 * user-defined hit modifications.
 *
 * @param {Object***REMOVED*** config See {@link workbox-google-analytics.initialize***REMOVED***.
 * @return {Function***REMOVED*** The requestWillDequeue callback function.
 *
 * @private
 */
const createOnSyncCallback = (config) => {
    return async ({ queue ***REMOVED***) => {
        let entry;
        while ((entry = await queue.shiftRequest())) {
            const { request, timestamp ***REMOVED*** = entry;
            const url = new URL(request.url);
            try {
                // Measurement protocol requests can set their payload parameters in
                // either the URL query string (for GET requests) or the POST body.
                const params = request.method === 'POST'
                    ? new URLSearchParams(await request.clone().text())
                    : url.searchParams;
                // Calculate the qt param, accounting for the fact that an existing
                // qt param may be present and should be updated rather than replaced.
                const originalHitTime = timestamp - (Number(params.get('qt')) || 0);
                const queueTime = Date.now() - originalHitTime;
                // Set the qt param prior to applying hitFilter or parameterOverrides.
                params.set('qt', String(queueTime));
                // Apply `parameterOverrides`, if set.
                if (config.parameterOverrides) {
                    for (const param of Object.keys(config.parameterOverrides)) {
                        const value = config.parameterOverrides[param];
                        params.set(param, value);
                    ***REMOVED***
                ***REMOVED***
                // Apply `hitFilter`, if set.
                if (typeof config.hitFilter === 'function') {
                    config.hitFilter.call(null, params);
                ***REMOVED***
                // Retry the fetch. Ignore URL search params from the URL as they're
                // now in the post body.
                await fetch(new Request(url.origin + url.pathname, {
                    body: params.toString(),
                    method: 'POST',
                    mode: 'cors',
                    credentials: 'omit',
                    headers: { 'Content-Type': 'text/plain' ***REMOVED***,
                ***REMOVED***));
                if (process.env.NODE_ENV !== 'production') {
                    logger.log(`Request for '${getFriendlyURL(url.href)***REMOVED***' ` + `has been replayed`);
                ***REMOVED***
            ***REMOVED***
            catch (err) {
                await queue.unshiftRequest(entry);
                if (process.env.NODE_ENV !== 'production') {
                    logger.log(`Request for '${getFriendlyURL(url.href)***REMOVED***' ` +
                        `failed to replay, putting it back in the queue.`);
                ***REMOVED***
                throw err;
            ***REMOVED***
        ***REMOVED***
        if (process.env.NODE_ENV !== 'production') {
            logger.log(`All Google Analytics request successfully replayed; ` +
                `the queue is now empty!`);
        ***REMOVED***
    ***REMOVED***;
***REMOVED***;
/**
 * Creates GET and POST routes to catch failed Measurement Protocol hits.
 *
 * @param {BackgroundSyncPlugin***REMOVED*** bgSyncPlugin
 * @return {Array<Route>***REMOVED*** The created routes.
 *
 * @private
 */
const createCollectRoutes = (bgSyncPlugin) => {
    const match = ({ url ***REMOVED***) => url.hostname === GOOGLE_ANALYTICS_HOST &&
        COLLECT_PATHS_REGEX.test(url.pathname);
    const handler = new NetworkOnly({
        plugins: [bgSyncPlugin],
    ***REMOVED***);
    return [new Route(match, handler, 'GET'), new Route(match, handler, 'POST')];
***REMOVED***;
/**
 * Creates a route with a network first strategy for the analytics.js script.
 *
 * @param {string***REMOVED*** cacheName
 * @return {Route***REMOVED*** The created route.
 *
 * @private
 */
const createAnalyticsJsRoute = (cacheName) => {
    const match = ({ url ***REMOVED***) => url.hostname === GOOGLE_ANALYTICS_HOST &&
        url.pathname === ANALYTICS_JS_PATH;
    const handler = new NetworkFirst({ cacheName ***REMOVED***);
    return new Route(match, handler, 'GET');
***REMOVED***;
/**
 * Creates a route with a network first strategy for the gtag.js script.
 *
 * @param {string***REMOVED*** cacheName
 * @return {Route***REMOVED*** The created route.
 *
 * @private
 */
const createGtagJsRoute = (cacheName) => {
    const match = ({ url ***REMOVED***) => url.hostname === GTM_HOST && url.pathname === GTAG_JS_PATH;
    const handler = new NetworkFirst({ cacheName ***REMOVED***);
    return new Route(match, handler, 'GET');
***REMOVED***;
/**
 * Creates a route with a network first strategy for the gtm.js script.
 *
 * @param {string***REMOVED*** cacheName
 * @return {Route***REMOVED*** The created route.
 *
 * @private
 */
const createGtmJsRoute = (cacheName) => {
    const match = ({ url ***REMOVED***) => url.hostname === GTM_HOST && url.pathname === GTM_JS_PATH;
    const handler = new NetworkFirst({ cacheName ***REMOVED***);
    return new Route(match, handler, 'GET');
***REMOVED***;
/**
 * @param {Object=***REMOVED*** [options]
 * @param {Object***REMOVED*** [options.cacheName] The cache name to store and retrieve
 *     analytics.js. Defaults to the cache names provided by `workbox-core`.
 * @param {Object***REMOVED*** [options.parameterOverrides]
 *     [Measurement Protocol parameters](https://developers.google.com/analytics/devguides/collection/protocol/v1/parameters),
 *     expressed as key/value pairs, to be added to replayed Google Analytics
 *     requests. This can be used to, e.g., set a custom dimension indicating
 *     that the request was replayed.
 * @param {Function***REMOVED*** [options.hitFilter] A function that allows you to modify
 *     the hit parameters prior to replaying
 *     the hit. The function is invoked with the original hit's URLSearchParams
 *     object as its only argument.
 *
 * @memberof workbox-google-analytics
 */
const initialize = (options = {***REMOVED***) => {
    const cacheName = cacheNames.getGoogleAnalyticsName(options.cacheName);
    const bgSyncPlugin = new BackgroundSyncPlugin(QUEUE_NAME, {
        maxRetentionTime: MAX_RETENTION_TIME,
        onSync: createOnSyncCallback(options),
    ***REMOVED***);
    const routes = [
        createGtmJsRoute(cacheName),
        createAnalyticsJsRoute(cacheName),
        createGtagJsRoute(cacheName),
        ...createCollectRoutes(bgSyncPlugin),
    ];
    const router = new Router();
    for (const route of routes) {
        router.registerRoute(route);
    ***REMOVED***
    router.addFetchListener();
***REMOVED***;
export { initialize ***REMOVED***;
