/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const LazySet = require("../util/LazySet");
const makeSerializable = require("../util/makeSerializable");

/** @typedef {import("enhanced-resolve").ResolveContext***REMOVED*** ResolveContext */
/** @typedef {import("enhanced-resolve").ResolveOptions***REMOVED*** ResolveOptions */
/** @typedef {import("enhanced-resolve").ResolveRequest***REMOVED*** ResolveRequest */
/** @typedef {import("enhanced-resolve").Resolver***REMOVED*** Resolver */
/** @typedef {import("../CacheFacade").ItemCacheFacade***REMOVED*** ItemCacheFacade */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../FileSystemInfo")***REMOVED*** FileSystemInfo */
/** @typedef {import("../FileSystemInfo").Snapshot***REMOVED*** Snapshot */
/** @typedef {import("../FileSystemInfo").SnapshotOptions***REMOVED*** SnapshotOptions */
/** @typedef {import("../ResolverFactory").ResolveOptionsWithDependencyType***REMOVED*** ResolveOptionsWithDependencyType */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext***REMOVED*** ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext***REMOVED*** ObjectSerializerContext */

/**
 * @template T
 * @typedef {import("tapable").SyncHook<T>***REMOVED*** SyncHook
 */

/**
 * @template H
 * @typedef {import("tapable").HookMapInterceptor<H>***REMOVED*** HookMapInterceptor
 */

class CacheEntry {
	/**
	 * @param {ResolveRequest***REMOVED*** result result
	 * @param {Snapshot***REMOVED*** snapshot snapshot
	 */
	constructor(result, snapshot) {
		this.result = result;
		this.snapshot = snapshot;
	***REMOVED***

	/**
	 * @param {ObjectSerializerContext***REMOVED*** context context
	 */
	serialize({ write ***REMOVED***) {
		write(this.result);
		write(this.snapshot);
	***REMOVED***

	/**
	 * @param {ObjectDeserializerContext***REMOVED*** context context
	 */
	deserialize({ read ***REMOVED***) {
		this.result = read();
		this.snapshot = read();
	***REMOVED***
***REMOVED***

makeSerializable(CacheEntry, "webpack/lib/cache/ResolverCachePlugin");

/**
 * @template T
 * @param {Set<T> | LazySet<T>***REMOVED*** set set to add items to
 * @param {Set<T> | LazySet<T> | Iterable<T>***REMOVED*** otherSet set to add items from
 * @returns {void***REMOVED***
 */
const addAllToSet = (set, otherSet) => {
	if (set instanceof LazySet) {
		set.addAll(otherSet);
	***REMOVED*** else {
		for (const item of otherSet) {
			set.add(item);
		***REMOVED***
	***REMOVED***
***REMOVED***;

/**
 * @template {object***REMOVED*** T
 * @param {T***REMOVED*** object an object
 * @param {boolean***REMOVED*** excludeContext if true, context is not included in string
 * @returns {string***REMOVED*** stringified version
 */
const objectToString = (object, excludeContext) => {
	let str = "";
	for (const key in object) {
		if (excludeContext && key === "context") continue;
		const value = object[key];
		str +=
			typeof value === "object" && value !== null
				? `|${key***REMOVED***=[${objectToString(value, false)***REMOVED***|]`
				: `|${key***REMOVED***=|${value***REMOVED***`;
	***REMOVED***
	return str;
***REMOVED***;

/** @typedef {NonNullable<ResolveContext["yield"]>***REMOVED*** Yield */

const PLUGIN_NAME = "ResolverCachePlugin";

class ResolverCachePlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		const cache = compiler.getCache(PLUGIN_NAME);
		/** @type {FileSystemInfo***REMOVED*** */
		let fileSystemInfo;
		/** @type {SnapshotOptions | undefined***REMOVED*** */
		let snapshotOptions;
		let realResolves = 0;
		let cachedResolves = 0;
		let cacheInvalidResolves = 0;
		let concurrentResolves = 0;
		compiler.hooks.thisCompilation.tap(PLUGIN_NAME, compilation => {
			snapshotOptions = compilation.options.snapshot.resolve;
			fileSystemInfo = compilation.fileSystemInfo;
			compilation.hooks.finishModules.tap(PLUGIN_NAME, () => {
				if (realResolves + cachedResolves > 0) {
					const logger = compilation.getLogger(`webpack.${PLUGIN_NAME***REMOVED***`);
					logger.log(
						`${Math.round(
							(100 * realResolves) / (realResolves + cachedResolves)
						)***REMOVED***% really resolved (${realResolves***REMOVED*** real resolves with ${cacheInvalidResolves***REMOVED*** cached but invalid, ${cachedResolves***REMOVED*** cached valid, ${concurrentResolves***REMOVED*** concurrent)`
					);
					realResolves = 0;
					cachedResolves = 0;
					cacheInvalidResolves = 0;
					concurrentResolves = 0;
				***REMOVED***
			***REMOVED***);
		***REMOVED***);

		/** @typedef {(err?: Error | null, resolveRequest?: ResolveRequest | null) => void***REMOVED*** Callback */
		/** @typedef {ResolveRequest & { _ResolverCachePluginCacheMiss: true ***REMOVED******REMOVED*** ResolveRequestWithCacheMiss */

		/**
		 * @param {ItemCacheFacade***REMOVED*** itemCache cache
		 * @param {Resolver***REMOVED*** resolver the resolver
		 * @param {ResolveContext***REMOVED*** resolveContext context for resolving meta info
		 * @param {ResolveRequest***REMOVED*** request the request info object
		 * @param {Callback***REMOVED*** callback callback function
		 * @returns {void***REMOVED***
		 */
		const doRealResolve = (
			itemCache,
			resolver,
			resolveContext,
			request,
			callback
		) => {
			realResolves++;
			const newRequest =
				/** @type {ResolveRequestWithCacheMiss***REMOVED*** */
				({
					_ResolverCachePluginCacheMiss: true,
					...request
				***REMOVED***);
			/** @type {ResolveContext***REMOVED*** */
			const newResolveContext = {
				...resolveContext,
				stack: new Set(),
				/** @type {LazySet<string>***REMOVED*** */
				missingDependencies: new LazySet(),
				/** @type {LazySet<string>***REMOVED*** */
				fileDependencies: new LazySet(),
				/** @type {LazySet<string>***REMOVED*** */
				contextDependencies: new LazySet()
			***REMOVED***;
			/** @type {ResolveRequest[] | undefined***REMOVED*** */
			let yieldResult;
			let withYield = false;
			if (typeof newResolveContext.yield === "function") {
				yieldResult = [];
				withYield = true;
				newResolveContext.yield = obj =>
					/** @type {ResolveRequest[]***REMOVED*** */
					(yieldResult).push(obj);
			***REMOVED***
			/**
			 * @param {"fileDependencies" | "contextDependencies" | "missingDependencies"***REMOVED*** key key
			 */
			const propagate = key => {
				if (resolveContext[key]) {
					addAllToSet(
						/** @type {Set<string>***REMOVED*** */ (resolveContext[key]),
						/** @type {Set<string>***REMOVED*** */ (newResolveContext[key])
					);
				***REMOVED***
			***REMOVED***;
			const resolveTime = Date.now();
			resolver.doResolve(
				resolver.hooks.resolve,
				newRequest,
				"Cache miss",
				newResolveContext,
				(err, result) => {
					propagate("fileDependencies");
					propagate("contextDependencies");
					propagate("missingDependencies");
					if (err) return callback(err);
					const fileDependencies = newResolveContext.fileDependencies;
					const contextDependencies = newResolveContext.contextDependencies;
					const missingDependencies = newResolveContext.missingDependencies;
					fileSystemInfo.createSnapshot(
						resolveTime,
						/** @type {Set<string>***REMOVED*** */
						(fileDependencies),
						/** @type {Set<string>***REMOVED*** */
						(contextDependencies),
						/** @type {Set<string>***REMOVED*** */
						(missingDependencies),
						snapshotOptions,
						(err, snapshot) => {
							if (err) return callback(err);
							const resolveResult = withYield ? yieldResult : result;
							// since we intercept resolve hook
							// we still can get result in callback
							if (withYield && result)
								/** @type {ResolveRequest[]***REMOVED*** */ (yieldResult).push(result);
							if (!snapshot) {
								if (resolveResult)
									return callback(
										null,
										/** @type {ResolveRequest***REMOVED*** */
										(resolveResult)
									);
								return callback();
							***REMOVED***
							itemCache.store(
								new CacheEntry(
									/** @type {ResolveRequest***REMOVED*** */
									(resolveResult),
									snapshot
								),
								storeErr => {
									if (storeErr) return callback(storeErr);
									if (resolveResult)
										return callback(
											null,
											/** @type {ResolveRequest***REMOVED*** */
											(resolveResult)
										);
									callback();
								***REMOVED***
							);
						***REMOVED***
					);
				***REMOVED***
			);
		***REMOVED***;
		compiler.resolverFactory.hooks.resolver.intercept({
			factory(type, _hook) {
				/** @typedef {(err?: Error, resolveRequest?: ResolveRequest) => void***REMOVED*** ActiveRequest */
				/** @type {Map<string, ActiveRequest[]>***REMOVED*** */
				const activeRequests = new Map();
				/** @type {Map<string, [ActiveRequest[], Yield[]]>***REMOVED*** */
				const activeRequestsWithYield = new Map();
				const hook =
					/** @type {SyncHook<[Resolver, ResolveOptions, ResolveOptionsWithDependencyType]>***REMOVED*** */
					(_hook);
				hook.tap(PLUGIN_NAME, (resolver, options, userOptions) => {
					if (
						/** @type {ResolveOptions & { cache: boolean ***REMOVED******REMOVED*** */
						(options).cache !== true
					)
						return;
					const optionsIdent = objectToString(userOptions, false);
					const cacheWithContext =
						options.cacheWithContext !== undefined
							? options.cacheWithContext
							: false;
					resolver.hooks.resolve.tapAsync(
						{
							name: PLUGIN_NAME,
							stage: -100
						***REMOVED***,
						(request, resolveContext, callback) => {
							if (
								/** @type {ResolveRequestWithCacheMiss***REMOVED*** */
								(request)._ResolverCachePluginCacheMiss ||
								!fileSystemInfo
							) {
								return callback();
							***REMOVED***
							const withYield = typeof resolveContext.yield === "function";
							const identifier = `${type***REMOVED***${
								withYield ? "|yield" : "|default"
							***REMOVED***${optionsIdent***REMOVED***${objectToString(request, !cacheWithContext)***REMOVED***`;

							if (withYield) {
								const activeRequest = activeRequestsWithYield.get(identifier);
								if (activeRequest) {
									activeRequest[0].push(callback);
									activeRequest[1].push(
										/** @type {Yield***REMOVED*** */
										(resolveContext.yield)
									);
									return;
								***REMOVED***
							***REMOVED*** else {
								const activeRequest = activeRequests.get(identifier);
								if (activeRequest) {
									activeRequest.push(callback);
									return;
								***REMOVED***
							***REMOVED***
							const itemCache = cache.getItemCache(identifier, null);
							/** @type {Callback[] | false | undefined***REMOVED*** */
							let callbacks;
							/** @type {Yield[] | undefined***REMOVED*** */
							let yields;

							/**
							 * @type {(err?: Error | null, result?: ResolveRequest | ResolveRequest[] | null) => void***REMOVED***
							 */
							const done = withYield
								? (err, result) => {
										if (callbacks === undefined) {
											if (err) {
												callback(err);
											***REMOVED*** else {
												if (result)
													for (const r of /** @type {ResolveRequest[]***REMOVED*** */ (
														result
													)) {
														/** @type {Yield***REMOVED*** */
														(resolveContext.yield)(r);
													***REMOVED***
												callback(null, null);
											***REMOVED***
											yields = undefined;
											callbacks = false;
										***REMOVED*** else {
											const definedCallbacks =
												/** @type {Callback[]***REMOVED*** */
												(callbacks);

											if (err) {
												for (const cb of definedCallbacks) cb(err);
											***REMOVED*** else {
												for (let i = 0; i < definedCallbacks.length; i++) {
													const cb = definedCallbacks[i];
													const yield_ = /** @type {Yield[]***REMOVED*** */ (yields)[i];
													if (result)
														for (const r of /** @type {ResolveRequest[]***REMOVED*** */ (
															result
														))
															yield_(r);
													cb(null, null);
												***REMOVED***
											***REMOVED***
											activeRequestsWithYield.delete(identifier);
											yields = undefined;
											callbacks = false;
										***REMOVED***
									***REMOVED***
								: (err, result) => {
										if (callbacks === undefined) {
											callback(err, /** @type {ResolveRequest***REMOVED*** */ (result));
											callbacks = false;
										***REMOVED*** else {
											for (const callback of /** @type {Callback[]***REMOVED*** */ (
												callbacks
											)) {
												callback(err, /** @type {ResolveRequest***REMOVED*** */ (result));
											***REMOVED***
											activeRequests.delete(identifier);
											callbacks = false;
										***REMOVED***
									***REMOVED***;
							/**
							 * @param {(Error | null)=***REMOVED*** err error if any
							 * @param {(CacheEntry | null)=***REMOVED*** cacheEntry cache entry
							 * @returns {void***REMOVED***
							 */
							const processCacheResult = (err, cacheEntry) => {
								if (err) return done(err);

								if (cacheEntry) {
									const { snapshot, result ***REMOVED*** = cacheEntry;
									fileSystemInfo.checkSnapshotValid(snapshot, (err, valid) => {
										if (err || !valid) {
											cacheInvalidResolves++;
											return doRealResolve(
												itemCache,
												resolver,
												resolveContext,
												request,
												done
											);
										***REMOVED***
										cachedResolves++;
										if (resolveContext.missingDependencies) {
											addAllToSet(
												/** @type {Set<string>***REMOVED*** */
												(resolveContext.missingDependencies),
												snapshot.getMissingIterable()
											);
										***REMOVED***
										if (resolveContext.fileDependencies) {
											addAllToSet(
												/** @type {Set<string>***REMOVED*** */
												(resolveContext.fileDependencies),
												snapshot.getFileIterable()
											);
										***REMOVED***
										if (resolveContext.contextDependencies) {
											addAllToSet(
												/** @type {Set<string>***REMOVED*** */
												(resolveContext.contextDependencies),
												snapshot.getContextIterable()
											);
										***REMOVED***
										done(null, result);
									***REMOVED***);
								***REMOVED*** else {
									doRealResolve(
										itemCache,
										resolver,
										resolveContext,
										request,
										done
									);
								***REMOVED***
							***REMOVED***;
							itemCache.get(processCacheResult);
							if (withYield && callbacks === undefined) {
								callbacks = [callback];
								yields = [/** @type {Yield***REMOVED*** */ (resolveContext.yield)];
								activeRequestsWithYield.set(identifier, [callbacks, yields]);
							***REMOVED*** else if (callbacks === undefined) {
								callbacks = [callback];
								activeRequests.set(identifier, callbacks);
							***REMOVED***
						***REMOVED***
					);
				***REMOVED***);
				return hook;
			***REMOVED***
		***REMOVED***);
	***REMOVED***
***REMOVED***

module.exports = ResolverCachePlugin;
