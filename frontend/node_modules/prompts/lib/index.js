'use strict';

const prompts = require('./prompts');

const passOn = ['suggest', 'format', 'onState', 'validate', 'onRender', 'type'];
const noop = () => {***REMOVED***;

/**
 * Prompt for a series of questions
 * @param {Array|Object***REMOVED*** questions Single question object or Array of question objects
 * @param {Function***REMOVED*** [onSubmit] Callback function called on prompt submit
 * @param {Function***REMOVED*** [onCancel] Callback function called on cancel/abort
 * @returns {Object***REMOVED*** Object with values from user input
 */
async function prompt(questions=[], { onSubmit=noop, onCancel=noop ***REMOVED***={***REMOVED***) {
  const answers = {***REMOVED***;
  const override = prompt._override || {***REMOVED***;
  questions = [].concat(questions);
  let answer, question, quit, name, type, lastPrompt;

  const getFormattedAnswer = async (question, answer, skipValidation = false) => {
    if (!skipValidation && question.validate && question.validate(answer) !== true) {
      return;
    ***REMOVED***
    return question.format ? await question.format(answer, answers) : answer
  ***REMOVED***;

  for (question of questions) {
    ({ name, type ***REMOVED*** = question);

    // evaluate type first and skip if type is a falsy value
    if (typeof type === 'function') {
      type = await type(answer, { ...answers ***REMOVED***, question)
      question['type'] = type
    ***REMOVED***
    if (!type) continue;

    // if property is a function, invoke it unless it's a special function
    for (let key in question) {
      if (passOn.includes(key)) continue;
      let value = question[key];
      question[key] = typeof value === 'function' ? await value(answer, { ...answers ***REMOVED***, lastPrompt) : value;
    ***REMOVED***

    lastPrompt = question;

    if (typeof question.message !== 'string') {
      throw new Error('prompt message is required');
    ***REMOVED***

    // update vars in case they changed
    ({ name, type ***REMOVED*** = question);

    if (prompts[type] === void 0) {
      throw new Error(`prompt type (${type***REMOVED***) is not defined`);
    ***REMOVED***

    if (override[question.name] !== undefined) {
      answer = await getFormattedAnswer(question, override[question.name]);
      if (answer !== undefined) {
        answers[name] = answer;
        continue;
      ***REMOVED***
    ***REMOVED***

    try {
      // Get the injected answer if there is one or prompt the user
      answer = prompt._injected ? getInjectedAnswer(prompt._injected, question.initial) : await prompts[type](question);
      answers[name] = answer = await getFormattedAnswer(question, answer, true);
      quit = await onSubmit(question, answer, answers);
    ***REMOVED*** catch (err) {
      quit = !(await onCancel(question, answers));
    ***REMOVED***

    if (quit) return answers;
  ***REMOVED***

  return answers;
***REMOVED***

function getInjectedAnswer(injected, deafultValue) {
  const answer = injected.shift();
    if (answer instanceof Error) {
      throw answer;
    ***REMOVED***

    return (answer === undefined) ? deafultValue : answer;
***REMOVED***

function inject(answers) {
  prompt._injected = (prompt._injected || []).concat(answers);
***REMOVED***

function override(answers) {
  prompt._override = Object.assign({***REMOVED***, answers);
***REMOVED***

module.exports = Object.assign(prompt, { prompt, prompts, inject, override ***REMOVED***);
