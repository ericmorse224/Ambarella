/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const identifierUtils = require("./util/identifier");

/** @typedef {import("../declarations/WebpackOptions").StatsOptions***REMOVED*** StatsOptions */
/** @typedef {import("./Compilation").CreateStatsOptionsContext***REMOVED*** CreateStatsOptionsContext */
/** @typedef {import("./Compilation").NormalizedStatsOptions***REMOVED*** NormalizedStatsOptions */
/** @typedef {import("./Stats")***REMOVED*** Stats */
/** @typedef {import("./stats/DefaultStatsFactoryPlugin").KnownStatsCompilation***REMOVED*** KnownStatsCompilation */
/** @typedef {import("./stats/DefaultStatsFactoryPlugin").StatsCompilation***REMOVED*** StatsCompilation */
/** @typedef {import("./stats/DefaultStatsFactoryPlugin").StatsError***REMOVED*** StatsError */

/**
 * @param {string***REMOVED*** str string
 * @param {string***REMOVED*** prefix pref
 * @returns {string***REMOVED*** indent
 */
const indent = (str, prefix) => {
	const rem = str.replace(/\n([^\n])/g, `\n${prefix***REMOVED***$1`);
	return prefix + rem;
***REMOVED***;

/** @typedef {{ version: boolean, hash: boolean, errorsCount: boolean, warningsCount: boolean, errors: boolean, warnings: boolean, children: NormalizedStatsOptions[] ***REMOVED******REMOVED*** ChildOptions */

class MultiStats {
	/**
	 * @param {Stats[]***REMOVED*** stats the child stats
	 */
	constructor(stats) {
		this.stats = stats;
	***REMOVED***

	get hash() {
		return this.stats.map(stat => stat.hash).join("");
	***REMOVED***

	/**
	 * @returns {boolean***REMOVED*** true if a child compilation encountered an error
	 */
	hasErrors() {
		return this.stats.some(stat => stat.hasErrors());
	***REMOVED***

	/**
	 * @returns {boolean***REMOVED*** true if a child compilation had a warning
	 */
	hasWarnings() {
		return this.stats.some(stat => stat.hasWarnings());
	***REMOVED***

	/**
	 * @param {string | boolean | StatsOptions | undefined***REMOVED*** options stats options
	 * @param {CreateStatsOptionsContext***REMOVED*** context context
	 * @returns {ChildOptions***REMOVED*** context context
	 */
	_createChildOptions(options, context) {
		const getCreateStatsOptions = () => {
			if (!options) {
				options = {***REMOVED***;
			***REMOVED***

			const { children: childrenOptions = undefined, ...baseOptions ***REMOVED*** =
				typeof options === "string"
					? { preset: options ***REMOVED***
					: /** @type {StatsOptions***REMOVED*** */ (options);

			return { childrenOptions, baseOptions ***REMOVED***;
		***REMOVED***;

		const children = this.stats.map((stat, idx) => {
			if (typeof options === "boolean") {
				return stat.compilation.createStatsOptions(options, context);
			***REMOVED***
			const { childrenOptions, baseOptions ***REMOVED*** = getCreateStatsOptions();
			const childOptions = Array.isArray(childrenOptions)
				? childrenOptions[idx]
				: childrenOptions;
			return stat.compilation.createStatsOptions(
				{
					...baseOptions,
					...(typeof childOptions === "string"
						? { preset: childOptions ***REMOVED***
						: childOptions && typeof childOptions === "object"
							? childOptions
							: undefined)
				***REMOVED***,
				context
			);
		***REMOVED***);
		return {
			version: children.every(o => o.version),
			hash: children.every(o => o.hash),
			errorsCount: children.every(o => o.errorsCount),
			warningsCount: children.every(o => o.warningsCount),
			errors: children.every(o => o.errors),
			warnings: children.every(o => o.warnings),
			children
		***REMOVED***;
	***REMOVED***

	/**
	 * @param {(string | boolean | StatsOptions)=***REMOVED*** options stats options
	 * @returns {StatsCompilation***REMOVED*** json output
	 */
	toJson(options) {
		const childOptions = this._createChildOptions(options, {
			forToString: false
		***REMOVED***);
		/** @type {KnownStatsCompilation***REMOVED*** */
		const obj = {***REMOVED***;
		obj.children = this.stats.map((stat, idx) => {
			const obj = stat.toJson(childOptions.children[idx]);
			const compilationName = stat.compilation.name;
			const name =
				compilationName &&
				identifierUtils.makePathsRelative(
					stat.compilation.compiler.context,
					compilationName,
					stat.compilation.compiler.root
				);
			obj.name = name;
			return obj;
		***REMOVED***);
		if (childOptions.version) {
			obj.version = obj.children[0].version;
		***REMOVED***
		if (childOptions.hash) {
			obj.hash = obj.children.map(j => j.hash).join("");
		***REMOVED***
		/**
		 * @param {StatsCompilation***REMOVED*** j stats error
		 * @param {StatsError***REMOVED*** obj Stats error
		 * @returns {StatsError***REMOVED*** result
		 */
		const mapError = (j, obj) => ({
			...obj,
			compilerPath: obj.compilerPath ? `${j.name***REMOVED***.${obj.compilerPath***REMOVED***` : j.name
		***REMOVED***);
		if (childOptions.errors) {
			obj.errors = [];
			for (const j of obj.children) {
				const errors =
					/** @type {NonNullable<KnownStatsCompilation["errors"]>***REMOVED*** */
					(j.errors);
				for (const i of errors) {
					obj.errors.push(mapError(j, i));
				***REMOVED***
			***REMOVED***
		***REMOVED***
		if (childOptions.warnings) {
			obj.warnings = [];
			for (const j of obj.children) {
				const warnings =
					/** @type {NonNullable<KnownStatsCompilation["warnings"]>***REMOVED*** */
					(j.warnings);
				for (const i of warnings) {
					obj.warnings.push(mapError(j, i));
				***REMOVED***
			***REMOVED***
		***REMOVED***
		if (childOptions.errorsCount) {
			obj.errorsCount = 0;
			for (const j of obj.children) {
				obj.errorsCount += /** @type {number***REMOVED*** */ (j.errorsCount);
			***REMOVED***
		***REMOVED***
		if (childOptions.warningsCount) {
			obj.warningsCount = 0;
			for (const j of obj.children) {
				obj.warningsCount += /** @type {number***REMOVED*** */ (j.warningsCount);
			***REMOVED***
		***REMOVED***
		return obj;
	***REMOVED***

	/**
	 * @param {(string | boolean | StatsOptions)=***REMOVED*** options stats options
	 * @returns {string***REMOVED*** string output
	 */
	toString(options) {
		const childOptions = this._createChildOptions(options, {
			forToString: true
		***REMOVED***);
		const results = this.stats.map((stat, idx) => {
			const str = stat.toString(childOptions.children[idx]);
			const compilationName = stat.compilation.name;
			const name =
				compilationName &&
				identifierUtils
					.makePathsRelative(
						stat.compilation.compiler.context,
						compilationName,
						stat.compilation.compiler.root
					)
					.replace(/\|/g, " ");
			if (!str) return str;
			return name ? `${name***REMOVED***:\n${indent(str, "  ")***REMOVED***` : str;
		***REMOVED***);
		return results.filter(Boolean).join("\n\n");
	***REMOVED***
***REMOVED***

module.exports = MultiStats;
