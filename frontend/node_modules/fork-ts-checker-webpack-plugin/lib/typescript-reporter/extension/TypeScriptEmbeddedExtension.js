"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const path_1 = require("path");
/**
 * It handles most of the logic required to process embedded TypeScript code (like in Vue components or MDX)
 *
 * @param embeddedExtensions List of file extensions that should be treated as an embedded TypeScript source
 *                           (for example ['.vue'])
 * @param getEmbeddedSource  Function that returns embedded TypeScript source text and extension that this file
 *                           would have if it would be a regular TypeScript file
 */
function createTypeScriptEmbeddedExtension({ embeddedExtensions, getEmbeddedSource, ***REMOVED***) {
    const embeddedSourceCache = new Map();
    function getCachedEmbeddedSource(fileName) {
        if (!embeddedSourceCache.has(fileName)) {
            embeddedSourceCache.set(fileName, getEmbeddedSource(fileName));
        ***REMOVED***
        return embeddedSourceCache.get(fileName);
    ***REMOVED***
    function parsePotentiallyEmbeddedFileName(fileName) {
        const extension = path_1.extname(fileName);
        const embeddedFileName = fileName.slice(0, fileName.length - extension.length);
        const embeddedExtension = path_1.extname(embeddedFileName);
        return {
            extension,
            embeddedFileName,
            embeddedExtension,
        ***REMOVED***;
    ***REMOVED***
    function createEmbeddedFileExists(fileExists) {
        return function embeddedFileExists(fileName) {
            const { embeddedExtension, embeddedFileName, extension ***REMOVED*** = parsePotentiallyEmbeddedFileName(fileName);
            if (embeddedExtensions.includes(embeddedExtension) && fileExists(embeddedFileName)) {
                const embeddedSource = getCachedEmbeddedSource(embeddedFileName);
                return !!(embeddedSource && embeddedSource.extension === extension);
            ***REMOVED***
            return fileExists(fileName);
        ***REMOVED***;
    ***REMOVED***
    function createEmbeddedReadFile(readFile) {
        return function embeddedReadFile(fileName, encoding) {
            const { embeddedExtension, embeddedFileName, extension ***REMOVED*** = parsePotentiallyEmbeddedFileName(fileName);
            if (embeddedExtensions.includes(embeddedExtension)) {
                const embeddedSource = getCachedEmbeddedSource(embeddedFileName);
                if (embeddedSource && embeddedSource.extension === extension) {
                    return embeddedSource.sourceText;
                ***REMOVED***
            ***REMOVED***
            return readFile(fileName, encoding);
        ***REMOVED***;
    ***REMOVED***
    return {
        extendIssues(issues) {
            return issues.map((issue) => {
                if (issue.file) {
                    const { embeddedExtension, embeddedFileName ***REMOVED*** = parsePotentiallyEmbeddedFileName(issue.file);
                    if (embeddedExtensions.includes(embeddedExtension)) {
                        return Object.assign(Object.assign({***REMOVED***, issue), { file: embeddedFileName ***REMOVED***);
                    ***REMOVED***
                ***REMOVED***
                return issue;
            ***REMOVED***);
        ***REMOVED***,
        extendWatchCompilerHost(host) {
            return Object.assign(Object.assign({***REMOVED***, host), { watchFile(fileName, callback, poolingInterval) {
                    const { embeddedExtension, embeddedFileName ***REMOVED*** = parsePotentiallyEmbeddedFileName(fileName);
                    if (embeddedExtensions.includes(embeddedExtension)) {
                        return host.watchFile(embeddedFileName, (innerFileName, eventKind) => {
                            embeddedSourceCache.delete(embeddedFileName);
                            return callback(fileName, eventKind);
                        ***REMOVED***, poolingInterval);
                    ***REMOVED***
                    else {
                        return host.watchFile(fileName, callback, poolingInterval);
                    ***REMOVED***
                ***REMOVED***, readFile: createEmbeddedReadFile(host.readFile), fileExists: createEmbeddedFileExists(host.fileExists) ***REMOVED***);
        ***REMOVED***,
        extendCompilerHost(host) {
            return Object.assign(Object.assign({***REMOVED***, host), { readFile: createEmbeddedReadFile(host.readFile), fileExists: createEmbeddedFileExists(host.fileExists) ***REMOVED***);
        ***REMOVED***,
        extendParseConfigFileHost(host) {
            return Object.assign(Object.assign({***REMOVED***, host), { readDirectory(rootDir, extensions, excludes, includes, depth) {
                    return host
                        .readDirectory(rootDir, [...extensions, ...embeddedExtensions], excludes, includes, depth)
                        .map((fileName) => {
                        const isEmbeddedFile = embeddedExtensions.some((embeddedExtension) => fileName.endsWith(embeddedExtension));
                        if (isEmbeddedFile) {
                            const embeddedSource = getCachedEmbeddedSource(fileName);
                            return embeddedSource ? `${fileName***REMOVED***${embeddedSource.extension***REMOVED***` : fileName;
                        ***REMOVED***
                        else {
                            return fileName;
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED*** ***REMOVED***);
        ***REMOVED***,
        extendDependencies(dependencies) {
            return Object.assign(Object.assign({***REMOVED***, dependencies), { files: dependencies.files.map((fileName) => {
                    const { embeddedExtension, embeddedFileName, extension, ***REMOVED*** = parsePotentiallyEmbeddedFileName(fileName);
                    if (embeddedExtensions.includes(embeddedExtension)) {
                        const embeddedSource = getCachedEmbeddedSource(embeddedFileName);
                        if (embeddedSource && embeddedSource.extension === extension) {
                            return embeddedFileName;
                        ***REMOVED***
                    ***REMOVED***
                    return fileName;
                ***REMOVED***), extensions: [...dependencies.extensions, ...embeddedExtensions] ***REMOVED***);
        ***REMOVED***,
    ***REMOVED***;
***REMOVED***
exports.createTypeScriptEmbeddedExtension = createTypeScriptEmbeddedExtension;
