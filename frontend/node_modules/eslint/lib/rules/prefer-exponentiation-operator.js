/**
 * @fileoverview Rule to disallow Math.pow in favor of the ** operator
 * @author Milos Djermanovic
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");
const { CALL, ReferenceTracker ***REMOVED*** = require("@eslint-community/eslint-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const PRECEDENCE_OF_EXPONENTIATION_EXPR = astUtils.getPrecedence({
	type: "BinaryExpression",
	operator: "**",
***REMOVED***);

/**
 * Determines whether the given node needs parens if used as the base in an exponentiation binary expression.
 * @param {ASTNode***REMOVED*** base The node to check.
 * @returns {boolean***REMOVED*** `true` if the node needs to be parenthesised.
 */
function doesBaseNeedParens(base) {
	return (
		// '**' is right-associative, parens are needed when Math.pow(a ** b, c) is converted to (a ** b) ** c
		astUtils.getPrecedence(base) <= PRECEDENCE_OF_EXPONENTIATION_EXPR ||
		// An unary operator cannot be used immediately before an exponentiation expression
		base.type === "AwaitExpression" ||
		base.type === "UnaryExpression"
	);
***REMOVED***

/**
 * Determines whether the given node needs parens if used as the exponent in an exponentiation binary expression.
 * @param {ASTNode***REMOVED*** exponent The node to check.
 * @returns {boolean***REMOVED*** `true` if the node needs to be parenthesised.
 */
function doesExponentNeedParens(exponent) {
	// '**' is right-associative, there is no need for parens when Math.pow(a, b ** c) is converted to a ** b ** c
	return astUtils.getPrecedence(exponent) < PRECEDENCE_OF_EXPONENTIATION_EXPR;
***REMOVED***

/**
 * Determines whether an exponentiation binary expression at the place of the given node would need parens.
 * @param {ASTNode***REMOVED*** node A node that would be replaced by an exponentiation binary expression.
 * @param {SourceCode***REMOVED*** sourceCode A SourceCode object.
 * @returns {boolean***REMOVED*** `true` if the expression needs to be parenthesised.
 */
function doesExponentiationExpressionNeedParens(node, sourceCode) {
	const parent =
		node.parent.type === "ChainExpression"
			? node.parent.parent
			: node.parent;

	const parentPrecedence = astUtils.getPrecedence(parent);
	const needsParens =
		parent.type === "ClassDeclaration" ||
		(parent.type.endsWith("Expression") &&
			(parentPrecedence === -1 ||
				parentPrecedence >= PRECEDENCE_OF_EXPONENTIATION_EXPR) &&
			!(
				parent.type === "BinaryExpression" &&
				parent.operator === "**" &&
				parent.right === node
			) &&
			!(
				(parent.type === "CallExpression" ||
					parent.type === "NewExpression") &&
				parent.arguments.includes(node)
			) &&
			!(
				parent.type === "MemberExpression" &&
				parent.computed &&
				parent.property === node
			) &&
			!(parent.type === "ArrayExpression"));

	return needsParens && !astUtils.isParenthesised(sourceCode, node);
***REMOVED***

/**
 * Optionally parenthesizes given text.
 * @param {string***REMOVED*** text The text to parenthesize.
 * @param {boolean***REMOVED*** shouldParenthesize If `true`, the text will be parenthesised.
 * @returns {string***REMOVED*** parenthesised or unchanged text.
 */
function parenthesizeIfShould(text, shouldParenthesize) {
	return shouldParenthesize ? `(${text***REMOVED***)` : text;
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "suggestion",

		docs: {
			description:
				"Disallow the use of `Math.pow` in favor of the `**` operator",
			recommended: false,
			frozen: true,
			url: "https://eslint.org/docs/latest/rules/prefer-exponentiation-operator",
		***REMOVED***,

		schema: [],
		fixable: "code",

		messages: {
			useExponentiation: "Use the '**' operator instead of 'Math.pow'.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const sourceCode = context.sourceCode;

		/**
		 * Reports the given node.
		 * @param {ASTNode***REMOVED*** node 'Math.pow()' node to report.
		 * @returns {void***REMOVED***
		 */
		function report(node) {
			context.report({
				node,
				messageId: "useExponentiation",
				fix(fixer) {
					if (
						node.arguments.length !== 2 ||
						node.arguments.some(
							arg => arg.type === "SpreadElement",
						) ||
						sourceCode.getCommentsInside(node).length > 0
					) {
						return null;
					***REMOVED***

					const base = node.arguments[0],
						exponent = node.arguments[1],
						baseText = sourceCode.getText(base),
						exponentText = sourceCode.getText(exponent),
						shouldParenthesizeBase = doesBaseNeedParens(base),
						shouldParenthesizeExponent =
							doesExponentNeedParens(exponent),
						shouldParenthesizeAll =
							doesExponentiationExpressionNeedParens(
								node,
								sourceCode,
							);

					let prefix = "",
						suffix = "";

					if (!shouldParenthesizeAll) {
						if (!shouldParenthesizeBase) {
							const firstReplacementToken =
									sourceCode.getFirstToken(base),
								tokenBefore = sourceCode.getTokenBefore(node);

							if (
								tokenBefore &&
								tokenBefore.range[1] === node.range[0] &&
								!astUtils.canTokensBeAdjacent(
									tokenBefore,
									firstReplacementToken,
								)
							) {
								prefix = " "; // a+Math.pow(++b, c) -> a+ ++b**c
							***REMOVED***
						***REMOVED***
						if (!shouldParenthesizeExponent) {
							const lastReplacementToken =
									sourceCode.getLastToken(exponent),
								tokenAfter = sourceCode.getTokenAfter(node);

							if (
								tokenAfter &&
								node.range[1] === tokenAfter.range[0] &&
								!astUtils.canTokensBeAdjacent(
									lastReplacementToken,
									tokenAfter,
								)
							) {
								suffix = " "; // Math.pow(a, b)in c -> a**b in c
							***REMOVED***
						***REMOVED***
					***REMOVED***

					const baseReplacement = parenthesizeIfShould(
							baseText,
							shouldParenthesizeBase,
						),
						exponentReplacement = parenthesizeIfShould(
							exponentText,
							shouldParenthesizeExponent,
						),
						replacement = parenthesizeIfShould(
							`${baseReplacement***REMOVED*****${exponentReplacement***REMOVED***`,
							shouldParenthesizeAll,
						);

					return fixer.replaceText(
						node,
						`${prefix***REMOVED***${replacement***REMOVED***${suffix***REMOVED***`,
					);
				***REMOVED***,
			***REMOVED***);
		***REMOVED***

		return {
			Program(node) {
				const scope = sourceCode.getScope(node);
				const tracker = new ReferenceTracker(scope);
				const trackMap = {
					Math: {
						pow: { [CALL]: true ***REMOVED***,
					***REMOVED***,
				***REMOVED***;

				for (const { node: refNode ***REMOVED*** of tracker.iterateGlobalReferences(
					trackMap,
				)) {
					report(refNode);
				***REMOVED***
			***REMOVED***,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
