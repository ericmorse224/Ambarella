/**
 * @fileoverview Disallow useless fragments
 */

'use strict';

const arrayIncludes = require('array-includes');

const pragmaUtil = require('../util/pragma');
const astUtil = require('../util/ast');
const jsxUtil = require('../util/jsx');
const docsUrl = require('../util/docsUrl');
const report = require('../util/report');
const getText = require('../util/eslint').getText;

function isJSXText(node) {
  return !!node && (node.type === 'JSXText' || node.type === 'Literal');
***REMOVED***

/**
 * @param {string***REMOVED*** text
 * @returns {boolean***REMOVED***
 */
function isOnlyWhitespace(text) {
  return text.trim().length === 0;
***REMOVED***

/**
 * @param {ASTNode***REMOVED*** node
 * @returns {boolean***REMOVED***
 */
function isNonspaceJSXTextOrJSXCurly(node) {
  return (isJSXText(node) && !isOnlyWhitespace(node.raw)) || node.type === 'JSXExpressionContainer';
***REMOVED***

/**
 * Somehow fragment like this is useful: <Foo content={<>ee eeee eeee ...</>***REMOVED*** />
 * @param {ASTNode***REMOVED*** node
 * @returns {boolean***REMOVED***
 */
function isFragmentWithOnlyTextAndIsNotChild(node) {
  return node.children.length === 1
    && isJSXText(node.children[0])
    && !(node.parent.type === 'JSXElement' || node.parent.type === 'JSXFragment');
***REMOVED***

/**
 * @param {string***REMOVED*** text
 * @returns {string***REMOVED***
 */
function trimLikeReact(text) {
  const leadingSpaces = /^\s*/.exec(text)[0];
  const trailingSpaces = /\s*$/.exec(text)[0];

  const start = arrayIncludes(leadingSpaces, '\n') ? leadingSpaces.length : 0;
  const end = arrayIncludes(trailingSpaces, '\n') ? text.length - trailingSpaces.length : text.length;

  return text.slice(start, end);
***REMOVED***

/**
 * Test if node is like `<Fragment key={_***REMOVED***>_</Fragment>`
 * @param {JSXElement***REMOVED*** node
 * @returns {boolean***REMOVED***
 */
function isKeyedElement(node) {
  return node.type === 'JSXElement'
    && node.openingElement.attributes
    && node.openingElement.attributes.some(jsxUtil.isJSXAttributeKey);
***REMOVED***

/**
 * @param {ASTNode***REMOVED*** node
 * @returns {boolean***REMOVED***
 */
function containsCallExpression(node) {
  return node
    && node.type === 'JSXExpressionContainer'
    && astUtil.isCallExpression(node.expression);
***REMOVED***

const messages = {
  NeedsMoreChildren: 'Fragments should contain more than one child - otherwise, thereâ€™s no need for a Fragment at all.',
  ChildOfHtmlElement: 'Passing a fragment to an HTML element is useless.',
***REMOVED***;

/** @type {import('eslint').Rule.RuleModule***REMOVED*** */
module.exports = {
  meta: {
    type: 'suggestion',
    fixable: 'code',
    docs: {
      description: 'Disallow unnecessary fragments',
      category: 'Possible Errors',
      recommended: false,
      url: docsUrl('jsx-no-useless-fragment'),
    ***REMOVED***,
    messages,
    schema: [{
      type: 'object',
      properties: {
        allowExpressions: {
          type: 'boolean',
        ***REMOVED***,
      ***REMOVED***,
    ***REMOVED***],
  ***REMOVED***,

  create(context) {
    const config = context.options[0] || {***REMOVED***;
    const allowExpressions = config.allowExpressions || false;

    const reactPragma = pragmaUtil.getFromContext(context);
    const fragmentPragma = pragmaUtil.getFragmentFromContext(context);

    /**
     * Test whether a node is an padding spaces trimmed by react runtime.
     * @param {ASTNode***REMOVED*** node
     * @returns {boolean***REMOVED***
     */
    function isPaddingSpaces(node) {
      return isJSXText(node)
        && isOnlyWhitespace(node.raw)
        && arrayIncludes(node.raw, '\n');
    ***REMOVED***

    function isFragmentWithSingleExpression(node) {
      const children = node && node.children.filter((child) => !isPaddingSpaces(child));
      return (
        children
        && children.length === 1
        && children[0].type === 'JSXExpressionContainer'
      );
    ***REMOVED***

    /**
     * Test whether a JSXElement has less than two children, excluding paddings spaces.
     * @param {JSXElement|JSXFragment***REMOVED*** node
     * @returns {boolean***REMOVED***
     */
    function hasLessThanTwoChildren(node) {
      if (!node || !node.children) {
        return true;
      ***REMOVED***

      /** @type {ASTNode[]***REMOVED*** */
      const nonPaddingChildren = node.children.filter(
        (child) => !isPaddingSpaces(child)
      );

      if (nonPaddingChildren.length < 2) {
        return !containsCallExpression(nonPaddingChildren[0]);
      ***REMOVED***
    ***REMOVED***

    /**
     * @param {JSXElement|JSXFragment***REMOVED*** node
     * @returns {boolean***REMOVED***
     */
    function isChildOfHtmlElement(node) {
      return node.parent.type === 'JSXElement'
        && node.parent.openingElement.name.type === 'JSXIdentifier'
        && /^[a-z]+$/.test(node.parent.openingElement.name.name);
    ***REMOVED***

    /**
     * @param {JSXElement|JSXFragment***REMOVED*** node
     * @return {boolean***REMOVED***
     */
    function isChildOfComponentElement(node) {
      return node.parent.type === 'JSXElement'
        && !isChildOfHtmlElement(node)
        && !jsxUtil.isFragment(node.parent, reactPragma, fragmentPragma);
    ***REMOVED***

    /**
     * @param {ASTNode***REMOVED*** node
     * @returns {boolean***REMOVED***
     */
    function canFix(node) {
      // Not safe to fix fragments without a jsx parent.
      if (!(node.parent.type === 'JSXElement' || node.parent.type === 'JSXFragment')) {
        // const a = <></>
        if (node.children.length === 0) {
          return false;
        ***REMOVED***

        // const a = <>cat {meow***REMOVED***</>
        if (node.children.some(isNonspaceJSXTextOrJSXCurly)) {
          return false;
        ***REMOVED***
      ***REMOVED***

      // Not safe to fix `<Eeee><>foo</></Eeee>` because `Eeee` might require its children be a ReactElement.
      if (isChildOfComponentElement(node)) {
        return false;
      ***REMOVED***

      // old TS parser can't handle this one
      if (node.type === 'JSXFragment' && (!node.openingFragment || !node.closingFragment)) {
        return false;
      ***REMOVED***

      return true;
    ***REMOVED***

    /**
     * @param {ASTNode***REMOVED*** node
     * @returns {Function | undefined***REMOVED***
     */
    function getFix(node) {
      if (!canFix(node)) {
        return undefined;
      ***REMOVED***

      return function fix(fixer) {
        const opener = node.type === 'JSXFragment' ? node.openingFragment : node.openingElement;
        const closer = node.type === 'JSXFragment' ? node.closingFragment : node.closingElement;

        const childrenText = opener.selfClosing ? '' : getText(context).slice(opener.range[1], closer.range[0]);

        return fixer.replaceText(node, trimLikeReact(childrenText));
      ***REMOVED***;
    ***REMOVED***

    function checkNode(node) {
      if (isKeyedElement(node)) {
        return;
      ***REMOVED***

      if (
        hasLessThanTwoChildren(node)
        && !isFragmentWithOnlyTextAndIsNotChild(node)
        && !(allowExpressions && isFragmentWithSingleExpression(node))
      ) {
        report(context, messages.NeedsMoreChildren, 'NeedsMoreChildren', {
          node,
          fix: getFix(node),
        ***REMOVED***);
      ***REMOVED***

      if (isChildOfHtmlElement(node)) {
        report(context, messages.ChildOfHtmlElement, 'ChildOfHtmlElement', {
          node,
          fix: getFix(node),
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    return {
      JSXElement(node) {
        if (jsxUtil.isFragment(node, reactPragma, fragmentPragma)) {
          checkNode(node);
        ***REMOVED***
      ***REMOVED***,
      JSXFragment: checkNode,
    ***REMOVED***;
  ***REMOVED***,
***REMOVED***;
