/**
 * @fileoverview Rule to disallow assignments to native objects or read-only global variables
 * @author Ilya Volodin
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "suggestion",

		defaultOptions: [{ exceptions: [] ***REMOVED***],

		docs: {
			description:
				"Disallow assignments to native objects or read-only global variables",
			recommended: true,
			url: "https://eslint.org/docs/latest/rules/no-global-assign",
		***REMOVED***,

		schema: [
			{
				type: "object",
				properties: {
					exceptions: {
						type: "array",
						items: { type: "string" ***REMOVED***,
						uniqueItems: true,
					***REMOVED***,
				***REMOVED***,
				additionalProperties: false,
			***REMOVED***,
		],

		messages: {
			globalShouldNotBeModified:
				"Read-only global '{{name***REMOVED******REMOVED***' should not be modified.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const sourceCode = context.sourceCode;
		const [{ exceptions ***REMOVED***] = context.options;

		/**
		 * Reports write references.
		 * @param {Reference***REMOVED*** reference A reference to check.
		 * @param {number***REMOVED*** index The index of the reference in the references.
		 * @param {Reference[]***REMOVED*** references The array that the reference belongs to.
		 * @returns {void***REMOVED***
		 */
		function checkReference(reference, index, references) {
			const identifier = reference.identifier;

			if (
				reference.init === false &&
				reference.isWrite() &&
				/*
				 * Destructuring assignments can have multiple default value,
				 * so possibly there are multiple writeable references for the same identifier.
				 */
				(index === 0 || references[index - 1].identifier !== identifier)
			) {
				context.report({
					node: identifier,
					messageId: "globalShouldNotBeModified",
					data: {
						name: identifier.name,
					***REMOVED***,
				***REMOVED***);
			***REMOVED***
		***REMOVED***

		/**
		 * Reports write references if a given variable is read-only builtin.
		 * @param {Variable***REMOVED*** variable A variable to check.
		 * @returns {void***REMOVED***
		 */
		function checkVariable(variable) {
			if (
				variable.writeable === false &&
				!exceptions.includes(variable.name)
			) {
				variable.references.forEach(checkReference);
			***REMOVED***
		***REMOVED***

		return {
			Program(node) {
				const globalScope = sourceCode.getScope(node);

				globalScope.variables.forEach(checkVariable);
			***REMOVED***,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
