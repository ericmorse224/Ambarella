/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const AsyncDependenciesBlock = require("../AsyncDependenciesBlock");
const CommentCompilationWarning = require("../CommentCompilationWarning");
const UnsupportedFeatureWarning = require("../UnsupportedFeatureWarning");
const { getImportAttributes ***REMOVED*** = require("../javascript/JavascriptParser");
const ContextDependencyHelpers = require("./ContextDependencyHelpers");
const ImportContextDependency = require("./ImportContextDependency");
const ImportDependency = require("./ImportDependency");
const ImportEagerDependency = require("./ImportEagerDependency");
const ImportWeakDependency = require("./ImportWeakDependency");

/** @typedef {import("../../declarations/WebpackOptions").JavascriptParserOptions***REMOVED*** JavascriptParserOptions */
/** @typedef {import("../ChunkGroup").RawChunkGroupOptions***REMOVED*** RawChunkGroupOptions */
/** @typedef {import("../ContextModule").ContextMode***REMOVED*** ContextMode */
/** @typedef {import("../Dependency").DependencyLocation***REMOVED*** DependencyLocation */
/** @typedef {import("../Module").BuildMeta***REMOVED*** BuildMeta */
/** @typedef {import("../javascript/JavascriptParser")***REMOVED*** JavascriptParser */
/** @typedef {import("../javascript/JavascriptParser").ImportExpression***REMOVED*** ImportExpression */
/** @typedef {import("../javascript/JavascriptParser").Range***REMOVED*** Range */

class ImportParserPlugin {
	/**
	 * @param {JavascriptParserOptions***REMOVED*** options options
	 */
	constructor(options) {
		this.options = options;
	***REMOVED***

	/**
	 * @param {JavascriptParser***REMOVED*** parser the parser
	 * @returns {void***REMOVED***
	 */
	apply(parser) {
		/**
		 * @template T
		 * @param {Iterable<T>***REMOVED*** enumerable enumerable
		 * @returns {T[][]***REMOVED*** array of array
		 */
		const exportsFromEnumerable = enumerable =>
			Array.from(enumerable, e => [e]);
		parser.hooks.importCall.tap("ImportParserPlugin", expr => {
			const param = parser.evaluateExpression(expr.source);

			let chunkName = null;
			let mode = /** @type {ContextMode***REMOVED*** */ (this.options.dynamicImportMode);
			let include = null;
			let exclude = null;
			/** @type {string[][] | null***REMOVED*** */
			let exports = null;
			/** @type {RawChunkGroupOptions***REMOVED*** */
			const groupOptions = {***REMOVED***;

			const {
				dynamicImportPreload,
				dynamicImportPrefetch,
				dynamicImportFetchPriority
			***REMOVED*** = this.options;
			if (dynamicImportPreload !== undefined && dynamicImportPreload !== false)
				groupOptions.preloadOrder =
					dynamicImportPreload === true ? 0 : dynamicImportPreload;
			if (
				dynamicImportPrefetch !== undefined &&
				dynamicImportPrefetch !== false
			)
				groupOptions.prefetchOrder =
					dynamicImportPrefetch === true ? 0 : dynamicImportPrefetch;
			if (
				dynamicImportFetchPriority !== undefined &&
				dynamicImportFetchPriority !== false
			)
				groupOptions.fetchPriority = dynamicImportFetchPriority;

			const { options: importOptions, errors: commentErrors ***REMOVED*** =
				parser.parseCommentOptions(/** @type {Range***REMOVED*** */ (expr.range));

			if (commentErrors) {
				for (const e of commentErrors) {
					const { comment ***REMOVED*** = e;
					parser.state.module.addWarning(
						new CommentCompilationWarning(
							`Compilation error while processing magic comment(-s): /*${comment.value***REMOVED****/: ${e.message***REMOVED***`,
							/** @type {DependencyLocation***REMOVED*** */ (comment.loc)
						)
					);
				***REMOVED***
			***REMOVED***

			if (importOptions) {
				if (importOptions.webpackIgnore !== undefined) {
					if (typeof importOptions.webpackIgnore !== "boolean") {
						parser.state.module.addWarning(
							new UnsupportedFeatureWarning(
								`\`webpackIgnore\` expected a boolean, but received: ${importOptions.webpackIgnore***REMOVED***.`,
								/** @type {DependencyLocation***REMOVED*** */ (expr.loc)
							)
						);
					***REMOVED*** else if (importOptions.webpackIgnore) {
						// Do not instrument `import()` if `webpackIgnore` is `true`
						return false;
					***REMOVED***
				***REMOVED***
				if (importOptions.webpackChunkName !== undefined) {
					if (typeof importOptions.webpackChunkName !== "string") {
						parser.state.module.addWarning(
							new UnsupportedFeatureWarning(
								`\`webpackChunkName\` expected a string, but received: ${importOptions.webpackChunkName***REMOVED***.`,
								/** @type {DependencyLocation***REMOVED*** */ (expr.loc)
							)
						);
					***REMOVED*** else {
						chunkName = importOptions.webpackChunkName;
					***REMOVED***
				***REMOVED***
				if (importOptions.webpackMode !== undefined) {
					if (typeof importOptions.webpackMode !== "string") {
						parser.state.module.addWarning(
							new UnsupportedFeatureWarning(
								`\`webpackMode\` expected a string, but received: ${importOptions.webpackMode***REMOVED***.`,
								/** @type {DependencyLocation***REMOVED*** */ (expr.loc)
							)
						);
					***REMOVED*** else {
						mode = /** @type {ContextMode***REMOVED*** */ (importOptions.webpackMode);
					***REMOVED***
				***REMOVED***
				if (importOptions.webpackPrefetch !== undefined) {
					if (importOptions.webpackPrefetch === true) {
						groupOptions.prefetchOrder = 0;
					***REMOVED*** else if (typeof importOptions.webpackPrefetch === "number") {
						groupOptions.prefetchOrder = importOptions.webpackPrefetch;
					***REMOVED*** else {
						parser.state.module.addWarning(
							new UnsupportedFeatureWarning(
								`\`webpackPrefetch\` expected true or a number, but received: ${importOptions.webpackPrefetch***REMOVED***.`,
								/** @type {DependencyLocation***REMOVED*** */ (expr.loc)
							)
						);
					***REMOVED***
				***REMOVED***
				if (importOptions.webpackPreload !== undefined) {
					if (importOptions.webpackPreload === true) {
						groupOptions.preloadOrder = 0;
					***REMOVED*** else if (typeof importOptions.webpackPreload === "number") {
						groupOptions.preloadOrder = importOptions.webpackPreload;
					***REMOVED*** else {
						parser.state.module.addWarning(
							new UnsupportedFeatureWarning(
								`\`webpackPreload\` expected true or a number, but received: ${importOptions.webpackPreload***REMOVED***.`,
								/** @type {DependencyLocation***REMOVED*** */ (expr.loc)
							)
						);
					***REMOVED***
				***REMOVED***
				if (importOptions.webpackFetchPriority !== undefined) {
					if (
						typeof importOptions.webpackFetchPriority === "string" &&
						["high", "low", "auto"].includes(importOptions.webpackFetchPriority)
					) {
						groupOptions.fetchPriority =
							/** @type {"low" | "high" | "auto"***REMOVED*** */
							(importOptions.webpackFetchPriority);
					***REMOVED*** else {
						parser.state.module.addWarning(
							new UnsupportedFeatureWarning(
								`\`webpackFetchPriority\` expected true or "low", "high" or "auto", but received: ${importOptions.webpackFetchPriority***REMOVED***.`,
								/** @type {DependencyLocation***REMOVED*** */ (expr.loc)
							)
						);
					***REMOVED***
				***REMOVED***
				if (importOptions.webpackInclude !== undefined) {
					if (
						!importOptions.webpackInclude ||
						!(importOptions.webpackInclude instanceof RegExp)
					) {
						parser.state.module.addWarning(
							new UnsupportedFeatureWarning(
								`\`webpackInclude\` expected a regular expression, but received: ${importOptions.webpackInclude***REMOVED***.`,
								/** @type {DependencyLocation***REMOVED*** */ (expr.loc)
							)
						);
					***REMOVED*** else {
						include = importOptions.webpackInclude;
					***REMOVED***
				***REMOVED***
				if (importOptions.webpackExclude !== undefined) {
					if (
						!importOptions.webpackExclude ||
						!(importOptions.webpackExclude instanceof RegExp)
					) {
						parser.state.module.addWarning(
							new UnsupportedFeatureWarning(
								`\`webpackExclude\` expected a regular expression, but received: ${importOptions.webpackExclude***REMOVED***.`,
								/** @type {DependencyLocation***REMOVED*** */ (expr.loc)
							)
						);
					***REMOVED*** else {
						exclude = importOptions.webpackExclude;
					***REMOVED***
				***REMOVED***
				if (importOptions.webpackExports !== undefined) {
					if (
						!(
							typeof importOptions.webpackExports === "string" ||
							(Array.isArray(importOptions.webpackExports) &&
								/** @type {string[]***REMOVED*** */ (importOptions.webpackExports).every(
									item => typeof item === "string"
								))
						)
					) {
						parser.state.module.addWarning(
							new UnsupportedFeatureWarning(
								`\`webpackExports\` expected a string or an array of strings, but received: ${importOptions.webpackExports***REMOVED***.`,
								/** @type {DependencyLocation***REMOVED*** */ (expr.loc)
							)
						);
					***REMOVED*** else if (typeof importOptions.webpackExports === "string") {
						exports = [[importOptions.webpackExports]];
					***REMOVED*** else {
						exports = exportsFromEnumerable(importOptions.webpackExports);
					***REMOVED***
				***REMOVED***
			***REMOVED***

			if (
				mode !== "lazy" &&
				mode !== "lazy-once" &&
				mode !== "eager" &&
				mode !== "weak"
			) {
				parser.state.module.addWarning(
					new UnsupportedFeatureWarning(
						`\`webpackMode\` expected 'lazy', 'lazy-once', 'eager' or 'weak', but received: ${mode***REMOVED***.`,
						/** @type {DependencyLocation***REMOVED*** */ (expr.loc)
					)
				);
				mode = "lazy";
			***REMOVED***

			const referencedPropertiesInDestructuring =
				parser.destructuringAssignmentPropertiesFor(expr);
			if (referencedPropertiesInDestructuring) {
				if (exports) {
					parser.state.module.addWarning(
						new UnsupportedFeatureWarning(
							"`webpackExports` could not be used with destructuring assignment.",
							/** @type {DependencyLocation***REMOVED*** */ (expr.loc)
						)
					);
				***REMOVED***
				exports = exportsFromEnumerable(
					[...referencedPropertiesInDestructuring].map(({ id ***REMOVED***) => id)
				);
			***REMOVED***

			if (param.isString()) {
				const attributes = getImportAttributes(expr);

				if (mode === "eager") {
					const dep = new ImportEagerDependency(
						/** @type {string***REMOVED*** */ (param.string),
						/** @type {Range***REMOVED*** */ (expr.range),
						exports,
						attributes
					);
					parser.state.current.addDependency(dep);
				***REMOVED*** else if (mode === "weak") {
					const dep = new ImportWeakDependency(
						/** @type {string***REMOVED*** */ (param.string),
						/** @type {Range***REMOVED*** */ (expr.range),
						exports,
						attributes
					);
					parser.state.current.addDependency(dep);
				***REMOVED*** else {
					const depBlock = new AsyncDependenciesBlock(
						{
							...groupOptions,
							name: chunkName
						***REMOVED***,
						/** @type {DependencyLocation***REMOVED*** */ (expr.loc),
						param.string
					);
					const dep = new ImportDependency(
						/** @type {string***REMOVED*** */ (param.string),
						/** @type {Range***REMOVED*** */ (expr.range),
						exports,
						attributes
					);
					dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expr.loc);
					dep.optional = Boolean(parser.scope.inTry);
					depBlock.addDependency(dep);
					parser.state.current.addBlock(depBlock);
				***REMOVED***
				return true;
			***REMOVED***
			if (mode === "weak") {
				mode = "async-weak";
			***REMOVED***
			const dep = ContextDependencyHelpers.create(
				ImportContextDependency,
				/** @type {Range***REMOVED*** */ (expr.range),
				param,
				expr,
				this.options,
				{
					chunkName,
					groupOptions,
					include,
					exclude,
					mode,
					namespaceObject: /** @type {BuildMeta***REMOVED*** */ (
						parser.state.module.buildMeta
					).strictHarmonyModule
						? "strict"
						: true,
					typePrefix: "import()",
					category: "esm",
					referencedExports: exports,
					attributes: getImportAttributes(expr)
				***REMOVED***,
				parser
			);
			if (!dep) return;
			dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expr.loc);
			dep.optional = Boolean(parser.scope.inTry);
			parser.state.current.addDependency(dep);
			return true;
		***REMOVED***);
	***REMOVED***
***REMOVED***

module.exports = ImportParserPlugin;
