/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { RawSource ***REMOVED*** = require("webpack-sources");
const Generator = require("../Generator");
const InitFragment = require("../InitFragment");
const { WEBASSEMBLY_TYPES ***REMOVED*** = require("../ModuleSourceTypesConstants");
const RuntimeGlobals = require("../RuntimeGlobals");
const Template = require("../Template");
const WebAssemblyImportDependency = require("../dependencies/WebAssemblyImportDependency");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../../declarations/WebpackOptions").OutputNormalized***REMOVED*** OutputOptions */
/** @typedef {import("../DependencyTemplates")***REMOVED*** DependencyTemplates */
/** @typedef {import("../Generator").GenerateContext***REMOVED*** GenerateContext */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../Module").SourceTypes***REMOVED*** SourceTypes */
/** @typedef {import("../NormalModule")***REMOVED*** NormalModule */
/** @typedef {import("../RuntimeTemplate")***REMOVED*** RuntimeTemplate */

/**
 * @typedef {{ request: string, importVar: string ***REMOVED******REMOVED*** ImportObjRequestItem
 */

class AsyncWebAssemblyJavascriptGenerator extends Generator {
	/**
	 * @param {OutputOptions["webassemblyModuleFilename"]***REMOVED*** filenameTemplate template for the WebAssembly module filename
	 */
	constructor(filenameTemplate) {
		super();
		this.filenameTemplate = filenameTemplate;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module fresh module
	 * @returns {SourceTypes***REMOVED*** available types (do not mutate)
	 */
	getTypes(module) {
		return WEBASSEMBLY_TYPES;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module the module
	 * @param {string=***REMOVED*** type source type
	 * @returns {number***REMOVED*** estimate size of the module
	 */
	getSize(module, type) {
		return 40 + module.dependencies.length * 10;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module module for which the code should be generated
	 * @param {GenerateContext***REMOVED*** generateContext context for generate
	 * @returns {Source | null***REMOVED*** generated code
	 */
	generate(module, generateContext) {
		const {
			runtimeTemplate,
			chunkGraph,
			moduleGraph,
			runtimeRequirements,
			runtime
		***REMOVED*** = generateContext;
		runtimeRequirements.add(RuntimeGlobals.module);
		runtimeRequirements.add(RuntimeGlobals.moduleId);
		runtimeRequirements.add(RuntimeGlobals.exports);
		runtimeRequirements.add(RuntimeGlobals.instantiateWasm);
		/** @type {InitFragment<InitFragment<string>>[]***REMOVED*** */
		const initFragments = [];
		/** @type {Map<Module, ImportObjRequestItem>***REMOVED*** */
		const depModules = new Map();
		/** @type {Map<string, WebAssemblyImportDependency[]>***REMOVED*** */
		const wasmDepsByRequest = new Map();
		for (const dep of module.dependencies) {
			if (dep instanceof WebAssemblyImportDependency) {
				const module = /** @type {Module***REMOVED*** */ (moduleGraph.getModule(dep));
				if (!depModules.has(module)) {
					depModules.set(module, {
						request: dep.request,
						importVar: `WEBPACK_IMPORTED_MODULE_${depModules.size***REMOVED***`
					***REMOVED***);
				***REMOVED***
				let list = wasmDepsByRequest.get(dep.request);
				if (list === undefined) {
					list = [];
					wasmDepsByRequest.set(dep.request, list);
				***REMOVED***
				list.push(dep);
			***REMOVED***
		***REMOVED***

		/** @type {Array<string>***REMOVED*** */
		const promises = [];

		const importStatements = Array.from(
			depModules,
			([importedModule, { request, importVar ***REMOVED***]) => {
				if (moduleGraph.isAsync(importedModule)) {
					promises.push(importVar);
				***REMOVED***
				return runtimeTemplate.importStatement({
					update: false,
					module: importedModule,
					chunkGraph,
					request,
					originModule: module,
					importVar,
					runtimeRequirements
				***REMOVED***);
			***REMOVED***
		);
		const importsCode = importStatements.map(([x]) => x).join("");
		const importsCompatCode = importStatements.map(([_, x]) => x).join("");

		const importObjRequestItems = Array.from(
			wasmDepsByRequest,
			([request, deps]) => {
				const exportItems = deps.map(dep => {
					const importedModule =
						/** @type {Module***REMOVED*** */
						(moduleGraph.getModule(dep));
					const importVar =
						/** @type {ImportObjRequestItem***REMOVED*** */
						(depModules.get(importedModule)).importVar;
					return `${JSON.stringify(
						dep.name
					)***REMOVED***: ${runtimeTemplate.exportFromImport({
						moduleGraph,
						module: importedModule,
						request,
						exportName: dep.name,
						originModule: module,
						asiSafe: true,
						isCall: false,
						callContext: false,
						defaultInterop: true,
						importVar,
						initFragments,
						runtime,
						runtimeRequirements
					***REMOVED***)***REMOVED***`;
				***REMOVED***);
				return Template.asString([
					`${JSON.stringify(request)***REMOVED***: {`,
					Template.indent(exportItems.join(",\n")),
					"***REMOVED***"
				]);
			***REMOVED***
		);

		const importsObj =
			importObjRequestItems.length > 0
				? Template.asString([
						"{",
						Template.indent(importObjRequestItems.join(",\n")),
						"***REMOVED***"
					])
				: undefined;

		const instantiateCall = `${RuntimeGlobals.instantiateWasm***REMOVED***(${module.exportsArgument***REMOVED***, ${
			module.moduleArgument
		***REMOVED***.id, ${JSON.stringify(
			chunkGraph.getRenderedModuleHash(module, runtime)
		)***REMOVED***${importsObj ? `, ${importsObj***REMOVED***)` : ")"***REMOVED***`;

		if (promises.length > 0)
			runtimeRequirements.add(RuntimeGlobals.asyncModule);

		const source = new RawSource(
			promises.length > 0
				? Template.asString([
						`var __webpack_instantiate__ = ${runtimeTemplate.basicFunction(
							`[${promises.join(", ")***REMOVED***]`,
							`${importsCompatCode***REMOVED***return ${instantiateCall***REMOVED***;`
						)***REMOVED***`,
						`${RuntimeGlobals.asyncModule***REMOVED***(${
							module.moduleArgument
						***REMOVED***, async ${runtimeTemplate.basicFunction(
							"__webpack_handle_async_dependencies__, __webpack_async_result__",
							[
								"try {",
								importsCode,
								`var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([${promises.join(
									", "
								)***REMOVED***]);`,
								`var [${promises.join(
									", "
								)***REMOVED***] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__;`,
								`${importsCompatCode***REMOVED***await ${instantiateCall***REMOVED***;`,
								"__webpack_async_result__();",
								"***REMOVED*** catch(e) { __webpack_async_result__(e); ***REMOVED***"
							]
						)***REMOVED***, 1);`
					])
				: `${importsCode***REMOVED***${importsCompatCode***REMOVED***module.exports = ${instantiateCall***REMOVED***;`
		);

		return InitFragment.addToSource(source, initFragments, generateContext);
	***REMOVED***

	/**
	 * @param {Error***REMOVED*** error the error
	 * @param {NormalModule***REMOVED*** module module for which the code should be generated
	 * @param {GenerateContext***REMOVED*** generateContext context for generate
	 * @returns {Source | null***REMOVED*** generated code
	 */
	generateError(error, module, generateContext) {
		return new RawSource(`throw new Error(${JSON.stringify(error.message)***REMOVED***);`);
	***REMOVED***
***REMOVED***

module.exports = AsyncWebAssemblyJavascriptGenerator;
