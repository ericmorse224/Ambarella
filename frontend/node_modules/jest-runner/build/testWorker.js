'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
***REMOVED***);
exports.setup = setup;
exports.worker = worker;

function _exit() {
  const data = _interopRequireDefault(require('exit'));

  _exit = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

function _jestHasteMap() {
  const data = _interopRequireDefault(require('jest-haste-map'));

  _jestHasteMap = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

function _jestMessageUtil() {
  const data = require('jest-message-util');

  _jestMessageUtil = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

function _jestRuntime() {
  const data = _interopRequireDefault(require('jest-runtime'));

  _jestRuntime = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

function _jestWorker() {
  const data = require('jest-worker');

  _jestWorker = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

var _runTest = _interopRequireDefault(require('./runTest'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj***REMOVED***;
***REMOVED***

/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
// Make sure uncaught errors are logged before we exit.
process.on('uncaughtException', err => {
  console.error(err.stack);
  (0, _exit().default)(1);
***REMOVED***);

const formatError = error => {
  if (typeof error === 'string') {
    const {message, stack***REMOVED*** = (0, _jestMessageUtil().separateMessageFromStack)(
      error
    );
    return {
      message,
      stack,
      type: 'Error'
    ***REMOVED***;
  ***REMOVED***

  return {
    code: error.code || undefined,
    message: error.message,
    stack: error.stack,
    type: 'Error'
  ***REMOVED***;
***REMOVED***;

const resolvers = new Map();

const getResolver = config => {
  const resolver = resolvers.get(config.name);

  if (!resolver) {
    throw new Error('Cannot find resolver for: ' + config.name);
  ***REMOVED***

  return resolver;
***REMOVED***;

function setup(setupData) {
  // Module maps that will be needed for the test runs are passed.
  for (const {
    config,
    serializableModuleMap
  ***REMOVED*** of setupData.serializableResolvers) {
    const moduleMap = _jestHasteMap()
      .default.getStatic(config)
      .getModuleMapFromJSON(serializableModuleMap);

    resolvers.set(
      config.name,
      _jestRuntime().default.createResolver(config, moduleMap)
    );
  ***REMOVED***
***REMOVED***

const sendMessageToJest = (eventName, args) => {
  (0, _jestWorker().messageParent)([eventName, args]);
***REMOVED***;

async function worker({config, globalConfig, path, context***REMOVED***) {
  try {
    return await (0, _runTest.default)(
      path,
      globalConfig,
      config,
      getResolver(config),
      context && {
        ...context,
        changedFiles: context.changedFiles && new Set(context.changedFiles),
        sourcesRelatedToTestsInChangedFiles:
          context.sourcesRelatedToTestsInChangedFiles &&
          new Set(context.sourcesRelatedToTestsInChangedFiles)
      ***REMOVED***,
      sendMessageToJest
    );
  ***REMOVED*** catch (error) {
    throw formatError(error);
  ***REMOVED***
***REMOVED***
