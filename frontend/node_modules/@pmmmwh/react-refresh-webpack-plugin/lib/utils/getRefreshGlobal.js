const { getRefreshGlobalScope ***REMOVED*** = require('../globals');

/**
 * @typedef {Object***REMOVED*** RuntimeTemplate
 * @property {function(string, string[]): string***REMOVED*** basicFunction
 * @property {function(): boolean***REMOVED*** supportsConst
 * @property {function(string, string=): string***REMOVED*** returningFunction
 */

/**
 * Generates the refresh global runtime template.
 * @param {import('webpack').Template***REMOVED*** Template The template helpers.
 * @param {Record<string, string>***REMOVED*** [RuntimeGlobals] The runtime globals.
 * @param {RuntimeTemplate***REMOVED*** [RuntimeTemplate] The runtime template helpers.
 * @returns {string***REMOVED*** The refresh global runtime template.
 */
function getRefreshGlobal(
  Template,
  RuntimeGlobals = {***REMOVED***,
  RuntimeTemplate = {
    basicFunction(args, body) {
      return `function(${args***REMOVED***) {\n${Template.indent(body)***REMOVED***\n***REMOVED***`;
    ***REMOVED***,
    supportsConst() {
      return false;
    ***REMOVED***,
    returningFunction(returnValue, args = '') {
      return `function(${args***REMOVED***) { return ${returnValue***REMOVED***; ***REMOVED***`;
    ***REMOVED***,
  ***REMOVED***
) {
  const declaration = RuntimeTemplate.supportsConst() ? 'const' : 'var';
  const refreshGlobal = getRefreshGlobalScope(RuntimeGlobals);
  return Template.asString([
    `${refreshGlobal***REMOVED*** = {`,
    Template.indent([
      // Lifecycle methods - They should be specific per module and restored after module execution.
      // These stubs ensure unwanted calls (e.g. unsupported patterns, broken transform) would not error out.
      // If the current module is processed by our loader,
      // they will be swapped in place during module initialisation by the `setup` method below.
      `register: ${RuntimeTemplate.returningFunction('undefined')***REMOVED***,`,
      `signature: ${RuntimeTemplate.returningFunction(
        RuntimeTemplate.returningFunction('type', 'type')
      )***REMOVED***,`,
      // Runtime - This should be a singleton and persist throughout the lifetime of the app.
      // This stub ensures calls to `runtime` would not error out.
      // If any module within the bundle is processed by our loader,
      // it will be swapped in place via an injected import.
      'runtime: {',
      Template.indent([
        `createSignatureFunctionForTransform: ${RuntimeTemplate.returningFunction(
          RuntimeTemplate.returningFunction('type', 'type')
        )***REMOVED***,`,
        `register: ${RuntimeTemplate.returningFunction('undefined')***REMOVED***`,
      ]),
      '***REMOVED***,',
      // Setup - This handles initialisation of the global runtime.
      // It should never be touched throughout the lifetime of the app.
      `setup: ${RuntimeTemplate.basicFunction('currentModuleId', [
        // Store all previous values for fields on `refreshGlobal` -
        // this allows proper restoration in the `cleanup` phase.
        `${declaration***REMOVED*** prevModuleId = ${refreshGlobal***REMOVED***.moduleId;`,
        `${declaration***REMOVED*** prevRegister = ${refreshGlobal***REMOVED***.register;`,
        `${declaration***REMOVED*** prevSignature = ${refreshGlobal***REMOVED***.signature;`,
        `${declaration***REMOVED*** prevCleanup = ${refreshGlobal***REMOVED***.cleanup;`,
        '',
        `${refreshGlobal***REMOVED***.moduleId = currentModuleId;`,
        '',
        `${refreshGlobal***REMOVED***.register = ${RuntimeTemplate.basicFunction('type, id', [
          `${declaration***REMOVED*** typeId = currentModuleId + " " + id;`,
          `${refreshGlobal***REMOVED***.runtime.register(type, typeId);`,
        ])***REMOVED***`,
        '',
        `${refreshGlobal***REMOVED***.signature = ${RuntimeTemplate.returningFunction(
          `${refreshGlobal***REMOVED***.runtime.createSignatureFunctionForTransform()`
        )***REMOVED***;`,
        '',
        `${refreshGlobal***REMOVED***.cleanup = ${RuntimeTemplate.basicFunction('cleanupModuleId', [
          // Only cleanup if the module IDs match.
          // In rare cases, it might get called in another module's `cleanup` phase.
          'if (currentModuleId === cleanupModuleId) {',
          Template.indent([
            `${refreshGlobal***REMOVED***.moduleId = prevModuleId;`,
            `${refreshGlobal***REMOVED***.register = prevRegister;`,
            `${refreshGlobal***REMOVED***.signature = prevSignature;`,
            `${refreshGlobal***REMOVED***.cleanup = prevCleanup;`,
          ]),
          '***REMOVED***',
        ])***REMOVED***`,
      ])***REMOVED***`,
    ]),
    '***REMOVED***;',
  ]);
***REMOVED***

module.exports = getRefreshGlobal;
