"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.default = _default;
function helpers() {
  const data = require("@babel/helpers");
  helpers = function () {
    return data;
  ***REMOVED***;
  return data;
***REMOVED***
function _generator() {
  const data = require("@babel/generator");
  _generator = function () {
    return data;
  ***REMOVED***;
  return data;
***REMOVED***
function _template() {
  const data = require("@babel/template");
  _template = function () {
    return data;
  ***REMOVED***;
  return data;
***REMOVED***
function _t() {
  const data = require("@babel/types");
  _t = function () {
    return data;
  ***REMOVED***;
  return data;
***REMOVED***
const {
  arrayExpression,
  assignmentExpression,
  binaryExpression,
  blockStatement,
  callExpression,
  cloneNode,
  conditionalExpression,
  exportNamedDeclaration,
  exportSpecifier,
  expressionStatement,
  functionExpression,
  identifier,
  memberExpression,
  objectExpression,
  program,
  stringLiteral,
  unaryExpression,
  variableDeclaration,
  variableDeclarator
***REMOVED*** = _t();
const buildUmdWrapper = replacements => _template().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      ***REMOVED*** else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      ***REMOVED*** else {
        factory(BROWSER_ARGUMENTS);
      ***REMOVED***
    ***REMOVED***)(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    ***REMOVED***);
  `(replacements);
function buildGlobal(allowlist) {
  const namespace = identifier("babelHelpers");
  const body = [];
  const container = functionExpression(null, [identifier("global")], blockStatement(body));
  const tree = program([expressionStatement(callExpression(container, [conditionalExpression(binaryExpression("===", unaryExpression("typeof", identifier("global")), stringLiteral("undefined")), identifier("self"), identifier("global"))]))]);
  body.push(variableDeclaration("var", [variableDeclarator(namespace, assignmentExpression("=", memberExpression(identifier("global"), namespace), objectExpression([])))]));
  buildHelpers(body, namespace, allowlist);
  return tree;
***REMOVED***
function buildModule(allowlist) {
  const body = [];
  const refs = buildHelpers(body, null, allowlist);
  body.unshift(exportNamedDeclaration(null, Object.keys(refs).map(name => {
    return exportSpecifier(cloneNode(refs[name]), identifier(name));
  ***REMOVED***)));
  return program(body, [], "module");
***REMOVED***
function buildUmd(allowlist) {
  const namespace = identifier("babelHelpers");
  const body = [];
  body.push(variableDeclaration("var", [variableDeclarator(namespace, identifier("global"))]));
  buildHelpers(body, namespace, allowlist);
  return program([buildUmdWrapper({
    FACTORY_PARAMETERS: identifier("global"),
    BROWSER_ARGUMENTS: assignmentExpression("=", memberExpression(identifier("root"), namespace), objectExpression([])),
    COMMON_ARGUMENTS: identifier("exports"),
    AMD_ARGUMENTS: arrayExpression([stringLiteral("exports")]),
    FACTORY_BODY: body,
    UMD_ROOT: identifier("this")
  ***REMOVED***)]);
***REMOVED***
function buildVar(allowlist) {
  const namespace = identifier("babelHelpers");
  const body = [];
  body.push(variableDeclaration("var", [variableDeclarator(namespace, objectExpression([]))]));
  const tree = program(body);
  buildHelpers(body, namespace, allowlist);
  body.push(expressionStatement(namespace));
  return tree;
***REMOVED***
function buildHelpers(body, namespace, allowlist) {
  const getHelperReference = name => {
    return namespace ? memberExpression(namespace, identifier(name)) : identifier(`_${name***REMOVED***`);
  ***REMOVED***;
  const refs = {***REMOVED***;
  helpers().list.forEach(function (name) {
    if (allowlist && !allowlist.includes(name)) return;
    const ref = refs[name] = getHelperReference(name);
    const {
      nodes
    ***REMOVED*** = helpers().get(name, getHelperReference, namespace ? null : `_${name***REMOVED***`, [], namespace ? (ast, exportName, mapExportBindingAssignments) => {
      mapExportBindingAssignments(node => assignmentExpression("=", ref, node));
      ast.body.push(expressionStatement(assignmentExpression("=", ref, identifier(exportName))));
    ***REMOVED*** : null);
    body.push(...nodes);
  ***REMOVED***);
  return refs;
***REMOVED***
function _default(allowlist, outputType = "global") {
  let tree;
  const build = {
    global: buildGlobal,
    module: buildModule,
    umd: buildUmd,
    var: buildVar
  ***REMOVED***[outputType];
  if (build) {
    tree = build(allowlist);
  ***REMOVED*** else {
    throw new Error(`Unsupported output type ${outputType***REMOVED***`);
  ***REMOVED***
  return (0, _generator().default)(tree).code;
***REMOVED***
0 && 0;

//# sourceMappingURL=build-external-helpers.js.map
