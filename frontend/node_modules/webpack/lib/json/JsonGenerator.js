/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { RawSource ***REMOVED*** = require("webpack-sources");
const ConcatenationScope = require("../ConcatenationScope");
const { UsageState ***REMOVED*** = require("../ExportsInfo");
const Generator = require("../Generator");
const { JS_TYPES ***REMOVED*** = require("../ModuleSourceTypesConstants");
const RuntimeGlobals = require("../RuntimeGlobals");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../../declarations/WebpackOptions").JsonGeneratorOptions***REMOVED*** JsonGeneratorOptions */
/** @typedef {import("../ExportsInfo")***REMOVED*** ExportsInfo */
/** @typedef {import("../Generator").GenerateContext***REMOVED*** GenerateContext */
/** @typedef {import("../Module").ConcatenationBailoutReasonContext***REMOVED*** ConcatenationBailoutReasonContext */
/** @typedef {import("../Module").SourceTypes***REMOVED*** SourceTypes */
/** @typedef {import("../NormalModule")***REMOVED*** NormalModule */
/** @typedef {import("../util/runtime").RuntimeSpec***REMOVED*** RuntimeSpec */
/** @typedef {import("./JsonData")***REMOVED*** JsonData */
/** @typedef {import("./JsonModulesPlugin").JsonArray***REMOVED*** JsonArray */
/** @typedef {import("./JsonModulesPlugin").JsonObject***REMOVED*** JsonObject */
/** @typedef {import("./JsonModulesPlugin").JsonValue***REMOVED*** JsonValue */

/**
 * @param {JsonValue***REMOVED*** data Raw JSON data
 * @returns {undefined|string***REMOVED*** stringified data
 */
const stringifySafe = data => {
	const stringified = JSON.stringify(data);
	if (!stringified) {
		return; // Invalid JSON
	***REMOVED***

	return stringified.replace(/\u2028|\u2029/g, str =>
		str === "\u2029" ? "\\u2029" : "\\u2028"
	); // invalid in JavaScript but valid JSON
***REMOVED***;

/**
 * @param {JsonObject | JsonArray***REMOVED*** data Raw JSON data (always an object or array)
 * @param {ExportsInfo***REMOVED*** exportsInfo exports info
 * @param {RuntimeSpec***REMOVED*** runtime the runtime
 * @returns {JsonObject | JsonArray***REMOVED*** reduced data
 */
const createObjectForExportsInfo = (data, exportsInfo, runtime) => {
	if (exportsInfo.otherExportsInfo.getUsed(runtime) !== UsageState.Unused)
		return data;
	const isArray = Array.isArray(data);
	/** @type {JsonObject | JsonArray***REMOVED*** */
	const reducedData = isArray ? [] : {***REMOVED***;
	for (const key of Object.keys(data)) {
		const exportInfo = exportsInfo.getReadOnlyExportInfo(key);
		const used = exportInfo.getUsed(runtime);
		if (used === UsageState.Unused) continue;

		// The real type is `JsonObject | JsonArray`, but typescript doesn't work `Object.keys(['string', 'other-string', 'etc'])` properly
		const newData = /** @type {JsonObject***REMOVED*** */ (data)[key];
		const value =
			used === UsageState.OnlyPropertiesUsed &&
			exportInfo.exportsInfo &&
			typeof newData === "object" &&
			newData
				? createObjectForExportsInfo(newData, exportInfo.exportsInfo, runtime)
				: newData;

		const name = /** @type {string***REMOVED*** */ (exportInfo.getUsedName(key, runtime));
		/** @type {JsonObject***REMOVED*** */
		(reducedData)[name] = value;
	***REMOVED***
	if (isArray) {
		const arrayLengthWhenUsed =
			exportsInfo.getReadOnlyExportInfo("length").getUsed(runtime) !==
			UsageState.Unused
				? data.length
				: undefined;

		let sizeObjectMinusArray = 0;
		const reducedDataLength =
			/** @type {JsonArray***REMOVED*** */
			(reducedData).length;
		for (let i = 0; i < reducedDataLength; i++) {
			if (/** @type {JsonArray***REMOVED*** */ (reducedData)[i] === undefined) {
				sizeObjectMinusArray -= 2;
			***REMOVED*** else {
				sizeObjectMinusArray += `${i***REMOVED***`.length + 3;
			***REMOVED***
		***REMOVED***
		if (arrayLengthWhenUsed !== undefined) {
			sizeObjectMinusArray +=
				`${arrayLengthWhenUsed***REMOVED***`.length +
				8 -
				(arrayLengthWhenUsed - reducedDataLength) * 2;
		***REMOVED***
		if (sizeObjectMinusArray < 0)
			return Object.assign(
				arrayLengthWhenUsed === undefined
					? {***REMOVED***
					: { length: arrayLengthWhenUsed ***REMOVED***,
				reducedData
			);
		/** @type {number***REMOVED*** */
		const generatedLength =
			arrayLengthWhenUsed !== undefined
				? Math.max(arrayLengthWhenUsed, reducedDataLength)
				: reducedDataLength;
		for (let i = 0; i < generatedLength; i++) {
			if (/** @type {JsonArray***REMOVED*** */ (reducedData)[i] === undefined) {
				/** @type {JsonArray***REMOVED*** */
				(reducedData)[i] = 0;
			***REMOVED***
		***REMOVED***
	***REMOVED***
	return reducedData;
***REMOVED***;

class JsonGenerator extends Generator {
	/**
	 * @param {JsonGeneratorOptions***REMOVED*** options options
	 */
	constructor(options) {
		super();
		this.options = options;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module fresh module
	 * @returns {SourceTypes***REMOVED*** available types (do not mutate)
	 */
	getTypes(module) {
		return JS_TYPES;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module the module
	 * @param {string=***REMOVED*** type source type
	 * @returns {number***REMOVED*** estimate size of the module
	 */
	getSize(module, type) {
		/** @type {JsonValue | undefined***REMOVED*** */
		const data =
			module.buildInfo &&
			module.buildInfo.jsonData &&
			module.buildInfo.jsonData.get();
		if (!data) return 0;
		return /** @type {string***REMOVED*** */ (stringifySafe(data)).length + 10;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module module for which the bailout reason should be determined
	 * @param {ConcatenationBailoutReasonContext***REMOVED*** context context
	 * @returns {string | undefined***REMOVED*** reason why this module can't be concatenated, undefined when it can be concatenated
	 */
	getConcatenationBailoutReason(module, context) {
		return undefined;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module module for which the code should be generated
	 * @param {GenerateContext***REMOVED*** generateContext context for generate
	 * @returns {Source | null***REMOVED*** generated code
	 */
	generate(
		module,
		{
			moduleGraph,
			runtimeTemplate,
			runtimeRequirements,
			runtime,
			concatenationScope
		***REMOVED***
	) {
		/** @type {JsonValue | undefined***REMOVED*** */
		const data =
			module.buildInfo &&
			module.buildInfo.jsonData &&
			module.buildInfo.jsonData.get();
		if (data === undefined) {
			return new RawSource(
				runtimeTemplate.missingModuleStatement({
					request: module.rawRequest
				***REMOVED***)
			);
		***REMOVED***
		const exportsInfo = moduleGraph.getExportsInfo(module);
		/** @type {JsonValue***REMOVED*** */
		const finalJson =
			typeof data === "object" &&
			data &&
			exportsInfo.otherExportsInfo.getUsed(runtime) === UsageState.Unused
				? createObjectForExportsInfo(data, exportsInfo, runtime)
				: data;
		// Use JSON because JSON.parse() is much faster than JavaScript evaluation
		const jsonStr = /** @type {string***REMOVED*** */ (stringifySafe(finalJson));
		const jsonExpr =
			this.options.JSONParse &&
			jsonStr.length > 20 &&
			typeof finalJson === "object"
				? `/*#__PURE__*/JSON.parse('${jsonStr.replace(/[\\']/g, "\\$&")***REMOVED***')`
				: jsonStr.replace(/"__proto__":/g, '["__proto__"]:');
		/** @type {string***REMOVED*** */
		let content;
		if (concatenationScope) {
			content = `${runtimeTemplate.supportsConst() ? "const" : "var"***REMOVED*** ${
				ConcatenationScope.NAMESPACE_OBJECT_EXPORT
			***REMOVED*** = ${jsonExpr***REMOVED***;`;
			concatenationScope.registerNamespaceExport(
				ConcatenationScope.NAMESPACE_OBJECT_EXPORT
			);
		***REMOVED*** else {
			runtimeRequirements.add(RuntimeGlobals.module);
			content = `${module.moduleArgument***REMOVED***.exports = ${jsonExpr***REMOVED***;`;
		***REMOVED***
		return new RawSource(content);
	***REMOVED***

	/**
	 * @param {Error***REMOVED*** error the error
	 * @param {NormalModule***REMOVED*** module module for which the code should be generated
	 * @param {GenerateContext***REMOVED*** generateContext context for generate
	 * @returns {Source | null***REMOVED*** generated code
	 */
	generateError(error, module, generateContext) {
		return new RawSource(`throw new Error(${JSON.stringify(error.message)***REMOVED***);`);
	***REMOVED***
***REMOVED***

module.exports = JsonGenerator;
