"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.default = void 0;

var _experimentalUtils = require("@typescript-eslint/experimental-utils");

var _utils = require("./utils");

var _default = (0, _utils.createRule)({
  name: __filename,
  meta: {
    docs: {
      category: 'Best Practices',
      description: 'Disallow Jasmine globals',
      recommended: 'error'
    ***REMOVED***,
    messages: {
      illegalGlobal: 'Illegal usage of global `{{ global ***REMOVED******REMOVED***`, prefer `{{ replacement ***REMOVED******REMOVED***`',
      illegalMethod: 'Illegal usage of `{{ method ***REMOVED******REMOVED***`, prefer `{{ replacement ***REMOVED******REMOVED***`',
      illegalFail: 'Illegal usage of `fail`, prefer throwing an error, or the `done.fail` callback',
      illegalPending: 'Illegal usage of `pending`, prefer explicitly skipping a test using `test.skip`',
      illegalJasmine: 'Illegal usage of jasmine global'
    ***REMOVED***,
    fixable: 'code',
    schema: [],
    type: 'suggestion'
  ***REMOVED***,
  defaultOptions: [],

  create(context) {
    return {
      CallExpression(node) {
        const {
          callee
        ***REMOVED*** = node;
        const calleeName = (0, _utils.getNodeName)(callee);

        if (!calleeName) {
          return;
        ***REMOVED***

        if (calleeName === 'spyOn' || calleeName === 'spyOnProperty' || calleeName === 'fail' || calleeName === 'pending') {
          if ((0, _utils.scopeHasLocalReference)(context.getScope(), calleeName)) {
            // It's a local variable, not a jasmine global.
            return;
          ***REMOVED***

          switch (calleeName) {
            case 'spyOn':
            case 'spyOnProperty':
              context.report({
                node,
                messageId: 'illegalGlobal',
                data: {
                  global: calleeName,
                  replacement: 'jest.spyOn'
                ***REMOVED***
              ***REMOVED***);
              break;

            case 'fail':
              context.report({
                node,
                messageId: 'illegalFail'
              ***REMOVED***);
              break;

            case 'pending':
              context.report({
                node,
                messageId: 'illegalPending'
              ***REMOVED***);
              break;
          ***REMOVED***

          return;
        ***REMOVED***

        if (callee.type === _experimentalUtils.AST_NODE_TYPES.MemberExpression && calleeName.startsWith('jasmine.')) {
          const functionName = calleeName.replace('jasmine.', '');

          if (functionName === 'any' || functionName === 'anything' || functionName === 'arrayContaining' || functionName === 'objectContaining' || functionName === 'stringMatching') {
            context.report({
              fix: fixer => [fixer.replaceText(callee.object, 'expect')],
              node,
              messageId: 'illegalMethod',
              data: {
                method: calleeName,
                replacement: `expect.${functionName***REMOVED***`
              ***REMOVED***
            ***REMOVED***);
            return;
          ***REMOVED***

          if (functionName === 'addMatchers') {
            context.report({
              node,
              messageId: 'illegalMethod',
              data: {
                method: calleeName,
                replacement: 'expect.extend'
              ***REMOVED***
            ***REMOVED***);
            return;
          ***REMOVED***

          if (functionName === 'createSpy') {
            context.report({
              node,
              messageId: 'illegalMethod',
              data: {
                method: calleeName,
                replacement: 'jest.fn'
              ***REMOVED***
            ***REMOVED***);
            return;
          ***REMOVED***

          context.report({
            node,
            messageId: 'illegalJasmine'
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***,

      MemberExpression(node) {
        if ((0, _utils.isSupportedAccessor)(node.object, 'jasmine')) {
          const {
            parent,
            property
          ***REMOVED*** = node;

          if (parent && parent.type === _experimentalUtils.AST_NODE_TYPES.AssignmentExpression) {
            if ((0, _utils.isSupportedAccessor)(property, 'DEFAULT_TIMEOUT_INTERVAL')) {
              const {
                right
              ***REMOVED*** = parent;

              if (right.type === _experimentalUtils.AST_NODE_TYPES.Literal) {
                context.report({
                  fix: fixer => [fixer.replaceText(parent, `jest.setTimeout(${right.value***REMOVED***)`)],
                  node,
                  messageId: 'illegalJasmine'
                ***REMOVED***);
                return;
              ***REMOVED***
            ***REMOVED***

            context.report({
              node,
              messageId: 'illegalJasmine'
            ***REMOVED***);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

    ***REMOVED***;
  ***REMOVED***

***REMOVED***);

exports.default = _default;