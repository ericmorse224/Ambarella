/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const glob2regexp = require("glob-to-regexp");
const {
	JAVASCRIPT_MODULE_TYPE_AUTO,
	JAVASCRIPT_MODULE_TYPE_ESM,
	JAVASCRIPT_MODULE_TYPE_DYNAMIC
***REMOVED*** = require("../ModuleTypeConstants");
const { STAGE_DEFAULT ***REMOVED*** = require("../OptimizationStages");
const HarmonyExportImportedSpecifierDependency = require("../dependencies/HarmonyExportImportedSpecifierDependency");
const HarmonyImportSpecifierDependency = require("../dependencies/HarmonyImportSpecifierDependency");
const formatLocation = require("../formatLocation");

/** @typedef {import("estree").MaybeNamedClassDeclaration***REMOVED*** MaybeNamedClassDeclaration */
/** @typedef {import("estree").MaybeNamedFunctionDeclaration***REMOVED*** MaybeNamedFunctionDeclaration */
/** @typedef {import("estree").ModuleDeclaration***REMOVED*** ModuleDeclaration */
/** @typedef {import("estree").Statement***REMOVED*** Statement */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../Dependency")***REMOVED*** Dependency */
/** @typedef {import("../Dependency").DependencyLocation***REMOVED*** DependencyLocation */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../Module").BuildMeta***REMOVED*** BuildMeta */
/** @typedef {import("../ModuleGraphConnection")***REMOVED*** ModuleGraphConnection */
/** @typedef {import("../NormalModuleFactory").ModuleSettings***REMOVED*** ModuleSettings */
/** @typedef {import("../javascript/JavascriptParser")***REMOVED*** JavascriptParser */
/** @typedef {import("../javascript/JavascriptParser").Range***REMOVED*** Range */

/**
 * @typedef {object***REMOVED*** ExportInModule
 * @property {Module***REMOVED*** module the module
 * @property {string***REMOVED*** exportName the name of the export
 * @property {boolean***REMOVED*** checked if the export is conditional
 */

/**
 * @typedef {object***REMOVED*** ReexportInfo
 * @property {Map<string, ExportInModule[]>***REMOVED*** static
 * @property {Map<Module, Set<string>>***REMOVED*** dynamic
 */

/** @typedef {Map<string, RegExp>***REMOVED*** CacheItem */

/** @type {WeakMap<Compiler, CacheItem>***REMOVED*** */
const globToRegexpCache = new WeakMap();

/**
 * @param {string***REMOVED*** glob the pattern
 * @param {Map<string, RegExp>***REMOVED*** cache the glob to RegExp cache
 * @returns {RegExp***REMOVED*** a regular expression
 */
const globToRegexp = (glob, cache) => {
	const cacheEntry = cache.get(glob);
	if (cacheEntry !== undefined) return cacheEntry;
	if (!glob.includes("/")) {
		glob = `**/${glob***REMOVED***`;
	***REMOVED***
	const baseRegexp = glob2regexp(glob, { globstar: true, extended: true ***REMOVED***);
	const regexpSource = baseRegexp.source;
	const regexp = new RegExp(`^(\\./)?${regexpSource.slice(1)***REMOVED***`);
	cache.set(glob, regexp);
	return regexp;
***REMOVED***;

const PLUGIN_NAME = "SideEffectsFlagPlugin";

class SideEffectsFlagPlugin {
	/**
	 * @param {boolean***REMOVED*** analyseSource analyse source code for side effects
	 */
	constructor(analyseSource = true) {
		this._analyseSource = analyseSource;
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		let cache = globToRegexpCache.get(compiler.root);
		if (cache === undefined) {
			cache = new Map();
			globToRegexpCache.set(compiler.root, cache);
		***REMOVED***
		compiler.hooks.compilation.tap(
			PLUGIN_NAME,
			(compilation, { normalModuleFactory ***REMOVED***) => {
				const moduleGraph = compilation.moduleGraph;
				normalModuleFactory.hooks.module.tap(PLUGIN_NAME, (module, data) => {
					const resolveData = data.resourceResolveData;
					if (
						resolveData &&
						resolveData.descriptionFileData &&
						resolveData.relativePath
					) {
						const sideEffects = resolveData.descriptionFileData.sideEffects;
						if (sideEffects !== undefined) {
							if (module.factoryMeta === undefined) {
								module.factoryMeta = {***REMOVED***;
							***REMOVED***
							const hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(
								resolveData.relativePath,
								sideEffects,
								/** @type {CacheItem***REMOVED*** */ (cache)
							);
							module.factoryMeta.sideEffectFree = !hasSideEffects;
						***REMOVED***
					***REMOVED***

					return module;
				***REMOVED***);
				normalModuleFactory.hooks.module.tap(PLUGIN_NAME, (module, data) => {
					const settings = /** @type {ModuleSettings***REMOVED*** */ (data.settings);
					if (typeof settings.sideEffects === "boolean") {
						if (module.factoryMeta === undefined) {
							module.factoryMeta = {***REMOVED***;
						***REMOVED***
						module.factoryMeta.sideEffectFree = !settings.sideEffects;
					***REMOVED***
					return module;
				***REMOVED***);
				if (this._analyseSource) {
					/**
					 * @param {JavascriptParser***REMOVED*** parser the parser
					 * @returns {void***REMOVED***
					 */
					const parserHandler = parser => {
						/** @type {undefined | Statement | ModuleDeclaration | MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration***REMOVED*** */
						let sideEffectsStatement;
						parser.hooks.program.tap(PLUGIN_NAME, () => {
							sideEffectsStatement = undefined;
						***REMOVED***);
						parser.hooks.statement.tap(
							{ name: PLUGIN_NAME, stage: -100 ***REMOVED***,
							statement => {
								if (sideEffectsStatement) return;
								if (parser.scope.topLevelScope !== true) return;
								switch (statement.type) {
									case "ExpressionStatement":
										if (
											!parser.isPure(
												statement.expression,
												/** @type {Range***REMOVED*** */
												(statement.range)[0]
											)
										) {
											sideEffectsStatement = statement;
										***REMOVED***
										break;
									case "IfStatement":
									case "WhileStatement":
									case "DoWhileStatement":
										if (
											!parser.isPure(
												statement.test,
												/** @type {Range***REMOVED*** */
												(statement.range)[0]
											)
										) {
											sideEffectsStatement = statement;
										***REMOVED***
										// statement hook will be called for child statements too
										break;
									case "ForStatement":
										if (
											!parser.isPure(
												statement.init,
												/** @type {Range***REMOVED*** */ (statement.range)[0]
											) ||
											!parser.isPure(
												statement.test,
												statement.init
													? /** @type {Range***REMOVED*** */ (statement.init.range)[1]
													: /** @type {Range***REMOVED*** */ (statement.range)[0]
											) ||
											!parser.isPure(
												statement.update,
												statement.test
													? /** @type {Range***REMOVED*** */ (statement.test.range)[1]
													: statement.init
														? /** @type {Range***REMOVED*** */ (statement.init.range)[1]
														: /** @type {Range***REMOVED*** */ (statement.range)[0]
											)
										) {
											sideEffectsStatement = statement;
										***REMOVED***
										// statement hook will be called for child statements too
										break;
									case "SwitchStatement":
										if (
											!parser.isPure(
												statement.discriminant,
												/** @type {Range***REMOVED*** */
												(statement.range)[0]
											)
										) {
											sideEffectsStatement = statement;
										***REMOVED***
										// statement hook will be called for child statements too
										break;
									case "VariableDeclaration":
									case "ClassDeclaration":
									case "FunctionDeclaration":
										if (
											!parser.isPure(
												statement,
												/** @type {Range***REMOVED*** */ (statement.range)[0]
											)
										) {
											sideEffectsStatement = statement;
										***REMOVED***
										break;
									case "ExportNamedDeclaration":
									case "ExportDefaultDeclaration":
										if (
											!parser.isPure(
												statement.declaration,
												/** @type {Range***REMOVED*** */
												(statement.range)[0]
											)
										) {
											sideEffectsStatement = statement;
										***REMOVED***
										break;
									case "LabeledStatement":
									case "BlockStatement":
										// statement hook will be called for child statements too
										break;
									case "EmptyStatement":
										break;
									case "ExportAllDeclaration":
									case "ImportDeclaration":
										// imports will be handled by the dependencies
										break;
									default:
										sideEffectsStatement = statement;
										break;
								***REMOVED***
							***REMOVED***
						);
						parser.hooks.finish.tap(PLUGIN_NAME, () => {
							if (sideEffectsStatement === undefined) {
								/** @type {BuildMeta***REMOVED*** */
								(parser.state.module.buildMeta).sideEffectFree = true;
							***REMOVED*** else {
								const { loc, type ***REMOVED*** = sideEffectsStatement;
								moduleGraph
									.getOptimizationBailout(parser.state.module)
									.push(
										() =>
											`Statement (${type***REMOVED***) with side effects in source code at ${formatLocation(
												/** @type {DependencyLocation***REMOVED*** */ (loc)
											)***REMOVED***`
									);
							***REMOVED***
						***REMOVED***);
					***REMOVED***;
					for (const key of [
						JAVASCRIPT_MODULE_TYPE_AUTO,
						JAVASCRIPT_MODULE_TYPE_ESM,
						JAVASCRIPT_MODULE_TYPE_DYNAMIC
					]) {
						normalModuleFactory.hooks.parser
							.for(key)
							.tap(PLUGIN_NAME, parserHandler);
					***REMOVED***
				***REMOVED***
				compilation.hooks.optimizeDependencies.tap(
					{
						name: PLUGIN_NAME,
						stage: STAGE_DEFAULT
					***REMOVED***,
					modules => {
						const logger = compilation.getLogger(
							"webpack.SideEffectsFlagPlugin"
						);

						logger.time("update dependencies");

						const optimizedModules = new Set();

						/**
						 * @param {Module***REMOVED*** module module
						 */
						const optimizeIncomingConnections = module => {
							if (optimizedModules.has(module)) return;
							optimizedModules.add(module);
							if (module.getSideEffectsConnectionState(moduleGraph) === false) {
								const exportsInfo = moduleGraph.getExportsInfo(module);
								for (const connection of moduleGraph.getIncomingConnections(
									module
								)) {
									const dep = connection.dependency;
									let isReexport;
									if (
										(isReexport =
											dep instanceof
											HarmonyExportImportedSpecifierDependency) ||
										(dep instanceof HarmonyImportSpecifierDependency &&
											!dep.namespaceObjectAsContext)
									) {
										if (connection.originModule !== null) {
											optimizeIncomingConnections(connection.originModule);
										***REMOVED***
										// TODO improve for export *
										if (isReexport && dep.name) {
											const exportInfo = moduleGraph.getExportInfo(
												/** @type {Module***REMOVED*** */ (connection.originModule),
												dep.name
											);
											exportInfo.moveTarget(
												moduleGraph,
												({ module ***REMOVED***) =>
													module.getSideEffectsConnectionState(moduleGraph) ===
													false,
												({ module: newModule, export: exportName ***REMOVED***) => {
													moduleGraph.updateModule(dep, newModule);
													moduleGraph.addExplanation(
														dep,
														"(skipped side-effect-free modules)"
													);
													const ids = dep.getIds(moduleGraph);
													dep.setIds(
														moduleGraph,
														exportName
															? [...exportName, ...ids.slice(1)]
															: ids.slice(1)
													);
													return /** @type {ModuleGraphConnection***REMOVED*** */ (
														moduleGraph.getConnection(dep)
													);
												***REMOVED***
											);
											continue;
										***REMOVED***
										// TODO improve for nested imports
										const ids = dep.getIds(moduleGraph);
										if (ids.length > 0) {
											const exportInfo = exportsInfo.getExportInfo(ids[0]);
											const target = exportInfo.getTarget(
												moduleGraph,
												({ module ***REMOVED***) =>
													module.getSideEffectsConnectionState(moduleGraph) ===
													false
											);
											if (!target) continue;

											moduleGraph.updateModule(dep, target.module);
											moduleGraph.addExplanation(
												dep,
												"(skipped side-effect-free modules)"
											);
											dep.setIds(
												moduleGraph,
												target.export
													? [...target.export, ...ids.slice(1)]
													: ids.slice(1)
											);
										***REMOVED***
									***REMOVED***
								***REMOVED***
							***REMOVED***
						***REMOVED***;

						for (const module of modules) {
							optimizeIncomingConnections(module);
						***REMOVED***
						logger.timeEnd("update dependencies");
					***REMOVED***
				);
			***REMOVED***
		);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** moduleName the module name
	 * @param {undefined | boolean | string | string[]***REMOVED*** flagValue the flag value
	 * @param {Map<string, RegExp>***REMOVED*** cache cache for glob to regexp
	 * @returns {boolean | undefined***REMOVED*** true, when the module has side effects, undefined or false when not
	 */
	static moduleHasSideEffects(moduleName, flagValue, cache) {
		switch (typeof flagValue) {
			case "undefined":
				return true;
			case "boolean":
				return flagValue;
			case "string":
				return globToRegexp(flagValue, cache).test(moduleName);
			case "object":
				return flagValue.some(glob =>
					SideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob, cache)
				);
		***REMOVED***
	***REMOVED***
***REMOVED***
module.exports = SideEffectsFlagPlugin;
