/**
 * @author Matthew Caruana Galizia <mattcg@gmail.com>
 * @license MIT: http://mattcg.mit-license.org/
 * @copyright Copyright (c) 2013, Matthew Caruana Galizia
 */

'use strict';

var Tag = require('./Tag.js');
var Subtag = require('./Subtag.js');
var index = require('language-subtag-registry/data/json/index.json');
var registry = require('language-subtag-registry/data/json/registry.json');
var tags = function tags(tag) {
  return new Tag(tag);
***REMOVED***;
module.exports = tags;
tags.check = function (tag) {
  return new Tag(tag).valid();
***REMOVED***;
tags.types = function (subtag) {
  var types = index[subtag.toLowerCase()];
  if (!types) {
    return [];
  ***REMOVED***
  return Object.keys(types).filter(function (type) {
    return type !== 'grandfathered' && type !== 'redundant';
  ***REMOVED***);
***REMOVED***;
tags.subtags = function (subtags) {
  var result = [];
  if (!Array.isArray(subtags)) {
    subtags = [subtags];
  ***REMOVED***
  subtags.forEach(function (subtag) {
    tags.types(subtag).forEach(function (type) {
      result.push(new Subtag(subtag, type));
    ***REMOVED***);
  ***REMOVED***);
  return result;
***REMOVED***;
tags.filter = function (subtags) {
  return subtags.filter(function (subtag) {
    return !tags.types(subtag).length;
  ***REMOVED***);
***REMOVED***;
tags.search = function (query, all) {
  var test;
  if ('function' === typeof query.test) {
    test = function test(description) {
      return query.test(description);
    ***REMOVED***;

    // If the query is all lowercase, make a case-insensitive match.
  ***REMOVED*** else if (query.toLowerCase() === query) {
    test = function test(description) {
      return -1 !== description.toLowerCase().indexOf(query);
    ***REMOVED***;
  ***REMOVED*** else {
    test = function test(description) {
      return -1 !== description.indexOf(query);
    ***REMOVED***;
  ***REMOVED***
  return registry.filter(function (record) {
    if (!record.Subtag && !all) {
      return false;
    ***REMOVED***
    return record.Description.some(test);

    // Sort by matched description string length.
    // This is a quick way to push precise matches towards the top.
  ***REMOVED***).sort(function (a, b) {
    return Math.min.apply(Math, a.Description.filter(test).map(function (description) {
      return description.length;
    ***REMOVED***)) - Math.min.apply(Math, b.Description.filter(test).map(function (description) {
      return description.length;
    ***REMOVED***));
  ***REMOVED***).map(function (record) {
    if (record.Subtag) {
      return new Subtag(record.Subtag, record.Type);
    ***REMOVED***
    return new Tag(record.Tag);
  ***REMOVED***);
***REMOVED***;
tags.languages = function (macrolanguage) {
  var i,
    l,
    record,
    results = [];
  macrolanguage = macrolanguage.toLowerCase();
  if (!require('language-subtag-registry/data/json/macrolanguage.json')[macrolanguage]) {
    throw new Error('\'' + macrolanguage + '\' is not a macrolanguage.');
  ***REMOVED***
  for (i = 0, l = registry.length; i < l; i++) {
    record = registry[i];
    if (record.Macrolanguage === macrolanguage) {
      results.push(new Subtag(record.Subtag, record.Type));
    ***REMOVED***
  ***REMOVED***
  return results;
***REMOVED***;
tags.language = function (subtag) {
  return tags.type(subtag, 'language');
***REMOVED***;
tags.region = function (subtag) {
  return tags.type(subtag, 'region');
***REMOVED***;
tags.type = function (subtag, type) {
  var types = index[subtag.toLowerCase()];
  if (types && types[type]) {
    return new Subtag(subtag, type);
  ***REMOVED***
  return null;
***REMOVED***;
tags.date = function () {
  return require('language-subtag-registry/data/json/meta.json')['File-Date'];
***REMOVED***;