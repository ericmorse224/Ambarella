/**
 * @fileoverview Rule to enforce line breaks after each array element
 * @author Jan Peer St√∂cklmair <https://github.com/JPeer264>
 */

"use strict";

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
    meta: {
        type: "layout",

        docs: {
            description: "enforce line breaks after each array element",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/array-element-newline"
        ***REMOVED***,

        fixable: "whitespace",

        schema: {
            definitions: {
                basicConfig: {
                    oneOf: [
                        {
                            enum: ["always", "never", "consistent"]
                        ***REMOVED***,
                        {
                            type: "object",
                            properties: {
                                multiline: {
                                    type: "boolean"
                                ***REMOVED***,
                                minItems: {
                                    type: ["integer", "null"],
                                    minimum: 0
                                ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***
                    ]
                ***REMOVED***
            ***REMOVED***,
            items: [
                {
                    oneOf: [
                        {
                            $ref: "#/definitions/basicConfig"
                        ***REMOVED***,
                        {
                            type: "object",
                            properties: {
                                ArrayExpression: {
                                    $ref: "#/definitions/basicConfig"
                                ***REMOVED***,
                                ArrayPattern: {
                                    $ref: "#/definitions/basicConfig"
                                ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false,
                            minProperties: 1
                        ***REMOVED***
                    ]
                ***REMOVED***
            ]
        ***REMOVED***,

        messages: {
            unexpectedLineBreak: "There should be no linebreak here.",
            missingLineBreak: "There should be a linebreak after this element."
        ***REMOVED***
    ***REMOVED***,

    create(context) {
        const sourceCode = context.getSourceCode();

        //----------------------------------------------------------------------
        // Helpers
        //----------------------------------------------------------------------

        /**
         * Normalizes a given option value.
         * @param {string|Object|undefined***REMOVED*** providedOption An option value to parse.
         * @returns {{multiline: boolean, minItems: number***REMOVED******REMOVED*** Normalized option object.
         */
        function normalizeOptionValue(providedOption) {
            let consistent = false;
            let multiline = false;
            let minItems;

            const option = providedOption || "always";

            if (!option || option === "always" || option.minItems === 0) {
                minItems = 0;
            ***REMOVED*** else if (option === "never") {
                minItems = Number.POSITIVE_INFINITY;
            ***REMOVED*** else if (option === "consistent") {
                consistent = true;
                minItems = Number.POSITIVE_INFINITY;
            ***REMOVED*** else {
                multiline = Boolean(option.multiline);
                minItems = option.minItems || Number.POSITIVE_INFINITY;
            ***REMOVED***

            return { consistent, multiline, minItems ***REMOVED***;
        ***REMOVED***

        /**
         * Normalizes a given option value.
         * @param {string|Object|undefined***REMOVED*** options An option value to parse.
         * @returns {{ArrayExpression: {multiline: boolean, minItems: number***REMOVED***, ArrayPattern: {multiline: boolean, minItems: number***REMOVED******REMOVED******REMOVED*** Normalized option object.
         */
        function normalizeOptions(options) {
            if (options && (options.ArrayExpression || options.ArrayPattern)) {
                let expressionOptions, patternOptions;

                if (options.ArrayExpression) {
                    expressionOptions = normalizeOptionValue(options.ArrayExpression);
                ***REMOVED***

                if (options.ArrayPattern) {
                    patternOptions = normalizeOptionValue(options.ArrayPattern);
                ***REMOVED***

                return { ArrayExpression: expressionOptions, ArrayPattern: patternOptions ***REMOVED***;
            ***REMOVED***

            const value = normalizeOptionValue(options);

            return { ArrayExpression: value, ArrayPattern: value ***REMOVED***;
        ***REMOVED***

        /**
         * Reports that there shouldn't be a line break after the first token
         * @param {Token***REMOVED*** token The token to use for the report.
         * @returns {void***REMOVED***
         */
        function reportNoLineBreak(token) {
            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true ***REMOVED***);

            context.report({
                loc: {
                    start: tokenBefore.loc.end,
                    end: token.loc.start
                ***REMOVED***,
                messageId: "unexpectedLineBreak",
                fix(fixer) {
                    if (astUtils.isCommentToken(tokenBefore)) {
                        return null;
                    ***REMOVED***

                    if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {
                        return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], " ");
                    ***REMOVED***

                    /*
                     * This will check if the comma is on the same line as the next element
                     * Following array:
                     * [
                     *     1
                     *     , 2
                     *     , 3
                     * ]
                     *
                     * will be fixed to:
                     * [
                     *     1, 2, 3
                     * ]
                     */
                    const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, { includeComments: true ***REMOVED***);

                    if (astUtils.isCommentToken(twoTokensBefore)) {
                        return null;
                    ***REMOVED***

                    return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], "");

                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        /**
         * Reports that there should be a line break after the first token
         * @param {Token***REMOVED*** token The token to use for the report.
         * @returns {void***REMOVED***
         */
        function reportRequiredLineBreak(token) {
            const tokenBefore = sourceCode.getTokenBefore(token, { includeComments: true ***REMOVED***);

            context.report({
                loc: {
                    start: tokenBefore.loc.end,
                    end: token.loc.start
                ***REMOVED***,
                messageId: "missingLineBreak",
                fix(fixer) {
                    return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], "\n");
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        /**
         * Reports a given node if it violated this rule.
         * @param {ASTNode***REMOVED*** node A node to check. This is an ObjectExpression node or an ObjectPattern node.
         * @returns {void***REMOVED***
         */
        function check(node) {
            const elements = node.elements;
            const normalizedOptions = normalizeOptions(context.options[0]);
            const options = normalizedOptions[node.type];

            if (!options) {
                return;
            ***REMOVED***

            let elementBreak = false;

            /*
             * MULTILINE: true
             * loop through every element and check
             * if at least one element has linebreaks inside
             * this ensures that following is not valid (due to elements are on the same line):
             *
             * [
             *      1,
             *      2,
             *      3
             * ]
             */
            if (options.multiline) {
                elementBreak = elements
                    .filter(element => element !== null)
                    .some(element => element.loc.start.line !== element.loc.end.line);
            ***REMOVED***

            const linebreaksCount = node.elements.map((element, i) => {
                const previousElement = elements[i - 1];

                if (i === 0 || element === null || previousElement === null) {
                    return false;
                ***REMOVED***

                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);
                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);
                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);

                return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);
            ***REMOVED***).filter(isBreak => isBreak === true).length;

            const needsLinebreaks = (
                elements.length >= options.minItems ||
                (
                    options.multiline &&
                    elementBreak
                ) ||
                (
                    options.consistent &&
                    linebreaksCount > 0 &&
                    linebreaksCount < node.elements.length
                )
            );

            elements.forEach((element, i) => {
                const previousElement = elements[i - 1];

                if (i === 0 || element === null || previousElement === null) {
                    return;
                ***REMOVED***

                const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);
                const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);
                const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);

                if (needsLinebreaks) {
                    if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
                        reportRequiredLineBreak(firstTokenOfCurrentElement);
                    ***REMOVED***
                ***REMOVED*** else {
                    if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
                        reportNoLineBreak(firstTokenOfCurrentElement);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------

        return {
            ArrayPattern: check,
            ArrayExpression: check
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
