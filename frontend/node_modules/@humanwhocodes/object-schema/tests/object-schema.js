/**
 * @filedescription Object Schema Tests
 */
/* global it, describe, beforeEach */

"use strict";

//-----------------------------------------------------------------------------
// Requirements
//-----------------------------------------------------------------------------

const assert = require("chai").assert;
const { ObjectSchema ***REMOVED*** = require("../src/");

//-----------------------------------------------------------------------------
// Class
//-----------------------------------------------------------------------------

describe("ObjectSchema", () => {

    let schema;

    describe("new ObjectSchema()", () => {

        it("should add a new key when a strategy is passed", () => {
            schema = new ObjectSchema({
                foo: {
                    merge() {***REMOVED***,
                    validate() {***REMOVED***
                ***REMOVED***
            ***REMOVED***);

            assert.isTrue(schema.hasKey("foo"));
        ***REMOVED***);

        it("should throw an error when a strategy is missing a merge() method", () => {
            assert.throws(() => {
                schema = new ObjectSchema({
                    foo: {
                        validate() { ***REMOVED***
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***, /Definition for key "foo" must have a merge property/);
        ***REMOVED***);

        it("should throw an error when a strategy is missing a merge() method", () => {
            assert.throws(() => {
                schema = new ObjectSchema();
            ***REMOVED***, /Schema definitions missing/);
        ***REMOVED***);

        it("should throw an error when a strategy is missing a validate() method", () => {
            assert.throws(() => {
                schema = new ObjectSchema({
                    foo: {
                        merge() { ***REMOVED***,
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***, /Definition for key "foo" must have a validate\(\) method/);
        ***REMOVED***);

        it("should throw an error when merge is an invalid string", () => {
            assert.throws(() => {
                new ObjectSchema({
                    foo: {
                        merge: "bar",
                        validate() { ***REMOVED***
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***, /key "foo" missing valid merge strategy/);
        ***REMOVED***);

        it("should throw an error when validate is an invalid string", () => {
            assert.throws(() => {
                new ObjectSchema({
                    foo: {
                        merge: "assign",
                        validate: "s"
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***, /key "foo" missing valid validation strategy/);
        ***REMOVED***);

    ***REMOVED***);


    describe("merge()", () => {

        it("should throw an error when an unexpected key is found", () => {
            let schema = new ObjectSchema({***REMOVED***);

            assert.throws(() => {
                schema.merge({ foo: true ***REMOVED***, { foo: true ***REMOVED***);
            ***REMOVED***, /Unexpected key "foo"/);
        ***REMOVED***);

        it("should throw an error when merge() throws an error", () => {
            let schema = new ObjectSchema({
                foo: {
                    merge() {
                        throw new Error("Boom!");
                    ***REMOVED***,
                    validate() {***REMOVED***
                ***REMOVED***
            ***REMOVED***);

            assert.throws(() => {
                schema.merge({ foo: true ***REMOVED***, { foo: true ***REMOVED***);
            ***REMOVED***, /Key "foo": Boom!/);
        
        ***REMOVED***);

        it("should call the merge() strategy for one key when called", () => {
            
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return "bar";
                    ***REMOVED***,
                    validate() {***REMOVED***
                ***REMOVED***
            ***REMOVED***);

            const result = schema.merge({ foo: true ***REMOVED***, { foo: false ***REMOVED***);
            assert.propertyVal(result, "foo", "bar");
        ***REMOVED***);

        it("should not call the merge() strategy when both objects don't contain the key", () => {
            
            let called = false;

            schema = new ObjectSchema({
                foo: {
                    merge() {
                        called = true;
                    ***REMOVED***,
                    validate() {***REMOVED***
                ***REMOVED***
            ***REMOVED***);

            schema.merge({***REMOVED***, {***REMOVED***);
            assert.isFalse(called, "The merge() strategy should not have been called.");
        ***REMOVED***);

        it("should omit returning the key when the merge() strategy returns undefined", () => {
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return undefined;
                    ***REMOVED***,
                    validate() { ***REMOVED***
                ***REMOVED***
            ***REMOVED***);
            
            const result = schema.merge({ foo: true ***REMOVED***, { foo: false ***REMOVED***);
            assert.notProperty(result, "foo");
        ***REMOVED***);

        it("should call the merge() strategy for two keys when called", () => {
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return "bar";
                    ***REMOVED***,
                    validate() { ***REMOVED***
                ***REMOVED***,
                bar: {
                    merge() {
                        return "baz";
                    ***REMOVED***,
                    validate() {***REMOVED***
                ***REMOVED***
            ***REMOVED***);
            
            const result = schema.merge({ foo: true, bar: 1 ***REMOVED***, { foo: true, bar: 2 ***REMOVED***);
            assert.propertyVal(result, "foo", "bar");
            assert.propertyVal(result, "bar", "baz");
        ***REMOVED***);

        it("should call the merge() strategy for two keys when called on three objects", () => {
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return "bar";
                    ***REMOVED***,
                    validate() { ***REMOVED***
                ***REMOVED***,
                bar: {
                    merge() {
                        return "baz";
                    ***REMOVED***,
                    validate() { ***REMOVED***
                ***REMOVED***
            ***REMOVED***);
            
            const result = schema.merge(
                { foo: true, bar: 1 ***REMOVED***,
                { foo: true, bar: 3 ***REMOVED***,
                { foo: false, bar: 2 ***REMOVED***
            );
            assert.propertyVal(result, "foo", "bar");
            assert.propertyVal(result, "bar", "baz");
        ***REMOVED***);

        it("should call the merge() strategy when defined as 'overwrite'", () => {
            schema = new ObjectSchema({
                foo: {
                    merge: "overwrite",
                    validate() { ***REMOVED***
                ***REMOVED***
            ***REMOVED***);
            
            const result = schema.merge(
                { foo: true ***REMOVED***,
                { foo: false ***REMOVED***
            );
            assert.propertyVal(result, "foo", false);
        ***REMOVED***);

        it("should call the merge() strategy when defined as 'assign'", () => {
            schema = new ObjectSchema({
                foo: {
                    merge: "assign",
                    validate() { ***REMOVED***
                ***REMOVED***
            ***REMOVED***);
            
            const result = schema.merge(
                { foo: { bar: true ***REMOVED*** ***REMOVED***,
                { foo: { baz: false ***REMOVED*** ***REMOVED***
            );

            assert.strictEqual(result.foo.bar, true);
            assert.strictEqual(result.foo.baz, false);
        ***REMOVED***);

        it("should call the merge strategy when there's a subschema", () => {

            schema = new ObjectSchema({
                name: {
                    schema: {
                        first: {
                            merge: "replace",
                            validate: "string"
                        ***REMOVED***,
                        last: {
                            merge: "replace",
                            validate: "string"
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***);

            const result = schema.merge({
                name: {
                    first: "n",
                    last: "z"
                ***REMOVED***
            ***REMOVED***, {
                name: {
                    first: "g"
                ***REMOVED***
            ***REMOVED***);

            assert.strictEqual(result.name.first, "g");
            assert.strictEqual(result.name.last, "z");
        ***REMOVED***);

        it("should return separate objects when using subschema", () => {

            schema = new ObjectSchema({
                age: {
                    merge: "replace",
                    validate: "number"
                ***REMOVED***,
                address: {
                    schema: {
                        street: {
                            schema: {
                                number: {
                                    merge: "replace",
                                    validate: "number"
                                ***REMOVED***,
                                streetName: {
                                    merge: "replace",
                                    validate: "string"
                                ***REMOVED***
                            ***REMOVED***
                        ***REMOVED***,
                        state: {
                            merge: "replace",
                            validate: "string"
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***);

            const baseObject = {
                address: {
                    street: {
                        number: 100,
                        streetName: "Foo St"
                    ***REMOVED***,
                    state: "HA"
                ***REMOVED***
            ***REMOVED***;

            const result = schema.merge(baseObject, {
                age: 29
            ***REMOVED***);

            assert.notStrictEqual(result.address.street, baseObject.address.street);
            assert.deepStrictEqual(result.address, baseObject.address);
        ***REMOVED***);

        it("should not error when calling the merge strategy when there's a subschema and no matching key in second object", () => {

            schema = new ObjectSchema({
                name: {
                    schema: {
                        first: {
                            merge: "replace",
                            validate: "string"
                        ***REMOVED***,
                        last: {
                            merge: "replace",
                            validate: "string"
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***);

            const result = schema.merge({
                name: {
                    first: "n",
                    last: "z"
                ***REMOVED***
            ***REMOVED***, {
            ***REMOVED***);

            assert.strictEqual(result.name.first, "n");
            assert.strictEqual(result.name.last, "z");
        ***REMOVED***);

        it("should not error when calling the merge strategy when there's multiple subschemas and no matching key in second object", () => {

            schema = new ObjectSchema({
                user: {
                    schema: {
                        name: {
                            schema: {
                                first: {
                                    merge: "replace",
                                    validate: "string"
                                ***REMOVED***,
                                last: {
                                    merge: "replace",
                                    validate: "string"
                                ***REMOVED***
                            ***REMOVED***
                        ***REMOVED***

                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***);

            const result = schema.merge({
                user: {
                    name: {
                        first: "n",
                        last: "z"
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***, {
            ***REMOVED***);

            assert.strictEqual(result.user.name.first, "n");
            assert.strictEqual(result.user.name.last, "z");
        ***REMOVED***);


    ***REMOVED***);

    describe("validate()", () => {

        it("should throw an error when an unexpected key is found", () => {
            let schema = new ObjectSchema({***REMOVED***);
            assert.throws(() => {
                schema.validate({ foo: true ***REMOVED***);
            ***REMOVED***, /Unexpected key "foo"/);
        ***REMOVED***);

        it("should not throw an error when an expected key is found", () => {
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return "bar";
                    ***REMOVED***,
                    validate() {***REMOVED***
                ***REMOVED***
            ***REMOVED***);
            
            schema.validate({ foo: true ***REMOVED***);
        ***REMOVED***);

        it("should pass the property value into validate() when key is found", () => {
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return "bar";
                    ***REMOVED***,
                    validate(value) {
                        assert.isTrue(value);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***);
            
            schema.validate({ foo: true ***REMOVED***);
        ***REMOVED***);

        it("should not throw an error when expected keys are found", () => {
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return "bar";
                    ***REMOVED***,
                    validate() {***REMOVED***
                ***REMOVED***,
                bar: {
                    merge() {
                        return "baz";
                    ***REMOVED***,
                    validate() {***REMOVED***
                ***REMOVED***
            ***REMOVED***);
            
            schema.validate({ foo: true, bar: true ***REMOVED***);
        ***REMOVED***);

        it("should not throw an error when expected keys are found with required keys", () => {
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return "bar";
                    ***REMOVED***,
                    validate() { ***REMOVED***
                ***REMOVED***,
                bar: {
                    requires: ["foo"],
                    merge() {
                        return "baz";
                    ***REMOVED***,
                    validate() { ***REMOVED***
                ***REMOVED***
            ***REMOVED***);
            
            schema.validate({ foo: true, bar: true ***REMOVED***);
        ***REMOVED***);

        it("should throw an error when expected keys are found without required keys", () => {
            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return "bar";
                    ***REMOVED***,
                    validate() { ***REMOVED***
                ***REMOVED***,
                baz: {
                    merge() {
                        return "baz";
                    ***REMOVED***,
                    validate() { ***REMOVED***
                ***REMOVED***,
                bar: {
                    name: "bar",
                    requires: ["foo", "baz"],
                    merge() { ***REMOVED***,
                    validate() { ***REMOVED***
                ***REMOVED***
            ***REMOVED***);

            assert.throws(() => {
                schema.validate({ bar: true ***REMOVED***);
            ***REMOVED***, /Key "bar" requires keys "foo", "baz"./);
        ***REMOVED***);


        it("should throw an error when an expected key is found but is invalid", () => {

            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return "bar";
                    ***REMOVED***,
                    validate() {
                        throw new Error("Invalid key.");
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***);

            assert.throws(() => {
                schema.validate({ foo: true ***REMOVED***);
            ***REMOVED***, /Key "foo": Invalid key/);
        ***REMOVED***);

        it("should throw an error when an expected key is found but is invalid with a string validator", () => {

            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return "bar";
                    ***REMOVED***,
                    validate: "string"
                ***REMOVED***
            ***REMOVED***);

            assert.throws(() => {
                schema.validate({ foo: true ***REMOVED***);
            ***REMOVED***, /Key "foo": Expected a string/);
        ***REMOVED***);

        it("should throw an error when an expected key is found but is invalid with a number validator", () => {

            schema = new ObjectSchema({
                foo: {
                    merge() {
                        return "bar";
                    ***REMOVED***,
                    validate: "number"
                ***REMOVED***
            ***REMOVED***);

            assert.throws(() => {
                schema.validate({ foo: true ***REMOVED***);
            ***REMOVED***, /Key "foo": Expected a number/);
        ***REMOVED***);

        it("should throw an error when a required key is missing", () => {

            schema = new ObjectSchema({
                foo: {
                    required: true,
                    merge() {
                        return "bar";
                    ***REMOVED***,
                    validate() {***REMOVED***
                ***REMOVED***
            ***REMOVED***);

            assert.throws(() => {
                schema.validate({***REMOVED***);
            ***REMOVED***, /Missing required key "foo"/);
        ***REMOVED***);

        it("should throw an error when a subschema is provided and the value doesn't validate", () => {

            schema = new ObjectSchema({
                name: {
                    schema: {
                        first: {
                            merge: "replace",
                            validate: "string"
                        ***REMOVED***,
                        last: {
                            merge: "replace",
                            validate: "string"
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***);

            assert.throws(() => {
                schema.validate({
                    name: {
                        first: 123,
                        last: "z"
                    ***REMOVED***
                ***REMOVED***);
                        
            ***REMOVED***, /Key "name": Key "first": Expected a string/);
        ***REMOVED***);

        it("should not throw an error when a subschema is provided and the value validates", () => {

            schema = new ObjectSchema({
                name: {
                    schema: {
                        first: {
                            merge: "replace",
                            validate: "string"
                        ***REMOVED***,
                        last: {
                            merge: "replace",
                            validate: "string"
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***);

            schema.validate({
                name: {
                    first: "n",
                    last: "z"
                ***REMOVED***
            ***REMOVED***);
                    
        ***REMOVED***);

    ***REMOVED***);

***REMOVED***);
