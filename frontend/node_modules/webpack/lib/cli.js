/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const path = require("path");
const webpackSchema = require("../schemas/WebpackOptions.json");

/** @typedef {import("json-schema").JSONSchema4***REMOVED*** JSONSchema4 */
/** @typedef {import("json-schema").JSONSchema6***REMOVED*** JSONSchema6 */
/** @typedef {import("json-schema").JSONSchema7***REMOVED*** JSONSchema7 */
/** @typedef {JSONSchema4 | JSONSchema6 | JSONSchema7***REMOVED*** JSONSchema */
/** @typedef {JSONSchema & { absolutePath: boolean, instanceof: string, cli: { helper?: boolean, exclude?: boolean, description?: string, negatedDescription?: string, resetDescription?: string ***REMOVED*** ***REMOVED******REMOVED*** Schema */

// TODO add originPath to PathItem for better errors
/**
 * @typedef {object***REMOVED*** PathItem
 * @property {Schema***REMOVED*** schema the part of the schema
 * @property {string***REMOVED*** path the path in the config
 */

/** @typedef {"unknown-argument" | "unexpected-non-array-in-path" | "unexpected-non-object-in-path" | "multiple-values-unexpected" | "invalid-value"***REMOVED*** ProblemType */

/** @typedef {string | number | boolean | RegExp***REMOVED*** Value */

/**
 * @typedef {object***REMOVED*** Problem
 * @property {ProblemType***REMOVED*** type
 * @property {string***REMOVED*** path
 * @property {string***REMOVED*** argument
 * @property {Value=***REMOVED*** value
 * @property {number=***REMOVED*** index
 * @property {string=***REMOVED*** expected
 */

/**
 * @typedef {object***REMOVED*** LocalProblem
 * @property {ProblemType***REMOVED*** type
 * @property {string***REMOVED*** path
 * @property {string=***REMOVED*** expected
 */

/** @typedef {{ [key: string]: EnumValue ***REMOVED******REMOVED*** EnumValueObject */
/** @typedef {EnumValue[]***REMOVED*** EnumValueArray */
/** @typedef {string | number | boolean | EnumValueObject | EnumValueArray | null***REMOVED*** EnumValue */

/**
 * @typedef {object***REMOVED*** ArgumentConfig
 * @property {string=***REMOVED*** description
 * @property {string=***REMOVED*** negatedDescription
 * @property {string***REMOVED*** path
 * @property {boolean***REMOVED*** multiple
 * @property {"enum" | "string" | "path" | "number" | "boolean" | "RegExp" | "reset"***REMOVED*** type
 * @property {EnumValue[]=***REMOVED*** values
 */

/** @typedef {"string" | "number" | "boolean"***REMOVED*** SimpleType */

/**
 * @typedef {object***REMOVED*** Argument
 * @property {string | undefined***REMOVED*** description
 * @property {SimpleType***REMOVED*** simpleType
 * @property {boolean***REMOVED*** multiple
 * @property {ArgumentConfig[]***REMOVED*** configs
 */

/** @typedef {Record<string, Argument>***REMOVED*** Flags */

/**
 * @param {Schema=***REMOVED*** schema a json schema to create arguments for (by default webpack schema is used)
 * @returns {Flags***REMOVED*** object of arguments
 */
const getArguments = (schema = webpackSchema) => {
	/** @type {Flags***REMOVED*** */
	const flags = {***REMOVED***;

	/**
	 * @param {string***REMOVED*** input input
	 * @returns {string***REMOVED*** result
	 */
	const pathToArgumentName = input =>
		input
			.replace(/\./g, "-")
			.replace(/\[\]/g, "")
			.replace(
				/(\p{Uppercase_Letter***REMOVED***+|\p{Lowercase_Letter***REMOVED***|\d)(\p{Uppercase_Letter***REMOVED***+)/gu,
				"$1-$2"
			)
			.replace(/-?[^\p{Uppercase_Letter***REMOVED***\p{Lowercase_Letter***REMOVED***\d]+/gu, "-")
			.toLowerCase();

	/**
	 * @param {string***REMOVED*** path path
	 * @returns {Schema***REMOVED*** schema part
	 */
	const getSchemaPart = path => {
		const newPath = path.split("/");

		let schemaPart = schema;

		for (let i = 1; i < newPath.length; i++) {
			const inner = schemaPart[/** @type {keyof Schema***REMOVED*** */ (newPath[i])];

			if (!inner) {
				break;
			***REMOVED***

			schemaPart = inner;
		***REMOVED***

		return schemaPart;
	***REMOVED***;

	/**
	 * @param {PathItem[]***REMOVED*** path path in the schema
	 * @returns {string | undefined***REMOVED*** description
	 */
	const getDescription = path => {
		for (const { schema ***REMOVED*** of path) {
			if (schema.cli) {
				if (schema.cli.helper) continue;
				if (schema.cli.description) return schema.cli.description;
			***REMOVED***
			if (schema.description) return schema.description;
		***REMOVED***
	***REMOVED***;

	/**
	 * @param {PathItem[]***REMOVED*** path path in the schema
	 * @returns {string | undefined***REMOVED*** negative description
	 */
	const getNegatedDescription = path => {
		for (const { schema ***REMOVED*** of path) {
			if (schema.cli) {
				if (schema.cli.helper) continue;
				if (schema.cli.negatedDescription) return schema.cli.negatedDescription;
			***REMOVED***
		***REMOVED***
	***REMOVED***;

	/**
	 * @param {PathItem[]***REMOVED*** path path in the schema
	 * @returns {string | undefined***REMOVED*** reset description
	 */
	const getResetDescription = path => {
		for (const { schema ***REMOVED*** of path) {
			if (schema.cli) {
				if (schema.cli.helper) continue;
				if (schema.cli.resetDescription) return schema.cli.resetDescription;
			***REMOVED***
		***REMOVED***
	***REMOVED***;

	/**
	 * @param {Schema***REMOVED*** schemaPart schema
	 * @returns {Pick<ArgumentConfig, "type" | "values"> | undefined***REMOVED*** partial argument config
	 */
	const schemaToArgumentConfig = schemaPart => {
		if (schemaPart.enum) {
			return {
				type: "enum",
				values: schemaPart.enum
			***REMOVED***;
		***REMOVED***
		switch (schemaPart.type) {
			case "number":
				return {
					type: "number"
				***REMOVED***;
			case "string":
				return {
					type: schemaPart.absolutePath ? "path" : "string"
				***REMOVED***;
			case "boolean":
				return {
					type: "boolean"
				***REMOVED***;
		***REMOVED***
		if (schemaPart.instanceof === "RegExp") {
			return {
				type: "RegExp"
			***REMOVED***;
		***REMOVED***
		return undefined;
	***REMOVED***;

	/**
	 * @param {PathItem[]***REMOVED*** path path in the schema
	 * @returns {void***REMOVED***
	 */
	const addResetFlag = path => {
		const schemaPath = path[0].path;
		const name = pathToArgumentName(`${schemaPath***REMOVED***.reset`);
		const description =
			getResetDescription(path) ||
			`Clear all items provided in '${schemaPath***REMOVED***' configuration. ${getDescription(
				path
			)***REMOVED***`;
		flags[name] = {
			configs: [
				{
					type: "reset",
					multiple: false,
					description,
					path: schemaPath
				***REMOVED***
			],
			description: undefined,
			simpleType:
				/** @type {SimpleType***REMOVED*** */
				(/** @type {unknown***REMOVED*** */ (undefined)),
			multiple: /** @type {boolean***REMOVED*** */ (/** @type {unknown***REMOVED*** */ (undefined))
		***REMOVED***;
	***REMOVED***;

	/**
	 * @param {PathItem[]***REMOVED*** path full path in schema
	 * @param {boolean***REMOVED*** multiple inside of an array
	 * @returns {number***REMOVED*** number of arguments added
	 */
	const addFlag = (path, multiple) => {
		const argConfigBase = schemaToArgumentConfig(path[0].schema);
		if (!argConfigBase) return 0;

		const negatedDescription = getNegatedDescription(path);
		const name = pathToArgumentName(path[0].path);
		/** @type {ArgumentConfig***REMOVED*** */
		const argConfig = {
			...argConfigBase,
			multiple,
			description: getDescription(path),
			path: path[0].path
		***REMOVED***;

		if (negatedDescription) {
			argConfig.negatedDescription = negatedDescription;
		***REMOVED***

		if (!flags[name]) {
			flags[name] = {
				configs: [],
				description: undefined,
				simpleType:
					/** @type {SimpleType***REMOVED*** */
					(/** @type {unknown***REMOVED*** */ (undefined)),
				multiple: /** @type {boolean***REMOVED*** */ (/** @type {unknown***REMOVED*** */ (undefined))
			***REMOVED***;
		***REMOVED***

		if (
			flags[name].configs.some(
				item => JSON.stringify(item) === JSON.stringify(argConfig)
			)
		) {
			return 0;
		***REMOVED***

		if (
			flags[name].configs.some(
				item => item.type === argConfig.type && item.multiple !== multiple
			)
		) {
			if (multiple) {
				throw new Error(
					`Conflicting schema for ${path[0].path***REMOVED*** with ${argConfig.type***REMOVED*** type (array type must be before single item type)`
				);
			***REMOVED***
			return 0;
		***REMOVED***

		flags[name].configs.push(argConfig);

		return 1;
	***REMOVED***;

	// TODO support `not` and `if/then/else`
	// TODO support `const`, but we don't use it on our schema
	/**
	 * @param {Schema***REMOVED*** schemaPart the current schema
	 * @param {string***REMOVED*** schemaPath the current path in the schema
	 * @param {PathItem[]***REMOVED*** path all previous visited schemaParts
	 * @param {string | null***REMOVED*** inArray if inside of an array, the path to the array
	 * @returns {number***REMOVED*** added arguments
	 */
	const traverse = (schemaPart, schemaPath = "", path = [], inArray = null) => {
		while (schemaPart.$ref) {
			schemaPart = getSchemaPart(schemaPart.$ref);
		***REMOVED***

		const repetitions = path.filter(({ schema ***REMOVED***) => schema === schemaPart);
		if (
			repetitions.length >= 2 ||
			repetitions.some(({ path ***REMOVED***) => path === schemaPath)
		) {
			return 0;
		***REMOVED***

		if (schemaPart.cli && schemaPart.cli.exclude) return 0;

		/** @type {PathItem[]***REMOVED*** */
		const fullPath = [{ schema: schemaPart, path: schemaPath ***REMOVED***, ...path];

		let addedArguments = 0;

		addedArguments += addFlag(fullPath, Boolean(inArray));

		if (schemaPart.type === "object") {
			if (schemaPart.properties) {
				for (const property of Object.keys(schemaPart.properties)) {
					addedArguments += traverse(
						/** @type {Schema***REMOVED*** */
						(schemaPart.properties[property]),
						schemaPath ? `${schemaPath***REMOVED***.${property***REMOVED***` : property,
						fullPath,
						inArray
					);
				***REMOVED***
			***REMOVED***

			return addedArguments;
		***REMOVED***

		if (schemaPart.type === "array") {
			if (inArray) {
				return 0;
			***REMOVED***
			if (Array.isArray(schemaPart.items)) {
				const i = 0;
				for (const item of schemaPart.items) {
					addedArguments += traverse(
						/** @type {Schema***REMOVED*** */
						(item),
						`${schemaPath***REMOVED***.${i***REMOVED***`,
						fullPath,
						schemaPath
					);
				***REMOVED***

				return addedArguments;
			***REMOVED***

			addedArguments += traverse(
				/** @type {Schema***REMOVED*** */
				(schemaPart.items),
				`${schemaPath***REMOVED***[]`,
				fullPath,
				schemaPath
			);

			if (addedArguments > 0) {
				addResetFlag(fullPath);
				addedArguments++;
			***REMOVED***

			return addedArguments;
		***REMOVED***

		const maybeOf = schemaPart.oneOf || schemaPart.anyOf || schemaPart.allOf;

		if (maybeOf) {
			const items = maybeOf;

			for (let i = 0; i < items.length; i++) {
				addedArguments += traverse(
					/** @type {Schema***REMOVED*** */
					(items[i]),
					schemaPath,
					fullPath,
					inArray
				);
			***REMOVED***

			return addedArguments;
		***REMOVED***

		return addedArguments;
	***REMOVED***;

	traverse(schema);

	// Summarize flags
	for (const name of Object.keys(flags)) {
		/** @type {Argument***REMOVED*** */
		const argument = flags[name];
		argument.description = argument.configs.reduce((desc, { description ***REMOVED***) => {
			if (!desc) return description;
			if (!description) return desc;
			if (desc.includes(description)) return desc;
			return `${desc***REMOVED*** ${description***REMOVED***`;
		***REMOVED***, /** @type {string | undefined***REMOVED*** */ (undefined));
		argument.simpleType =
			/** @type {SimpleType***REMOVED*** */
			(
				argument.configs.reduce((t, argConfig) => {
					/** @type {SimpleType***REMOVED*** */
					let type = "string";
					switch (argConfig.type) {
						case "number":
							type = "number";
							break;
						case "reset":
						case "boolean":
							type = "boolean";
							break;
						case "enum": {
							const values =
								/** @type {NonNullable<ArgumentConfig["values"]>***REMOVED*** */
								(argConfig.values);

							if (values.every(v => typeof v === "boolean")) type = "boolean";
							if (values.every(v => typeof v === "number")) type = "number";
							break;
						***REMOVED***
					***REMOVED***
					if (t === undefined) return type;
					return t === type ? t : "string";
				***REMOVED***, /** @type {SimpleType | undefined***REMOVED*** */ (undefined))
			);
		argument.multiple = argument.configs.some(c => c.multiple);
	***REMOVED***

	return flags;
***REMOVED***;

const cliAddedItems = new WeakMap();

/** @typedef {string | number***REMOVED*** Property */

/**
 * @param {Configuration***REMOVED*** config configuration
 * @param {string***REMOVED*** schemaPath path in the config
 * @param {number | undefined***REMOVED*** index index of value when multiple values are provided, otherwise undefined
 * @returns {{ problem?: LocalProblem, object?: TODO, property?: Property, value?: EXPECTED_OBJECT | EXPECTED_ANY[] ***REMOVED******REMOVED*** problem or object with property and value
 */
const getObjectAndProperty = (config, schemaPath, index = 0) => {
	if (!schemaPath) return { value: config ***REMOVED***;
	const parts = schemaPath.split(".");
	const property = /** @type {string***REMOVED*** */ (parts.pop());
	let current = config;
	let i = 0;
	for (const part of parts) {
		const isArray = part.endsWith("[]");
		const name = isArray ? part.slice(0, -2) : part;
		let value = current[name];
		if (isArray) {
			if (value === undefined) {
				value = {***REMOVED***;
				current[name] = [...Array.from({ length: index ***REMOVED***), value];
				cliAddedItems.set(current[name], index + 1);
			***REMOVED*** else if (!Array.isArray(value)) {
				return {
					problem: {
						type: "unexpected-non-array-in-path",
						path: parts.slice(0, i).join(".")
					***REMOVED***
				***REMOVED***;
			***REMOVED*** else {
				let addedItems = cliAddedItems.get(value) || 0;
				while (addedItems <= index) {
					value.push(undefined);
					addedItems++;
				***REMOVED***
				cliAddedItems.set(value, addedItems);
				const x = value.length - addedItems + index;
				if (value[x] === undefined) {
					value[x] = {***REMOVED***;
				***REMOVED*** else if (value[x] === null || typeof value[x] !== "object") {
					return {
						problem: {
							type: "unexpected-non-object-in-path",
							path: parts.slice(0, i).join(".")
						***REMOVED***
					***REMOVED***;
				***REMOVED***
				value = value[x];
			***REMOVED***
		***REMOVED*** else if (value === undefined) {
			value = current[name] = {***REMOVED***;
		***REMOVED*** else if (value === null || typeof value !== "object") {
			return {
				problem: {
					type: "unexpected-non-object-in-path",
					path: parts.slice(0, i).join(".")
				***REMOVED***
			***REMOVED***;
		***REMOVED***
		current = value;
		i++;
	***REMOVED***
	const value = current[property];
	if (property.endsWith("[]")) {
		const name = property.slice(0, -2);
		const value = current[name];
		if (value === undefined) {
			current[name] = [...Array.from({ length: index ***REMOVED***), undefined];
			cliAddedItems.set(current[name], index + 1);
			return { object: current[name], property: index, value: undefined ***REMOVED***;
		***REMOVED*** else if (!Array.isArray(value)) {
			current[name] = [value, ...Array.from({ length: index ***REMOVED***), undefined];
			cliAddedItems.set(current[name], index + 1);
			return { object: current[name], property: index + 1, value: undefined ***REMOVED***;
		***REMOVED***
		let addedItems = cliAddedItems.get(value) || 0;
		while (addedItems <= index) {
			value.push(undefined);
			addedItems++;
		***REMOVED***
		cliAddedItems.set(value, addedItems);
		const x = value.length - addedItems + index;
		if (value[x] === undefined) {
			value[x] = {***REMOVED***;
		***REMOVED*** else if (value[x] === null || typeof value[x] !== "object") {
			return {
				problem: {
					type: "unexpected-non-object-in-path",
					path: schemaPath
				***REMOVED***
			***REMOVED***;
		***REMOVED***
		return {
			object: value,
			property: x,
			value: value[x]
		***REMOVED***;
	***REMOVED***
	return { object: current, property, value ***REMOVED***;
***REMOVED***;

/**
 * @param {Configuration***REMOVED*** config configuration
 * @param {string***REMOVED*** schemaPath path in the config
 * @param {ParsedValue***REMOVED*** value parsed value
 * @param {number | undefined***REMOVED*** index index of value when multiple values are provided, otherwise undefined
 * @returns {LocalProblem | null***REMOVED*** problem or null for success
 */
const setValue = (config, schemaPath, value, index) => {
	const { problem, object, property ***REMOVED*** = getObjectAndProperty(
		config,
		schemaPath,
		index
	);
	if (problem) return problem;
	object[/** @type {Property***REMOVED*** */ (property)] = value;
	return null;
***REMOVED***;

/**
 * @param {ArgumentConfig***REMOVED*** argConfig processing instructions
 * @param {Configuration***REMOVED*** config configuration
 * @param {Value***REMOVED*** value the value
 * @param {number | undefined***REMOVED*** index the index if multiple values provided
 * @returns {LocalProblem | null***REMOVED*** a problem if any
 */
const processArgumentConfig = (argConfig, config, value, index) => {
	if (index !== undefined && !argConfig.multiple) {
		return {
			type: "multiple-values-unexpected",
			path: argConfig.path
		***REMOVED***;
	***REMOVED***
	const parsed = parseValueForArgumentConfig(argConfig, value);
	if (parsed === undefined) {
		return {
			type: "invalid-value",
			path: argConfig.path,
			expected: getExpectedValue(argConfig)
		***REMOVED***;
	***REMOVED***
	const problem = setValue(config, argConfig.path, parsed, index);
	if (problem) return problem;
	return null;
***REMOVED***;

/**
 * @param {ArgumentConfig***REMOVED*** argConfig processing instructions
 * @returns {string | undefined***REMOVED*** expected message
 */
const getExpectedValue = argConfig => {
	switch (argConfig.type) {
		case "boolean":
			return "true | false";
		case "RegExp":
			return "regular expression (example: /ab?c*/)";
		case "enum":
			return /** @type {NonNullable<ArgumentConfig["values"]>***REMOVED*** */ (
				argConfig.values
			)
				.map(v => `${v***REMOVED***`)
				.join(" | ");
		case "reset":
			return "true (will reset the previous value to an empty array)";
		default:
			return argConfig.type;
	***REMOVED***
***REMOVED***;

/** @typedef {null | string | number | boolean | RegExp | EnumValue | []***REMOVED*** ParsedValue */

/**
 * @param {ArgumentConfig***REMOVED*** argConfig processing instructions
 * @param {Value***REMOVED*** value the value
 * @returns {ParsedValue | undefined***REMOVED*** parsed value
 */
const parseValueForArgumentConfig = (argConfig, value) => {
	switch (argConfig.type) {
		case "string":
			if (typeof value === "string") {
				return value;
			***REMOVED***
			break;
		case "path":
			if (typeof value === "string") {
				return path.resolve(value);
			***REMOVED***
			break;
		case "number":
			if (typeof value === "number") return value;
			if (typeof value === "string" && /^[+-]?\d*(\.\d*)[eE]\d+$/) {
				const n = Number(value);
				if (!Number.isNaN(n)) return n;
			***REMOVED***
			break;
		case "boolean":
			if (typeof value === "boolean") return value;
			if (value === "true") return true;
			if (value === "false") return false;
			break;
		case "RegExp":
			if (value instanceof RegExp) return value;
			if (typeof value === "string") {
				// cspell:word yugi
				const match = /^\/(.*)\/([yugi]*)$/.exec(value);
				if (match && !/[^\\]\//.test(match[1]))
					return new RegExp(match[1], match[2]);
			***REMOVED***
			break;
		case "enum": {
			const values =
				/** @type {EnumValue[]***REMOVED*** */
				(argConfig.values);
			if (values.includes(/** @type {Exclude<Value, RegExp>***REMOVED*** */ (value)))
				return value;
			for (const item of values) {
				if (`${item***REMOVED***` === value) return item;
			***REMOVED***
			break;
		***REMOVED***
		case "reset":
			if (value === true) return [];
			break;
	***REMOVED***
***REMOVED***;

/** @typedef {TODO***REMOVED*** Configuration */

/**
 * @param {Flags***REMOVED*** args object of arguments
 * @param {Configuration***REMOVED*** config configuration
 * @param {Record<string, Value[]>***REMOVED*** values object with values
 * @returns {Problem[] | null***REMOVED*** problems or null for success
 */
const processArguments = (args, config, values) => {
	/** @type {Problem[]***REMOVED*** */
	const problems = [];
	for (const key of Object.keys(values)) {
		const arg = args[key];
		if (!arg) {
			problems.push({
				type: "unknown-argument",
				path: "",
				argument: key
			***REMOVED***);
			continue;
		***REMOVED***
		/**
		 * @param {Value***REMOVED*** value value
		 * @param {number | undefined***REMOVED*** i index
		 */
		const processValue = (value, i) => {
			const currentProblems = [];
			for (const argConfig of arg.configs) {
				const problem = processArgumentConfig(argConfig, config, value, i);
				if (!problem) {
					return;
				***REMOVED***
				currentProblems.push({
					...problem,
					argument: key,
					value,
					index: i
				***REMOVED***);
			***REMOVED***
			problems.push(...currentProblems);
		***REMOVED***;
		const value = values[key];
		if (Array.isArray(value)) {
			for (let i = 0; i < value.length; i++) {
				processValue(value[i], i);
			***REMOVED***
		***REMOVED*** else {
			processValue(value, undefined);
		***REMOVED***
	***REMOVED***
	if (problems.length === 0) return null;
	return problems;
***REMOVED***;

module.exports.getArguments = getArguments;
module.exports.processArguments = processArguments;
