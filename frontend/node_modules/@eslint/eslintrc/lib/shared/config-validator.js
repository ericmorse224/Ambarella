/**
 * @fileoverview Validates configs.
 * @author Brandon Mills
 */

"use strict";

/* eslint class-methods-use-this: "off" */

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const
    util = require("util"),
    configSchema = require("../../conf/config-schema"),
    BuiltInEnvironments = require("../../conf/environments"),
    ConfigOps = require("./config-ops"),
    { emitDeprecationWarning ***REMOVED*** = require("./deprecation-warnings");

const ajv = require("./ajv")();
const ruleValidators = new WeakMap();
const noop = Function.prototype;

//------------------------------------------------------------------------------
// Private
//------------------------------------------------------------------------------
let validateSchema;
const severityMap = {
    error: 2,
    warn: 1,
    off: 0
***REMOVED***;

const validated = new WeakSet();

//-----------------------------------------------------------------------------
// Exports
//-----------------------------------------------------------------------------

module.exports = class ConfigValidator {
    constructor({ builtInRules = new Map() ***REMOVED*** = {***REMOVED***) {
        this.builtInRules = builtInRules;
    ***REMOVED***

    /**
     * Gets a complete options schema for a rule.
     * @param {{create: Function, schema: (Array|null)***REMOVED******REMOVED*** rule A new-style rule object
     * @returns {Object***REMOVED*** JSON Schema for the rule's options.
     */
    getRuleOptionsSchema(rule) {
        if (!rule) {
            return null;
        ***REMOVED***

        const schema = rule.schema || rule.meta && rule.meta.schema;

        // Given a tuple of schemas, insert warning level at the beginning
        if (Array.isArray(schema)) {
            if (schema.length) {
                return {
                    type: "array",
                    items: schema,
                    minItems: 0,
                    maxItems: schema.length
                ***REMOVED***;
            ***REMOVED***
            return {
                type: "array",
                minItems: 0,
                maxItems: 0
            ***REMOVED***;

        ***REMOVED***

        // Given a full schema, leave it alone
        return schema || null;
    ***REMOVED***

    /**
     * Validates a rule's severity and returns the severity value. Throws an error if the severity is invalid.
     * @param {options***REMOVED*** options The given options for the rule.
     * @returns {number|string***REMOVED*** The rule's severity value
     */
    validateRuleSeverity(options) {
        const severity = Array.isArray(options) ? options[0] : options;
        const normSeverity = typeof severity === "string" ? severityMap[severity.toLowerCase()] : severity;

        if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {
            return normSeverity;
        ***REMOVED***

        throw new Error(`\tSeverity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util.inspect(severity).replace(/'/gu, "\"").replace(/\n/gu, "")***REMOVED***').\n`);

    ***REMOVED***

    /**
     * Validates the non-severity options passed to a rule, based on its schema.
     * @param {{create: Function***REMOVED******REMOVED*** rule The rule to validate
     * @param {Array***REMOVED*** localOptions The options for the rule, excluding severity
     * @returns {void***REMOVED***
     */
    validateRuleSchema(rule, localOptions) {
        if (!ruleValidators.has(rule)) {
            const schema = this.getRuleOptionsSchema(rule);

            if (schema) {
                ruleValidators.set(rule, ajv.compile(schema));
            ***REMOVED***
        ***REMOVED***

        const validateRule = ruleValidators.get(rule);

        if (validateRule) {
            validateRule(localOptions);
            if (validateRule.errors) {
                throw new Error(validateRule.errors.map(
                    error => `\tValue ${JSON.stringify(error.data)***REMOVED*** ${error.message***REMOVED***.\n`
                ).join(""));
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    /**
     * Validates a rule's options against its schema.
     * @param {{create: Function***REMOVED***|null***REMOVED*** rule The rule that the config is being validated for
     * @param {string***REMOVED*** ruleId The rule's unique name.
     * @param {Array|number***REMOVED*** options The given options for the rule.
     * @param {string|null***REMOVED*** source The name of the configuration source to report in any errors. If null or undefined,
     * no source is prepended to the message.
     * @returns {void***REMOVED***
     */
    validateRuleOptions(rule, ruleId, options, source = null) {
        try {
            const severity = this.validateRuleSeverity(options);

            if (severity !== 0) {
                this.validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);
            ***REMOVED***
        ***REMOVED*** catch (err) {
            const enhancedMessage = `Configuration for rule "${ruleId***REMOVED***" is invalid:\n${err.message***REMOVED***`;

            if (typeof source === "string") {
                throw new Error(`${source***REMOVED***:\n\t${enhancedMessage***REMOVED***`);
            ***REMOVED*** else {
                throw new Error(enhancedMessage);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    /**
     * Validates an environment object
     * @param {Object***REMOVED*** environment The environment config object to validate.
     * @param {string***REMOVED*** source The name of the configuration source to report in any errors.
     * @param {function(envId:string): Object***REMOVED*** [getAdditionalEnv] A map from strings to loaded environments.
     * @returns {void***REMOVED***
     */
    validateEnvironment(
        environment,
        source,
        getAdditionalEnv = noop
    ) {

        // not having an environment is ok
        if (!environment) {
            return;
        ***REMOVED***

        Object.keys(environment).forEach(id => {
            const env = getAdditionalEnv(id) || BuiltInEnvironments.get(id) || null;

            if (!env) {
                const message = `${source***REMOVED***:\n\tEnvironment key "${id***REMOVED***" is unknown\n`;

                throw new Error(message);
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***

    /**
     * Validates a rules config object
     * @param {Object***REMOVED*** rulesConfig The rules config object to validate.
     * @param {string***REMOVED*** source The name of the configuration source to report in any errors.
     * @param {function(ruleId:string): Object***REMOVED*** getAdditionalRule A map from strings to loaded rules
     * @returns {void***REMOVED***
     */
    validateRules(
        rulesConfig,
        source,
        getAdditionalRule = noop
    ) {
        if (!rulesConfig) {
            return;
        ***REMOVED***

        Object.keys(rulesConfig).forEach(id => {
            const rule = getAdditionalRule(id) || this.builtInRules.get(id) || null;

            this.validateRuleOptions(rule, id, rulesConfig[id], source);
        ***REMOVED***);
    ***REMOVED***

    /**
     * Validates a `globals` section of a config file
     * @param {Object***REMOVED*** globalsConfig The `globals` section
     * @param {string|null***REMOVED*** source The name of the configuration source to report in the event of an error.
     * @returns {void***REMOVED***
     */
    validateGlobals(globalsConfig, source = null) {
        if (!globalsConfig) {
            return;
        ***REMOVED***

        Object.entries(globalsConfig)
            .forEach(([configuredGlobal, configuredValue]) => {
                try {
                    ConfigOps.normalizeConfigGlobal(configuredValue);
                ***REMOVED*** catch (err) {
                    throw new Error(`ESLint configuration of global '${configuredGlobal***REMOVED***' in ${source***REMOVED*** is invalid:\n${err.message***REMOVED***`);
                ***REMOVED***
            ***REMOVED***);
    ***REMOVED***

    /**
     * Validate `processor` configuration.
     * @param {string|undefined***REMOVED*** processorName The processor name.
     * @param {string***REMOVED*** source The name of config file.
     * @param {function(id:string): Processor***REMOVED*** getProcessor The getter of defined processors.
     * @returns {void***REMOVED***
     */
    validateProcessor(processorName, source, getProcessor) {
        if (processorName && !getProcessor(processorName)) {
            throw new Error(`ESLint configuration of processor in '${source***REMOVED***' is invalid: '${processorName***REMOVED***' was not found.`);
        ***REMOVED***
    ***REMOVED***

    /**
     * Formats an array of schema validation errors.
     * @param {Array***REMOVED*** errors An array of error messages to format.
     * @returns {string***REMOVED*** Formatted error message
     */
    formatErrors(errors) {
        return errors.map(error => {
            if (error.keyword === "additionalProperties") {
                const formattedPropertyPath = error.dataPath.length ? `${error.dataPath.slice(1)***REMOVED***.${error.params.additionalProperty***REMOVED***` : error.params.additionalProperty;

                return `Unexpected top-level property "${formattedPropertyPath***REMOVED***"`;
            ***REMOVED***
            if (error.keyword === "type") {
                const formattedField = error.dataPath.slice(1);
                const formattedExpectedType = Array.isArray(error.schema) ? error.schema.join("/") : error.schema;
                const formattedValue = JSON.stringify(error.data);

                return `Property "${formattedField***REMOVED***" is the wrong type (expected ${formattedExpectedType***REMOVED*** but got \`${formattedValue***REMOVED***\`)`;
            ***REMOVED***

            const field = error.dataPath[0] === "." ? error.dataPath.slice(1) : error.dataPath;

            return `"${field***REMOVED***" ${error.message***REMOVED***. Value: ${JSON.stringify(error.data)***REMOVED***`;
        ***REMOVED***).map(message => `\t- ${message***REMOVED***.\n`).join("");
    ***REMOVED***

    /**
     * Validates the top level properties of the config object.
     * @param {Object***REMOVED*** config The config object to validate.
     * @param {string***REMOVED*** source The name of the configuration source to report in any errors.
     * @returns {void***REMOVED***
     */
    validateConfigSchema(config, source = null) {
        validateSchema = validateSchema || ajv.compile(configSchema);

        if (!validateSchema(config)) {
            throw new Error(`ESLint configuration in ${source***REMOVED*** is invalid:\n${this.formatErrors(validateSchema.errors)***REMOVED***`);
        ***REMOVED***

        if (Object.hasOwnProperty.call(config, "ecmaFeatures")) {
            emitDeprecationWarning(source, "ESLINT_LEGACY_ECMAFEATURES");
        ***REMOVED***
    ***REMOVED***

    /**
     * Validates an entire config object.
     * @param {Object***REMOVED*** config The config object to validate.
     * @param {string***REMOVED*** source The name of the configuration source to report in any errors.
     * @param {function(ruleId:string): Object***REMOVED*** [getAdditionalRule] A map from strings to loaded rules.
     * @param {function(envId:string): Object***REMOVED*** [getAdditionalEnv] A map from strings to loaded envs.
     * @returns {void***REMOVED***
     */
    validate(config, source, getAdditionalRule, getAdditionalEnv) {
        this.validateConfigSchema(config, source);
        this.validateRules(config.rules, source, getAdditionalRule);
        this.validateEnvironment(config.env, source, getAdditionalEnv);
        this.validateGlobals(config.globals, source);

        for (const override of config.overrides || []) {
            this.validateRules(override.rules, source, getAdditionalRule);
            this.validateEnvironment(override.env, source, getAdditionalEnv);
            this.validateGlobals(config.globals, source);
        ***REMOVED***
    ***REMOVED***

    /**
     * Validate config array object.
     * @param {ConfigArray***REMOVED*** configArray The config array to validate.
     * @returns {void***REMOVED***
     */
    validateConfigArray(configArray) {
        const getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);
        const getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);
        const getPluginRule = Map.prototype.get.bind(configArray.pluginRules);

        // Validate.
        for (const element of configArray) {
            if (validated.has(element)) {
                continue;
            ***REMOVED***
            validated.add(element);

            this.validateEnvironment(element.env, element.name, getPluginEnv);
            this.validateGlobals(element.globals, element.name);
            this.validateProcessor(element.processor, element.name, getPluginProcessor);
            this.validateRules(element.rules, element.name, getPluginRule);
        ***REMOVED***
    ***REMOVED***

***REMOVED***;
