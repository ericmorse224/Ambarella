/**
 * @author Matthew Caruana Galizia <mattcg@gmail.com>
 * @license MIT: http://mattcg.mit-license.org/
 * @copyright Copyright (c) 2013, Matthew Caruana Galizia
 */

'use strict';

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; ***REMOVED*** : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; ***REMOVED***, _typeof(obj); ***REMOVED***
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); ***REMOVED*** ***REMOVED***
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); ***REMOVED*** ***REMOVED***
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false ***REMOVED***); return Constructor; ***REMOVED***
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true ***REMOVED***); ***REMOVED*** else { obj[key] = value; ***REMOVED*** return obj; ***REMOVED***
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); ***REMOVED***
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); ***REMOVED*** return (hint === "string" ? String : Number)(input); ***REMOVED***
var index = require('language-subtag-registry/data/json/index.json');
var registry = require('language-subtag-registry/data/json/registry.json');
var Subtag = require('./Subtag.js');
var Tag = /*#__PURE__*/function () {
  /** @param {string***REMOVED*** tag */
  function Tag(tag) {
    _classCallCheck(this, Tag);
    var types;

    // Lowercase for consistency (case is only a formatting convention, not a standard requirement).
    tag = tag.trim().toLowerCase();
    this.data = {
      tag: tag
    ***REMOVED***;

    // Check if the input tag is grandfathered or redundant.
    types = index[tag];
    if (types && (types.grandfathered || types.redundant)) {
      this.data.record = registry[types.grandfathered || types.redundant];
    ***REMOVED***
  ***REMOVED***
  _createClass(Tag, [{
    key: "preferred",
    value: function preferred() {
      var preferred = this.data.record['Preferred-Value'];
      if (preferred) {
        return new Tag(preferred);
      ***REMOVED***
      return null;
    ***REMOVED***

    /** @return {Subtag[]***REMOVED*** */
  ***REMOVED***, {
    key: "subtags",
    value: function subtags() {
      var codes,
        data = this.data,
        subtags = [];

      // No subtags if the tag is grandfathered.
      if (data.record && this.type() === 'grandfathered') {
        return subtags;
      ***REMOVED***
      codes = data.tag.split('-');
      if (!codes.length) {
        return subtags;
      ***REMOVED***

      // Try and find the language tag.
      codes.some(function (code, i) {
        var types;

        // Singletons and anything after are unhandled.
        if (code.length < 2) {
          return true; // Stop the loop (stop processing after a singleton).
        ***REMOVED***

        types = index[code];

        // Check for non-existent tag.
        if (!types) {
          return; // Skip to the next item.
        ***REMOVED***

        // Check against undefined because value could be 0.
        // Language subtags may only appear at the beginning of the tag, otherwise the subtag type is indeterminate.
        if (0 === i && undefined !== types.language) {
          subtags.push(new Subtag(code, 'language'));
          return;
        ***REMOVED***
        switch (code.length) {
          case 2:
            // Should be a region.
            if (types.region) {
              subtags.push(new Subtag(code, 'region'));

              // Error case: language subtag in the wrong place.
            ***REMOVED*** else if (types.language) {
              subtags.push(new Subtag(code, 'language'));
            ***REMOVED***
            break;
          case 3:
            // Could be a numeric region code e.g. '001' for 'World'.
            if (types.region) {
              subtags.push(new Subtag(code, 'region'));
            ***REMOVED*** else if (types.extlang) {
              subtags.push(new Subtag(code, 'extlang'));

              // Error case: language subtag in the wrong place.
            ***REMOVED*** else if (types.language) {
              subtags.push(new Subtag(code, 'language'));
            ***REMOVED***
            break;
          case 4:
            // Could be a numeric variant.
            if (types.variant) {
              subtags.push(new Subtag(code, 'variant'));
            ***REMOVED*** else if (types.script) {
              subtags.push(new Subtag(code, 'script'));
            ***REMOVED***
            break;
          default:
            // Should be a variant.
            if (types.variant) {
              subtags.push(new Subtag(code, 'variant'));
            ***REMOVED***
            break;
        ***REMOVED***
      ***REMOVED***);
      return subtags;
    ***REMOVED***
  ***REMOVED***, {
    key: "language",
    value: function language() {
      return this.find('language');
    ***REMOVED***
  ***REMOVED***, {
    key: "region",
    value: function region() {
      return this.find('region');
    ***REMOVED***
  ***REMOVED***, {
    key: "script",
    value: function script() {
      return this.find('script');
    ***REMOVED***

    /** @param {string***REMOVED*** type */
  ***REMOVED***, {
    key: "find",
    value: function find(type) {
      var i,
        l,
        subtag,
        subtags = this.subtags();
      for (i = 0, l = subtags.length; i < l; i++) {
        subtag = subtags[i];
        if (subtag.type() === type) {
          return subtag;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***, {
    key: "valid",
    value: function valid() {
      return this.errors().length < 1;
    ***REMOVED***
  ***REMOVED***, {
    key: "errors",
    value: function errors() {
      var error,
        subtags,
        data = this.data,
        errors = [];
      error = function error(code, subtag) {
        var err, message;
        switch (code) {
          case Tag.ERR_DEPRECATED:
            message = 'The tag \'' + data.tag + '\' is deprecated.';

            // Note that a record that contains a 'Deprecated' field and no corresponding 'Preferred-Value' field has no replacement mapping (RFC 5646 section 3.1.6).
            if (data.record['Preferred-Value']) {
              message += ' Use \'' + data.record['Preferred-Value'] + '\' instead.';
            ***REMOVED***
            break;
          case Tag.ERR_SUBTAG_DEPRECATED:
            message = 'The subtag \'' + subtag + '\' is deprecated.';
            break;
          case Tag.ERR_NO_LANGUAGE:
            if (!data.tag) {
              message = 'Empty tag.';
            ***REMOVED*** else {
              message = 'Missing language tag in \'' + data.tag + '\'.';
            ***REMOVED***
            break;
          case Tag.ERR_UNKNOWN:
            message = 'Unknown code \'' + subtag + '\'';
            break;
          case Tag.ERR_TOO_LONG:
            message = 'The private-use subtag \'' + subtag + '\' is too long.';
            break;
          case Tag.ERR_EXTRA_LANGUAGE:
          case Tag.ERR_EXTRA_EXTLANG:
          case Tag.ERR_EXTRA_REGION:
          case Tag.ERR_EXTRA_SCRIPT:
            message = 'Extra ' + subtag.type() + ' subtag \'' + subtag + '\' found.';
            break;
          case Tag.ERR_DUPLICATE_VARIANT:
            message = 'Duplicate variant subtag \'' + subtag + '\' found.';
            break;
          case Tag.ERR_WRONG_ORDER:
            message = 'The subtag \'' + subtag[0] + '\' should not appear before \'' + subtag[1] + '\'.';
            break;
          case Tag.ERR_SUPPRESS_SCRIPT:
            message = 'The script subtag \'' + subtag + '\' is the same as the language suppress-script.';
            break;
        ***REMOVED***
        err = new Error(message);
        err.code = code;
        err.tag = data.tag;
        err.subtag = subtag;
        errors.push(err);
      ***REMOVED***;

      // Check if the tag is grandfathered and if the grandfathered tag is deprecated (e.g. no-nyn).
      if (data.record) {
        if (data.record.Deprecated) {
          error(Tag.ERR_DEPRECATED);
        ***REMOVED***

        // Only check every subtag if the tag is not explicitly listed as grandfathered or redundant.
        return errors;
      ***REMOVED***

      // Check that all subtag codes are meaningful.
      data.tag.split('-').some(function (code, i, codes) {
        var types;

        // Ignore anything after a singleton.
        if (code.length < 2) {
          // Check that each private-use subtag is within the maximum allowed length.
          codes.slice(i).forEach(function (code) {
            if (code.length > 8) {
              error(Tag.ERR_TOO_LONG, code);
            ***REMOVED***
          ***REMOVED***);
          return true;
        ***REMOVED***
        types = index[code];
        if (!types) {
          error(Tag.ERR_UNKNOWN, code);
        ***REMOVED***
        return false; // Continue to the next item.
      ***REMOVED***);

      // Check that first tag is a language tag.
      subtags = this.subtags();
      if (!subtags.length || 'language' !== subtags[0].type()) {
        error(Tag.ERR_NO_LANGUAGE);
        return errors;
      ***REMOVED***

      // Check for more than one of some types and for deprecation.
      subtags.forEach(function (subtag, i) {
        var type = subtag.type(),
          language,
          script,
          found = this;
        if (subtag.deprecated()) {
          error(Tag.ERR_SUBTAG_DEPRECATED, subtag);
        ***REMOVED***
        if (found[type]) {
          found[type].push(subtag);
        ***REMOVED***
        switch (type) {
          case 'language':
            if (found.language.length > 1) {
              error(Tag.ERR_EXTRA_LANGUAGE, subtag);
            ***REMOVED***
            break;
          case 'region':
            if (found.region.length > 1) {
              error(Tag.ERR_EXTRA_REGION, subtag);
            ***REMOVED***
            break;
          case 'extlang':
            if (found.extlang.length > 1) {
              error(Tag.ERR_EXTRA_EXTLANG, subtag);
            ***REMOVED***
            break;
          case 'script':
            if (found.script.length > 1) {
              error(Tag.ERR_EXTRA_SCRIPT, subtag);

              // Check if script is same as language suppress-script.
            ***REMOVED*** else {
              language = subtags[0];
              if ('language' === language.type()) {
                script = language.script();
                if (script && script.format() === subtag.format()) {
                  error(Tag.ERR_SUPPRESS_SCRIPT, subtag);
                ***REMOVED***
              ***REMOVED***
            ***REMOVED***
            break;
          case 'variant':
            if (found.variant.length > 1 && found.variant.some(function (variant) {
              return variant.format() === subtag.format();
            ***REMOVED***)) {
              error(Tag.ERR_DUPLICATE_VARIANT, subtag);
            ***REMOVED***
        ***REMOVED***
      ***REMOVED***, {
        language: [],
        extlang: [],
        variant: [],
        script: [],
        region: []
      ***REMOVED***);

      // Check for correct order.
      subtags.forEach(function (subtag, i, subtags) {
        var priority = this,
          next = subtags[i + 1];
        if (next && priority[subtag.type()] > priority[next.type()]) {
          error(Tag.ERR_WRONG_ORDER, [subtag, next]);
        ***REMOVED***
      ***REMOVED***, {
        language: 4,
        extlang: 5,
        script: 6,
        region: 7,
        variant: 8
      ***REMOVED***);
      return errors;
    ***REMOVED***
  ***REMOVED***, {
    key: "type",
    value: function type() {
      var record = this.data.record;
      if (record) {
        return record.Type;
      ***REMOVED***
      return 'tag';
    ***REMOVED***
  ***REMOVED***, {
    key: "added",
    value: function added() {
      var record = this.data.record;
      return record && record.Added;
    ***REMOVED***
  ***REMOVED***, {
    key: "deprecated",
    value: function deprecated() {
      var record = this.data.record;
      return record && record.Deprecated;
    ***REMOVED***
  ***REMOVED***, {
    key: "descriptions",
    value: function descriptions() {
      var record = this.data.record;
      if (record && record.Description) {
        return record.Description;
      ***REMOVED***
      return [];
    ***REMOVED***
  ***REMOVED***, {
    key: "format",
    value: function format() {
      var tag = this.data.tag;

      // Format according to algorithm defined in RFC 5646 section 2.1.1.
      return tag.split('-').reduce(function (p, c, i, a) {
        if (i === 0) {
          return c;
        ***REMOVED***
        if (a[i - 1].length === 1) {
          return p + '-' + c;
        ***REMOVED***
        switch (c.length) {
          case 2:
            return p + '-' + c.toUpperCase();
          case 4:
            return p + '-' + c[0].toUpperCase() + c.substr(1);
        ***REMOVED***
        return p + '-' + c;
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***]);
  return Tag;
***REMOVED***();
_defineProperty(Tag, "ERR_DEPRECATED", 1);
_defineProperty(Tag, "ERR_NO_LANGUAGE", 2);
_defineProperty(Tag, "ERR_UNKNOWN", 3);
_defineProperty(Tag, "ERR_TOO_LONG", 4);
_defineProperty(Tag, "ERR_EXTRA_REGION", 5);
_defineProperty(Tag, "ERR_EXTRA_EXTLANG", 6);
_defineProperty(Tag, "ERR_EXTRA_SCRIPT", 7);
_defineProperty(Tag, "ERR_DUPLICATE_VARIANT", 8);
_defineProperty(Tag, "ERR_WRONG_ORDER", 9);
_defineProperty(Tag, "ERR_SUPPRESS_SCRIPT", 10);
_defineProperty(Tag, "ERR_SUBTAG_DEPRECATED", 11);
_defineProperty(Tag, "ERR_EXTRA_LANGUAGE", 12);
module.exports = Tag;