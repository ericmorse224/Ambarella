/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/

"use strict";

const path = require("path");

const WINDOWS_ABS_PATH_REGEXP = /^[a-zA-Z]:[\\/]/;
const SEGMENTS_SPLIT_REGEXP = /([|!])/;
const WINDOWS_PATH_SEPARATOR_REGEXP = /\\/g;

/**
 * @param {string***REMOVED*** relativePath relative path
 * @returns {string***REMOVED*** request
 */
const relativePathToRequest = relativePath => {
	if (relativePath === "") return "./.";
	if (relativePath === "..") return "../.";
	if (relativePath.startsWith("../")) return relativePath;
	return `./${relativePath***REMOVED***`;
***REMOVED***;

/**
 * @param {string***REMOVED*** context context for relative path
 * @param {string***REMOVED*** maybeAbsolutePath path to make relative
 * @returns {string***REMOVED*** relative path in request style
 */
const absoluteToRequest = (context, maybeAbsolutePath) => {
	if (maybeAbsolutePath[0] === "/") {
		if (
			maybeAbsolutePath.length > 1 &&
			maybeAbsolutePath[maybeAbsolutePath.length - 1] === "/"
		) {
			// this 'path' is actually a regexp generated by dynamic requires.
			// Don't treat it as an absolute path.
			return maybeAbsolutePath;
		***REMOVED***

		const querySplitPos = maybeAbsolutePath.indexOf("?");
		let resource =
			querySplitPos === -1
				? maybeAbsolutePath
				: maybeAbsolutePath.slice(0, querySplitPos);
		resource = relativePathToRequest(path.posix.relative(context, resource));
		return querySplitPos === -1
			? resource
			: resource + maybeAbsolutePath.slice(querySplitPos);
	***REMOVED***

	if (WINDOWS_ABS_PATH_REGEXP.test(maybeAbsolutePath)) {
		const querySplitPos = maybeAbsolutePath.indexOf("?");
		let resource =
			querySplitPos === -1
				? maybeAbsolutePath
				: maybeAbsolutePath.slice(0, querySplitPos);
		resource = path.win32.relative(context, resource);
		if (!WINDOWS_ABS_PATH_REGEXP.test(resource)) {
			resource = relativePathToRequest(
				resource.replace(WINDOWS_PATH_SEPARATOR_REGEXP, "/")
			);
		***REMOVED***
		return querySplitPos === -1
			? resource
			: resource + maybeAbsolutePath.slice(querySplitPos);
	***REMOVED***

	// not an absolute path
	return maybeAbsolutePath;
***REMOVED***;

/**
 * @param {string***REMOVED*** context context for relative path
 * @param {string***REMOVED*** relativePath path
 * @returns {string***REMOVED*** absolute path
 */
const requestToAbsolute = (context, relativePath) => {
	if (relativePath.startsWith("./") || relativePath.startsWith("../"))
		return path.join(context, relativePath);
	return relativePath;
***REMOVED***;

/** @typedef {EXPECTED_OBJECT***REMOVED*** AssociatedObjectForCache */

/**
 * @template T
 * @typedef {(value: string, cache?: AssociatedObjectForCache) => T***REMOVED*** MakeCacheableResult
 */

/**
 * @template T
 * @typedef {(value: string) => T***REMOVED*** BindCacheResultFn
 */

/**
 * @template T
 * @typedef {(cache: AssociatedObjectForCache) => BindCacheResultFn<T>***REMOVED*** BindCache
 */

/**
 * @template T
 * @param {((value: string) => T)***REMOVED*** realFn real function
 * @returns {MakeCacheableResult<T> & { bindCache: BindCache<T> ***REMOVED******REMOVED*** cacheable function
 */
const makeCacheable = realFn => {
	/**
	 * @template T
	 * @typedef {Map<string, T>***REMOVED*** CacheItem
	 */
	/** @type {WeakMap<AssociatedObjectForCache, CacheItem<T>>***REMOVED*** */
	const cache = new WeakMap();

	/**
	 * @param {AssociatedObjectForCache***REMOVED*** associatedObjectForCache an object to which the cache will be attached
	 * @returns {CacheItem<T>***REMOVED*** cache item
	 */
	const getCache = associatedObjectForCache => {
		const entry = cache.get(associatedObjectForCache);
		if (entry !== undefined) return entry;
		/** @type {Map<string, T>***REMOVED*** */
		const map = new Map();
		cache.set(associatedObjectForCache, map);
		return map;
	***REMOVED***;

	/** @type {MakeCacheableResult<T> & { bindCache: BindCache<T> ***REMOVED******REMOVED*** */
	const fn = (str, associatedObjectForCache) => {
		if (!associatedObjectForCache) return realFn(str);
		const cache = getCache(associatedObjectForCache);
		const entry = cache.get(str);
		if (entry !== undefined) return entry;
		const result = realFn(str);
		cache.set(str, result);
		return result;
	***REMOVED***;

	/** @type {BindCache<T>***REMOVED*** */
	fn.bindCache = associatedObjectForCache => {
		const cache = getCache(associatedObjectForCache);
		/**
		 * @param {string***REMOVED*** str string
		 * @returns {T***REMOVED*** value
		 */
		return str => {
			const entry = cache.get(str);
			if (entry !== undefined) return entry;
			const result = realFn(str);
			cache.set(str, result);
			return result;
		***REMOVED***;
	***REMOVED***;

	return fn;
***REMOVED***;

/** @typedef {(context: string, value: string, associatedObjectForCache?: AssociatedObjectForCache) => string***REMOVED*** MakeCacheableWithContextResult */
/** @typedef {(context: string, value: string) => string***REMOVED*** BindCacheForContextResultFn */
/** @typedef {(value: string) => string***REMOVED*** BindContextCacheForContextResultFn */
/** @typedef {(associatedObjectForCache?: AssociatedObjectForCache) => BindCacheForContextResultFn***REMOVED*** BindCacheForContext */
/** @typedef {(value: string, associatedObjectForCache?: AssociatedObjectForCache) => BindContextCacheForContextResultFn***REMOVED*** BindContextCacheForContext */

/**
 * @param {(context: string, identifier: string) => string***REMOVED*** fn function
 * @returns {MakeCacheableWithContextResult & { bindCache: BindCacheForContext, bindContextCache: BindContextCacheForContext ***REMOVED******REMOVED*** cacheable function with context
 */
const makeCacheableWithContext = fn => {
	/** @type {WeakMap<AssociatedObjectForCache, Map<string, Map<string, string>>>***REMOVED*** */
	const cache = new WeakMap();

	/** @type {MakeCacheableWithContextResult & { bindCache: BindCacheForContext, bindContextCache: BindContextCacheForContext ***REMOVED******REMOVED*** */
	const cachedFn = (context, identifier, associatedObjectForCache) => {
		if (!associatedObjectForCache) return fn(context, identifier);

		let innerCache = cache.get(associatedObjectForCache);
		if (innerCache === undefined) {
			innerCache = new Map();
			cache.set(associatedObjectForCache, innerCache);
		***REMOVED***

		let cachedResult;
		let innerSubCache = innerCache.get(context);
		if (innerSubCache === undefined) {
			innerCache.set(context, (innerSubCache = new Map()));
		***REMOVED*** else {
			cachedResult = innerSubCache.get(identifier);
		***REMOVED***

		if (cachedResult !== undefined) {
			return cachedResult;
		***REMOVED***
		const result = fn(context, identifier);
		innerSubCache.set(identifier, result);
		return result;
	***REMOVED***;

	/** @type {BindCacheForContext***REMOVED*** */
	cachedFn.bindCache = associatedObjectForCache => {
		let innerCache;
		if (associatedObjectForCache) {
			innerCache = cache.get(associatedObjectForCache);
			if (innerCache === undefined) {
				innerCache = new Map();
				cache.set(associatedObjectForCache, innerCache);
			***REMOVED***
		***REMOVED*** else {
			innerCache = new Map();
		***REMOVED***

		/**
		 * @param {string***REMOVED*** context context used to create relative path
		 * @param {string***REMOVED*** identifier identifier used to create relative path
		 * @returns {string***REMOVED*** the returned relative path
		 */
		const boundFn = (context, identifier) => {
			let cachedResult;
			let innerSubCache = innerCache.get(context);
			if (innerSubCache === undefined) {
				innerCache.set(context, (innerSubCache = new Map()));
			***REMOVED*** else {
				cachedResult = innerSubCache.get(identifier);
			***REMOVED***

			if (cachedResult !== undefined) {
				return cachedResult;
			***REMOVED***
			const result = fn(context, identifier);
			innerSubCache.set(identifier, result);
			return result;
		***REMOVED***;

		return boundFn;
	***REMOVED***;

	/** @type {BindContextCacheForContext***REMOVED*** */
	cachedFn.bindContextCache = (context, associatedObjectForCache) => {
		let innerSubCache;
		if (associatedObjectForCache) {
			let innerCache = cache.get(associatedObjectForCache);
			if (innerCache === undefined) {
				innerCache = new Map();
				cache.set(associatedObjectForCache, innerCache);
			***REMOVED***

			innerSubCache = innerCache.get(context);
			if (innerSubCache === undefined) {
				innerCache.set(context, (innerSubCache = new Map()));
			***REMOVED***
		***REMOVED*** else {
			innerSubCache = new Map();
		***REMOVED***

		/**
		 * @param {string***REMOVED*** identifier identifier used to create relative path
		 * @returns {string***REMOVED*** the returned relative path
		 */
		const boundFn = identifier => {
			const cachedResult = innerSubCache.get(identifier);
			if (cachedResult !== undefined) {
				return cachedResult;
			***REMOVED***
			const result = fn(context, identifier);
			innerSubCache.set(identifier, result);
			return result;
		***REMOVED***;

		return boundFn;
	***REMOVED***;

	return cachedFn;
***REMOVED***;

/**
 * @param {string***REMOVED*** context context for relative path
 * @param {string***REMOVED*** identifier identifier for path
 * @returns {string***REMOVED*** a converted relative path
 */
const _makePathsRelative = (context, identifier) =>
	identifier
		.split(SEGMENTS_SPLIT_REGEXP)
		.map(str => absoluteToRequest(context, str))
		.join("");

module.exports.makePathsRelative = makeCacheableWithContext(_makePathsRelative);

/**
 * @param {string***REMOVED*** context context for relative path
 * @param {string***REMOVED*** identifier identifier for path
 * @returns {string***REMOVED*** a converted relative path
 */
const _makePathsAbsolute = (context, identifier) =>
	identifier
		.split(SEGMENTS_SPLIT_REGEXP)
		.map(str => requestToAbsolute(context, str))
		.join("");

module.exports.makePathsAbsolute = makeCacheableWithContext(_makePathsAbsolute);

/**
 * @param {string***REMOVED*** context absolute context path
 * @param {string***REMOVED*** request any request string may containing absolute paths, query string, etc.
 * @returns {string***REMOVED*** a new request string avoiding absolute paths when possible
 */
const _contextify = (context, request) =>
	request
		.split("!")
		.map(r => absoluteToRequest(context, r))
		.join("!");

const contextify = makeCacheableWithContext(_contextify);
module.exports.contextify = contextify;

/**
 * @param {string***REMOVED*** context absolute context path
 * @param {string***REMOVED*** request any request string
 * @returns {string***REMOVED*** a new request string using absolute paths when possible
 */
const _absolutify = (context, request) =>
	request
		.split("!")
		.map(r => requestToAbsolute(context, r))
		.join("!");

const absolutify = makeCacheableWithContext(_absolutify);
module.exports.absolutify = absolutify;

const PATH_QUERY_FRAGMENT_REGEXP =
	/^((?:\0.|[^?#\0])*)(\?(?:\0.|[^#\0])*)?(#.*)?$/;
const PATH_QUERY_REGEXP = /^((?:\0.|[^?\0])*)(\?.*)?$/;

/** @typedef {{ resource: string, path: string, query: string, fragment: string ***REMOVED******REMOVED*** ParsedResource */
/** @typedef {{ resource: string, path: string, query: string ***REMOVED******REMOVED*** ParsedResourceWithoutFragment */

/**
 * @param {string***REMOVED*** str the path with query and fragment
 * @returns {ParsedResource***REMOVED*** parsed parts
 */
const _parseResource = str => {
	const match =
		/** @type {[string, string, string | undefined, string | undefined]***REMOVED*** */
		(/** @type {unknown***REMOVED*** */ (PATH_QUERY_FRAGMENT_REGEXP.exec(str)));
	return {
		resource: str,
		path: match[1].replace(/\0(.)/g, "$1"),
		query: match[2] ? match[2].replace(/\0(.)/g, "$1") : "",
		fragment: match[3] || ""
	***REMOVED***;
***REMOVED***;
module.exports.parseResource = makeCacheable(_parseResource);

/**
 * Parse resource, skips fragment part
 * @param {string***REMOVED*** str the path with query and fragment
 * @returns {ParsedResourceWithoutFragment***REMOVED*** parsed parts
 */
const _parseResourceWithoutFragment = str => {
	const match =
		/** @type {[string, string, string | undefined]***REMOVED*** */
		(/** @type {unknown***REMOVED*** */ (PATH_QUERY_REGEXP.exec(str)));
	return {
		resource: str,
		path: match[1].replace(/\0(.)/g, "$1"),
		query: match[2] ? match[2].replace(/\0(.)/g, "$1") : ""
	***REMOVED***;
***REMOVED***;
module.exports.parseResourceWithoutFragment = makeCacheable(
	_parseResourceWithoutFragment
);

/**
 * @param {string***REMOVED*** filename the filename which should be undone
 * @param {string***REMOVED*** outputPath the output path that is restored (only relevant when filename contains "..")
 * @param {boolean***REMOVED*** enforceRelative true returns ./ for empty paths
 * @returns {string***REMOVED*** repeated ../ to leave the directory of the provided filename to be back on output dir
 */
module.exports.getUndoPath = (filename, outputPath, enforceRelative) => {
	let depth = -1;
	let append = "";
	outputPath = outputPath.replace(/[\\/]$/, "");
	for (const part of filename.split(/[/\\]+/)) {
		if (part === "..") {
			if (depth > -1) {
				depth--;
			***REMOVED*** else {
				const i = outputPath.lastIndexOf("/");
				const j = outputPath.lastIndexOf("\\");
				const pos = i < 0 ? j : j < 0 ? i : Math.max(i, j);
				if (pos < 0) return `${outputPath***REMOVED***/`;
				append = `${outputPath.slice(pos + 1)***REMOVED***/${append***REMOVED***`;
				outputPath = outputPath.slice(0, pos);
			***REMOVED***
		***REMOVED*** else if (part !== ".") {
			depth++;
		***REMOVED***
	***REMOVED***
	return depth > 0
		? `${"../".repeat(depth)***REMOVED***${append***REMOVED***`
		: enforceRelative
			? `./${append***REMOVED***`
			: append;
***REMOVED***;
