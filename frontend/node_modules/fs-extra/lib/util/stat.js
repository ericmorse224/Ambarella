'use strict'

const fs = require('../fs')
const path = require('path')
const util = require('util')

function getStats (src, dest, opts) {
  const statFunc = opts.dereference
    ? (file) => fs.stat(file, { bigint: true ***REMOVED***)
    : (file) => fs.lstat(file, { bigint: true ***REMOVED***)
  return Promise.all([
    statFunc(src),
    statFunc(dest).catch(err => {
      if (err.code === 'ENOENT') return null
      throw err
    ***REMOVED***)
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat ***REMOVED***))
***REMOVED***

function getStatsSync (src, dest, opts) {
  let destStat
  const statFunc = opts.dereference
    ? (file) => fs.statSync(file, { bigint: true ***REMOVED***)
    : (file) => fs.lstatSync(file, { bigint: true ***REMOVED***)
  const srcStat = statFunc(src)
  try {
    destStat = statFunc(dest)
  ***REMOVED*** catch (err) {
    if (err.code === 'ENOENT') return { srcStat, destStat: null ***REMOVED***
    throw err
  ***REMOVED***
  return { srcStat, destStat ***REMOVED***
***REMOVED***

function checkPaths (src, dest, funcName, opts, cb) {
  util.callbackify(getStats)(src, dest, opts, (err, stats) => {
    if (err) return cb(err)
    const { srcStat, destStat ***REMOVED*** = stats

    if (destStat) {
      if (areIdentical(srcStat, destStat)) {
        const srcBaseName = path.basename(src)
        const destBaseName = path.basename(dest)
        if (funcName === 'move' &&
          srcBaseName !== destBaseName &&
          srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
          return cb(null, { srcStat, destStat, isChangingCase: true ***REMOVED***)
        ***REMOVED***
        return cb(new Error('Source and destination must not be the same.'))
      ***REMOVED***
      if (srcStat.isDirectory() && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest***REMOVED***' with directory '${src***REMOVED***'.`))
      ***REMOVED***
      if (!srcStat.isDirectory() && destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite directory '${dest***REMOVED***' with non-directory '${src***REMOVED***'.`))
      ***REMOVED***
    ***REMOVED***

    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
      return cb(new Error(errMsg(src, dest, funcName)))
    ***REMOVED***
    return cb(null, { srcStat, destStat ***REMOVED***)
  ***REMOVED***)
***REMOVED***

function checkPathsSync (src, dest, funcName, opts) {
  const { srcStat, destStat ***REMOVED*** = getStatsSync(src, dest, opts)

  if (destStat) {
    if (areIdentical(srcStat, destStat)) {
      const srcBaseName = path.basename(src)
      const destBaseName = path.basename(dest)
      if (funcName === 'move' &&
        srcBaseName !== destBaseName &&
        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true ***REMOVED***
      ***REMOVED***
      throw new Error('Source and destination must not be the same.')
    ***REMOVED***
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest***REMOVED***' with directory '${src***REMOVED***'.`)
    ***REMOVED***
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest***REMOVED***' with non-directory '${src***REMOVED***'.`)
    ***REMOVED***
  ***REMOVED***

  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName))
  ***REMOVED***
  return { srcStat, destStat ***REMOVED***
***REMOVED***

// recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.
function checkParentPaths (src, srcStat, dest, funcName, cb) {
  const srcParent = path.resolve(path.dirname(src))
  const destParent = path.resolve(path.dirname(dest))
  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()
  fs.stat(destParent, { bigint: true ***REMOVED***, (err, destStat) => {
    if (err) {
      if (err.code === 'ENOENT') return cb()
      return cb(err)
    ***REMOVED***
    if (areIdentical(srcStat, destStat)) {
      return cb(new Error(errMsg(src, dest, funcName)))
    ***REMOVED***
    return checkParentPaths(src, srcStat, destParent, funcName, cb)
  ***REMOVED***)
***REMOVED***

function checkParentPathsSync (src, srcStat, dest, funcName) {
  const srcParent = path.resolve(path.dirname(src))
  const destParent = path.resolve(path.dirname(dest))
  if (destParent === srcParent || destParent === path.parse(destParent).root) return
  let destStat
  try {
    destStat = fs.statSync(destParent, { bigint: true ***REMOVED***)
  ***REMOVED*** catch (err) {
    if (err.code === 'ENOENT') return
    throw err
  ***REMOVED***
  if (areIdentical(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName))
  ***REMOVED***
  return checkParentPathsSync(src, srcStat, destParent, funcName)
***REMOVED***

function areIdentical (srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev
***REMOVED***

// return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.
function isSrcSubdir (src, dest) {
  const srcArr = path.resolve(src).split(path.sep).filter(i => i)
  const destArr = path.resolve(dest).split(path.sep).filter(i => i)
  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)
***REMOVED***

function errMsg (src, dest, funcName) {
  return `Cannot ${funcName***REMOVED*** '${src***REMOVED***' to a subdirectory of itself, '${dest***REMOVED***'.`
***REMOVED***

module.exports = {
  checkPaths,
  checkPathsSync,
  checkParentPaths,
  checkParentPathsSync,
  isSrcSubdir,
  areIdentical
***REMOVED***
