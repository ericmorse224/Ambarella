/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const util = require("util");
const ChunkGraph = require("./ChunkGraph");
const DependenciesBlock = require("./DependenciesBlock");
const ModuleGraph = require("./ModuleGraph");
const { JS_TYPES ***REMOVED*** = require("./ModuleSourceTypesConstants");
const RuntimeGlobals = require("./RuntimeGlobals");
const { first ***REMOVED*** = require("./util/SetHelpers");
const { compareChunksById ***REMOVED*** = require("./util/comparators");
const makeSerializable = require("./util/makeSerializable");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../declarations/WebpackOptions").ResolveOptions***REMOVED*** ResolveOptions */
/** @typedef {import("../declarations/WebpackOptions").WebpackOptionsNormalized***REMOVED*** WebpackOptions */
/** @typedef {import("./Chunk")***REMOVED*** Chunk */
/** @typedef {import("./ChunkGraph").ModuleId***REMOVED*** ModuleId */
/** @typedef {import("./ChunkGroup")***REMOVED*** ChunkGroup */
/** @typedef {import("./CodeGenerationResults")***REMOVED*** CodeGenerationResults */
/** @typedef {import("./Compilation")***REMOVED*** Compilation */
/** @typedef {import("./Compilation").AssetInfo***REMOVED*** AssetInfo */
/** @typedef {import("./Compilation").UnsafeCacheData***REMOVED*** UnsafeCacheData */
/** @typedef {import("./ConcatenationScope")***REMOVED*** ConcatenationScope */
/** @typedef {import("./Dependency")***REMOVED*** Dependency */
/** @typedef {import("./Dependency").UpdateHashContext***REMOVED*** UpdateHashContext */
/** @typedef {import("./DependencyTemplate").CssData***REMOVED*** CssData */
/** @typedef {import("./DependencyTemplates")***REMOVED*** DependencyTemplates */
/** @typedef {import("./ExportsInfo").UsageStateType***REMOVED*** UsageStateType */
/** @typedef {import("./FileSystemInfo")***REMOVED*** FileSystemInfo */
/** @typedef {import("./FileSystemInfo").Snapshot***REMOVED*** Snapshot */
/** @typedef {import("./ModuleGraphConnection").ConnectionState***REMOVED*** ConnectionState */
/** @typedef {import("./ModuleTypeConstants").ModuleTypes***REMOVED*** ModuleTypes */
/** @typedef {import("./NormalModuleFactory")***REMOVED*** NormalModuleFactory */
/** @typedef {import("./RequestShortener")***REMOVED*** RequestShortener */
/** @typedef {import("./ResolverFactory").ResolverWithOptions***REMOVED*** ResolverWithOptions */
/** @typedef {import("./RuntimeTemplate")***REMOVED*** RuntimeTemplate */
/** @typedef {import("./WebpackError")***REMOVED*** WebpackError */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectDeserializerContext***REMOVED*** ObjectDeserializerContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectSerializerContext***REMOVED*** ObjectSerializerContext */
/** @typedef {import("./util/Hash")***REMOVED*** Hash */
/** @typedef {import("./util/fs").InputFileSystem***REMOVED*** InputFileSystem */
/** @typedef {import("./util/identifier").AssociatedObjectForCache***REMOVED*** AssociatedObjectForCache */
/** @typedef {import("./util/runtime").RuntimeSpec***REMOVED*** RuntimeSpec */

/**
 * @template T
 * @typedef {import("./util/LazySet")<T>***REMOVED*** LazySet<T>
 */

/**
 * @template T
 * @typedef {import("./util/SortableSet")<T>***REMOVED*** SortableSet<T>
 */

/**
 * @typedef {object***REMOVED*** SourceContext
 * @property {DependencyTemplates***REMOVED*** dependencyTemplates the dependency templates
 * @property {RuntimeTemplate***REMOVED*** runtimeTemplate the runtime template
 * @property {ModuleGraph***REMOVED*** moduleGraph the module graph
 * @property {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @property {RuntimeSpec***REMOVED*** runtime the runtimes code should be generated for
 * @property {string=***REMOVED*** type the type of source that should be generated
 */

/** @typedef {ReadonlySet<string>***REMOVED*** SourceTypes */

// TODO webpack 6: compilation will be required in CodeGenerationContext
/**
 * @typedef {object***REMOVED*** CodeGenerationContext
 * @property {DependencyTemplates***REMOVED*** dependencyTemplates the dependency templates
 * @property {RuntimeTemplate***REMOVED*** runtimeTemplate the runtime template
 * @property {ModuleGraph***REMOVED*** moduleGraph the module graph
 * @property {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @property {RuntimeSpec***REMOVED*** runtime the runtimes code should be generated for
 * @property {ConcatenationScope=***REMOVED*** concatenationScope when in concatenated module, information about other concatenated modules
 * @property {CodeGenerationResults | undefined***REMOVED*** codeGenerationResults code generation results of other modules (need to have a codeGenerationDependency to use that)
 * @property {Compilation=***REMOVED*** compilation the compilation
 * @property {SourceTypes=***REMOVED*** sourceTypes source types
 */

/**
 * @typedef {object***REMOVED*** ConcatenationBailoutReasonContext
 * @property {ModuleGraph***REMOVED*** moduleGraph the module graph
 * @property {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 */

/** @typedef {Set<string>***REMOVED*** RuntimeRequirements */
/** @typedef {ReadonlySet<string>***REMOVED*** ReadOnlyRuntimeRequirements */

/**
 * @typedef {object***REMOVED*** CodeGenerationResult
 * @property {Map<string, Source>***REMOVED*** sources the resulting sources for all source types
 * @property {Map<string, TODO>=***REMOVED*** data the resulting data for all source types
 * @property {ReadOnlyRuntimeRequirements | null***REMOVED*** runtimeRequirements the runtime requirements
 * @property {string=***REMOVED*** hash a hash of the code generation result (will be automatically calculated from sources and runtimeRequirements if not provided)
 */

/**
 * @typedef {object***REMOVED*** LibIdentOptions
 * @property {string***REMOVED*** context absolute context path to which lib ident is relative to
 * @property {AssociatedObjectForCache=***REMOVED*** associatedObjectForCache object for caching
 */

/**
 * @typedef {object***REMOVED*** KnownBuildMeta
 * @property {("default" | "namespace" | "flagged" | "dynamic")=***REMOVED*** exportsType
 * @property {(false | "redirect" | "redirect-warn")=***REMOVED*** defaultObject
 * @property {boolean=***REMOVED*** strictHarmonyModule
 * @property {boolean=***REMOVED*** async
 * @property {boolean=***REMOVED*** sideEffectFree
 * @property {Record<string, string>=***REMOVED*** exportsFinalName
 * @property {boolean=***REMOVED*** isCSSModule
 */

/**
 * @typedef {object***REMOVED*** KnownBuildInfo
 * @property {boolean=***REMOVED*** cacheable
 * @property {boolean=***REMOVED*** parsed
 * @property {boolean=***REMOVED*** strict
 * @property {string=***REMOVED*** moduleArgument using in AMD
 * @property {string=***REMOVED*** exportsArgument using in AMD
 * @property {string=***REMOVED*** moduleConcatenationBailout using in CommonJs
 * @property {boolean=***REMOVED*** needCreateRequire using in APIPlugin
 * @property {string=***REMOVED*** resourceIntegrity using in HttpUriPlugin
 * @property {LazySet<string>=***REMOVED*** fileDependencies using in NormalModule
 * @property {LazySet<string>=***REMOVED*** contextDependencies using in NormalModule
 * @property {LazySet<string>=***REMOVED*** missingDependencies using in NormalModule
 * @property {LazySet<string>=***REMOVED*** buildDependencies using in NormalModule
 * @property {ValueCacheVersions=***REMOVED*** valueDependencies using in NormalModule
 * @property {Record<string, Source>=***REMOVED*** assets using in NormalModule
 * @property {string=***REMOVED*** hash using in NormalModule
 * @property {(Snapshot | null)=***REMOVED*** snapshot using in ContextModule
 * @property {string=***REMOVED*** fullContentHash for assets modules
 * @property {string=***REMOVED*** filename for assets modules
 * @property {Map<string, AssetInfo | undefined>=***REMOVED*** assetsInfo for assets modules
 * @property {boolean=***REMOVED*** dataUrl for assets modules
 * @property {CssData=***REMOVED*** cssData for css modules
 */

/** @typedef {Map<string, string | Set<string>>***REMOVED*** ValueCacheVersions */

/**
 * @typedef {object***REMOVED*** NeedBuildContext
 * @property {Compilation***REMOVED*** compilation
 * @property {FileSystemInfo***REMOVED*** fileSystemInfo
 * @property {ValueCacheVersions***REMOVED*** valueCacheVersions
 */

/** @typedef {(err?: WebpackError | null, needBuild?: boolean) => void***REMOVED*** NeedBuildCallback */

/** @typedef {(err?: WebpackError) => void***REMOVED*** BuildCallback */

/** @typedef {KnownBuildMeta & Record<string, EXPECTED_ANY>***REMOVED*** BuildMeta */
/** @typedef {KnownBuildInfo & Record<string, EXPECTED_ANY>***REMOVED*** BuildInfo */

/**
 * @typedef {object***REMOVED*** FactoryMeta
 * @property {boolean=***REMOVED*** sideEffectFree
 */

const EMPTY_RESOLVE_OPTIONS = {***REMOVED***;

let debugId = 1000;

const DEFAULT_TYPES_UNKNOWN = new Set(["unknown"]);

const deprecatedNeedRebuild = util.deprecate(
	/**
	 * @param {Module***REMOVED*** module the module
	 * @param {NeedBuildContext***REMOVED*** context context info
	 * @returns {boolean***REMOVED*** true, when rebuild is needed
	 */
	(module, context) =>
		module.needRebuild(
			context.fileSystemInfo.getDeprecatedFileTimestamps(),
			context.fileSystemInfo.getDeprecatedContextTimestamps()
		),
	"Module.needRebuild is deprecated in favor of Module.needBuild",
	"DEP_WEBPACK_MODULE_NEED_REBUILD"
);

/** @typedef {(requestShortener: RequestShortener) => string***REMOVED*** OptimizationBailoutFunction */

class Module extends DependenciesBlock {
	/**
	 * @param {ModuleTypes | ""***REMOVED*** type the module type, when deserializing the type is not known and is an empty string
	 * @param {(string | null)=***REMOVED*** context an optional context
	 * @param {(string | null)=***REMOVED*** layer an optional layer in which the module is
	 */
	constructor(type, context = null, layer = null) {
		super();

		/** @type {ModuleTypes***REMOVED*** */
		this.type = type;
		/** @type {string | null***REMOVED*** */
		this.context = context;
		/** @type {string | null***REMOVED*** */
		this.layer = layer;
		/** @type {boolean***REMOVED*** */
		this.needId = true;

		// Unique Id
		/** @type {number***REMOVED*** */
		this.debugId = debugId++;

		// Info from Factory
		/** @type {ResolveOptions | undefined***REMOVED*** */
		this.resolveOptions = EMPTY_RESOLVE_OPTIONS;
		/** @type {FactoryMeta | undefined***REMOVED*** */
		this.factoryMeta = undefined;
		// TODO refactor this -> options object filled from Factory
		// TODO webpack 6: use an enum
		/** @type {boolean***REMOVED*** */
		this.useSourceMap = false;
		/** @type {boolean***REMOVED*** */
		this.useSimpleSourceMap = false;

		// Is in hot context, i.e. HotModuleReplacementPlugin.js enabled
		// TODO do we need hot here?
		/** @type {boolean***REMOVED*** */
		this.hot = false;
		// Info from Build
		/** @type {WebpackError[] | undefined***REMOVED*** */
		this._warnings = undefined;
		/** @type {WebpackError[] | undefined***REMOVED*** */
		this._errors = undefined;
		/** @type {BuildMeta | undefined***REMOVED*** */
		this.buildMeta = undefined;
		/** @type {BuildInfo | undefined***REMOVED*** */
		this.buildInfo = undefined;
		/** @type {Dependency[] | undefined***REMOVED*** */
		this.presentationalDependencies = undefined;
		/** @type {Dependency[] | undefined***REMOVED*** */
		this.codeGenerationDependencies = undefined;
	***REMOVED***

	// TODO remove in webpack 6
	// BACKWARD-COMPAT START
	/**
	 * @returns {ModuleId | null***REMOVED*** module id
	 */
	get id() {
		return ChunkGraph.getChunkGraphForModule(
			this,
			"Module.id",
			"DEP_WEBPACK_MODULE_ID"
		).getModuleId(this);
	***REMOVED***

	/**
	 * @param {ModuleId***REMOVED*** value value
	 */
	set id(value) {
		if (value === "") {
			this.needId = false;
			return;
		***REMOVED***
		ChunkGraph.getChunkGraphForModule(
			this,
			"Module.id",
			"DEP_WEBPACK_MODULE_ID"
		).setModuleId(this, value);
	***REMOVED***

	/**
	 * @returns {string***REMOVED*** the hash of the module
	 */
	get hash() {
		return ChunkGraph.getChunkGraphForModule(
			this,
			"Module.hash",
			"DEP_WEBPACK_MODULE_HASH"
		).getModuleHash(this, undefined);
	***REMOVED***

	/**
	 * @returns {string***REMOVED*** the shortened hash of the module
	 */
	get renderedHash() {
		return ChunkGraph.getChunkGraphForModule(
			this,
			"Module.renderedHash",
			"DEP_WEBPACK_MODULE_RENDERED_HASH"
		).getRenderedModuleHash(this, undefined);
	***REMOVED***

	get profile() {
		return ModuleGraph.getModuleGraphForModule(
			this,
			"Module.profile",
			"DEP_WEBPACK_MODULE_PROFILE"
		).getProfile(this);
	***REMOVED***

	set profile(value) {
		ModuleGraph.getModuleGraphForModule(
			this,
			"Module.profile",
			"DEP_WEBPACK_MODULE_PROFILE"
		).setProfile(this, value);
	***REMOVED***

	/**
	 * @returns {number | null***REMOVED*** the pre order index
	 */
	get index() {
		return ModuleGraph.getModuleGraphForModule(
			this,
			"Module.index",
			"DEP_WEBPACK_MODULE_INDEX"
		).getPreOrderIndex(this);
	***REMOVED***

	/**
	 * @param {number***REMOVED*** value the pre order index
	 */
	set index(value) {
		ModuleGraph.getModuleGraphForModule(
			this,
			"Module.index",
			"DEP_WEBPACK_MODULE_INDEX"
		).setPreOrderIndex(this, value);
	***REMOVED***

	/**
	 * @returns {number | null***REMOVED*** the post order index
	 */
	get index2() {
		return ModuleGraph.getModuleGraphForModule(
			this,
			"Module.index2",
			"DEP_WEBPACK_MODULE_INDEX2"
		).getPostOrderIndex(this);
	***REMOVED***

	/**
	 * @param {number***REMOVED*** value the post order index
	 */
	set index2(value) {
		ModuleGraph.getModuleGraphForModule(
			this,
			"Module.index2",
			"DEP_WEBPACK_MODULE_INDEX2"
		).setPostOrderIndex(this, value);
	***REMOVED***

	/**
	 * @returns {number | null***REMOVED*** the depth
	 */
	get depth() {
		return ModuleGraph.getModuleGraphForModule(
			this,
			"Module.depth",
			"DEP_WEBPACK_MODULE_DEPTH"
		).getDepth(this);
	***REMOVED***

	/**
	 * @param {number***REMOVED*** value the depth
	 */
	set depth(value) {
		ModuleGraph.getModuleGraphForModule(
			this,
			"Module.depth",
			"DEP_WEBPACK_MODULE_DEPTH"
		).setDepth(this, value);
	***REMOVED***

	/**
	 * @returns {Module | null | undefined***REMOVED*** issuer
	 */
	get issuer() {
		return ModuleGraph.getModuleGraphForModule(
			this,
			"Module.issuer",
			"DEP_WEBPACK_MODULE_ISSUER"
		).getIssuer(this);
	***REMOVED***

	/**
	 * @param {Module | null***REMOVED*** value issuer
	 */
	set issuer(value) {
		ModuleGraph.getModuleGraphForModule(
			this,
			"Module.issuer",
			"DEP_WEBPACK_MODULE_ISSUER"
		).setIssuer(this, value);
	***REMOVED***

	get usedExports() {
		return ModuleGraph.getModuleGraphForModule(
			this,
			"Module.usedExports",
			"DEP_WEBPACK_MODULE_USED_EXPORTS"
		).getUsedExports(this, undefined);
	***REMOVED***

	/**
	 * @deprecated
	 * @returns {(string | OptimizationBailoutFunction)[]***REMOVED*** list
	 */
	get optimizationBailout() {
		return ModuleGraph.getModuleGraphForModule(
			this,
			"Module.optimizationBailout",
			"DEP_WEBPACK_MODULE_OPTIMIZATION_BAILOUT"
		).getOptimizationBailout(this);
	***REMOVED***

	get optional() {
		return this.isOptional(
			ModuleGraph.getModuleGraphForModule(
				this,
				"Module.optional",
				"DEP_WEBPACK_MODULE_OPTIONAL"
			)
		);
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk the chunk
	 * @returns {boolean***REMOVED*** true, when the module was added
	 */
	addChunk(chunk) {
		const chunkGraph = ChunkGraph.getChunkGraphForModule(
			this,
			"Module.addChunk",
			"DEP_WEBPACK_MODULE_ADD_CHUNK"
		);
		if (chunkGraph.isModuleInChunk(this, chunk)) return false;
		chunkGraph.connectChunkAndModule(chunk, this);
		return true;
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk the chunk
	 * @returns {void***REMOVED***
	 */
	removeChunk(chunk) {
		return ChunkGraph.getChunkGraphForModule(
			this,
			"Module.removeChunk",
			"DEP_WEBPACK_MODULE_REMOVE_CHUNK"
		).disconnectChunkAndModule(chunk, this);
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk the chunk
	 * @returns {boolean***REMOVED*** true, when the module is in the chunk
	 */
	isInChunk(chunk) {
		return ChunkGraph.getChunkGraphForModule(
			this,
			"Module.isInChunk",
			"DEP_WEBPACK_MODULE_IS_IN_CHUNK"
		).isModuleInChunk(this, chunk);
	***REMOVED***

	isEntryModule() {
		return ChunkGraph.getChunkGraphForModule(
			this,
			"Module.isEntryModule",
			"DEP_WEBPACK_MODULE_IS_ENTRY_MODULE"
		).isEntryModule(this);
	***REMOVED***

	getChunks() {
		return ChunkGraph.getChunkGraphForModule(
			this,
			"Module.getChunks",
			"DEP_WEBPACK_MODULE_GET_CHUNKS"
		).getModuleChunks(this);
	***REMOVED***

	getNumberOfChunks() {
		return ChunkGraph.getChunkGraphForModule(
			this,
			"Module.getNumberOfChunks",
			"DEP_WEBPACK_MODULE_GET_NUMBER_OF_CHUNKS"
		).getNumberOfModuleChunks(this);
	***REMOVED***

	get chunksIterable() {
		return ChunkGraph.getChunkGraphForModule(
			this,
			"Module.chunksIterable",
			"DEP_WEBPACK_MODULE_CHUNKS_ITERABLE"
		).getOrderedModuleChunksIterable(this, compareChunksById);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** exportName a name of an export
	 * @returns {boolean | null***REMOVED*** true, if the export is provided why the module.
	 * null, if it's unknown.
	 * false, if it's not provided.
	 */
	isProvided(exportName) {
		return ModuleGraph.getModuleGraphForModule(
			this,
			"Module.usedExports",
			"DEP_WEBPACK_MODULE_USED_EXPORTS"
		).isExportProvided(this, exportName);
	***REMOVED***
	// BACKWARD-COMPAT END

	/**
	 * @returns {string***REMOVED*** name of the exports argument
	 */
	get exportsArgument() {
		return (this.buildInfo && this.buildInfo.exportsArgument) || "exports";
	***REMOVED***

	/**
	 * @returns {string***REMOVED*** name of the module argument
	 */
	get moduleArgument() {
		return (this.buildInfo && this.buildInfo.moduleArgument) || "module";
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @param {boolean | undefined***REMOVED*** strict the importing module is strict
	 * @returns {"namespace" | "default-only" | "default-with-named" | "dynamic"***REMOVED*** export type
	 * "namespace": Exports is already a namespace object. namespace = exports.
	 * "dynamic": Check at runtime if __esModule is set. When set: namespace = { ...exports, default: exports ***REMOVED***. When not set: namespace = { default: exports ***REMOVED***.
	 * "default-only": Provide a namespace object with only default export. namespace = { default: exports ***REMOVED***
	 * "default-with-named": Provide a namespace object with named and default export. namespace = { ...exports, default: exports ***REMOVED***
	 */
	getExportsType(moduleGraph, strict) {
		switch (this.buildMeta && this.buildMeta.exportsType) {
			case "flagged":
				return strict ? "default-with-named" : "namespace";
			case "namespace":
				return "namespace";
			case "default":
				switch (/** @type {BuildMeta***REMOVED*** */ (this.buildMeta).defaultObject) {
					case "redirect":
						return "default-with-named";
					case "redirect-warn":
						return strict ? "default-only" : "default-with-named";
					default:
						return "default-only";
				***REMOVED***
			case "dynamic": {
				if (strict) return "default-with-named";
				// Try to figure out value of __esModule by following reexports
				const handleDefault = () => {
					switch (/** @type {BuildMeta***REMOVED*** */ (this.buildMeta).defaultObject) {
						case "redirect":
						case "redirect-warn":
							return "default-with-named";
						default:
							return "default-only";
					***REMOVED***
				***REMOVED***;
				const exportInfo = moduleGraph.getReadOnlyExportInfo(
					this,
					"__esModule"
				);
				if (exportInfo.provided === false) {
					return handleDefault();
				***REMOVED***
				const target = exportInfo.getTarget(moduleGraph);
				if (
					!target ||
					!target.export ||
					target.export.length !== 1 ||
					target.export[0] !== "__esModule"
				) {
					return "dynamic";
				***REMOVED***
				switch (
					target.module.buildMeta &&
					target.module.buildMeta.exportsType
				) {
					case "flagged":
					case "namespace":
						return "namespace";
					case "default":
						return handleDefault();
					default:
						return "dynamic";
				***REMOVED***
			***REMOVED***
			default:
				return strict ? "default-with-named" : "dynamic";
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Dependency***REMOVED*** presentationalDependency dependency being tied to module.
	 * This is a Dependency without edge in the module graph. It's only for presentation.
	 * @returns {void***REMOVED***
	 */
	addPresentationalDependency(presentationalDependency) {
		if (this.presentationalDependencies === undefined) {
			this.presentationalDependencies = [];
		***REMOVED***
		this.presentationalDependencies.push(presentationalDependency);
	***REMOVED***

	/**
	 * @param {Dependency***REMOVED*** codeGenerationDependency dependency being tied to module.
	 * This is a Dependency where the code generation result of the referenced module is needed during code generation.
	 * The Dependency should also be added to normal dependencies via addDependency.
	 * @returns {void***REMOVED***
	 */
	addCodeGenerationDependency(codeGenerationDependency) {
		if (this.codeGenerationDependencies === undefined) {
			this.codeGenerationDependencies = [];
		***REMOVED***
		this.codeGenerationDependencies.push(codeGenerationDependency);
	***REMOVED***

	/**
	 * Removes all dependencies and blocks
	 * @returns {void***REMOVED***
	 */
	clearDependenciesAndBlocks() {
		if (this.presentationalDependencies !== undefined) {
			this.presentationalDependencies.length = 0;
		***REMOVED***
		if (this.codeGenerationDependencies !== undefined) {
			this.codeGenerationDependencies.length = 0;
		***REMOVED***
		super.clearDependenciesAndBlocks();
	***REMOVED***

	/**
	 * @param {WebpackError***REMOVED*** warning the warning
	 * @returns {void***REMOVED***
	 */
	addWarning(warning) {
		if (this._warnings === undefined) {
			this._warnings = [];
		***REMOVED***
		this._warnings.push(warning);
	***REMOVED***

	/**
	 * @returns {Iterable<WebpackError> | undefined***REMOVED*** list of warnings if any
	 */
	getWarnings() {
		return this._warnings;
	***REMOVED***

	/**
	 * @returns {number***REMOVED*** number of warnings
	 */
	getNumberOfWarnings() {
		return this._warnings !== undefined ? this._warnings.length : 0;
	***REMOVED***

	/**
	 * @param {WebpackError***REMOVED*** error the error
	 * @returns {void***REMOVED***
	 */
	addError(error) {
		if (this._errors === undefined) {
			this._errors = [];
		***REMOVED***
		this._errors.push(error);
	***REMOVED***

	/**
	 * @returns {Iterable<WebpackError> | undefined***REMOVED*** list of errors if any
	 */
	getErrors() {
		return this._errors;
	***REMOVED***

	/**
	 * @returns {number***REMOVED*** number of errors
	 */
	getNumberOfErrors() {
		return this._errors !== undefined ? this._errors.length : 0;
	***REMOVED***

	/**
	 * removes all warnings and errors
	 * @returns {void***REMOVED***
	 */
	clearWarningsAndErrors() {
		if (this._warnings !== undefined) {
			this._warnings.length = 0;
		***REMOVED***
		if (this._errors !== undefined) {
			this._errors.length = 0;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @returns {boolean***REMOVED*** true, if the module is optional
	 */
	isOptional(moduleGraph) {
		let hasConnections = false;
		for (const r of moduleGraph.getIncomingConnections(this)) {
			if (
				!r.dependency ||
				!r.dependency.optional ||
				!r.isTargetActive(undefined)
			) {
				return false;
			***REMOVED***
			hasConnections = true;
		***REMOVED***
		return hasConnections;
	***REMOVED***

	/**
	 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
	 * @param {Chunk***REMOVED*** chunk a chunk
	 * @param {Chunk=***REMOVED*** ignoreChunk chunk to be ignored
	 * @returns {boolean***REMOVED*** true, if the module is accessible from "chunk" when ignoring "ignoreChunk"
	 */
	isAccessibleInChunk(chunkGraph, chunk, ignoreChunk) {
		// Check if module is accessible in ALL chunk groups
		for (const chunkGroup of chunk.groupsIterable) {
			if (!this.isAccessibleInChunkGroup(chunkGraph, chunkGroup)) return false;
		***REMOVED***
		return true;
	***REMOVED***

	/**
	 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
	 * @param {ChunkGroup***REMOVED*** chunkGroup a chunk group
	 * @param {Chunk=***REMOVED*** ignoreChunk chunk to be ignored
	 * @returns {boolean***REMOVED*** true, if the module is accessible from "chunkGroup" when ignoring "ignoreChunk"
	 */
	isAccessibleInChunkGroup(chunkGraph, chunkGroup, ignoreChunk) {
		const queue = new Set([chunkGroup]);

		// Check if module is accessible from all items of the queue
		queueFor: for (const cg of queue) {
			// 1. If module is in one of the chunks of the group we can continue checking the next items
			//    because it's accessible.
			for (const chunk of cg.chunks) {
				if (chunk !== ignoreChunk && chunkGraph.isModuleInChunk(this, chunk))
					continue queueFor;
			***REMOVED***
			// 2. If the chunk group is initial, we can break here because it's not accessible.
			if (chunkGroup.isInitial()) return false;
			// 3. Enqueue all parents because it must be accessible from ALL parents
			for (const parent of chunkGroup.parentsIterable) queue.add(parent);
		***REMOVED***
		// When we processed through the whole list and we didn't bailout, the module is accessible
		return true;
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk a chunk
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
	 * @returns {boolean***REMOVED*** true, if the module has any reason why "chunk" should be included
	 */
	hasReasonForChunk(chunk, moduleGraph, chunkGraph) {
		// check for each reason if we need the chunk
		for (const [
			fromModule,
			connections
		] of moduleGraph.getIncomingConnectionsByOriginModule(this)) {
			if (!connections.some(c => c.isTargetActive(chunk.runtime))) continue;
			for (const originChunk of chunkGraph.getModuleChunksIterable(
				/** @type {Module***REMOVED*** */ (fromModule)
			)) {
				// return true if module this is not reachable from originChunk when ignoring chunk
				if (!this.isAccessibleInChunk(chunkGraph, originChunk, chunk))
					return true;
			***REMOVED***
		***REMOVED***
		return false;
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @returns {boolean***REMOVED*** true if at least one other module depends on this module
	 */
	hasReasons(moduleGraph, runtime) {
		for (const c of moduleGraph.getIncomingConnections(this)) {
			if (c.isTargetActive(runtime)) return true;
		***REMOVED***
		return false;
	***REMOVED***

	/**
	 * @returns {string***REMOVED*** for debugging
	 */
	toString() {
		return `Module[${this.debugId***REMOVED***: ${this.identifier()***REMOVED***]`;
	***REMOVED***

	/**
	 * @param {NeedBuildContext***REMOVED*** context context info
	 * @param {NeedBuildCallback***REMOVED*** callback callback function, returns true, if the module needs a rebuild
	 * @returns {void***REMOVED***
	 */
	needBuild(context, callback) {
		callback(
			null,
			!this.buildMeta ||
				this.needRebuild === Module.prototype.needRebuild ||
				deprecatedNeedRebuild(this, context)
		);
	***REMOVED***

	/**
	 * @deprecated Use needBuild instead
	 * @param {Map<string, number|null>***REMOVED*** fileTimestamps timestamps of files
	 * @param {Map<string, number|null>***REMOVED*** contextTimestamps timestamps of directories
	 * @returns {boolean***REMOVED*** true, if the module needs a rebuild
	 */
	needRebuild(fileTimestamps, contextTimestamps) {
		return true;
	***REMOVED***

	/**
	 * @param {Hash***REMOVED*** hash the hash used to track dependencies
	 * @param {UpdateHashContext***REMOVED*** context context
	 * @returns {void***REMOVED***
	 */
	updateHash(
		hash,
		context = {
			chunkGraph: ChunkGraph.getChunkGraphForModule(
				this,
				"Module.updateHash",
				"DEP_WEBPACK_MODULE_UPDATE_HASH"
			),
			runtime: undefined
		***REMOVED***
	) {
		const { chunkGraph, runtime ***REMOVED*** = context;
		hash.update(chunkGraph.getModuleGraphHash(this, runtime));
		if (this.presentationalDependencies !== undefined) {
			for (const dep of this.presentationalDependencies) {
				dep.updateHash(hash, context);
			***REMOVED***
		***REMOVED***
		super.updateHash(hash, context);
	***REMOVED***

	/**
	 * @returns {void***REMOVED***
	 */
	invalidateBuild() {
		// should be overridden to support this feature
	***REMOVED***

	/* istanbul ignore next */
	/**
	 * @abstract
	 * @returns {string***REMOVED*** a unique identifier of the module
	 */
	identifier() {
		const AbstractMethodError = require("./AbstractMethodError");
		throw new AbstractMethodError();
	***REMOVED***

	/* istanbul ignore next */
	/**
	 * @abstract
	 * @param {RequestShortener***REMOVED*** requestShortener the request shortener
	 * @returns {string***REMOVED*** a user readable identifier of the module
	 */
	readableIdentifier(requestShortener) {
		const AbstractMethodError = require("./AbstractMethodError");
		throw new AbstractMethodError();
	***REMOVED***

	/* istanbul ignore next */
	/**
	 * @abstract
	 * @param {WebpackOptions***REMOVED*** options webpack options
	 * @param {Compilation***REMOVED*** compilation the compilation
	 * @param {ResolverWithOptions***REMOVED*** resolver the resolver
	 * @param {InputFileSystem***REMOVED*** fs the file system
	 * @param {BuildCallback***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	build(options, compilation, resolver, fs, callback) {
		const AbstractMethodError = require("./AbstractMethodError");
		throw new AbstractMethodError();
	***REMOVED***

	/**
	 * @abstract
	 * @returns {SourceTypes***REMOVED*** types available (do not mutate)
	 */
	getSourceTypes() {
		// Better override this method to return the correct types
		if (this.source === Module.prototype.source) {
			return DEFAULT_TYPES_UNKNOWN;
		***REMOVED***
		return JS_TYPES;
	***REMOVED***

	/**
	 * @abstract
	 * @deprecated Use codeGeneration() instead
	 * @param {DependencyTemplates***REMOVED*** dependencyTemplates the dependency templates
	 * @param {RuntimeTemplate***REMOVED*** runtimeTemplate the runtime template
	 * @param {string=***REMOVED*** type the type of source that should be generated
	 * @returns {Source***REMOVED*** generated source
	 */
	source(dependencyTemplates, runtimeTemplate, type = "javascript") {
		if (this.codeGeneration === Module.prototype.codeGeneration) {
			const AbstractMethodError = require("./AbstractMethodError");
			throw new AbstractMethodError();
		***REMOVED***
		const chunkGraph = ChunkGraph.getChunkGraphForModule(
			this,
			"Module.source() is deprecated. Use Compilation.codeGenerationResults.getSource(module, runtime, type) instead",
			"DEP_WEBPACK_MODULE_SOURCE"
		);
		/** @type {CodeGenerationContext***REMOVED*** */
		const codeGenContext = {
			dependencyTemplates,
			runtimeTemplate,
			moduleGraph: chunkGraph.moduleGraph,
			chunkGraph,
			runtime: undefined,
			codeGenerationResults: undefined
		***REMOVED***;
		const sources = this.codeGeneration(codeGenContext).sources;

		return /** @type {Source***REMOVED*** */ (
			type
				? sources.get(type)
				: sources.get(/** @type {string***REMOVED*** */ (first(this.getSourceTypes())))
		);
	***REMOVED***

	/* istanbul ignore next */
	/**
	 * @abstract
	 * @param {string=***REMOVED*** type the source type for which the size should be estimated
	 * @returns {number***REMOVED*** the estimated size of the module (must be non-zero)
	 */
	size(type) {
		const AbstractMethodError = require("./AbstractMethodError");
		throw new AbstractMethodError();
	***REMOVED***

	/**
	 * @param {LibIdentOptions***REMOVED*** options options
	 * @returns {string | null***REMOVED*** an identifier for library inclusion
	 */
	libIdent(options) {
		return null;
	***REMOVED***

	/**
	 * @returns {string | null***REMOVED*** absolute path which should be used for condition matching (usually the resource path)
	 */
	nameForCondition() {
		return null;
	***REMOVED***

	/**
	 * @param {ConcatenationBailoutReasonContext***REMOVED*** context context
	 * @returns {string | undefined***REMOVED*** reason why this module can't be concatenated, undefined when it can be concatenated
	 */
	getConcatenationBailoutReason(context) {
		return `Module Concatenation is not implemented for ${this.constructor.name***REMOVED***`;
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @returns {ConnectionState***REMOVED*** how this module should be connected to referencing modules when consumed for side-effects only
	 */
	getSideEffectsConnectionState(moduleGraph) {
		return true;
	***REMOVED***

	/**
	 * @param {CodeGenerationContext***REMOVED*** context context for code generation
	 * @returns {CodeGenerationResult***REMOVED*** result
	 */
	codeGeneration(context) {
		// Best override this method
		const sources = new Map();
		for (const type of this.getSourceTypes()) {
			if (type !== "unknown") {
				sources.set(
					type,
					this.source(
						context.dependencyTemplates,
						context.runtimeTemplate,
						type
					)
				);
			***REMOVED***
		***REMOVED***
		return {
			sources,
			runtimeRequirements: new Set([
				RuntimeGlobals.module,
				RuntimeGlobals.exports,
				RuntimeGlobals.require
			])
		***REMOVED***;
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk the chunk which condition should be checked
	 * @param {Compilation***REMOVED*** compilation the compilation
	 * @returns {boolean***REMOVED*** true, if the chunk is ok for the module
	 */
	chunkCondition(chunk, compilation) {
		return true;
	***REMOVED***

	hasChunkCondition() {
		return this.chunkCondition !== Module.prototype.chunkCondition;
	***REMOVED***

	/**
	 * Assuming this module is in the cache. Update the (cached) module with
	 * the fresh module from the factory. Usually updates internal references
	 * and properties.
	 * @param {Module***REMOVED*** module fresh module
	 * @returns {void***REMOVED***
	 */
	updateCacheModule(module) {
		this.type = module.type;
		this.layer = module.layer;
		this.context = module.context;
		this.factoryMeta = module.factoryMeta;
		this.resolveOptions = module.resolveOptions;
	***REMOVED***

	/**
	 * Module should be unsafe cached. Get data that's needed for that.
	 * This data will be passed to restoreFromUnsafeCache later.
	 * @returns {UnsafeCacheData***REMOVED*** cached data
	 */
	getUnsafeCacheData() {
		return {
			factoryMeta: this.factoryMeta,
			resolveOptions: this.resolveOptions
		***REMOVED***;
	***REMOVED***

	/**
	 * restore unsafe cache data
	 * @param {UnsafeCacheData***REMOVED*** unsafeCacheData data from getUnsafeCacheData
	 * @param {NormalModuleFactory***REMOVED*** normalModuleFactory the normal module factory handling the unsafe caching
	 */
	_restoreFromUnsafeCache(unsafeCacheData, normalModuleFactory) {
		this.factoryMeta = unsafeCacheData.factoryMeta;
		this.resolveOptions = unsafeCacheData.resolveOptions;
	***REMOVED***

	/**
	 * Assuming this module is in the cache. Remove internal references to allow freeing some memory.
	 */
	cleanupForCache() {
		this.factoryMeta = undefined;
		this.resolveOptions = undefined;
	***REMOVED***

	/**
	 * @returns {Source | null***REMOVED*** the original source for the module before webpack transformation
	 */
	originalSource() {
		return null;
	***REMOVED***

	/**
	 * @param {LazySet<string>***REMOVED*** fileDependencies set where file dependencies are added to
	 * @param {LazySet<string>***REMOVED*** contextDependencies set where context dependencies are added to
	 * @param {LazySet<string>***REMOVED*** missingDependencies set where missing dependencies are added to
	 * @param {LazySet<string>***REMOVED*** buildDependencies set where build dependencies are added to
	 */
	addCacheDependencies(
		fileDependencies,
		contextDependencies,
		missingDependencies,
		buildDependencies
	) {***REMOVED***

	/**
	 * @param {ObjectSerializerContext***REMOVED*** context context
	 */
	serialize(context) {
		const { write ***REMOVED*** = context;
		write(this.type);
		write(this.layer);
		write(this.context);
		write(this.resolveOptions);
		write(this.factoryMeta);
		write(this.useSourceMap);
		write(this.useSimpleSourceMap);
		write(this.hot);
		write(
			this._warnings !== undefined && this._warnings.length === 0
				? undefined
				: this._warnings
		);
		write(
			this._errors !== undefined && this._errors.length === 0
				? undefined
				: this._errors
		);
		write(this.buildMeta);
		write(this.buildInfo);
		write(this.presentationalDependencies);
		write(this.codeGenerationDependencies);
		super.serialize(context);
	***REMOVED***

	/**
	 * @param {ObjectDeserializerContext***REMOVED*** context context
	 */
	deserialize(context) {
		const { read ***REMOVED*** = context;
		this.type = read();
		this.layer = read();
		this.context = read();
		this.resolveOptions = read();
		this.factoryMeta = read();
		this.useSourceMap = read();
		this.useSimpleSourceMap = read();
		this.hot = read();
		this._warnings = read();
		this._errors = read();
		this.buildMeta = read();
		this.buildInfo = read();
		this.presentationalDependencies = read();
		this.codeGenerationDependencies = read();
		super.deserialize(context);
	***REMOVED***
***REMOVED***

makeSerializable(Module, "webpack/lib/Module");

// TODO remove in webpack 6
Object.defineProperty(Module.prototype, "hasEqualsChunks", {
	/**
	 * @deprecated
	 * @returns {EXPECTED_ANY***REMOVED*** throw an error
	 */
	get() {
		throw new Error(
			"Module.hasEqualsChunks was renamed (use hasEqualChunks instead)"
		);
	***REMOVED***
***REMOVED***);

// TODO remove in webpack 6
Object.defineProperty(Module.prototype, "isUsed", {
	/**
	 * @deprecated
	 * @returns {EXPECTED_ANY***REMOVED*** throw an error
	 */
	get() {
		throw new Error(
			"Module.isUsed was renamed (use getUsedName, isExportUsed or isModuleUsed instead)"
		);
	***REMOVED***
***REMOVED***);

// TODO remove in webpack 6
Object.defineProperty(Module.prototype, "errors", {
	/**
	 * @deprecated
	 * @returns {WebpackError[]***REMOVED*** errors
	 */
	get: util.deprecate(
		/**
		 * @this {Module***REMOVED***
		 * @returns {WebpackError[]***REMOVED*** errors
		 */
		function () {
			if (this._errors === undefined) {
				this._errors = [];
			***REMOVED***
			return this._errors;
		***REMOVED***,
		"Module.errors was removed (use getErrors instead)",
		"DEP_WEBPACK_MODULE_ERRORS"
	)
***REMOVED***);

// TODO remove in webpack 6
Object.defineProperty(Module.prototype, "warnings", {
	/**
	 * @deprecated
	 * @returns {WebpackError[]***REMOVED*** warnings
	 */
	get: util.deprecate(
		/**
		 * @this {Module***REMOVED***
		 * @returns {WebpackError[]***REMOVED*** warnings
		 */
		function () {
			if (this._warnings === undefined) {
				this._warnings = [];
			***REMOVED***
			return this._warnings;
		***REMOVED***,
		"Module.warnings was removed (use getWarnings instead)",
		"DEP_WEBPACK_MODULE_WARNINGS"
	)
***REMOVED***);

// TODO remove in webpack 6
Object.defineProperty(Module.prototype, "used", {
	/**
	 * @deprecated
	 * @returns {EXPECTED_ANY***REMOVED*** throw an error
	 */
	get() {
		throw new Error(
			"Module.used was refactored (use ModuleGraph.getUsedExports instead)"
		);
	***REMOVED***,
	/**
	 * @param {EXPECTED_ANY***REMOVED*** value value
	 */
	set(value) {
		throw new Error(
			"Module.used was refactored (use ModuleGraph.setUsedExports instead)"
		);
	***REMOVED***
***REMOVED***);

module.exports = Module;
