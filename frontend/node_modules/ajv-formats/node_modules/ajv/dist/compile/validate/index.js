"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
const boolSchema_1 = require("./boolSchema");
const dataType_1 = require("./dataType");
const applicability_1 = require("./applicability");
const dataType_2 = require("./dataType");
const defaults_1 = require("./defaults");
const keyword_1 = require("./keyword");
const subschema_1 = require("./subschema");
const codegen_1 = require("../codegen");
const names_1 = require("../names");
const resolve_1 = require("../resolve");
const util_1 = require("../util");
const errors_1 = require("../errors");
// schema compilation - generates validation function, subschemaCode (below) is used for subschemas
function validateFunctionCode(it) {
    if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
            topSchemaObjCode(it);
            return;
        ***REMOVED***
    ***REMOVED***
    validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
***REMOVED***
exports.validateFunctionCode = validateFunctionCode;
function validateFunction({ gen, validateName, schema, schemaEnv, opts ***REMOVED***, body) {
    if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._) `${names_1.default.data***REMOVED***, ${names_1.default.valCxt***REMOVED***`, schemaEnv.$async, () => {
            gen.code((0, codegen_1._) `"use strict"; ${funcSourceUrl(schema, opts)***REMOVED***`);
            destructureValCxtES5(gen, opts);
            gen.code(body);
        ***REMOVED***);
    ***REMOVED***
    else {
        gen.func(validateName, (0, codegen_1._) `${names_1.default.data***REMOVED***, ${destructureValCxt(opts)***REMOVED***`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    ***REMOVED***
***REMOVED***
function destructureValCxt(opts) {
    return (0, codegen_1._) `{${names_1.default.instancePath***REMOVED***="", ${names_1.default.parentData***REMOVED***, ${names_1.default.parentDataProperty***REMOVED***, ${names_1.default.rootData***REMOVED***=${names_1.default.data***REMOVED***${opts.dynamicRef ? (0, codegen_1._) `, ${names_1.default.dynamicAnchors***REMOVED***={***REMOVED***` : codegen_1.nil***REMOVED******REMOVED***={***REMOVED***`;
***REMOVED***
function destructureValCxtES5(gen, opts) {
    gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._) `${names_1.default.valCxt***REMOVED***.${names_1.default.instancePath***REMOVED***`);
        gen.var(names_1.default.parentData, (0, codegen_1._) `${names_1.default.valCxt***REMOVED***.${names_1.default.parentData***REMOVED***`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `${names_1.default.valCxt***REMOVED***.${names_1.default.parentDataProperty***REMOVED***`);
        gen.var(names_1.default.rootData, (0, codegen_1._) `${names_1.default.valCxt***REMOVED***.${names_1.default.rootData***REMOVED***`);
        if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `${names_1.default.valCxt***REMOVED***.${names_1.default.dynamicAnchors***REMOVED***`);
    ***REMOVED***, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._) `""`);
        gen.var(names_1.default.parentData, (0, codegen_1._) `undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._) `undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
            gen.var(names_1.default.dynamicAnchors, (0, codegen_1._) `{***REMOVED***`);
    ***REMOVED***);
***REMOVED***
function topSchemaObjCode(it) {
    const { schema, opts, gen ***REMOVED*** = it;
    validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
            commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
            resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
    ***REMOVED***);
    return;
***REMOVED***
function resetEvaluated(it) {
    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated
    const { gen, validateName ***REMOVED*** = it;
    it.evaluated = gen.const("evaluated", (0, codegen_1._) `${validateName***REMOVED***.evaluated`);
    gen.if((0, codegen_1._) `${it.evaluated***REMOVED***.dynamicProps`, () => gen.assign((0, codegen_1._) `${it.evaluated***REMOVED***.props`, (0, codegen_1._) `undefined`));
    gen.if((0, codegen_1._) `${it.evaluated***REMOVED***.dynamicItems`, () => gen.assign((0, codegen_1._) `${it.evaluated***REMOVED***.items`, (0, codegen_1._) `undefined`));
***REMOVED***
function funcSourceUrl(schema, opts) {
    const schId = typeof schema == "object" && schema[opts.schemaId];
    return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._) `/*# sourceURL=${schId***REMOVED*** */` : codegen_1.nil;
***REMOVED***
// schema compilation - this function is used recursively to generate code for sub-schemas
function subschemaCode(it, valid) {
    if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
            subSchemaObjCode(it, valid);
            return;
        ***REMOVED***
    ***REMOVED***
    (0, boolSchema_1.boolOrEmptySchema)(it, valid);
***REMOVED***
function schemaCxtHasRules({ schema, self ***REMOVED***) {
    if (typeof schema == "boolean")
        return !schema;
    for (const key in schema)
        if (self.RULES.all[key])
            return true;
    return false;
***REMOVED***
function isSchemaObj(it) {
    return typeof it.schema != "boolean";
***REMOVED***
function subSchemaObjCode(it, valid) {
    const { schema, gen, opts ***REMOVED*** = it;
    if (opts.$comment && schema.$comment)
        commentKeyword(it);
    updateContext(it);
    checkAsyncSchema(it);
    const errsCount = gen.const("_errs", names_1.default.errors);
    typeAndKeywords(it, errsCount);
    // TODO var
    gen.var(valid, (0, codegen_1._) `${errsCount***REMOVED*** === ${names_1.default.errors***REMOVED***`);
***REMOVED***
function checkKeywords(it) {
    (0, util_1.checkUnknownRules)(it);
    checkRefsAndKeywords(it);
***REMOVED***
function typeAndKeywords(it, errsCount) {
    if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
    const types = (0, dataType_1.getSchemaTypes)(it.schema);
    const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
    schemaKeywords(it, types, !checkedTypes, errsCount);
***REMOVED***
function checkRefsAndKeywords(it) {
    const { schema, errSchemaPath, opts, self ***REMOVED*** = it;
    if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath***REMOVED***"`);
    ***REMOVED***
***REMOVED***
function checkNoDefault(it) {
    const { schema, opts ***REMOVED*** = it;
    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
    ***REMOVED***
***REMOVED***
function updateContext(it) {
    const schId = it.schema[it.opts.schemaId];
    if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
***REMOVED***
function checkAsyncSchema(it) {
    if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
***REMOVED***
function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts ***REMOVED***) {
    const msg = schema.$comment;
    if (opts.$comment === true) {
        gen.code((0, codegen_1._) `${names_1.default.self***REMOVED***.logger.log(${msg***REMOVED***)`);
    ***REMOVED***
    else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str) `${errSchemaPath***REMOVED***/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root ***REMOVED***);
        gen.code((0, codegen_1._) `${names_1.default.self***REMOVED***.opts.$comment(${msg***REMOVED***, ${schemaPath***REMOVED***, ${rootName***REMOVED***.schema)`);
    ***REMOVED***
***REMOVED***
function returnResults(it) {
    const { gen, schemaEnv, validateName, ValidationError, opts ***REMOVED*** = it;
    if (schemaEnv.$async) {
        // TODO assign unevaluated
        gen.if((0, codegen_1._) `${names_1.default.errors***REMOVED*** === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._) `new ${ValidationError***REMOVED***(${names_1.default.vErrors***REMOVED***)`));
    ***REMOVED***
    else {
        gen.assign((0, codegen_1._) `${validateName***REMOVED***.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
            assignEvaluated(it);
        gen.return((0, codegen_1._) `${names_1.default.errors***REMOVED*** === 0`);
    ***REMOVED***
***REMOVED***
function assignEvaluated({ gen, evaluated, props, items ***REMOVED***) {
    if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._) `${evaluated***REMOVED***.props`, props);
    if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._) `${evaluated***REMOVED***.items`, items);
***REMOVED***
function schemaKeywords(it, types, typeErrors, errsCount) {
    const { gen, schema, data, allErrors, opts, self ***REMOVED*** = it;
    const { RULES ***REMOVED*** = self;
    if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition)); // TODO typecast
        return;
    ***REMOVED***
    if (!opts.jtd)
        checkStrictTypes(it, types);
    gen.block(() => {
        for (const group of RULES.rules)
            groupKeywords(group);
        groupKeywords(RULES.post);
    ***REMOVED***);
    function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
            return;
        if (group.type) {
            gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
            iterateKeywords(it, group);
            if (types.length === 1 && types[0] === group.type && typeErrors) {
                gen.else();
                (0, dataType_2.reportTypeError)(it);
            ***REMOVED***
            gen.endIf();
        ***REMOVED***
        else {
            iterateKeywords(it, group);
        ***REMOVED***
        // TODO make it "ok" call?
        if (!allErrors)
            gen.if((0, codegen_1._) `${names_1.default.errors***REMOVED*** === ${errsCount || 0***REMOVED***`);
    ***REMOVED***
***REMOVED***
function iterateKeywords(it, group) {
    const { gen, schema, opts: { useDefaults ***REMOVED***, ***REMOVED*** = it;
    if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
    gen.block(() => {
        for (const rule of group.rules) {
            if ((0, applicability_1.shouldUseRule)(schema, rule)) {
                keywordCode(it, rule.keyword, rule.definition, group.type);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***);
***REMOVED***
function checkStrictTypes(it, types) {
    if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
    checkContextTypes(it, types);
    if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
    checkKeywordTypes(it, it.dataTypes);
***REMOVED***
function checkContextTypes(it, types) {
    if (!types.length)
        return;
    if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
    ***REMOVED***
    types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
            strictTypesError(it, `type "${t***REMOVED***" not allowed by context "${it.dataTypes.join(",")***REMOVED***"`);
        ***REMOVED***
    ***REMOVED***);
    narrowSchemaTypes(it, types);
***REMOVED***
function checkMultipleTypes(it, ts) {
    if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    ***REMOVED***
***REMOVED***
function checkKeywordTypes(it, ts) {
    const rules = it.self.RULES.all;
    for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
            const { type ***REMOVED*** = rule.definition;
            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
                strictTypesError(it, `missing type "${type.join(",")***REMOVED***" for keyword "${keyword***REMOVED***"`);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
***REMOVED***
function hasApplicableType(schTs, kwdT) {
    return schTs.includes(kwdT) || (kwdT === "number" && schTs.includes("integer"));
***REMOVED***
function includesType(ts, t) {
    return ts.includes(t) || (t === "integer" && ts.includes("number"));
***REMOVED***
function narrowSchemaTypes(it, withTypes) {
    const ts = [];
    for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
            ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
            ts.push("integer");
    ***REMOVED***
    it.dataTypes = ts;
***REMOVED***
function strictTypesError(it, msg) {
    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
    msg += ` at "${schemaPath***REMOVED***" (strictTypes)`;
    (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
***REMOVED***
class KeywordCxt {
    constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {***REMOVED***;
        this.it = it;
        this.def = def;
        if (this.$data) {
            this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        ***REMOVED***
        else {
            this.schemaCode = this.schemaValue;
            if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
                throw new Error(`${keyword***REMOVED*** value must be ${JSON.stringify(def.schemaType)***REMOVED***`);
            ***REMOVED***
        ***REMOVED***
        if ("code" in def ? def.trackErrors : def.errors !== false) {
            this.errsCount = it.gen.const("_errs", names_1.default.errors);
        ***REMOVED***
    ***REMOVED***
    result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
    ***REMOVED***
    failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
            failAction();
        else
            this.error();
        if (successAction) {
            this.gen.else();
            successAction();
            if (this.allErrors)
                this.gen.endIf();
        ***REMOVED***
        else {
            if (this.allErrors)
                this.gen.endIf();
            else
                this.gen.else();
        ***REMOVED***
    ***REMOVED***
    pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), undefined, failAction);
    ***REMOVED***
    fail(condition) {
        if (condition === undefined) {
            this.error();
            if (!this.allErrors)
                this.gen.if(false); // this branch will be removed by gen.optimize
            return;
        ***REMOVED***
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
            this.gen.endIf();
        else
            this.gen.else();
    ***REMOVED***
    fail$data(condition) {
        if (!this.$data)
            return this.fail(condition);
        const { schemaCode ***REMOVED*** = this;
        this.fail((0, codegen_1._) `${schemaCode***REMOVED*** !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)***REMOVED***)`);
    ***REMOVED***
    error(append, errorParams, errorPaths) {
        if (errorParams) {
            this.setParams(errorParams);
            this._error(append, errorPaths);
            this.setParams({***REMOVED***);
            return;
        ***REMOVED***
        this._error(append, errorPaths);
    ***REMOVED***
    _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
    ***REMOVED***
    $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
    ***REMOVED***
    reset() {
        if (this.errsCount === undefined)
            throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
    ***REMOVED***
    ok(cond) {
        if (!this.allErrors)
            this.gen.if(cond);
    ***REMOVED***
    setParams(obj, assign) {
        if (assign)
            Object.assign(this.params, obj);
        else
            this.params = obj;
    ***REMOVED***
    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
            this.check$data(valid, $dataValid);
            codeBlock();
        ***REMOVED***);
    ***REMOVED***
    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
            return;
        const { gen, schemaCode, schemaType, def ***REMOVED*** = this;
        gen.if((0, codegen_1.or)((0, codegen_1._) `${schemaCode***REMOVED*** === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
            gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
            gen.elseIf(this.invalid$data());
            this.$dataError();
            if (valid !== codegen_1.nil)
                gen.assign(valid, false);
        ***REMOVED***
        gen.else();
    ***REMOVED***
    invalid$data() {
        const { gen, schemaCode, schemaType, def, it ***REMOVED*** = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
            if (schemaType.length) {
                /* istanbul ignore if */
                if (!(schemaCode instanceof codegen_1.Name))
                    throw new Error("ajv implementation error");
                const st = Array.isArray(schemaType) ? schemaType : [schemaType];
                return (0, codegen_1._) `${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)***REMOVED***`;
            ***REMOVED***
            return codegen_1.nil;
        ***REMOVED***
        function invalid$DataSchema() {
            if (def.validateSchema) {
                const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema ***REMOVED***); // TODO value.code for standalone
                return (0, codegen_1._) `!${validateSchemaRef***REMOVED***(${schemaCode***REMOVED***)`;
            ***REMOVED***
            return codegen_1.nil;
        ***REMOVED***
    ***REMOVED***
    subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined ***REMOVED***;
        subschemaCode(nextContext, valid);
        return nextContext;
    ***REMOVED***
    mergeEvaluated(schemaCxt, toName) {
        const { it, gen ***REMOVED*** = this;
        if (!it.opts.unevaluated)
            return;
        if (it.props !== true && schemaCxt.props !== undefined) {
            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        ***REMOVED***
        if (it.items !== true && schemaCxt.items !== undefined) {
            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        ***REMOVED***
    ***REMOVED***
    mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen ***REMOVED*** = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
            return true;
        ***REMOVED***
    ***REMOVED***
***REMOVED***
exports.KeywordCxt = KeywordCxt;
function keywordCode(it, keyword, def, ruleType) {
    const cxt = new KeywordCxt(it, def, keyword);
    if ("code" in def) {
        def.code(cxt, ruleType);
    ***REMOVED***
    else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
    ***REMOVED***
    else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
    ***REMOVED***
    else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
    ***REMOVED***
***REMOVED***
const JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
const RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, { dataLevel, dataNames, dataPathArr ***REMOVED***) {
    let jsonPointer;
    let data;
    if ($data === "")
        return names_1.default.rootData;
    if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
            throw new Error(`Invalid JSON-pointer: ${$data***REMOVED***`);
        jsonPointer = $data;
        data = names_1.default.rootData;
    ***REMOVED***
    else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
            throw new Error(`Invalid JSON-pointer: ${$data***REMOVED***`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
            if (up >= dataLevel)
                throw new Error(errorMsg("property/index", up));
            return dataPathArr[dataLevel - up];
        ***REMOVED***
        if (up > dataLevel)
            throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
            return data;
    ***REMOVED***
    let expr = data;
    const segments = jsonPointer.split("/");
    for (const segment of segments) {
        if (segment) {
            data = (0, codegen_1._) `${data***REMOVED***${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))***REMOVED***`;
            expr = (0, codegen_1._) `${expr***REMOVED*** && ${data***REMOVED***`;
        ***REMOVED***
    ***REMOVED***
    return expr;
    function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType***REMOVED*** ${up***REMOVED*** levels up, current level is ${dataLevel***REMOVED***`;
    ***REMOVED***
***REMOVED***
exports.getData = getData;
//# sourceMappingURL=index.js.map