"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod ***REMOVED***;
***REMOVED***;
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
exports.Server = void 0;
const multicast_dns_1 = __importDefault(require("multicast-dns"));
const es6_1 = __importDefault(require("fast-deep-equal/es6"));
const dns_equal_1 = __importDefault(require("./utils/dns-equal"));
class Server {
    constructor(opts, errorCallback) {
        this.registry = {***REMOVED***;
        this.mdns = (0, multicast_dns_1.default)(opts);
        this.mdns.setMaxListeners(0);
        this.mdns.on('query', this.respondToQuery.bind(this));
        this.errorCallback = errorCallback !== null && errorCallback !== void 0 ? errorCallback : function (err) { throw err; ***REMOVED***;
    ***REMOVED***
    register(records) {
        const shouldRegister = (record) => {
            var subRegistry = this.registry[record.type];
            if (!subRegistry) {
                subRegistry = this.registry[record.type] = [];
            ***REMOVED***
            else if (subRegistry.some(this.isDuplicateRecord(record))) {
                return;
            ***REMOVED***
            subRegistry.push(record);
        ***REMOVED***;
        if (Array.isArray(records)) {
            records.forEach(shouldRegister);
        ***REMOVED***
        else {
            shouldRegister(records);
        ***REMOVED***
    ***REMOVED***
    unregister(records) {
        const shouldUnregister = (record) => {
            let type = record.type;
            if (!(type in this.registry)) {
                return;
            ***REMOVED***
            this.registry[type] = this.registry[type].filter((i) => i.name !== record.name);
        ***REMOVED***;
        if (Array.isArray(records)) {
            records.forEach(shouldUnregister);
        ***REMOVED***
        else {
            shouldUnregister(records);
        ***REMOVED***
    ***REMOVED***
    respondToQuery(query) {
        let self = this;
        query.questions.forEach((question) => {
            var type = question.type;
            var name = question.name;
            var answers = type === 'ANY'
                ? Object.keys(self.registry).map(self.recordsFor.bind(self, name)).flat(1)
                : self.recordsFor(name, type);
            if (answers.length === 0)
                return;
            var additionals = [];
            if (type !== 'ANY') {
                answers.forEach((answer) => {
                    if (answer.type !== 'PTR')
                        return;
                    additionals = additionals
                        .concat(self.recordsFor(answer.data, 'SRV'))
                        .concat(self.recordsFor(answer.data, 'TXT'));
                ***REMOVED***);
                additionals
                    .filter(function (record) {
                    return record.type === 'SRV';
                ***REMOVED***)
                    .map(function (record) {
                    return record.data.target;
                ***REMOVED***)
                    .filter(this.unique())
                    .forEach(function (target) {
                    additionals = additionals
                        .concat(self.recordsFor(target, 'A'))
                        .concat(self.recordsFor(target, 'AAAA'));
                ***REMOVED***);
            ***REMOVED***
            self.mdns.respond({ answers: answers, additionals: additionals ***REMOVED***, (err) => {
                if (err) {
                    this.errorCallback(err);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***);
    ***REMOVED***
    recordsFor(name, type) {
        if (!(type in this.registry)) {
            return [];
        ***REMOVED***
        return this.registry[type].filter((record) => {
            var _name = ~name.indexOf('.') ? record.name : record.name.split('.')[0];
            return (0, dns_equal_1.default)(_name, name);
        ***REMOVED***);
    ***REMOVED***
    isDuplicateRecord(a) {
        return (b) => {
            return a.type === b.type &&
                a.name === b.name &&
                (0, es6_1.default)(a.data, b.data);
        ***REMOVED***;
    ***REMOVED***
    unique() {
        var set = [];
        return (obj) => {
            if (~set.indexOf(obj))
                return false;
            set.push(obj);
            return true;
        ***REMOVED***;
    ***REMOVED***
***REMOVED***
exports.Server = Server;
exports.default = Server;
//# sourceMappingURL=mdns-server.js.map