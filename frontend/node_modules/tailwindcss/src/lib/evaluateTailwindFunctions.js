import dlv from 'dlv'
import didYouMean from 'didyoumean'
import transformThemeValue from '../util/transformThemeValue'
import parseValue from '../value-parser/index'
import { normalizeScreens ***REMOVED*** from '../util/normalizeScreens'
import buildMediaQuery from '../util/buildMediaQuery'
import { toPath ***REMOVED*** from '../util/toPath'
import { withAlphaValue ***REMOVED*** from '../util/withAlphaVariable'
import { parseColorFormat ***REMOVED*** from '../util/pluginUtils'
import log from '../util/log'

function isObject(input) {
  return typeof input === 'object' && input !== null
***REMOVED***

function findClosestExistingPath(theme, path) {
  let parts = toPath(path)
  do {
    parts.pop()

    if (dlv(theme, parts) !== undefined) break
  ***REMOVED*** while (parts.length)

  return parts.length ? parts : undefined
***REMOVED***

function pathToString(path) {
  if (typeof path === 'string') return path
  return path.reduce((acc, cur, i) => {
    if (cur.includes('.')) return `${acc***REMOVED***[${cur***REMOVED***]`
    return i === 0 ? cur : `${acc***REMOVED***.${cur***REMOVED***`
  ***REMOVED***, '')
***REMOVED***

function list(items) {
  return items.map((key) => `'${key***REMOVED***'`).join(', ')
***REMOVED***

function listKeys(obj) {
  return list(Object.keys(obj))
***REMOVED***

function validatePath(config, path, defaultValue, themeOpts = {***REMOVED***) {
  const pathString = Array.isArray(path) ? pathToString(path) : path.replace(/^['"]+|['"]+$/g, '')
  const pathSegments = Array.isArray(path) ? path : toPath(pathString)
  const value = dlv(config.theme, pathSegments, defaultValue)

  if (value === undefined) {
    let error = `'${pathString***REMOVED***' does not exist in your theme config.`
    const parentSegments = pathSegments.slice(0, -1)
    const parentValue = dlv(config.theme, parentSegments)

    if (isObject(parentValue)) {
      const validKeys = Object.keys(parentValue).filter(
        (key) => validatePath(config, [...parentSegments, key]).isValid
      )
      const suggestion = didYouMean(pathSegments[pathSegments.length - 1], validKeys)
      if (suggestion) {
        error += ` Did you mean '${pathToString([...parentSegments, suggestion])***REMOVED***'?`
      ***REMOVED*** else if (validKeys.length > 0) {
        error += ` '${pathToString(parentSegments)***REMOVED***' has the following valid keys: ${list(
          validKeys
        )***REMOVED***`
      ***REMOVED***
    ***REMOVED*** else {
      const closestPath = findClosestExistingPath(config.theme, pathString)
      if (closestPath) {
        const closestValue = dlv(config.theme, closestPath)
        if (isObject(closestValue)) {
          error += ` '${pathToString(closestPath)***REMOVED***' has the following keys: ${listKeys(
            closestValue
          )***REMOVED***`
        ***REMOVED*** else {
          error += ` '${pathToString(closestPath)***REMOVED***' is not an object.`
        ***REMOVED***
      ***REMOVED*** else {
        error += ` Your theme has the following top-level keys: ${listKeys(config.theme)***REMOVED***`
      ***REMOVED***
    ***REMOVED***

    return {
      isValid: false,
      error,
    ***REMOVED***
  ***REMOVED***

  if (
    !(
      typeof value === 'string' ||
      typeof value === 'number' ||
      typeof value === 'function' ||
      value instanceof String ||
      value instanceof Number ||
      Array.isArray(value)
    )
  ) {
    let error = `'${pathString***REMOVED***' was found but does not resolve to a string.`

    if (isObject(value)) {
      let validKeys = Object.keys(value).filter(
        (key) => validatePath(config, [...pathSegments, key]).isValid
      )
      if (validKeys.length) {
        error += ` Did you mean something like '${pathToString([...pathSegments, validKeys[0]])***REMOVED***'?`
      ***REMOVED***
    ***REMOVED***

    return {
      isValid: false,
      error,
    ***REMOVED***
  ***REMOVED***

  const [themeSection] = pathSegments

  return {
    isValid: true,
    value: transformThemeValue(themeSection)(value, themeOpts),
  ***REMOVED***
***REMOVED***

function extractArgs(node, vNodes, functions) {
  vNodes = vNodes.map((vNode) => resolveVNode(node, vNode, functions))

  let args = ['']

  for (let vNode of vNodes) {
    if (vNode.type === 'div' && vNode.value === ',') {
      args.push('')
    ***REMOVED*** else {
      args[args.length - 1] += parseValue.stringify(vNode)
    ***REMOVED***
  ***REMOVED***

  return args
***REMOVED***

function resolveVNode(node, vNode, functions) {
  if (vNode.type === 'function' && functions[vNode.value] !== undefined) {
    let args = extractArgs(node, vNode.nodes, functions)
    vNode.type = 'word'
    vNode.value = functions[vNode.value](node, ...args)
  ***REMOVED***

  return vNode
***REMOVED***

function resolveFunctions(node, input, functions) {
  let hasAnyFn = Object.keys(functions).some((fn) => input.includes(`${fn***REMOVED***(`))
  if (!hasAnyFn) return input

  return parseValue(input)
    .walk((vNode) => {
      resolveVNode(node, vNode, functions)
    ***REMOVED***)
    .toString()
***REMOVED***

let nodeTypePropertyMap = {
  atrule: 'params',
  decl: 'value',
***REMOVED***

/**
 * @param {string***REMOVED*** path
 * @returns {Iterable<[path: string, alpha: string|undefined]>***REMOVED***
 */
function* toPaths(path) {
  // Strip quotes from beginning and end of string
  // This allows the alpha value to be present inside of quotes
  path = path.replace(/^['"]+|['"]+$/g, '')

  let matches = path.match(/^([^\s]+)(?![^\[]*\])(?:\s*\/\s*([^\/\s]+))$/)
  let alpha = undefined

  yield [path, undefined]

  if (matches) {
    path = matches[1]
    alpha = matches[2]

    yield [path, alpha]
  ***REMOVED***
***REMOVED***

/**
 *
 * @param {any***REMOVED*** config
 * @param {string***REMOVED*** path
 * @param {any***REMOVED*** defaultValue
 */
function resolvePath(config, path, defaultValue) {
  const results = Array.from(toPaths(path)).map(([path, alpha]) => {
    return Object.assign(validatePath(config, path, defaultValue, { opacityValue: alpha ***REMOVED***), {
      resolvedPath: path,
      alpha,
    ***REMOVED***)
  ***REMOVED***)

  return results.find((result) => result.isValid) ?? results[0]
***REMOVED***

export default function (context) {
  let config = context.tailwindConfig

  let functions = {
    theme: (node, path, ...defaultValue) => {
      let { isValid, value, error, alpha ***REMOVED*** = resolvePath(
        config,
        path,
        defaultValue.length ? defaultValue : undefined
      )

      if (!isValid) {
        let parentNode = node.parent
        let candidate = parentNode?.raws.tailwind?.candidate

        if (parentNode && candidate !== undefined) {
          // Remove this utility from any caches
          context.markInvalidUtilityNode(parentNode)

          // Remove the CSS node from the markup
          parentNode.remove()

          // Show a warning
          log.warn('invalid-theme-key-in-class', [
            `The utility \`${candidate***REMOVED***\` contains an invalid theme value and was not generated.`,
          ])

          return
        ***REMOVED***

        throw node.error(error)
      ***REMOVED***

      let maybeColor = parseColorFormat(value)
      let isColorFunction = maybeColor !== undefined && typeof maybeColor === 'function'

      if (alpha !== undefined || isColorFunction) {
        if (alpha === undefined) {
          alpha = 1.0
        ***REMOVED***

        value = withAlphaValue(maybeColor, alpha, maybeColor)
      ***REMOVED***

      return value
    ***REMOVED***,
    screen: (node, screen) => {
      screen = screen.replace(/^['"]+/g, '').replace(/['"]+$/g, '')
      let screens = normalizeScreens(config.theme.screens)
      let screenDefinition = screens.find(({ name ***REMOVED***) => name === screen)

      if (!screenDefinition) {
        throw node.error(`The '${screen***REMOVED***' screen does not exist in your theme.`)
      ***REMOVED***

      return buildMediaQuery(screenDefinition)
    ***REMOVED***,
  ***REMOVED***
  return (root) => {
    root.walk((node) => {
      let property = nodeTypePropertyMap[node.type]

      if (property === undefined) {
        return
      ***REMOVED***

      node[property] = resolveFunctions(node, node[property], functions)
    ***REMOVED***)
  ***REMOVED***
***REMOVED***
