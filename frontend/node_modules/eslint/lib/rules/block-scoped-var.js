/**
 * @fileoverview Rule to check for "block scoped" variables by binding context
 * @author Matt DuVall <http://www.mattduvall.com>
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "suggestion",

		docs: {
			description:
				"Enforce the use of variables within the scope they are defined",
			recommended: false,
			url: "https://eslint.org/docs/latest/rules/block-scoped-var",
		***REMOVED***,

		schema: [],

		messages: {
			outOfScope:
				"'{{name***REMOVED******REMOVED***' declared on line {{definitionLine***REMOVED******REMOVED*** column {{definitionColumn***REMOVED******REMOVED*** is used outside of binding context.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		let stack = [];
		const sourceCode = context.sourceCode;

		/**
		 * Makes a block scope.
		 * @param {ASTNode***REMOVED*** node A node of a scope.
		 * @returns {void***REMOVED***
		 */
		function enterScope(node) {
			stack.push(node.range);
		***REMOVED***

		/**
		 * Pops the last block scope.
		 * @returns {void***REMOVED***
		 */
		function exitScope() {
			stack.pop();
		***REMOVED***

		/**
		 * Reports a given reference.
		 * @param {eslint-scope.Reference***REMOVED*** reference A reference to report.
		 * @param {eslint-scope.Definition***REMOVED*** definition A definition for which to report reference.
		 * @returns {void***REMOVED***
		 */
		function report(reference, definition) {
			const identifier = reference.identifier;
			const definitionPosition = definition.name.loc.start;

			context.report({
				node: identifier,
				messageId: "outOfScope",
				data: {
					name: identifier.name,
					definitionLine: definitionPosition.line,
					definitionColumn: definitionPosition.column + 1,
				***REMOVED***,
			***REMOVED***);
		***REMOVED***

		/**
		 * Finds and reports references which are outside of valid scopes.
		 * @param {ASTNode***REMOVED*** node A node to get variables.
		 * @returns {void***REMOVED***
		 */
		function checkForVariables(node) {
			if (node.kind !== "var") {
				return;
			***REMOVED***

			// Defines a predicate to check whether or not a given reference is outside of valid scope.
			const scopeRange = stack.at(-1);

			/**
			 * Check if a reference is out of scope
			 * @param {ASTNode***REMOVED*** reference node to examine
			 * @returns {boolean***REMOVED*** True is its outside the scope
			 * @private
			 */
			function isOutsideOfScope(reference) {
				const idRange = reference.identifier.range;

				return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];
			***REMOVED***

			// Gets declared variables, and checks its references.
			const variables = sourceCode.getDeclaredVariables(node);

			for (let i = 0; i < variables.length; ++i) {
				// Reports.
				variables[i].references.filter(isOutsideOfScope).forEach(ref =>
					report(
						ref,
						variables[i].defs.find(def => def.parent === node),
					),
				);
			***REMOVED***
		***REMOVED***

		return {
			Program(node) {
				stack = [node.range];
			***REMOVED***,

			// Manages scopes.
			BlockStatement: enterScope,
			"BlockStatement:exit": exitScope,
			ForStatement: enterScope,
			"ForStatement:exit": exitScope,
			ForInStatement: enterScope,
			"ForInStatement:exit": exitScope,
			ForOfStatement: enterScope,
			"ForOfStatement:exit": exitScope,
			SwitchStatement: enterScope,
			"SwitchStatement:exit": exitScope,
			CatchClause: enterScope,
			"CatchClause:exit": exitScope,
			StaticBlock: enterScope,
			"StaticBlock:exit": exitScope,

			// Finds and reports references which are outside of valid scope.
			VariableDeclaration: checkForVariables,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
