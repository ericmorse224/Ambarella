const BULK_SIZE = 2000;

// We are using an object instead of a Map as this will stay static during the runtime
// so access to it can be optimized by v8
const digestCaches = {***REMOVED***;

class BulkUpdateDecorator {
  /**
   * @param {Hash | function(): Hash***REMOVED*** hashOrFactory function to create a hash
   * @param {string=***REMOVED*** hashKey key for caching
   */
  constructor(hashOrFactory, hashKey) {
    this.hashKey = hashKey;

    if (typeof hashOrFactory === "function") {
      this.hashFactory = hashOrFactory;
      this.hash = undefined;
    ***REMOVED*** else {
      this.hashFactory = undefined;
      this.hash = hashOrFactory;
    ***REMOVED***

    this.buffer = "";
  ***REMOVED***

  /**
   * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding***REMOVED***
   * @param {string|Buffer***REMOVED*** data data
   * @param {string=***REMOVED*** inputEncoding data encoding
   * @returns {this***REMOVED*** updated hash
   */
  update(data, inputEncoding) {
    if (
      inputEncoding !== undefined ||
      typeof data !== "string" ||
      data.length > BULK_SIZE
    ) {
      if (this.hash === undefined) {
        this.hash = this.hashFactory();
      ***REMOVED***

      if (this.buffer.length > 0) {
        this.hash.update(this.buffer);
        this.buffer = "";
      ***REMOVED***

      this.hash.update(data, inputEncoding);
    ***REMOVED*** else {
      this.buffer += data;

      if (this.buffer.length > BULK_SIZE) {
        if (this.hash === undefined) {
          this.hash = this.hashFactory();
        ***REMOVED***

        this.hash.update(this.buffer);
        this.buffer = "";
      ***REMOVED***
    ***REMOVED***

    return this;
  ***REMOVED***

  /**
   * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding***REMOVED***
   * @param {string=***REMOVED*** encoding encoding of the return value
   * @returns {string|Buffer***REMOVED*** digest
   */
  digest(encoding) {
    let digestCache;

    const buffer = this.buffer;

    if (this.hash === undefined) {
      // short data for hash, we can use caching
      const cacheKey = `${this.hashKey***REMOVED***-${encoding***REMOVED***`;

      digestCache = digestCaches[cacheKey];

      if (digestCache === undefined) {
        digestCache = digestCaches[cacheKey] = new Map();
      ***REMOVED***

      const cacheEntry = digestCache.get(buffer);

      if (cacheEntry !== undefined) {
        return cacheEntry;
      ***REMOVED***

      this.hash = this.hashFactory();
    ***REMOVED***

    if (buffer.length > 0) {
      this.hash.update(buffer);
    ***REMOVED***

    const digestResult = this.hash.digest(encoding);

    if (digestCache !== undefined) {
      digestCache.set(buffer, digestResult);
    ***REMOVED***

    return digestResult;
  ***REMOVED***
***REMOVED***

module.exports = BulkUpdateDecorator;
