/**
 * @fileoverview `ExtractedConfig` class.
 *
 * `ExtractedConfig` class expresses a final configuration for a specific file.
 *
 * It provides one method.
 *
 * - `toCompatibleObjectAsConfigFileContent()`
 *      Convert this configuration to the compatible object as the content of
 *      config files. It converts the loaded parser and plugins to strings.
 *      `CLIEngine#getConfigForFile(filePath)` method uses this method.
 *
 * `ConfigArray#extractConfig(filePath)` creates a `ExtractedConfig` instance.
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */
"use strict";

const { IgnorePattern ***REMOVED*** = require("./ignore-pattern");

// For VSCode intellisense
/** @typedef {import("../../shared/types").ConfigData***REMOVED*** ConfigData */
/** @typedef {import("../../shared/types").GlobalConf***REMOVED*** GlobalConf */
/** @typedef {import("../../shared/types").SeverityConf***REMOVED*** SeverityConf */
/** @typedef {import("./config-dependency").DependentParser***REMOVED*** DependentParser */
/** @typedef {import("./config-dependency").DependentPlugin***REMOVED*** DependentPlugin */

/**
 * Check if `xs` starts with `ys`.
 * @template T
 * @param {T[]***REMOVED*** xs The array to check.
 * @param {T[]***REMOVED*** ys The array that may be the first part of `xs`.
 * @returns {boolean***REMOVED*** `true` if `xs` starts with `ys`.
 */
function startsWith(xs, ys) {
    return xs.length >= ys.length && ys.every((y, i) => y === xs[i]);
***REMOVED***

/**
 * The class for extracted config data.
 */
class ExtractedConfig {
    constructor() {

        /**
         * The config name what `noInlineConfig` setting came from.
         * @type {string***REMOVED***
         */
        this.configNameOfNoInlineConfig = "";

        /**
         * Environments.
         * @type {Record<string, boolean>***REMOVED***
         */
        this.env = {***REMOVED***;

        /**
         * Global variables.
         * @type {Record<string, GlobalConf>***REMOVED***
         */
        this.globals = {***REMOVED***;

        /**
         * The glob patterns that ignore to lint.
         * @type {(((filePath:string, dot?:boolean) => boolean) & { basePath:string; patterns:string[] ***REMOVED***) | undefined***REMOVED***
         */
        this.ignores = void 0;

        /**
         * The flag that disables directive comments.
         * @type {boolean|undefined***REMOVED***
         */
        this.noInlineConfig = void 0;

        /**
         * Parser definition.
         * @type {DependentParser|null***REMOVED***
         */
        this.parser = null;

        /**
         * Options for the parser.
         * @type {Object***REMOVED***
         */
        this.parserOptions = {***REMOVED***;

        /**
         * Plugin definitions.
         * @type {Record<string, DependentPlugin>***REMOVED***
         */
        this.plugins = {***REMOVED***;

        /**
         * Processor ID.
         * @type {string|null***REMOVED***
         */
        this.processor = null;

        /**
         * The flag that reports unused `eslint-disable` directive comments.
         * @type {boolean|undefined***REMOVED***
         */
        this.reportUnusedDisableDirectives = void 0;

        /**
         * Rule settings.
         * @type {Record<string, [SeverityConf, ...any[]]>***REMOVED***
         */
        this.rules = {***REMOVED***;

        /**
         * Shared settings.
         * @type {Object***REMOVED***
         */
        this.settings = {***REMOVED***;
    ***REMOVED***

    /**
     * Convert this config to the compatible object as a config file content.
     * @returns {ConfigData***REMOVED*** The converted object.
     */
    toCompatibleObjectAsConfigFileContent() {
        const {
            /* eslint-disable no-unused-vars */
            configNameOfNoInlineConfig: _ignore1,
            processor: _ignore2,
            /* eslint-enable no-unused-vars */
            ignores,
            ...config
        ***REMOVED*** = this;

        config.parser = config.parser && config.parser.filePath;
        config.plugins = Object.keys(config.plugins).filter(Boolean).reverse();
        config.ignorePatterns = ignores ? ignores.patterns : [];

        // Strip the default patterns from `ignorePatterns`.
        if (startsWith(config.ignorePatterns, IgnorePattern.DefaultPatterns)) {
            config.ignorePatterns =
                config.ignorePatterns.slice(IgnorePattern.DefaultPatterns.length);
        ***REMOVED***

        return config;
    ***REMOVED***
***REMOVED***

module.exports = { ExtractedConfig ***REMOVED***;
