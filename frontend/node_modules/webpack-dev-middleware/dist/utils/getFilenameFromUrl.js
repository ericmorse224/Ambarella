"use strict";

const path = require("path");

const {
  parse
***REMOVED*** = require("url");

const querystring = require("querystring");

const getPaths = require("./getPaths");
/** @typedef {import("../index.js").IncomingMessage***REMOVED*** IncomingMessage */

/** @typedef {import("../index.js").ServerResponse***REMOVED*** ServerResponse */


const cacheStore = new WeakMap();
/**
 * @template T
 * @param {Function***REMOVED*** fn
 * @param {{ cache?: Map<string, { data: T ***REMOVED***> ***REMOVED*** | undefined***REMOVED*** cache
 * @param {(value: T) => T***REMOVED*** callback
 * @returns {any***REMOVED***
 */
// @ts-ignore

const mem = (fn, {
  cache = new Map()
***REMOVED*** = {***REMOVED***, callback) => {
  /**
   * @param {any***REMOVED*** arguments_
   * @return {any***REMOVED***
   */
  const memoized = (...arguments_) => {
    const [key] = arguments_;
    const cacheItem = cache.get(key);

    if (cacheItem) {
      return cacheItem.data;
    ***REMOVED***

    let result = fn.apply(void 0, arguments_);
    result = callback(result);
    cache.set(key, {
      data: result
    ***REMOVED***);
    return result;
  ***REMOVED***;

  cacheStore.set(memoized, cache);
  return memoized;
***REMOVED***; // eslint-disable-next-line no-undefined


const memoizedParse = mem(parse, undefined, value => {
  if (value.pathname) {
    // eslint-disable-next-line no-param-reassign
    value.pathname = decode(value.pathname);
  ***REMOVED***

  return value;
***REMOVED***);
const UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
/**
 * @typedef {Object***REMOVED*** Extra
 * @property {import("fs").Stats=***REMOVED*** stats
 * @property {number=***REMOVED*** errorCode
 */

/**
 * decodeURIComponent.
 *
 * Allows V8 to only deoptimize this fn instead of all of send().
 *
 * @param {string***REMOVED*** input
 * @returns {string***REMOVED***
 */

function decode(input) {
  return querystring.unescape(input);
***REMOVED***
/**
 * @template {IncomingMessage***REMOVED*** Request
 * @template {ServerResponse***REMOVED*** Response
 * @param {import("../index.js").Context<Request, Response>***REMOVED*** context
 * @param {string***REMOVED*** url
 * @param {Extra=***REMOVED*** extra
 * @returns {string | undefined***REMOVED***
 */


function getFilenameFromUrl(context, url, extra = {***REMOVED***) {
  const {
    options
  ***REMOVED*** = context;
  const paths = getPaths(context);
  /** @type {string | undefined***REMOVED*** */

  let foundFilename;
  /** @type {URL***REMOVED*** */

  let urlObject;

  try {
    // The `url` property of the `request` is contains only  `pathname`, `search` and `hash`
    urlObject = memoizedParse(url, false, true);
  ***REMOVED*** catch (_ignoreError) {
    return;
  ***REMOVED***

  for (const {
    publicPath,
    outputPath
  ***REMOVED*** of paths) {
    /** @type {string | undefined***REMOVED*** */
    let filename;
    /** @type {URL***REMOVED*** */

    let publicPathObject;

    try {
      publicPathObject = memoizedParse(publicPath !== "auto" && publicPath ? publicPath : "/", false, true);
    ***REMOVED*** catch (_ignoreError) {
      // eslint-disable-next-line no-continue
      continue;
    ***REMOVED***

    const {
      pathname
    ***REMOVED*** = urlObject;
    const {
      pathname: publicPathPathname
    ***REMOVED*** = publicPathObject;

    if (pathname && pathname.startsWith(publicPathPathname)) {
      // Null byte(s)
      if (pathname.includes("\0")) {
        // eslint-disable-next-line no-param-reassign
        extra.errorCode = 400;
        return;
      ***REMOVED*** // ".." is malicious


      if (UP_PATH_REGEXP.test(path.normalize(`./${pathname***REMOVED***`))) {
        // eslint-disable-next-line no-param-reassign
        extra.errorCode = 403;
        return;
      ***REMOVED*** // Strip the `pathname` property from the `publicPath` option from the start of requested url
      // `/complex/foo.js` => `foo.js`
      // and add outputPath
      // `foo.js` => `/home/user/my-project/dist/foo.js`


      filename = path.join(outputPath, pathname.slice(publicPathPathname.length));

      try {
        // eslint-disable-next-line no-param-reassign
        extra.stats =
        /** @type {import("fs").statSync***REMOVED*** */
        context.outputFileSystem.statSync(filename);
      ***REMOVED*** catch (_ignoreError) {
        // eslint-disable-next-line no-continue
        continue;
      ***REMOVED***

      if (extra.stats.isFile()) {
        foundFilename = filename;
        break;
      ***REMOVED*** else if (extra.stats.isDirectory() && (typeof options.index === "undefined" || options.index)) {
        const indexValue = typeof options.index === "undefined" || typeof options.index === "boolean" ? "index.html" : options.index;
        filename = path.join(filename, indexValue);

        try {
          // eslint-disable-next-line no-param-reassign
          extra.stats =
          /** @type {import("fs").statSync***REMOVED*** */
          context.outputFileSystem.statSync(filename);
        ***REMOVED*** catch (__ignoreError) {
          // eslint-disable-next-line no-continue
          continue;
        ***REMOVED***

        if (extra.stats.isFile()) {
          foundFilename = filename;
          break;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** // eslint-disable-next-line consistent-return


  return foundFilename;
***REMOVED***

module.exports = getFilenameFromUrl;