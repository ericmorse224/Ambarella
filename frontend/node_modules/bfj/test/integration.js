'use strict'

const assert = require('chai').assert
const axios = require('axios')
const fs = require('fs')
const path = require('path')
const Promise = require('bluebird')
const stream = require('stream')

const modulePath = '../src'

suite('integration:', () => {
  let log

  setup(() => {
    log = {***REMOVED***
  ***REMOVED***)

  test('require does not throw', () => {
    assert.doesNotThrow(() => {
      require(modulePath)
    ***REMOVED***)
  ***REMOVED***)

  test('require returns object', () => {
    assert.isObject(require(modulePath))
  ***REMOVED***)

  suite('require:', () => {
    let bfj

    setup(() => {
      bfj = require(modulePath)
    ***REMOVED***)

    test('walk function is exported', () => {
      assert.isFunction(bfj.walk)
    ***REMOVED***)

    test('walk expects one argument', () => {
      assert.lengthOf(bfj.walk, 1)
    ***REMOVED***)

    test('match function is exported', () => {
      assert.isFunction(bfj.match)
    ***REMOVED***)

    test('match expects two arguments', () => {
      assert.lengthOf(bfj.match, 2)
    ***REMOVED***)

    test('parse function is exported', () => {
      assert.isFunction(bfj.parse)
    ***REMOVED***)

    test('parse expects one argument', () => {
      assert.lengthOf(bfj.parse, 1)
    ***REMOVED***)

    test('read function is exported', () => {
      assert.isFunction(bfj.read)
    ***REMOVED***)

    test('read expects two arguments', () => {
      assert.lengthOf(bfj.read, 2)
    ***REMOVED***)

    test('eventify function is exported', () => {
      assert.isFunction(bfj.eventify)
    ***REMOVED***)

    test('eventify expects one argument', () => {
      assert.lengthOf(bfj.eventify, 1)
    ***REMOVED***)

    test('streamify function is exported', () => {
      assert.isFunction(bfj.streamify)
    ***REMOVED***)

    test('streamify expects one argument', () => {
      assert.lengthOf(bfj.streamify, 1)
    ***REMOVED***)

    test('stringify function is exported', () => {
      assert.isFunction(bfj.stringify)
    ***REMOVED***)

    test('stringify expects two arguments', () => {
      assert.lengthOf(bfj.stringify, 2)
    ***REMOVED***)

    test('write function is exported', () => {
      assert.isFunction(bfj.write)
    ***REMOVED***)

    test('write expects two arguments', () => {
      assert.lengthOf(bfj.write, 3)
    ***REMOVED***)

    test('events are exported', () => {
      assert.deepEqual(bfj.events, require('../src/events'))
    ***REMOVED***)

    suite('read object:', () => {
      let failed, file, result, error

      setup(() => {
        failed = false
        file = path.join(__dirname, 'data.json')
        fs.writeFileSync(file, JSON.stringify({
          foo: [ 'b', 'a', 'r' ],
          baz: null,
          qux: 3.14159265359e42
        ***REMOVED***, null, '\t'))
        return bfj.read(file)
          .then(res => {
            result = res
          ***REMOVED***)
          .catch(err => {
            failed = true
            error = err
          ***REMOVED***)
      ***REMOVED***)

      teardown(() => {
        fs.unlinkSync(file)
      ***REMOVED***)

      test('result was correct', () => {
        assert.isFalse(failed)
        assert.isUndefined(error)
        assert.isObject(result)
        assert.lengthOf(Object.keys(result), 3)
        assert.isArray(result.foo)
        assert.lengthOf(result.foo, 3)
        assert.strictEqual(result.foo[0], 'b')
        assert.strictEqual(result.foo[1], 'a')
        assert.strictEqual(result.foo[2], 'r')
        assert.isNull(result.baz)
        assert.strictEqual(result.qux, 3.14159265359e42)
      ***REMOVED***)
    ***REMOVED***)

    suite('read value:', () => {
      let failed, file, result, error

      setup(() => {
        failed = false
        file = path.join(__dirname, 'data.json')
        fs.writeFileSync(file, '"foo"')
        return bfj.read(file)
          .then(res => {
            result = res
          ***REMOVED***)
          .catch(err => {
            failed = true
            error = err
          ***REMOVED***)
      ***REMOVED***)

      teardown(() => {
        fs.unlinkSync(file)
      ***REMOVED***)

      test('result was correct', () => {
        assert.isFalse(failed)
        assert.isUndefined(error)
        assert.strictEqual(result, 'foo')
      ***REMOVED***)
    ***REMOVED***)

    suite('read error:', () => {
      let failed, file, result, error

      setup(() => {
        failed = false
        file = path.join(__dirname, 'data.json')
        fs.writeFileSync(file, '"foo" "bar"')
        return bfj.read(file)
          .then(res => result = res)
          .catch(err => {
            failed = true
            error = err
          ***REMOVED***)
      ***REMOVED***)

      teardown(() => {
        fs.unlinkSync(file)
      ***REMOVED***)

      test('result was correct', () => {
        assert.isTrue(failed)
        assert.isUndefined(result)
        assert.instanceOf(error, Error)
      ***REMOVED***)
    ***REMOVED***)

    suite('read missing file:', () => {
      let failed, file, result, error

      setup(() => {
        failed = false
        file = path.join(__dirname, 'missing.json')
        assert.isFalse(fs.existsSync(file))
        return bfj.read(file)
          .then(res => result = res)
          .catch(err => {
            failed = true
            error = err
          ***REMOVED***)
      ***REMOVED***)

      test('result was correct', () => {
        assert.isTrue(failed)
        assert.isUndefined(result)
        assert.instanceOf(error, Error)
      ***REMOVED***)
    ***REMOVED***)

    suite('match predicate:', () => {
      let file, results, errors

      setup(done => {
        file = path.join(__dirname, 'data.json')
        fs.writeFileSync(file, JSON.stringify({
          foo: 'bar',
          baz: 'qux',
          wibble: 'blee'
        ***REMOVED***))
        results = []
        errors = []
        const datastream = bfj.match(
          fs.createReadStream(file),
          (k, v) => k === 'baz' || v === 'blee',
          { minDepth: 1 ***REMOVED***
        )
        datastream.on('data', item => results.push(item))
        datastream.on('error', error => errors.push(error))
        datastream.on('end', done)
      ***REMOVED***)

      test('the correct properties were matched', () => {
        assert.deepEqual([ 'qux', 'blee' ], results)
      ***REMOVED***)

      test('no errors occurred', () => {
        assert.deepEqual(errors, [])
      ***REMOVED***)
    ***REMOVED***)

    suite('match nested:', () => {
      let file, results, errors

      setup(done => {
        file = path.join(__dirname, 'data.json')
        fs.writeFileSync(file, JSON.stringify({
          foo: {
            bar: 'baz'
          ***REMOVED***
        ***REMOVED***))
        results = []
        errors = []
        const datastream = bfj.match(fs.createReadStream(file), () => true)
        datastream.on('data', item => results.push(item))
        datastream.on('error', error => errors.push(error))
        datastream.on('end', done)
      ***REMOVED***)

      test('the correct properties were matched', () => {
        assert.deepEqual([ 'baz', { bar: 'baz' ***REMOVED***, { foo: { bar: 'baz' ***REMOVED*** ***REMOVED*** ], results)
      ***REMOVED***)

      test('no errors occurred', () => {
        assert.deepEqual(errors, [])
      ***REMOVED***)
    ***REMOVED***)

    suite('match ndjson:', () => {
      let file, results, errors

      setup(done => {
        file = path.join(__dirname, 'data.ndjson')
        fs.writeFileSync(file, [
          JSON.stringify([ 'a', 'b' ]),
          JSON.stringify(null),
          '',
          '',
          JSON.stringify('wibble')
        ].join('\n'))
        results = []
        errors = []
        const datastream = bfj.match(fs.createReadStream(file), () => true, { ndjson: true ***REMOVED***)
        datastream.on('data', item => results.push(item))
        datastream.on('error', error => errors.push(error))
        datastream.on('end', done)
      ***REMOVED***)

      test('the correct properties were matched', () => {
        assert.deepEqual([ 'a', 'b', [ 'a', 'b' ], 'wibble' ], results)
      ***REMOVED***)

      test('no errors occurred', () => {
        assert.deepEqual(errors, [])
      ***REMOVED***)
    ***REMOVED***)

    suite('parse request:', () => {
      let error, result

      setup((done) => {
        const jsonstream = new stream.PassThrough()
        axios({
          responseType: 'stream',
          url: 'https://gitlab.com/philbooth/bfj/raw/master/package.json',
        ***REMOVED***).then((response) => response.data.pipe(bfj.unpipe((err, res) => {
          error = err
          result = res
          done()
        ***REMOVED***)))
      ***REMOVED***)

      test('result was correct', () => {
        assert.isNull(error)
        assert.deepEqual(result, require('../package.json'))
      ***REMOVED***)
    ***REMOVED***)

    suite('parse NDJSON:', () => {
      let failed, file, results

      setup(() => {
        failed = false
        file = path.join(__dirname, 'data.ndjson')
        results = []
        fs.writeFileSync(file, [
          JSON.stringify([ 'b', 'a', 'r' ]),
          JSON.stringify(null),
          '',
          '',
          JSON.stringify('wibble')
        ].join('\n'))
        const stream = fs.createReadStream(file)
        return bfj.parse(stream, { ndjson: true ***REMOVED***)
          .then(result => {
            results.push(result)
            return bfj.parse(stream, { ndjson: true ***REMOVED***)
          ***REMOVED***)
          .then(result => {
            results.push(result)
            return bfj.parse(stream, { ndjson: true ***REMOVED***)
          ***REMOVED***)
          .then(result => {
            results.push(result)
            return bfj.parse(stream, { ndjson: true ***REMOVED***)
          ***REMOVED***)
          .then(result => {
            results.push(result)
            return bfj.parse(stream, { ndjson: true ***REMOVED***)
          ***REMOVED***)
          .then(result => results.push(result))
          .catch(e => {
            failed = true
          ***REMOVED***)
      ***REMOVED***)

      teardown(() => {
        fs.unlinkSync(file)
      ***REMOVED***)

      test('results were correct', () => {
        assert.isFalse(failed)
        assert.lengthOf(results, 5)
        assert.deepEqual(results, [
          [ 'b', 'a', 'r' ],
          null,
          'wibble',
          undefined,
          undefined
        ])
      ***REMOVED***)
    ***REMOVED***)

    suite('stringify value:', () => {
      let result

      setup(() => {
        return bfj.stringify(new Promise(resolve => {
          setTimeout(resolve.bind(null, 'foo\t"\nbar'), 20)
        ***REMOVED***))
        .then(res => result = res)
      ***REMOVED***)

      test('result was correct', () => {
        assert.strictEqual(result, '"foo\\t\\"\\nbar"')
      ***REMOVED***)
    ***REMOVED***)

    suite('write object:', () => {
      let failed, file, result

      setup(() => {
        failed = false
        file = path.join(__dirname, 'data.json')
        return bfj.write(
          file,
          { foo: [ 'b', 'a', 'r' ], baz: null, qux: 3.14159265359e42 ***REMOVED***
        )
        .then(() => {
          result = fs.readFileSync(file, { encoding: 'utf8' ***REMOVED***)
        ***REMOVED***)
        .catch(error => {
          failed = true
          result = error
        ***REMOVED***)
      ***REMOVED***)

      teardown(() => {
        fs.unlinkSync(file)
      ***REMOVED***)

      test('did not fail', () => {
        assert.isFalse(failed)
      ***REMOVED***)

      test('result was correct', () => {
        assert.strictEqual(result, '{"foo":["b","a","r"],"baz":null,"qux":3.14159265359e+42***REMOVED***')
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***)
***REMOVED***)

