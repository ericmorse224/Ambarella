/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/

import {logger***REMOVED*** from 'workbox-core/_private/logger.js';
import {
  RouteHandlerCallback,
  RouteHandlerCallbackOptions,
***REMOVED*** from 'workbox-core/types.js';
import {createHeaders***REMOVED*** from './utils/createHeaders.js';
import {concatenateToResponse***REMOVED*** from './concatenateToResponse.js';
import {isSupported***REMOVED*** from './isSupported.js';
import {StreamSource***REMOVED*** from './_types.js';
import './_version.js';

export interface StreamsHandlerCallback {
  ({url, request, event, params***REMOVED***: RouteHandlerCallbackOptions):
    | Promise<StreamSource>
    | StreamSource;
***REMOVED***

/**
 * A shortcut to create a strategy that could be dropped-in to Workbox's router.
 *
 * On browsers that do not support constructing new `ReadableStream`s, this
 * strategy will automatically wait for all the `sourceFunctions` to complete,
 * and create a final response that concatenates their values together.
 *
 * @param {Array<function({event, request, url, params***REMOVED***)>***REMOVED*** sourceFunctions
 * An array of functions similar to {@link workbox-routing~handlerCallback***REMOVED***
 * but that instead return a {@link workbox-streams.StreamSource***REMOVED*** (or a
 * Promise which resolves to one).
 * @param {HeadersInit***REMOVED*** [headersInit] If there's no `Content-Type` specified,
 * `'text/html'` will be used by default.
 * @return {workbox-routing~handlerCallback***REMOVED***
 * @memberof workbox-streams
 */
function strategy(
  sourceFunctions: StreamsHandlerCallback[],
  headersInit: HeadersInit,
): RouteHandlerCallback {
  return async ({event, request, url, params***REMOVED***: RouteHandlerCallbackOptions) => {
    const sourcePromises = sourceFunctions.map((fn) => {
      // Ensure the return value of the function is always a promise.
      return Promise.resolve(fn({event, request, url, params***REMOVED***));
    ***REMOVED***);

    if (isSupported()) {
      const {done, response***REMOVED*** = concatenateToResponse(
        sourcePromises,
        headersInit,
      );

      if (event) {
        event.waitUntil(done);
      ***REMOVED***
      return response;
    ***REMOVED***

    if (process.env.NODE_ENV !== 'production') {
      logger.log(
        `The current browser doesn't support creating response ` +
          `streams. Falling back to non-streaming response instead.`,
      );
    ***REMOVED***

    // Fallback to waiting for everything to finish, and concatenating the
    // responses.
    const blobPartsPromises = sourcePromises.map(async (sourcePromise) => {
      const source = await sourcePromise;
      if (source instanceof Response) {
        return source.blob();
      ***REMOVED*** else {
        // Technically, a `StreamSource` object can include any valid
        // `BodyInit` type, including `FormData` and `URLSearchParams`, which
        // cannot be passed to the Blob constructor directly, so we have to
        // convert them to actual Blobs first.
        return new Response(source).blob();
      ***REMOVED***
    ***REMOVED***);
    const blobParts = await Promise.all(blobPartsPromises);
    const headers = createHeaders(headersInit);

    // Constructing a new Response from a Blob source is well-supported.
    // So is constructing a new Blob from multiple source Blobs or strings.
    return new Response(new Blob(blobParts), {headers***REMOVED***);
  ***REMOVED***;
***REMOVED***

export {strategy***REMOVED***;
