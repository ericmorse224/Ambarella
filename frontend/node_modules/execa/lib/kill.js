'use strict';
const os = require('os');
const onExit = require('signal-exit');

const DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;

// Monkey-patches `childProcess.kill()` to add `forceKillAfterTimeout` behavior
const spawnedKill = (kill, signal = 'SIGTERM', options = {***REMOVED***) => {
	const killResult = kill(signal);
	setKillTimeout(kill, signal, options, killResult);
	return killResult;
***REMOVED***;

const setKillTimeout = (kill, signal, options, killResult) => {
	if (!shouldForceKill(signal, options, killResult)) {
		return;
	***REMOVED***

	const timeout = getForceKillAfterTimeout(options);
	const t = setTimeout(() => {
		kill('SIGKILL');
	***REMOVED***, timeout);

	// Guarded because there's no `.unref()` when `execa` is used in the renderer
	// process in Electron. This cannot be tested since we don't run tests in
	// Electron.
	// istanbul ignore else
	if (t.unref) {
		t.unref();
	***REMOVED***
***REMOVED***;

const shouldForceKill = (signal, {forceKillAfterTimeout***REMOVED***, killResult) => {
	return isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
***REMOVED***;

const isSigterm = signal => {
	return signal === os.constants.signals.SIGTERM ||
		(typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM');
***REMOVED***;

const getForceKillAfterTimeout = ({forceKillAfterTimeout = true***REMOVED***) => {
	if (forceKillAfterTimeout === true) {
		return DEFAULT_FORCE_KILL_TIMEOUT;
	***REMOVED***

	if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
		throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout***REMOVED***\` (${typeof forceKillAfterTimeout***REMOVED***)`);
	***REMOVED***

	return forceKillAfterTimeout;
***REMOVED***;

// `childProcess.cancel()`
const spawnedCancel = (spawned, context) => {
	const killResult = spawned.kill();

	if (killResult) {
		context.isCanceled = true;
	***REMOVED***
***REMOVED***;

const timeoutKill = (spawned, signal, reject) => {
	spawned.kill(signal);
	reject(Object.assign(new Error('Timed out'), {timedOut: true, signal***REMOVED***));
***REMOVED***;

// `timeout` option handling
const setupTimeout = (spawned, {timeout, killSignal = 'SIGTERM'***REMOVED***, spawnedPromise) => {
	if (timeout === 0 || timeout === undefined) {
		return spawnedPromise;
	***REMOVED***

	let timeoutId;
	const timeoutPromise = new Promise((resolve, reject) => {
		timeoutId = setTimeout(() => {
			timeoutKill(spawned, killSignal, reject);
		***REMOVED***, timeout);
	***REMOVED***);

	const safeSpawnedPromise = spawnedPromise.finally(() => {
		clearTimeout(timeoutId);
	***REMOVED***);

	return Promise.race([timeoutPromise, safeSpawnedPromise]);
***REMOVED***;

const validateTimeout = ({timeout***REMOVED***) => {
	if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {
		throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout***REMOVED***\` (${typeof timeout***REMOVED***)`);
	***REMOVED***
***REMOVED***;

// `cleanup` option handling
const setExitHandler = async (spawned, {cleanup, detached***REMOVED***, timedPromise) => {
	if (!cleanup || detached) {
		return timedPromise;
	***REMOVED***

	const removeExitHandler = onExit(() => {
		spawned.kill();
	***REMOVED***);

	return timedPromise.finally(() => {
		removeExitHandler();
	***REMOVED***);
***REMOVED***;

module.exports = {
	spawnedKill,
	spawnedCancel,
	setupTimeout,
	validateTimeout,
	setExitHandler
***REMOVED***;
