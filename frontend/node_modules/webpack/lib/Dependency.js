/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const RawModule = require("./RawModule");
const memoize = require("./util/memoize");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("./ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("./DependenciesBlock")***REMOVED*** DependenciesBlock */
/** @typedef {import("./DependencyTemplates")***REMOVED*** DependencyTemplates */
/** @typedef {import("./Module")***REMOVED*** Module */
/** @typedef {import("./ModuleGraph")***REMOVED*** ModuleGraph */
/** @typedef {import("./ModuleGraphConnection")***REMOVED*** ModuleGraphConnection */
/** @typedef {import("./ModuleGraphConnection").ConnectionState***REMOVED*** ConnectionState */
/** @typedef {import("./RuntimeTemplate")***REMOVED*** RuntimeTemplate */
/** @typedef {import("./WebpackError")***REMOVED*** WebpackError */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectDeserializerContext***REMOVED*** ObjectDeserializerContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectSerializerContext***REMOVED*** ObjectSerializerContext */
/** @typedef {import("./util/Hash")***REMOVED*** Hash */
/** @typedef {import("./util/runtime").RuntimeSpec***REMOVED*** RuntimeSpec */

/**
 * @typedef {object***REMOVED*** UpdateHashContext
 * @property {ChunkGraph***REMOVED*** chunkGraph
 * @property {RuntimeSpec***REMOVED*** runtime
 * @property {RuntimeTemplate=***REMOVED*** runtimeTemplate
 */

/**
 * @typedef {object***REMOVED*** SourcePosition
 * @property {number***REMOVED*** line
 * @property {number=***REMOVED*** column
 */

/**
 * @typedef {object***REMOVED*** RealDependencyLocation
 * @property {SourcePosition***REMOVED*** start
 * @property {SourcePosition=***REMOVED*** end
 * @property {number=***REMOVED*** index
 */

/**
 * @typedef {object***REMOVED*** SyntheticDependencyLocation
 * @property {string***REMOVED*** name
 * @property {number=***REMOVED*** index
 */

/** @typedef {SyntheticDependencyLocation | RealDependencyLocation***REMOVED*** DependencyLocation */

/**
 * @typedef {object***REMOVED*** ExportSpec
 * @property {string***REMOVED*** name the name of the export
 * @property {boolean=***REMOVED*** canMangle can the export be renamed (defaults to true)
 * @property {boolean=***REMOVED*** terminalBinding is the export a terminal binding that should be checked for export star conflicts
 * @property {(string | ExportSpec)[]=***REMOVED*** exports nested exports
 * @property {ModuleGraphConnection=***REMOVED*** from when reexported: from which module
 * @property {string[] | null=***REMOVED*** export when reexported: from which export
 * @property {number=***REMOVED*** priority when reexported: with which priority
 * @property {boolean=***REMOVED*** hidden export is not visible, because another export blends over it
 */

/**
 * @typedef {object***REMOVED*** ExportsSpec
 * @property {(string | ExportSpec)[] | true | null***REMOVED*** exports exported names, true for unknown exports or null for no exports
 * @property {Set<string>=***REMOVED*** excludeExports when exports = true, list of unaffected exports
 * @property {(Set<string> | null)=***REMOVED*** hideExports list of maybe prior exposed, but now hidden exports
 * @property {ModuleGraphConnection=***REMOVED*** from when reexported: from which module
 * @property {number=***REMOVED*** priority when reexported: with which priority
 * @property {boolean=***REMOVED*** canMangle can the export be renamed (defaults to true)
 * @property {boolean=***REMOVED*** terminalBinding are the exports terminal bindings that should be checked for export star conflicts
 * @property {Module[]=***REMOVED*** dependencies module on which the result depends on
 */

/**
 * @typedef {object***REMOVED*** ReferencedExport
 * @property {string[]***REMOVED*** name name of the referenced export
 * @property {boolean=***REMOVED*** canMangle when false, referenced export can not be mangled, defaults to true
 */

/** @typedef {(moduleGraphConnection: ModuleGraphConnection, runtime: RuntimeSpec) => ConnectionState***REMOVED*** GetConditionFn */

const TRANSITIVE = Symbol("transitive");

const getIgnoredModule = memoize(
	() => new RawModule("/* (ignored) */", "ignored", "(ignored)")
);

class Dependency {
	constructor() {
		/** @type {Module | undefined***REMOVED*** */
		this._parentModule = undefined;
		/** @type {DependenciesBlock | undefined***REMOVED*** */
		this._parentDependenciesBlock = undefined;
		/** @type {number***REMOVED*** */
		this._parentDependenciesBlockIndex = -1;
		// TODO check if this can be moved into ModuleDependency
		/** @type {boolean***REMOVED*** */
		this.weak = false;
		// TODO check if this can be moved into ModuleDependency
		/** @type {boolean***REMOVED*** */
		this.optional = false;
		this._locSL = 0;
		this._locSC = 0;
		this._locEL = 0;
		this._locEC = 0;
		this._locI = undefined;
		this._locN = undefined;
		this._loc = undefined;
	***REMOVED***

	/**
	 * @returns {string***REMOVED*** a display name for the type of dependency
	 */
	get type() {
		return "unknown";
	***REMOVED***

	/**
	 * @returns {string***REMOVED*** a dependency category, typical categories are "commonjs", "amd", "esm"
	 */
	get category() {
		return "unknown";
	***REMOVED***

	/**
	 * @returns {DependencyLocation***REMOVED*** location
	 */
	get loc() {
		if (this._loc !== undefined) return this._loc;
		/** @type {SyntheticDependencyLocation & RealDependencyLocation***REMOVED*** */
		const loc = {
			start: { line: 0, column: 0 ***REMOVED***,
			end: { line: 0, column: 0 ***REMOVED***,
			name: "",
			index: -1
		***REMOVED***;
		if (this._locSL > 0) {
			loc.start = { line: this._locSL, column: this._locSC ***REMOVED***;
		***REMOVED***
		if (this._locEL > 0) {
			loc.end = { line: this._locEL, column: this._locEC ***REMOVED***;
		***REMOVED***

		loc.name = this._locN;

		loc.index = this._locI;

		return (this._loc = loc);
	***REMOVED***

	set loc(loc) {
		if ("start" in loc && typeof loc.start === "object") {
			this._locSL = loc.start.line || 0;
			this._locSC = loc.start.column || 0;
		***REMOVED*** else {
			this._locSL = 0;
			this._locSC = 0;
		***REMOVED***
		if ("end" in loc && typeof loc.end === "object") {
			this._locEL = loc.end.line || 0;
			this._locEC = loc.end.column || 0;
		***REMOVED*** else {
			this._locEL = 0;
			this._locEC = 0;
		***REMOVED***
		this._locI = "index" in loc ? loc.index : undefined;
		this._locN = "name" in loc ? loc.name : undefined;
		this._loc = loc;
	***REMOVED***

	/**
	 * @param {number***REMOVED*** startLine start line
	 * @param {number***REMOVED*** startColumn start column
	 * @param {number***REMOVED*** endLine end line
	 * @param {number***REMOVED*** endColumn end column
	 */
	setLoc(startLine, startColumn, endLine, endColumn) {
		this._locSL = startLine;
		this._locSC = startColumn;
		this._locEL = endLine;
		this._locEC = endColumn;
		this._locI = undefined;
		this._locN = undefined;
		this._loc = undefined;
	***REMOVED***

	/**
	 * @returns {string | undefined***REMOVED*** a request context
	 */
	getContext() {
		return undefined;
	***REMOVED***

	/**
	 * @returns {string | null***REMOVED*** an identifier to merge equal requests
	 */
	getResourceIdentifier() {
		return null;
	***REMOVED***

	/**
	 * @returns {boolean | TRANSITIVE***REMOVED*** true, when changes to the referenced module could affect the referencing module; TRANSITIVE, when changes to the referenced module could affect referencing modules of the referencing module
	 */
	couldAffectReferencingModule() {
		return TRANSITIVE;
	***REMOVED***

	/**
	 * Returns the referenced module and export
	 * @deprecated
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @returns {never***REMOVED*** throws error
	 */
	getReference(moduleGraph) {
		throw new Error(
			"Dependency.getReference was removed in favor of Dependency.getReferencedExports, ModuleGraph.getModule and ModuleGraph.getConnection().active"
		);
	***REMOVED***

	/**
	 * Returns list of exports referenced by this dependency
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime for which the module is analysed
	 * @returns {(string[] | ReferencedExport)[]***REMOVED*** referenced exports
	 */
	getReferencedExports(moduleGraph, runtime) {
		return Dependency.EXPORTS_OBJECT_REFERENCED;
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @returns {null | false | GetConditionFn***REMOVED*** function to determine if the connection is active
	 */
	getCondition(moduleGraph) {
		return null;
	***REMOVED***

	/**
	 * Returns the exported names
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @returns {ExportsSpec | undefined***REMOVED*** export names
	 */
	getExports(moduleGraph) {
		return undefined;
	***REMOVED***

	/**
	 * Returns warnings
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @returns {WebpackError[] | null | undefined***REMOVED*** warnings
	 */
	getWarnings(moduleGraph) {
		return null;
	***REMOVED***

	/**
	 * Returns errors
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @returns {WebpackError[] | null | undefined***REMOVED*** errors
	 */
	getErrors(moduleGraph) {
		return null;
	***REMOVED***

	/**
	 * Update the hash
	 * @param {Hash***REMOVED*** hash hash to be updated
	 * @param {UpdateHashContext***REMOVED*** context context
	 * @returns {void***REMOVED***
	 */
	updateHash(hash, context) {***REMOVED***

	/**
	 * implement this method to allow the occurrence order plugin to count correctly
	 * @returns {number***REMOVED*** count how often the id is used in this dependency
	 */
	getNumberOfIdOccurrences() {
		return 1;
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @returns {ConnectionState***REMOVED*** how this dependency connects the module to referencing modules
	 */
	getModuleEvaluationSideEffectsState(moduleGraph) {
		return true;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** context context directory
	 * @returns {Module | null***REMOVED*** a module
	 */
	createIgnoredModule(context) {
		return getIgnoredModule();
	***REMOVED***

	/**
	 * @param {ObjectSerializerContext***REMOVED*** context context
	 */
	serialize({ write ***REMOVED***) {
		write(this.weak);
		write(this.optional);
		write(this._locSL);
		write(this._locSC);
		write(this._locEL);
		write(this._locEC);
		write(this._locI);
		write(this._locN);
	***REMOVED***

	/**
	 * @param {ObjectDeserializerContext***REMOVED*** context context
	 */
	deserialize({ read ***REMOVED***) {
		this.weak = read();
		this.optional = read();
		this._locSL = read();
		this._locSC = read();
		this._locEL = read();
		this._locEC = read();
		this._locI = read();
		this._locN = read();
	***REMOVED***
***REMOVED***

/** @type {string[][]***REMOVED*** */
Dependency.NO_EXPORTS_REFERENCED = [];
/** @type {string[][]***REMOVED*** */
Dependency.EXPORTS_OBJECT_REFERENCED = [[]];

// TODO remove in webpack 6
Object.defineProperty(Dependency.prototype, "module", {
	/**
	 * @deprecated
	 * @returns {EXPECTED_ANY***REMOVED*** throws
	 */
	get() {
		throw new Error(
			"module property was removed from Dependency (use compilation.moduleGraph.getModule(dependency) instead)"
		);
	***REMOVED***,

	/**
	 * @deprecated
	 * @returns {never***REMOVED*** throws
	 */
	set() {
		throw new Error(
			"module property was removed from Dependency (use compilation.moduleGraph.updateModule(dependency, module) instead)"
		);
	***REMOVED***
***REMOVED***);

// TODO remove in webpack 6
Object.defineProperty(Dependency.prototype, "disconnect", {
	/**
	 * @deprecated
	 * @returns {EXPECTED_ANY***REMOVED*** throws
	 */
	get() {
		throw new Error(
			"disconnect was removed from Dependency (Dependency no longer carries graph specific information)"
		);
	***REMOVED***
***REMOVED***);

Dependency.TRANSITIVE = TRANSITIVE;

module.exports = Dependency;
