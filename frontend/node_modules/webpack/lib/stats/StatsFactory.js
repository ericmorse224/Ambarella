/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { HookMap, SyncBailHook, SyncWaterfallHook ***REMOVED*** = require("tapable");
const { concatComparators, keepOriginalOrder ***REMOVED*** = require("../util/comparators");
const smartGrouping = require("../util/smartGrouping");

/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../ChunkGroup").OriginRecord***REMOVED*** OriginRecord */
/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("../Compilation").Asset***REMOVED*** Asset */
/** @typedef {import("../Compilation").NormalizedStatsOptions***REMOVED*** NormalizedStatsOptions */
/** @typedef {import("../Dependency")***REMOVED*** Dependency */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../ModuleGraph").ModuleProfile***REMOVED*** ModuleProfile */
/** @typedef {import("../ModuleGraphConnection")***REMOVED*** ModuleGraphConnection */
/** @typedef {import("../WebpackError")***REMOVED*** WebpackError */
/** @typedef {import("../util/comparators").Comparator<EXPECTED_ANY>***REMOVED*** Comparator */
/** @typedef {import("../util/runtime").RuntimeSpec***REMOVED*** RuntimeSpec */
/** @typedef {import("../util/smartGrouping").GroupConfig<EXPECTED_ANY, EXPECTED_OBJECT>***REMOVED*** GroupConfig */
/** @typedef {import("./DefaultStatsFactoryPlugin").ChunkGroupInfoWithName***REMOVED*** ChunkGroupInfoWithName */
/** @typedef {import("./DefaultStatsFactoryPlugin").ModuleIssuerPath***REMOVED*** ModuleIssuerPath */
/** @typedef {import("./DefaultStatsFactoryPlugin").ModuleTrace***REMOVED*** ModuleTrace */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsAsset***REMOVED*** StatsAsset */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsChunk***REMOVED*** StatsChunk */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsChunkGroup***REMOVED*** StatsChunkGroup */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsChunkOrigin***REMOVED*** StatsChunkOrigin */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsCompilation***REMOVED*** StatsCompilation */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsError***REMOVED*** StatsError */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsModule***REMOVED*** StatsModule */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsModuleIssuer***REMOVED*** StatsModuleIssuer */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsModuleReason***REMOVED*** StatsModuleReason */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsModuleTraceDependency***REMOVED*** StatsModuleTraceDependency */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsModuleTraceItem***REMOVED*** StatsModuleTraceItem */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsProfile***REMOVED*** StatsProfile */

/**
 * @typedef {object***REMOVED*** KnownStatsFactoryContext
 * @property {string***REMOVED*** type
 * @property {(path: string) => string***REMOVED*** makePathsRelative
 * @property {Compilation***REMOVED*** compilation
 * @property {Set<Module>***REMOVED*** rootModules
 * @property {Map<string, Chunk[]>***REMOVED*** compilationFileToChunks
 * @property {Map<string, Chunk[]>***REMOVED*** compilationAuxiliaryFileToChunks
 * @property {RuntimeSpec***REMOVED*** runtime
 * @property {(compilation: Compilation) => WebpackError[]***REMOVED*** cachedGetErrors
 * @property {(compilation: Compilation) => WebpackError[]***REMOVED*** cachedGetWarnings
 */

/** @typedef {KnownStatsFactoryContext & Record<string, EXPECTED_ANY>***REMOVED*** StatsFactoryContext */

// StatsLogging StatsLoggingEntry

/**
 * @template T
 * @template F
 * @typedef {T extends Compilation ? StatsCompilation : T extends ChunkGroupInfoWithName ? StatsChunkGroup : T extends Chunk ? StatsChunk : T extends OriginRecord ? StatsChunkOrigin : T extends Module ? StatsModule : T extends ModuleGraphConnection ? StatsModuleReason : T extends Asset ? StatsAsset : T extends ModuleTrace ? StatsModuleTraceItem : T extends Dependency ? StatsModuleTraceDependency : T extends Error ? StatsError : T extends ModuleProfile ? StatsProfile : F***REMOVED*** StatsObject
 */

/**
 * @template T
 * @template F
 * @typedef {T extends ChunkGroupInfoWithName[] ? Record<string, StatsObject<ChunkGroupInfoWithName, F>> : T extends (infer V)[] ? StatsObject<V, F>[] : StatsObject<T, F>***REMOVED*** CreatedObject
 */

/** @typedef {TODO***REMOVED*** FactoryData */
/** @typedef {TODO***REMOVED*** FactoryDataItem */
/** @typedef {TODO***REMOVED*** Result */
/** @typedef {Record<string, TODO>***REMOVED*** ObjectForExtract */

/**
 * @typedef {object***REMOVED*** StatsFactoryHooks
 * @property {HookMap<SyncBailHook<[ObjectForExtract, FactoryData, StatsFactoryContext], void>>***REMOVED*** extract
 * @property {HookMap<SyncBailHook<[FactoryDataItem, StatsFactoryContext, number, number], boolean | void>>***REMOVED*** filter
 * @property {HookMap<SyncBailHook<[Comparator[], StatsFactoryContext], void>>***REMOVED*** sort
 * @property {HookMap<SyncBailHook<[FactoryDataItem, StatsFactoryContext, number, number], boolean | void>>***REMOVED*** filterSorted
 * @property {HookMap<SyncBailHook<[GroupConfig[], StatsFactoryContext], void>>***REMOVED*** groupResults
 * @property {HookMap<SyncBailHook<[Comparator[], StatsFactoryContext], void>>***REMOVED*** sortResults
 * @property {HookMap<SyncBailHook<[FactoryDataItem, StatsFactoryContext, number, number], boolean | void>>***REMOVED*** filterResults
 * @property {HookMap<SyncBailHook<[FactoryDataItem[], StatsFactoryContext], Result | void>>***REMOVED*** merge
 * @property {HookMap<SyncBailHook<[Result, StatsFactoryContext], Result>>***REMOVED*** result
 * @property {HookMap<SyncBailHook<[FactoryDataItem, StatsFactoryContext], string | void>>***REMOVED*** getItemName
 * @property {HookMap<SyncBailHook<[FactoryDataItem, StatsFactoryContext], StatsFactory | void>>***REMOVED*** getItemFactory
 */

/**
 * @template T
 * @typedef {Map<string, T[]>***REMOVED*** Caches
 */

class StatsFactory {
	constructor() {
		/** @type {StatsFactoryHooks***REMOVED*** */
		this.hooks = Object.freeze({
			extract: new HookMap(
				() => new SyncBailHook(["object", "data", "context"])
			),
			filter: new HookMap(
				() => new SyncBailHook(["item", "context", "index", "unfilteredIndex"])
			),
			sort: new HookMap(() => new SyncBailHook(["comparators", "context"])),
			filterSorted: new HookMap(
				() => new SyncBailHook(["item", "context", "index", "unfilteredIndex"])
			),
			groupResults: new HookMap(
				() => new SyncBailHook(["groupConfigs", "context"])
			),
			sortResults: new HookMap(
				() => new SyncBailHook(["comparators", "context"])
			),
			filterResults: new HookMap(
				() => new SyncBailHook(["item", "context", "index", "unfilteredIndex"])
			),
			merge: new HookMap(() => new SyncBailHook(["items", "context"])),
			result: new HookMap(() => new SyncWaterfallHook(["result", "context"])),
			getItemName: new HookMap(() => new SyncBailHook(["item", "context"])),
			getItemFactory: new HookMap(() => new SyncBailHook(["item", "context"]))
		***REMOVED***);
		const hooks = this.hooks;
		this._caches = /** @type {TODO***REMOVED*** */ ({***REMOVED***);
		for (const key of Object.keys(hooks)) {
			this._caches[/** @type {keyof StatsFactoryHooks***REMOVED*** */ (key)] = new Map();
		***REMOVED***
		this._inCreate = false;
	***REMOVED***

	/**
	 * @template {StatsFactoryHooks[keyof StatsFactoryHooks]***REMOVED*** HM
	 * @template {HM extends HookMap<infer H> ? H : never***REMOVED*** H
	 * @param {HM***REMOVED*** hookMap hook map
	 * @param {Caches<H>***REMOVED*** cache cache
	 * @param {string***REMOVED*** type type
	 * @returns {H[]***REMOVED*** hooks
	 * @private
	 */
	_getAllLevelHooks(hookMap, cache, type) {
		const cacheEntry = cache.get(type);
		if (cacheEntry !== undefined) {
			return cacheEntry;
		***REMOVED***
		const hooks = /** @type {H[]***REMOVED*** */ ([]);
		const typeParts = type.split(".");
		for (let i = 0; i < typeParts.length; i++) {
			const hook = /** @type {H***REMOVED*** */ (hookMap.get(typeParts.slice(i).join(".")));
			if (hook) {
				hooks.push(hook);
			***REMOVED***
		***REMOVED***
		cache.set(type, hooks);
		return hooks;
	***REMOVED***

	/**
	 * @template {StatsFactoryHooks[keyof StatsFactoryHooks]***REMOVED*** HM
	 * @template {HM extends HookMap<infer H> ? H : never***REMOVED*** H
	 * @template {H extends import("tapable").Hook<any, infer R> ? R : never***REMOVED*** R
	 * @param {HM***REMOVED*** hookMap hook map
	 * @param {Caches<H>***REMOVED*** cache cache
	 * @param {string***REMOVED*** type type
	 * @param {(hook: H) => R | void***REMOVED*** fn fn
	 * @returns {R | void***REMOVED*** hook
	 * @private
	 */
	_forEachLevel(hookMap, cache, type, fn) {
		for (const hook of this._getAllLevelHooks(hookMap, cache, type)) {
			const result = fn(/** @type {H***REMOVED*** */ (hook));
			if (result !== undefined) return result;
		***REMOVED***
	***REMOVED***

	/**
	 * @template {StatsFactoryHooks[keyof StatsFactoryHooks]***REMOVED*** HM
	 * @template {HM extends HookMap<infer H> ? H : never***REMOVED*** H
	 * @param {HM***REMOVED*** hookMap hook map
	 * @param {Caches<H>***REMOVED*** cache cache
	 * @param {string***REMOVED*** type type
	 * @param {FactoryData***REMOVED*** data data
	 * @param {(hook: H, factoryData: FactoryData) => FactoryData***REMOVED*** fn fn
	 * @returns {FactoryData***REMOVED*** data
	 * @private
	 */
	_forEachLevelWaterfall(hookMap, cache, type, data, fn) {
		for (const hook of this._getAllLevelHooks(hookMap, cache, type)) {
			data = fn(/** @type {H***REMOVED*** */ (hook), data);
		***REMOVED***
		return data;
	***REMOVED***

	/**
	 * @template {StatsFactoryHooks[keyof StatsFactoryHooks]***REMOVED*** T
	 * @template {T extends HookMap<infer H> ? H : never***REMOVED*** H
	 * @template {H extends import("tapable").Hook<any, infer R> ? R : never***REMOVED*** R
	 * @param {T***REMOVED*** hookMap hook map
	 * @param {Caches<H>***REMOVED*** cache cache
	 * @param {string***REMOVED*** type type
	 * @param {Array<FactoryData>***REMOVED*** items items
	 * @param {(hook: H, item: R, idx: number, i: number) => R | undefined***REMOVED*** fn fn
	 * @param {boolean***REMOVED*** forceClone force clone
	 * @returns {R[]***REMOVED*** result for each level
	 * @private
	 */
	_forEachLevelFilter(hookMap, cache, type, items, fn, forceClone) {
		const hooks = this._getAllLevelHooks(hookMap, cache, type);
		if (hooks.length === 0) return forceClone ? items.slice() : items;
		let i = 0;
		return items.filter((item, idx) => {
			for (const hook of hooks) {
				const r = fn(/** @type {H***REMOVED*** */ (hook), item, idx, i);
				if (r !== undefined) {
					if (r) i++;
					return r;
				***REMOVED***
			***REMOVED***
			i++;
			return true;
		***REMOVED***);
	***REMOVED***

	/**
	 * @template FactoryData
	 * @template FallbackCreatedObject
	 * @param {string***REMOVED*** type type
	 * @param {FactoryData***REMOVED*** data factory data
	 * @param {Omit<StatsFactoryContext, "type">***REMOVED*** baseContext context used as base
	 * @returns {CreatedObject<FactoryData, FallbackCreatedObject>***REMOVED*** created object
	 */
	create(type, data, baseContext) {
		if (this._inCreate) {
			return this._create(type, data, baseContext);
		***REMOVED***
		try {
			this._inCreate = true;
			return this._create(type, data, baseContext);
		***REMOVED*** finally {
			for (const key of Object.keys(this._caches))
				this._caches[/** @type {keyof StatsFactoryHooks***REMOVED*** */ (key)].clear();
			this._inCreate = false;
		***REMOVED***
	***REMOVED***

	/**
	 * @private
	 * @template FactoryData
	 * @template FallbackCreatedObject
	 * @param {string***REMOVED*** type type
	 * @param {FactoryData***REMOVED*** data factory data
	 * @param {Omit<StatsFactoryContext, "type">***REMOVED*** baseContext context used as base
	 * @returns {CreatedObject<FactoryData, FallbackCreatedObject>***REMOVED*** created object
	 */
	_create(type, data, baseContext) {
		const context = /** @type {StatsFactoryContext***REMOVED*** */ ({
			...baseContext,
			type,
			[type]: data
		***REMOVED***);
		if (Array.isArray(data)) {
			// run filter on unsorted items
			const items = this._forEachLevelFilter(
				this.hooks.filter,
				this._caches.filter,
				type,
				data,
				(h, r, idx, i) => h.call(r, context, idx, i),
				true
			);

			// sort items
			/** @type {Comparator[]***REMOVED*** */
			const comparators = [];
			this._forEachLevel(this.hooks.sort, this._caches.sort, type, h =>
				h.call(comparators, context)
			);
			if (comparators.length > 0) {
				items.sort(
					// @ts-expect-error number of arguments is correct
					concatComparators(...comparators, keepOriginalOrder(items))
				);
			***REMOVED***

			// run filter on sorted items
			const items2 = this._forEachLevelFilter(
				this.hooks.filterSorted,
				this._caches.filterSorted,
				type,
				items,
				(h, r, idx, i) => h.call(r, context, idx, i),
				false
			);

			// for each item
			let resultItems = items2.map((item, i) => {
				/** @type {StatsFactoryContext***REMOVED*** */
				const itemContext = {
					...context,
					_index: i
				***REMOVED***;

				// run getItemName
				const itemName = this._forEachLevel(
					this.hooks.getItemName,
					this._caches.getItemName,
					`${type***REMOVED***[]`,
					h => h.call(item, itemContext)
				);
				if (itemName) itemContext[itemName] = item;
				const innerType = itemName ? `${type***REMOVED***[].${itemName***REMOVED***` : `${type***REMOVED***[]`;

				// run getItemFactory
				const itemFactory =
					this._forEachLevel(
						this.hooks.getItemFactory,
						this._caches.getItemFactory,
						innerType,
						h => h.call(item, itemContext)
					) || this;

				// run item factory
				return itemFactory.create(innerType, item, itemContext);
			***REMOVED***);

			// sort result items
			/** @type {Comparator[]***REMOVED*** */
			const comparators2 = [];
			this._forEachLevel(
				this.hooks.sortResults,
				this._caches.sortResults,
				type,
				h => h.call(comparators2, context)
			);
			if (comparators2.length > 0) {
				resultItems.sort(
					// @ts-expect-error number of arguments is correct
					concatComparators(...comparators2, keepOriginalOrder(resultItems))
				);
			***REMOVED***

			// group result items
			/** @type {GroupConfig[]***REMOVED*** */
			const groupConfigs = [];
			this._forEachLevel(
				this.hooks.groupResults,
				this._caches.groupResults,
				type,
				h => h.call(groupConfigs, context)
			);
			if (groupConfigs.length > 0) {
				resultItems = smartGrouping(resultItems, groupConfigs);
			***REMOVED***

			// run filter on sorted result items
			const finalResultItems = this._forEachLevelFilter(
				this.hooks.filterResults,
				this._caches.filterResults,
				type,
				resultItems,
				(h, r, idx, i) => h.call(r, context, idx, i),
				false
			);

			// run merge on mapped items
			let result = this._forEachLevel(
				this.hooks.merge,
				this._caches.merge,
				type,
				h => h.call(finalResultItems, context)
			);
			if (result === undefined) result = finalResultItems;

			// run result on merged items
			return this._forEachLevelWaterfall(
				this.hooks.result,
				this._caches.result,
				type,
				result,
				(h, r) => h.call(r, context)
			);
		***REMOVED***
		/** @type {ObjectForExtract***REMOVED*** */
		const object = {***REMOVED***;

		// run extract on value
		this._forEachLevel(this.hooks.extract, this._caches.extract, type, h =>
			h.call(object, data, context)
		);

		// run result on extracted object
		return this._forEachLevelWaterfall(
			this.hooks.result,
			this._caches.result,
			type,
			object,
			(h, r) => h.call(r, context)
		);
	***REMOVED***
***REMOVED***
module.exports = StatsFactory;
