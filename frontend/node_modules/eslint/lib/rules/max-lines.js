/**
 * @fileoverview enforce a maximum file length
 * @author Alberto RodrÃ­guez
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Creates an array of numbers from `start` up to, but not including, `end`
 * @param {number***REMOVED*** start The start of the range
 * @param {number***REMOVED*** end The end of the range
 * @returns {number[]***REMOVED*** The range of numbers
 */
function range(start, end) {
    return [...Array(end - start).keys()].map(x => x + start);
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "enforce a maximum number of lines per file",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/max-lines"
        ***REMOVED***,

        schema: [
            {
                oneOf: [
                    {
                        type: "integer",
                        minimum: 0
                    ***REMOVED***,
                    {
                        type: "object",
                        properties: {
                            max: {
                                type: "integer",
                                minimum: 0
                            ***REMOVED***,
                            skipComments: {
                                type: "boolean"
                            ***REMOVED***,
                            skipBlankLines: {
                                type: "boolean"
                            ***REMOVED***
                        ***REMOVED***,
                        additionalProperties: false
                    ***REMOVED***
                ]
            ***REMOVED***
        ],
        messages: {
            exceed:
                "File has too many lines ({{actual***REMOVED******REMOVED***). Maximum allowed is {{max***REMOVED******REMOVED***."
        ***REMOVED***
    ***REMOVED***,

    create(context) {
        const option = context.options[0];
        let max = 300;

        if (
            typeof option === "object" &&
            Object.prototype.hasOwnProperty.call(option, "max")
        ) {
            max = option.max;
        ***REMOVED*** else if (typeof option === "number") {
            max = option;
        ***REMOVED***

        const skipComments = option && option.skipComments;
        const skipBlankLines = option && option.skipBlankLines;

        const sourceCode = context.getSourceCode();

        /**
         * Returns whether or not a token is a comment node type
         * @param {Token***REMOVED*** token The token to check
         * @returns {boolean***REMOVED*** True if the token is a comment node
         */
        function isCommentNodeType(token) {
            return token && (token.type === "Block" || token.type === "Line");
        ***REMOVED***

        /**
         * Returns the line numbers of a comment that don't have any code on the same line
         * @param {Node***REMOVED*** comment The comment node to check
         * @returns {number[]***REMOVED*** The line numbers
         */
        function getLinesWithoutCode(comment) {
            let start = comment.loc.start.line;
            let end = comment.loc.end.line;

            let token;

            token = comment;
            do {
                token = sourceCode.getTokenBefore(token, {
                    includeComments: true
                ***REMOVED***);
            ***REMOVED*** while (isCommentNodeType(token));

            if (token && astUtils.isTokenOnSameLine(token, comment)) {
                start += 1;
            ***REMOVED***

            token = comment;
            do {
                token = sourceCode.getTokenAfter(token, {
                    includeComments: true
                ***REMOVED***);
            ***REMOVED*** while (isCommentNodeType(token));

            if (token && astUtils.isTokenOnSameLine(comment, token)) {
                end -= 1;
            ***REMOVED***

            if (start <= end) {
                return range(start, end + 1);
            ***REMOVED***
            return [];
        ***REMOVED***

        /**
         * Returns a new array formed by applying a given callback function to each element of the array, and then flattening the result by one level.
         * TODO(stephenwade): Replace this with array.flatMap when we drop support for Node v10
         * @param {any[]***REMOVED*** array The array to process
         * @param {Function***REMOVED*** fn The function to use
         * @returns {any[]***REMOVED*** The result array
         */
        function flatMap(array, fn) {
            const mapped = array.map(fn);
            const flattened = [].concat(...mapped);

            return flattened;
        ***REMOVED***

        return {
            "Program:exit"() {
                let lines = sourceCode.lines.map((text, i) => ({
                    lineNumber: i + 1,
                    text
                ***REMOVED***));

                /*
                 * If file ends with a linebreak, `sourceCode.lines` will have one extra empty line at the end.
                 * That isn't a real line, so we shouldn't count it.
                 */
                if (lines.length > 1 && lines[lines.length - 1].text === "") {
                    lines.pop();
                ***REMOVED***

                if (skipBlankLines) {
                    lines = lines.filter(l => l.text.trim() !== "");
                ***REMOVED***

                if (skipComments) {
                    const comments = sourceCode.getAllComments();

                    const commentLines = flatMap(comments, comment => getLinesWithoutCode(comment));

                    lines = lines.filter(
                        l => !commentLines.includes(l.lineNumber)
                    );
                ***REMOVED***

                if (lines.length > max) {
                    const loc = {
                        start: {
                            line: lines[max].lineNumber,
                            column: 0
                        ***REMOVED***,
                        end: {
                            line: sourceCode.lines.length,
                            column: sourceCode.lines[sourceCode.lines.length - 1].length
                        ***REMOVED***
                    ***REMOVED***;

                    context.report({
                        loc,
                        messageId: "exceed",
                        data: {
                            max,
                            actual: lines.length
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
