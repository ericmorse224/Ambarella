/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const util = require("util");
const ExternalModule = require("./ExternalModule");
const ContextElementDependency = require("./dependencies/ContextElementDependency");
const CssImportDependency = require("./dependencies/CssImportDependency");
const CssUrlDependency = require("./dependencies/CssUrlDependency");
const HarmonyImportDependency = require("./dependencies/HarmonyImportDependency");
const ImportDependency = require("./dependencies/ImportDependency");
const { resolveByProperty, cachedSetProperty ***REMOVED*** = require("./util/cleverMerge");

/** @typedef {import("../declarations/WebpackOptions").ExternalItemFunctionData***REMOVED*** ExternalItemFunctionData */
/** @typedef {import("../declarations/WebpackOptions").ExternalItemObjectKnown***REMOVED*** ExternalItemObjectKnown */
/** @typedef {import("../declarations/WebpackOptions").ExternalItemObjectUnknown***REMOVED*** ExternalItemObjectUnknown */
/** @typedef {import("../declarations/WebpackOptions").Externals***REMOVED*** Externals */
/** @typedef {import("./Compilation").DepConstructor***REMOVED*** DepConstructor */
/** @typedef {import("./ExternalModule").DependencyMeta***REMOVED*** DependencyMeta */
/** @typedef {import("./Module")***REMOVED*** Module */
/** @typedef {import("./ModuleFactory").IssuerLayer***REMOVED*** IssuerLayer */
/** @typedef {import("./NormalModuleFactory")***REMOVED*** NormalModuleFactory */

const UNSPECIFIED_EXTERNAL_TYPE_REGEXP = /^[a-z0-9-]+ /;
const EMPTY_RESOLVE_OPTIONS = {***REMOVED***;

// TODO webpack 6 remove this
const callDeprecatedExternals = util.deprecate(
	/**
	 * @param {EXPECTED_FUNCTION***REMOVED*** externalsFunction externals function
	 * @param {string***REMOVED*** context context
	 * @param {string***REMOVED*** request request
	 * @param {(err: Error | null | undefined, value: ExternalValue | undefined, ty: ExternalType | undefined) => void***REMOVED*** cb cb
	 */
	(externalsFunction, context, request, cb) => {
		// eslint-disable-next-line no-useless-call
		externalsFunction.call(null, context, request, cb);
	***REMOVED***,
	"The externals-function should be defined like ({context, request***REMOVED***, cb) => { ... ***REMOVED***",
	"DEP_WEBPACK_EXTERNALS_FUNCTION_PARAMETERS"
);

/** @typedef {ExternalItemObjectKnown & ExternalItemObjectUnknown***REMOVED*** ExternalItemObject */

/**
 * @template {ExternalItemObject***REMOVED*** T
 * @typedef {WeakMap<T, Map<IssuerLayer, Omit<T, "byLayer">>>***REMOVED*** ExternalWeakCache
 */

/** @type {ExternalWeakCache<ExternalItemObject>***REMOVED*** */
const cache = new WeakMap();

/**
 * @param {ExternalItemObject***REMOVED*** obj obj
 * @param {IssuerLayer***REMOVED*** layer layer
 * @returns {Omit<ExternalItemObject, "byLayer">***REMOVED*** result
 */
const resolveLayer = (obj, layer) => {
	let map = cache.get(obj);
	if (map === undefined) {
		map = new Map();
		cache.set(obj, map);
	***REMOVED*** else {
		const cacheEntry = map.get(layer);
		if (cacheEntry !== undefined) return cacheEntry;
	***REMOVED***
	const result = resolveByProperty(obj, "byLayer", layer);
	map.set(layer, result);
	return result;
***REMOVED***;

/** @typedef {string | string[] | boolean | Record<string, string | string[]>***REMOVED*** ExternalValue */
/** @typedef {string | undefined***REMOVED*** ExternalType */

class ExternalModuleFactoryPlugin {
	/**
	 * @param {string | undefined***REMOVED*** type default external type
	 * @param {Externals***REMOVED*** externals externals config
	 */
	constructor(type, externals) {
		this.type = type;
		this.externals = externals;
	***REMOVED***

	/**
	 * @param {NormalModuleFactory***REMOVED*** normalModuleFactory the normal module factory
	 * @returns {void***REMOVED***
	 */
	apply(normalModuleFactory) {
		const globalType = this.type;
		normalModuleFactory.hooks.factorize.tapAsync(
			"ExternalModuleFactoryPlugin",
			(data, callback) => {
				const context = data.context;
				const contextInfo = data.contextInfo;
				const dependency = data.dependencies[0];
				const dependencyType = data.dependencyType;

				/** @typedef {(err?: Error | null, externalModule?: ExternalModule) => void***REMOVED*** HandleExternalCallback */

				/**
				 * @param {ExternalValue***REMOVED*** value the external config
				 * @param {ExternalType | undefined***REMOVED*** type type of external
				 * @param {HandleExternalCallback***REMOVED*** callback callback
				 * @returns {void***REMOVED***
				 */
				const handleExternal = (value, type, callback) => {
					if (value === false) {
						// Not externals, fallback to original factory
						return callback();
					***REMOVED***
					/** @type {string | string[] | Record<string, string|string[]>***REMOVED*** */
					let externalConfig = value === true ? dependency.request : value;
					// When no explicit type is specified, extract it from the externalConfig
					if (type === undefined) {
						if (
							typeof externalConfig === "string" &&
							UNSPECIFIED_EXTERNAL_TYPE_REGEXP.test(externalConfig)
						) {
							const idx = externalConfig.indexOf(" ");
							type = externalConfig.slice(0, idx);
							externalConfig = externalConfig.slice(idx + 1);
						***REMOVED*** else if (
							Array.isArray(externalConfig) &&
							externalConfig.length > 0 &&
							UNSPECIFIED_EXTERNAL_TYPE_REGEXP.test(externalConfig[0])
						) {
							const firstItem = externalConfig[0];
							const idx = firstItem.indexOf(" ");
							type = firstItem.slice(0, idx);
							externalConfig = [
								firstItem.slice(idx + 1),
								...externalConfig.slice(1)
							];
						***REMOVED***
					***REMOVED***

					const resolvedType = /** @type {string***REMOVED*** */ (type || globalType);

					// TODO make it pluggable/add hooks to `ExternalModule` to allow output modules own externals?
					/** @type {DependencyMeta | undefined***REMOVED*** */
					let dependencyMeta;

					if (
						dependency instanceof HarmonyImportDependency ||
						dependency instanceof ImportDependency ||
						dependency instanceof ContextElementDependency
					) {
						const externalType =
							dependency instanceof HarmonyImportDependency
								? "module"
								: dependency instanceof ImportDependency
									? "import"
									: undefined;

						dependencyMeta = {
							attributes: dependency.assertions,
							externalType
						***REMOVED***;
					***REMOVED*** else if (dependency instanceof CssImportDependency) {
						dependencyMeta = {
							layer: dependency.layer,
							supports: dependency.supports,
							media: dependency.media
						***REMOVED***;
					***REMOVED***

					if (
						resolvedType === "asset" &&
						dependency instanceof CssUrlDependency
					) {
						dependencyMeta = { sourceType: "css-url" ***REMOVED***;
					***REMOVED***

					callback(
						null,
						new ExternalModule(
							externalConfig,
							resolvedType,
							dependency.request,
							dependencyMeta
						)
					);
				***REMOVED***;

				/**
				 * @param {Externals***REMOVED*** externals externals config
				 * @param {HandleExternalCallback***REMOVED*** callback callback
				 * @returns {void***REMOVED***
				 */
				const handleExternals = (externals, callback) => {
					if (typeof externals === "string") {
						if (externals === dependency.request) {
							return handleExternal(dependency.request, undefined, callback);
						***REMOVED***
					***REMOVED*** else if (Array.isArray(externals)) {
						let i = 0;
						const next = () => {
							/** @type {boolean | undefined***REMOVED*** */
							let asyncFlag;
							/**
							 * @param {(Error | null)=***REMOVED*** err err
							 * @param {ExternalModule=***REMOVED*** module module
							 * @returns {void***REMOVED***
							 */
							const handleExternalsAndCallback = (err, module) => {
								if (err) return callback(err);
								if (!module) {
									if (asyncFlag) {
										asyncFlag = false;
										return;
									***REMOVED***
									return next();
								***REMOVED***
								callback(null, module);
							***REMOVED***;

							do {
								asyncFlag = true;
								if (i >= externals.length) return callback();
								handleExternals(externals[i++], handleExternalsAndCallback);
							***REMOVED*** while (!asyncFlag);
							asyncFlag = false;
						***REMOVED***;

						next();
						return;
					***REMOVED*** else if (externals instanceof RegExp) {
						if (externals.test(dependency.request)) {
							return handleExternal(dependency.request, undefined, callback);
						***REMOVED***
					***REMOVED*** else if (typeof externals === "function") {
						/**
						 * @param {Error | null | undefined***REMOVED*** err err
						 * @param {ExternalValue=***REMOVED*** value value
						 * @param {ExternalType=***REMOVED*** type type
						 * @returns {void***REMOVED***
						 */
						const cb = (err, value, type) => {
							if (err) return callback(err);
							if (value !== undefined) {
								handleExternal(value, type, callback);
							***REMOVED*** else {
								callback();
							***REMOVED***
						***REMOVED***;
						if (externals.length === 3) {
							// TODO webpack 6 remove this
							callDeprecatedExternals(
								externals,
								context,
								dependency.request,
								cb
							);
						***REMOVED*** else {
							const promise = externals(
								{
									context,
									request: dependency.request,
									dependencyType,
									contextInfo,
									getResolve: options => (context, request, callback) => {
										const resolveContext = {
											fileDependencies: data.fileDependencies,
											missingDependencies: data.missingDependencies,
											contextDependencies: data.contextDependencies
										***REMOVED***;
										let resolver = normalModuleFactory.getResolver(
											"normal",
											dependencyType
												? cachedSetProperty(
														data.resolveOptions || EMPTY_RESOLVE_OPTIONS,
														"dependencyType",
														dependencyType
													)
												: data.resolveOptions
										);
										if (options) resolver = resolver.withOptions(options);
										if (callback) {
											resolver.resolve(
												{***REMOVED***,
												context,
												request,
												resolveContext,
												callback
											);
										***REMOVED*** else {
											return new Promise((resolve, reject) => {
												resolver.resolve(
													{***REMOVED***,
													context,
													request,
													resolveContext,
													(err, result) => {
														if (err) reject(err);
														else resolve(result);
													***REMOVED***
												);
											***REMOVED***);
										***REMOVED***
									***REMOVED***
								***REMOVED***,
								cb
							);
							if (promise && promise.then) promise.then(r => cb(null, r), cb);
						***REMOVED***
						return;
					***REMOVED*** else if (typeof externals === "object") {
						const resolvedExternals = resolveLayer(
							externals,
							/** @type {IssuerLayer***REMOVED*** */
							(contextInfo.issuerLayer)
						);
						if (
							Object.prototype.hasOwnProperty.call(
								resolvedExternals,
								dependency.request
							)
						) {
							return handleExternal(
								resolvedExternals[dependency.request],
								undefined,
								callback
							);
						***REMOVED***
					***REMOVED***
					callback();
				***REMOVED***;

				handleExternals(this.externals, callback);
			***REMOVED***
		);
	***REMOVED***
***REMOVED***
module.exports = ExternalModuleFactoryPlugin;
