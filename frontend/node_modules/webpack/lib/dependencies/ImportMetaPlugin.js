/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Ivan Kopeykin @vankop
*/

"use strict";

const { pathToFileURL ***REMOVED*** = require("url");
const ModuleDependencyWarning = require("../ModuleDependencyWarning");
const {
	JAVASCRIPT_MODULE_TYPE_AUTO,
	JAVASCRIPT_MODULE_TYPE_ESM
***REMOVED*** = require("../ModuleTypeConstants");
const Template = require("../Template");
const BasicEvaluatedExpression = require("../javascript/BasicEvaluatedExpression");
const {
	evaluateToIdentifier,
	toConstantDependency,
	evaluateToString,
	evaluateToNumber
***REMOVED*** = require("../javascript/JavascriptParserHelpers");
const memoize = require("../util/memoize");
const propertyAccess = require("../util/propertyAccess");
const ConstDependency = require("./ConstDependency");

/** @typedef {import("estree").MemberExpression***REMOVED*** MemberExpression */
/** @typedef {import("../../declarations/WebpackOptions").JavascriptParserOptions***REMOVED*** JavascriptParserOptions */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../Dependency").DependencyLocation***REMOVED*** DependencyLocation */
/** @typedef {import("../NormalModule")***REMOVED*** NormalModule */
/** @typedef {import("../javascript/JavascriptParser")***REMOVED*** Parser */
/** @typedef {import("../javascript/JavascriptParser").Range***REMOVED*** Range */

const getCriticalDependencyWarning = memoize(() =>
	require("./CriticalDependencyWarning")
);

const PLUGIN_NAME = "ImportMetaPlugin";

class ImportMetaPlugin {
	/**
	 * @param {Compiler***REMOVED*** compiler compiler
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			PLUGIN_NAME,
			(compilation, { normalModuleFactory ***REMOVED***) => {
				/**
				 * @param {NormalModule***REMOVED*** module module
				 * @returns {string***REMOVED*** file url
				 */
				const getUrl = module => pathToFileURL(module.resource).toString();
				/**
				 * @param {Parser***REMOVED*** parser parser parser
				 * @param {JavascriptParserOptions***REMOVED*** parserOptions parserOptions
				 * @returns {void***REMOVED***
				 */
				const parserHandler = (parser, { importMeta ***REMOVED***) => {
					if (importMeta === false) {
						const { importMetaName ***REMOVED*** = compilation.outputOptions;
						if (importMetaName === "import.meta") return;

						parser.hooks.expression
							.for("import.meta")
							.tap(PLUGIN_NAME, metaProperty => {
								const dep = new ConstDependency(
									/** @type {string***REMOVED*** */ (importMetaName),
									/** @type {Range***REMOVED*** */ (metaProperty.range)
								);
								dep.loc = /** @type {DependencyLocation***REMOVED*** */ (metaProperty.loc);
								parser.state.module.addPresentationalDependency(dep);
								return true;
							***REMOVED***);
						return;
					***REMOVED***

					// import.meta direct
					const webpackVersion = Number.parseInt(
						require("../../package.json").version,
						10
					);
					const importMetaUrl = () =>
						JSON.stringify(getUrl(parser.state.module));
					const importMetaWebpackVersion = () => JSON.stringify(webpackVersion);
					/**
					 * @param {string[]***REMOVED*** members members
					 * @returns {string***REMOVED*** error message
					 */
					const importMetaUnknownProperty = members =>
						`${Template.toNormalComment(
							`unsupported import.meta.${members.join(".")***REMOVED***`
						)***REMOVED*** undefined${propertyAccess(members, 1)***REMOVED***`;
					parser.hooks.typeof
						.for("import.meta")
						.tap(
							PLUGIN_NAME,
							toConstantDependency(parser, JSON.stringify("object"))
						);
					parser.hooks.expression
						.for("import.meta")
						.tap(PLUGIN_NAME, metaProperty => {
							const referencedPropertiesInDestructuring =
								parser.destructuringAssignmentPropertiesFor(metaProperty);
							if (!referencedPropertiesInDestructuring) {
								const CriticalDependencyWarning =
									getCriticalDependencyWarning();
								parser.state.module.addWarning(
									new ModuleDependencyWarning(
										parser.state.module,
										new CriticalDependencyWarning(
											"Accessing import.meta directly is unsupported (only property access or destructuring is supported)"
										),
										/** @type {DependencyLocation***REMOVED*** */ (metaProperty.loc)
									)
								);
								const dep = new ConstDependency(
									`${
										parser.isAsiPosition(
											/** @type {Range***REMOVED*** */ (metaProperty.range)[0]
										)
											? ";"
											: ""
									***REMOVED***({***REMOVED***)`,
									/** @type {Range***REMOVED*** */ (metaProperty.range)
								);
								dep.loc = /** @type {DependencyLocation***REMOVED*** */ (metaProperty.loc);
								parser.state.module.addPresentationalDependency(dep);
								return true;
							***REMOVED***

							let str = "";
							for (const { id: prop ***REMOVED*** of referencedPropertiesInDestructuring) {
								switch (prop) {
									case "url":
										str += `url: ${importMetaUrl()***REMOVED***,`;
										break;
									case "webpack":
										str += `webpack: ${importMetaWebpackVersion()***REMOVED***,`;
										break;
									default:
										str += `[${JSON.stringify(
											prop
										)***REMOVED***]: ${importMetaUnknownProperty([prop])***REMOVED***,`;
										break;
								***REMOVED***
							***REMOVED***
							const dep = new ConstDependency(
								`({${str***REMOVED******REMOVED***)`,
								/** @type {Range***REMOVED*** */ (metaProperty.range)
							);
							dep.loc = /** @type {DependencyLocation***REMOVED*** */ (metaProperty.loc);
							parser.state.module.addPresentationalDependency(dep);
							return true;
						***REMOVED***);
					parser.hooks.evaluateTypeof
						.for("import.meta")
						.tap(PLUGIN_NAME, evaluateToString("object"));
					parser.hooks.evaluateIdentifier.for("import.meta").tap(
						PLUGIN_NAME,
						evaluateToIdentifier("import.meta", "import.meta", () => [], true)
					);

					// import.meta.url
					parser.hooks.typeof
						.for("import.meta.url")
						.tap(
							PLUGIN_NAME,
							toConstantDependency(parser, JSON.stringify("string"))
						);
					parser.hooks.expression
						.for("import.meta.url")
						.tap(PLUGIN_NAME, expr => {
							const dep = new ConstDependency(
								importMetaUrl(),
								/** @type {Range***REMOVED*** */ (expr.range)
							);
							dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expr.loc);
							parser.state.module.addPresentationalDependency(dep);
							return true;
						***REMOVED***);
					parser.hooks.evaluateTypeof
						.for("import.meta.url")
						.tap(PLUGIN_NAME, evaluateToString("string"));
					parser.hooks.evaluateIdentifier
						.for("import.meta.url")
						.tap(PLUGIN_NAME, expr =>
							new BasicEvaluatedExpression()
								.setString(getUrl(parser.state.module))
								.setRange(/** @type {Range***REMOVED*** */ (expr.range))
						);

					// import.meta.webpack
					parser.hooks.typeof
						.for("import.meta.webpack")
						.tap(
							PLUGIN_NAME,
							toConstantDependency(parser, JSON.stringify("number"))
						);
					parser.hooks.expression
						.for("import.meta.webpack")
						.tap(
							PLUGIN_NAME,
							toConstantDependency(parser, importMetaWebpackVersion())
						);
					parser.hooks.evaluateTypeof
						.for("import.meta.webpack")
						.tap(PLUGIN_NAME, evaluateToString("number"));
					parser.hooks.evaluateIdentifier
						.for("import.meta.webpack")
						.tap(PLUGIN_NAME, evaluateToNumber(webpackVersion));

					// Unknown properties
					parser.hooks.unhandledExpressionMemberChain
						.for("import.meta")
						.tap(PLUGIN_NAME, (expr, members) => {
							const dep = new ConstDependency(
								importMetaUnknownProperty(members),
								/** @type {Range***REMOVED*** */ (expr.range)
							);
							dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expr.loc);
							parser.state.module.addPresentationalDependency(dep);
							return true;
						***REMOVED***);
					parser.hooks.evaluate
						.for("MemberExpression")
						.tap(PLUGIN_NAME, expression => {
							const expr = /** @type {MemberExpression***REMOVED*** */ (expression);
							if (
								expr.object.type === "MetaProperty" &&
								expr.object.meta.name === "import" &&
								expr.object.property.name === "meta" &&
								expr.property.type ===
									(expr.computed ? "Literal" : "Identifier")
							) {
								return new BasicEvaluatedExpression()
									.setUndefined()
									.setRange(/** @type {Range***REMOVED*** */ (expr.range));
							***REMOVED***
						***REMOVED***);
				***REMOVED***;

				normalModuleFactory.hooks.parser
					.for(JAVASCRIPT_MODULE_TYPE_AUTO)
					.tap(PLUGIN_NAME, parserHandler);
				normalModuleFactory.hooks.parser
					.for(JAVASCRIPT_MODULE_TYPE_ESM)
					.tap(PLUGIN_NAME, parserHandler);
			***REMOVED***
		);
	***REMOVED***
***REMOVED***

module.exports = ImportMetaPlugin;
