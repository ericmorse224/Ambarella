/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { HookMap, SyncWaterfallHook, SyncBailHook ***REMOVED*** = require("tapable");

/** @typedef {import("./DefaultStatsFactoryPlugin").StatsAsset***REMOVED*** StatsAsset */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsChunk***REMOVED*** StatsChunk */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsChunkGroup***REMOVED*** StatsChunkGroup */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsCompilation***REMOVED*** StatsCompilation */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsError***REMOVED*** StatsError */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsLogging***REMOVED*** StatsLogging */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsModule***REMOVED*** StatsModule */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsModuleIssuer***REMOVED*** StatsModuleIssuer */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsModuleReason***REMOVED*** StatsModuleReason */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsModuleTraceDependency***REMOVED*** StatsModuleTraceDependency */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsModuleTraceItem***REMOVED*** StatsModuleTraceItem */
/** @typedef {import("./DefaultStatsFactoryPlugin").StatsProfile***REMOVED*** StatsProfile */

/**
 * @typedef {object***REMOVED*** PrintedElement
 * @property {string***REMOVED*** element
 * @property {string | undefined***REMOVED*** content
 */

/**
 * @typedef {object***REMOVED*** KnownStatsPrinterContext
 * @property {string=***REMOVED*** type
 * @property {StatsCompilation=***REMOVED*** compilation
 * @property {StatsChunkGroup=***REMOVED*** chunkGroup
 * @property {string=***REMOVED*** chunkGroupKind
 * @property {StatsAsset=***REMOVED*** asset
 * @property {StatsModule=***REMOVED*** module
 * @property {StatsChunk=***REMOVED*** chunk
 * @property {StatsModuleReason=***REMOVED*** moduleReason
 * @property {StatsModuleIssuer=***REMOVED*** moduleIssuer
 * @property {StatsError=***REMOVED*** error
 * @property {StatsProfile=***REMOVED*** profile
 * @property {StatsLogging=***REMOVED*** logging
 * @property {StatsModuleTraceItem=***REMOVED*** moduleTraceItem
 * @property {StatsModuleTraceDependency=***REMOVED*** moduleTraceDependency
 */

/** @typedef {(value: string | number) => string***REMOVED*** ColorFunction */

/**
 * @typedef {object***REMOVED*** KnownStatsPrinterColorFunctions
 * @property {ColorFunction=***REMOVED*** bold
 * @property {ColorFunction=***REMOVED*** yellow
 * @property {ColorFunction=***REMOVED*** red
 * @property {ColorFunction=***REMOVED*** green
 * @property {ColorFunction=***REMOVED*** magenta
 * @property {ColorFunction=***REMOVED*** cyan
 */

/**
 * @typedef {object***REMOVED*** KnownStatsPrinterFormatters
 * @property {(file: string, oversize?: boolean) => string=***REMOVED*** formatFilename
 * @property {(id: string | number) => string=***REMOVED*** formatModuleId
 * @property {(id: string | number, direction?: "parent" | "child" | "sibling") => string=***REMOVED*** formatChunkId
 * @property {(size: number) => string=***REMOVED*** formatSize
 * @property {(size: string) => string=***REMOVED*** formatLayer
 * @property {(dateTime: number) => string=***REMOVED*** formatDateTime
 * @property {(flag: string) => string=***REMOVED*** formatFlag
 * @property {(time: number, boldQuantity?: boolean) => string=***REMOVED*** formatTime
 * @property {(message: string) => string=***REMOVED*** formatError
 */

/** @typedef {KnownStatsPrinterColorFunctions & KnownStatsPrinterFormatters & KnownStatsPrinterContext & Record<string, EXPECTED_ANY>***REMOVED*** StatsPrinterContext */
/** @typedef {StatsPrinterContext & Required<KnownStatsPrinterColorFunctions> & Required<KnownStatsPrinterFormatters> & { type: string ***REMOVED******REMOVED*** StatsPrinterContextWithExtra */
/** @typedef {EXPECTED_ANY***REMOVED*** PrintObject */

/**
 * @typedef {object***REMOVED*** StatsPrintHooks
 * @property {HookMap<SyncBailHook<[string[], StatsPrinterContext], void>>***REMOVED*** sortElements
 * @property {HookMap<SyncBailHook<[PrintedElement[], StatsPrinterContext], string | undefined | void>>***REMOVED*** printElements
 * @property {HookMap<SyncBailHook<[PrintObject[], StatsPrinterContext], boolean | void>>***REMOVED*** sortItems
 * @property {HookMap<SyncBailHook<[PrintObject, StatsPrinterContext], string | void>>***REMOVED*** getItemName
 * @property {HookMap<SyncBailHook<[string[], StatsPrinterContext], string | undefined>>***REMOVED*** printItems
 * @property {HookMap<SyncBailHook<[PrintObject, StatsPrinterContext], string | undefined | void>>***REMOVED*** print
 * @property {HookMap<SyncWaterfallHook<[string, StatsPrinterContext]>>***REMOVED*** result
 */

class StatsPrinter {
	constructor() {
		/** @type {StatsPrintHooks***REMOVED*** */
		this.hooks = Object.freeze({
			sortElements: new HookMap(
				() => new SyncBailHook(["elements", "context"])
			),
			printElements: new HookMap(
				() => new SyncBailHook(["printedElements", "context"])
			),
			sortItems: new HookMap(() => new SyncBailHook(["items", "context"])),
			getItemName: new HookMap(() => new SyncBailHook(["item", "context"])),
			printItems: new HookMap(
				() => new SyncBailHook(["printedItems", "context"])
			),
			print: new HookMap(() => new SyncBailHook(["object", "context"])),
			result: new HookMap(() => new SyncWaterfallHook(["result", "context"]))
		***REMOVED***);
		/**
		 * @type {TODO***REMOVED***
		 */
		this._levelHookCache = new Map();
		this._inPrint = false;
	***REMOVED***

	/**
	 * get all level hooks
	 * @private
	 * @template {StatsPrintHooks[keyof StatsPrintHooks]***REMOVED*** HM
	 * @template {HM extends HookMap<infer H> ? H : never***REMOVED*** H
	 * @param {HM***REMOVED*** hookMap hook map
	 * @param {string***REMOVED*** type type
	 * @returns {H[]***REMOVED*** hooks
	 */
	_getAllLevelHooks(hookMap, type) {
		let cache = this._levelHookCache.get(hookMap);
		if (cache === undefined) {
			cache = new Map();
			this._levelHookCache.set(hookMap, cache);
		***REMOVED***
		const cacheEntry = cache.get(type);
		if (cacheEntry !== undefined) {
			return cacheEntry;
		***REMOVED***
		/** @type {H[]***REMOVED*** */
		const hooks = [];
		const typeParts = type.split(".");
		for (let i = 0; i < typeParts.length; i++) {
			const hook = /** @type {H***REMOVED*** */ (hookMap.get(typeParts.slice(i).join(".")));
			if (hook) {
				hooks.push(hook);
			***REMOVED***
		***REMOVED***
		cache.set(type, hooks);
		return hooks;
	***REMOVED***

	/**
	 * Run `fn` for each level
	 * @private
	 * @template {StatsPrintHooks[keyof StatsPrintHooks]***REMOVED*** HM
	 * @template {HM extends HookMap<infer H> ? H : never***REMOVED*** H
	 * @template {H extends import("tapable").Hook<any, infer R> ? R : never***REMOVED*** R
	 * @param {HM***REMOVED*** hookMap hook map
	 * @param {string***REMOVED*** type type
	 * @param {(hooK: H) => R | undefined | void***REMOVED*** fn fn
	 * @returns {R | undefined***REMOVED*** hook
	 */
	_forEachLevel(hookMap, type, fn) {
		for (const hook of this._getAllLevelHooks(hookMap, type)) {
			const result = fn(/** @type {H***REMOVED*** */ (hook));
			if (result !== undefined) return /** @type {R***REMOVED*** */ (result);
		***REMOVED***
	***REMOVED***

	/**
	 * Run `fn` for each level
	 * @private
	 * @template {StatsPrintHooks[keyof StatsPrintHooks]***REMOVED*** HM
	 * @template {HM extends HookMap<infer H> ? H : never***REMOVED*** H
	 * @param {HM***REMOVED*** hookMap hook map
	 * @param {string***REMOVED*** type type
	 * @param {string***REMOVED*** data data
	 * @param {(hook: H, data: string) => string***REMOVED*** fn fn
	 * @returns {string | undefined***REMOVED*** result of `fn`
	 */
	_forEachLevelWaterfall(hookMap, type, data, fn) {
		for (const hook of this._getAllLevelHooks(hookMap, type)) {
			data = fn(/** @type {H***REMOVED*** */ (hook), data);
		***REMOVED***
		return data;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** type The type
	 * @param {PrintObject***REMOVED*** object Object to print
	 * @param {StatsPrinterContext=***REMOVED*** baseContext The base context
	 * @returns {string | undefined***REMOVED*** printed result
	 */
	print(type, object, baseContext) {
		if (this._inPrint) {
			return this._print(type, object, baseContext);
		***REMOVED***
		try {
			this._inPrint = true;
			return this._print(type, object, baseContext);
		***REMOVED*** finally {
			this._levelHookCache.clear();
			this._inPrint = false;
		***REMOVED***
	***REMOVED***

	/**
	 * @private
	 * @param {string***REMOVED*** type type
	 * @param {PrintObject***REMOVED*** object object
	 * @param {StatsPrinterContext=***REMOVED*** baseContext context
	 * @returns {string | undefined***REMOVED*** printed result
	 */
	_print(type, object, baseContext) {
		/** @type {StatsPrinterContext***REMOVED*** */
		const context = {
			...baseContext,
			type,
			[type]: object
		***REMOVED***;

		/** @type {string | undefined***REMOVED*** */
		let printResult = this._forEachLevel(this.hooks.print, type, hook =>
			hook.call(object, context)
		);
		if (printResult === undefined) {
			if (Array.isArray(object)) {
				const sortedItems = object.slice();
				this._forEachLevel(this.hooks.sortItems, type, h =>
					h.call(
						sortedItems,
						/** @type {StatsPrinterContextWithExtra***REMOVED*** */
						(context)
					)
				);
				const printedItems = sortedItems.map((item, i) => {
					const itemContext =
						/** @type {StatsPrinterContextWithExtra***REMOVED*** */
						({
							...context,
							_index: i
						***REMOVED***);
					const itemName = this._forEachLevel(
						this.hooks.getItemName,
						`${type***REMOVED***[]`,
						h => h.call(item, itemContext)
					);
					if (itemName) itemContext[itemName] = item;
					return this.print(
						itemName ? `${type***REMOVED***[].${itemName***REMOVED***` : `${type***REMOVED***[]`,
						item,
						itemContext
					);
				***REMOVED***);
				printResult = this._forEachLevel(this.hooks.printItems, type, h =>
					h.call(
						/** @type {string[]***REMOVED*** */ (printedItems),
						/** @type {StatsPrinterContextWithExtra***REMOVED*** */
						(context)
					)
				);
				if (printResult === undefined) {
					const result = printedItems.filter(Boolean);
					if (result.length > 0) printResult = result.join("\n");
				***REMOVED***
			***REMOVED*** else if (object !== null && typeof object === "object") {
				const elements = Object.keys(object).filter(
					key => object[key] !== undefined
				);
				this._forEachLevel(this.hooks.sortElements, type, h =>
					h.call(
						elements,
						/** @type {StatsPrinterContextWithExtra***REMOVED*** */
						(context)
					)
				);
				const printedElements = elements.map(element => {
					const content = this.print(`${type***REMOVED***.${element***REMOVED***`, object[element], {
						...context,
						_parent: object,
						_element: element,
						[element]: object[element]
					***REMOVED***);
					return { element, content ***REMOVED***;
				***REMOVED***);
				printResult = this._forEachLevel(this.hooks.printElements, type, h =>
					h.call(
						printedElements,
						/** @type {StatsPrinterContextWithExtra***REMOVED*** */
						(context)
					)
				);
				if (printResult === undefined) {
					const result = printedElements.map(e => e.content).filter(Boolean);
					if (result.length > 0) printResult = result.join("\n");
				***REMOVED***
			***REMOVED***
		***REMOVED***

		return this._forEachLevelWaterfall(
			this.hooks.result,
			type,
			/** @type {string***REMOVED*** */
			(printResult),
			(h, r) => h.call(r, /** @type {StatsPrinterContextWithExtra***REMOVED*** */ (context))
		);
	***REMOVED***
***REMOVED***
module.exports = StatsPrinter;
