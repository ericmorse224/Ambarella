"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.default = _usingCtx;
function _usingCtx() {
  var _disposeSuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed) {
      var err = new Error();
      err.name = "SuppressedError";
      err.error = error;
      err.suppressed = suppressed;
      return err;
    ***REMOVED***,
    empty = {***REMOVED***,
    stack = [];
  function using(isAwait, value) {
    if (value != null) {
      if (Object(value) !== value) {
        throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");
      ***REMOVED***
      if (isAwait) {
        var dispose = value[Symbol.asyncDispose || Symbol.for("Symbol.asyncDispose")];
      ***REMOVED***
      if (dispose === undefined) {
        dispose = value[Symbol.dispose || Symbol.for("Symbol.dispose")];
        if (isAwait) {
          var inner = dispose;
        ***REMOVED***
      ***REMOVED***
      if (typeof dispose !== "function") {
        throw new TypeError("Object is not disposable.");
      ***REMOVED***
      if (inner) {
        dispose = function () {
          try {
            inner.call(value);
          ***REMOVED*** catch (e) {
            return Promise.reject(e);
          ***REMOVED***
        ***REMOVED***;
      ***REMOVED***
      stack.push({
        v: value,
        d: dispose,
        a: isAwait
      ***REMOVED***);
    ***REMOVED*** else if (isAwait) {
      stack.push({
        d: value,
        a: isAwait
      ***REMOVED***);
    ***REMOVED***
    return value;
  ***REMOVED***
  return {
    e: empty,
    u: using.bind(null, false),
    a: using.bind(null, true),
    d: function () {
      var error = this.e,
        state = 0,
        resource;
      function next() {
        while (resource = stack.pop()) {
          try {
            if (!resource.a && state === 1) {
              state = 0;
              stack.push(resource);
              return Promise.resolve().then(next);
            ***REMOVED***
            if (resource.d) {
              var disposalResult = resource.d.call(resource.v);
              if (resource.a) {
                state |= 2;
                return Promise.resolve(disposalResult).then(next, err);
              ***REMOVED***
            ***REMOVED*** else {
              state |= 1;
            ***REMOVED***
          ***REMOVED*** catch (e) {
            return err(e);
          ***REMOVED***
        ***REMOVED***
        if (state === 1) {
          if (error !== empty) {
            return Promise.reject(error);
          ***REMOVED*** else {
            return Promise.resolve();
          ***REMOVED***
        ***REMOVED***
        if (error !== empty) throw error;
      ***REMOVED***
      function err(e) {
        error = error !== empty ? new _disposeSuppressedError(e, error) : e;
        return next();
      ***REMOVED***
      return next();
    ***REMOVED***
  ***REMOVED***;
***REMOVED***

//# sourceMappingURL=usingCtx.js.map
