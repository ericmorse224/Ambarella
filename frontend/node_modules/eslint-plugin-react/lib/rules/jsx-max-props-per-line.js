/**
 * @fileoverview Limit maximum of props on a single line in JSX
 * @author Yannick Croissant
 */

'use strict';

const docsUrl = require('../util/docsUrl');
const getText = require('../util/eslint').getText;
const report = require('../util/report');

function getPropName(context, propNode) {
  if (propNode.type === 'JSXSpreadAttribute') {
    return getText(context, propNode.argument);
  ***REMOVED***
  return propNode.name.name;
***REMOVED***

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

const messages = {
  newLine: 'Prop `{{prop***REMOVED******REMOVED***` must be placed on a new line',
***REMOVED***;

/** @type {import('eslint').Rule.RuleModule***REMOVED*** */
module.exports = {
  meta: {
    docs: {
      description: 'Enforce maximum of props on a single line in JSX',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-max-props-per-line'),
    ***REMOVED***,
    fixable: 'code',

    messages,

    schema: [{
      anyOf: [{
        type: 'object',
        properties: {
          maximum: {
            type: 'object',
            properties: {
              single: {
                type: 'integer',
                minimum: 1,
              ***REMOVED***,
              multi: {
                type: 'integer',
                minimum: 1,
              ***REMOVED***,
            ***REMOVED***,
          ***REMOVED***,
        ***REMOVED***,
        additionalProperties: false,
      ***REMOVED***, {
        type: 'object',
        properties: {
          maximum: {
            type: 'number',
            minimum: 1,
          ***REMOVED***,
          when: {
            type: 'string',
            enum: ['always', 'multiline'],
          ***REMOVED***,
        ***REMOVED***,
        additionalProperties: false,
      ***REMOVED***],
    ***REMOVED***],
  ***REMOVED***,

  create(context) {
    const configuration = context.options[0] || {***REMOVED***;
    const maximum = configuration.maximum || 1;

    const maxConfig = typeof maximum === 'number'
      ? {
        single: configuration.when === 'multiline' ? Infinity : maximum,
        multi: maximum,
      ***REMOVED***
      : {
        single: maximum.single || Infinity,
        multi: maximum.multi || Infinity,
      ***REMOVED***;

    function generateFixFunction(line, max) {
      const output = [];
      const front = line[0].range[0];
      const back = line[line.length - 1].range[1];

      for (let i = 0; i < line.length; i += max) {
        const nodes = line.slice(i, i + max);
        output.push(nodes.reduce((prev, curr) => {
          if (prev === '') {
            return getText(context, curr);
          ***REMOVED***
          return `${prev***REMOVED*** ${getText(context, curr)***REMOVED***`;
        ***REMOVED***, ''));
      ***REMOVED***

      const code = output.join('\n');

      return function fix(fixer) {
        return fixer.replaceTextRange([front, back], code);
      ***REMOVED***;
    ***REMOVED***

    return {
      JSXOpeningElement(node) {
        if (!node.attributes.length) {
          return;
        ***REMOVED***

        const isSingleLineTag = node.loc.start.line === node.loc.end.line;

        if ((isSingleLineTag ? maxConfig.single : maxConfig.multi) === Infinity) {
          return;
        ***REMOVED***

        const firstProp = node.attributes[0];
        const linePartitionedProps = [[firstProp]];

        node.attributes.reduce((last, decl) => {
          if (last.loc.end.line === decl.loc.start.line) {
            linePartitionedProps[linePartitionedProps.length - 1].push(decl);
          ***REMOVED*** else {
            linePartitionedProps.push([decl]);
          ***REMOVED***
          return decl;
        ***REMOVED***);

        linePartitionedProps.forEach((propsInLine) => {
          const maxPropsCountPerLine = isSingleLineTag && propsInLine[0].loc.start.line === node.loc.start.line
            ? maxConfig.single
            : maxConfig.multi;

          if (propsInLine.length > maxPropsCountPerLine) {
            const name = getPropName(context, propsInLine[maxPropsCountPerLine]);
            report(context, messages.newLine, 'newLine', {
              node: propsInLine[maxPropsCountPerLine],
              data: {
                prop: name,
              ***REMOVED***,
              fix: generateFixFunction(propsInLine, maxPropsCountPerLine),
            ***REMOVED***);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***,
    ***REMOVED***;
  ***REMOVED***,
***REMOVED***;
