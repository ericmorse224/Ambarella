import type {KeywordCxt***REMOVED*** from "."
import type {
  AnySchema,
  SchemaValidateFunction,
  AnyValidateFunction,
  AddedKeywordDefinition,
  MacroKeywordDefinition,
  FuncKeywordDefinition,
***REMOVED*** from "../../types"
import type {SchemaObjCxt***REMOVED*** from ".."
import {_, nil, not, stringify, Code, Name, CodeGen***REMOVED*** from "../codegen"
import N from "../names"
import type {JSONType***REMOVED*** from "../rules"
import {callValidateCode***REMOVED*** from "../../vocabularies/code"
import {extendErrors***REMOVED*** from "../errors"

type KeywordCompilationResult = AnySchema | SchemaValidateFunction | AnyValidateFunction

export function macroKeywordCode(cxt: KeywordCxt, def: MacroKeywordDefinition): void {
  const {gen, keyword, schema, parentSchema, it***REMOVED*** = cxt
  const macroSchema = def.macro.call(it.self, schema, parentSchema, it)
  const schemaRef = useKeyword(gen, keyword, macroSchema)
  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true)

  const valid = gen.name("valid")
  cxt.subschema(
    {
      schema: macroSchema,
      schemaPath: nil,
      errSchemaPath: `${it.errSchemaPath***REMOVED***/${keyword***REMOVED***`,
      topSchemaRef: schemaRef,
      compositeRule: true,
    ***REMOVED***,
    valid
  )
  cxt.pass(valid, () => cxt.error(true))
***REMOVED***

export function funcKeywordCode(cxt: KeywordCxt, def: FuncKeywordDefinition): void {
  const {gen, keyword, schema, parentSchema, $data, it***REMOVED*** = cxt
  checkAsyncKeyword(it, def)
  const validate =
    !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate
  const validateRef = useKeyword(gen, keyword, validate)
  const valid = gen.let("valid")
  cxt.block$data(valid, validateKeyword)
  cxt.ok(def.valid ?? valid)

  function validateKeyword(): void {
    if (def.errors === false) {
      assignValid()
      if (def.modifying) modifyData(cxt)
      reportErrs(() => cxt.error())
    ***REMOVED*** else {
      const ruleErrs = def.async ? validateAsync() : validateSync()
      if (def.modifying) modifyData(cxt)
      reportErrs(() => addErrs(cxt, ruleErrs))
    ***REMOVED***
  ***REMOVED***

  function validateAsync(): Name {
    const ruleErrs = gen.let("ruleErrs", null)
    gen.try(
      () => assignValid(_`await `),
      (e) =>
        gen.assign(valid, false).if(
          _`${e***REMOVED*** instanceof ${it.ValidationError as Name***REMOVED***`,
          () => gen.assign(ruleErrs, _`${e***REMOVED***.errors`),
          () => gen.throw(e)
        )
    )
    return ruleErrs
  ***REMOVED***

  function validateSync(): Code {
    const validateErrs = _`${validateRef***REMOVED***.errors`
    gen.assign(validateErrs, null)
    assignValid(nil)
    return validateErrs
  ***REMOVED***

  function assignValid(_await: Code = def.async ? _`await ` : nil): void {
    const passCxt = it.opts.passContext ? N.this : N.self
    const passSchema = !(("compile" in def && !$data) || def.schema === false)
    gen.assign(
      valid,
      _`${_await***REMOVED***${callValidateCode(cxt, validateRef, passCxt, passSchema)***REMOVED***`,
      def.modifying
    )
  ***REMOVED***

  function reportErrs(errors: () => void): void {
    gen.if(not(def.valid ?? valid), errors)
  ***REMOVED***
***REMOVED***

function modifyData(cxt: KeywordCxt): void {
  const {gen, data, it***REMOVED*** = cxt
  gen.if(it.parentData, () => gen.assign(data, _`${it.parentData***REMOVED***[${it.parentDataProperty***REMOVED***]`))
***REMOVED***

function addErrs(cxt: KeywordCxt, errs: Code): void {
  const {gen***REMOVED*** = cxt
  gen.if(
    _`Array.isArray(${errs***REMOVED***)`,
    () => {
      gen
        .assign(N.vErrors, _`${N.vErrors***REMOVED*** === null ? ${errs***REMOVED*** : ${N.vErrors***REMOVED***.concat(${errs***REMOVED***)`)
        .assign(N.errors, _`${N.vErrors***REMOVED***.length`)
      extendErrors(cxt)
    ***REMOVED***,
    () => cxt.error()
  )
***REMOVED***

function checkAsyncKeyword({schemaEnv***REMOVED***: SchemaObjCxt, def: FuncKeywordDefinition): void {
  if (def.async && !schemaEnv.$async) throw new Error("async keyword in sync schema")
***REMOVED***

function useKeyword(gen: CodeGen, keyword: string, result?: KeywordCompilationResult): Name {
  if (result === undefined) throw new Error(`keyword "${keyword***REMOVED***" failed to compile`)
  return gen.scopeValue(
    "keyword",
    typeof result == "function" ? {ref: result***REMOVED*** : {ref: result, code: stringify(result)***REMOVED***
  )
***REMOVED***

export function validSchemaType(
  schema: unknown,
  schemaType: JSONType[],
  allowUndefined = false
): boolean {
  // TODO add tests
  return (
    !schemaType.length ||
    schemaType.some((st) =>
      st === "array"
        ? Array.isArray(schema)
        : st === "object"
        ? schema && typeof schema == "object" && !Array.isArray(schema)
        : typeof schema == st || (allowUndefined && typeof schema == "undefined")
    )
  )
***REMOVED***

export function validateKeywordUsage(
  {schema, opts, self, errSchemaPath***REMOVED***: SchemaObjCxt,
  def: AddedKeywordDefinition,
  keyword: string
): void {
  /* istanbul ignore if */
  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
    throw new Error("ajv implementation error")
  ***REMOVED***

  const deps = def.dependencies
  if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
    throw new Error(`parent schema must have dependencies of ${keyword***REMOVED***: ${deps.join(",")***REMOVED***`)
  ***REMOVED***

  if (def.validateSchema) {
    const valid = def.validateSchema(schema[keyword])
    if (!valid) {
      const msg =
        `keyword "${keyword***REMOVED***" value is invalid at path "${errSchemaPath***REMOVED***": ` +
        self.errorsText(def.validateSchema.errors)
      if (opts.validateSchema === "log") self.logger.error(msg)
      else throw new Error(msg)
    ***REMOVED***
  ***REMOVED***
***REMOVED***
