/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const ConditionalInitFragment = require("../ConditionalInitFragment");
const Dependency = require("../Dependency");
const { UsageState ***REMOVED*** = require("../ExportsInfo");
const HarmonyLinkingError = require("../HarmonyLinkingError");
const InitFragment = require("../InitFragment");
const RuntimeGlobals = require("../RuntimeGlobals");
const Template = require("../Template");
const { countIterable ***REMOVED*** = require("../util/IterableHelpers");
const { first, combine ***REMOVED*** = require("../util/SetHelpers");
const makeSerializable = require("../util/makeSerializable");
const propertyAccess = require("../util/propertyAccess");
const { propertyName ***REMOVED*** = require("../util/propertyName");
const {
	getRuntimeKey,
	keyToRuntime,
	filterRuntime
***REMOVED*** = require("../util/runtime");
const HarmonyExportInitFragment = require("./HarmonyExportInitFragment");
const HarmonyImportDependency = require("./HarmonyImportDependency");
const processExportInfo = require("./processExportInfo");

/** @typedef {import("webpack-sources").ReplaceSource***REMOVED*** ReplaceSource */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../Dependency").ExportsSpec***REMOVED*** ExportsSpec */
/** @typedef {import("../Dependency").GetConditionFn***REMOVED*** GetConditionFn */
/** @typedef {import("../Dependency").ReferencedExport***REMOVED*** ReferencedExport */
/** @typedef {import("../Dependency").TRANSITIVE***REMOVED*** TRANSITIVE */
/** @typedef {import("../Dependency").UpdateHashContext***REMOVED*** UpdateHashContext */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext***REMOVED*** DependencyTemplateContext */
/** @typedef {import("../ExportsInfo")***REMOVED*** ExportsInfo */
/** @typedef {import("../ExportsInfo").ExportInfo***REMOVED*** ExportInfo */
/** @typedef {import("../ExportsInfo").UsedName***REMOVED*** UsedName */
/** @typedef {import("../Generator").GenerateContext***REMOVED*** GenerateContext */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../Module").BuildMeta***REMOVED*** BuildMeta */
/** @typedef {import("../Module").RuntimeRequirements***REMOVED*** RuntimeRequirements */
/** @typedef {import("../ModuleGraph")***REMOVED*** ModuleGraph */
/** @typedef {import("../ModuleGraphConnection")***REMOVED*** ModuleGraphConnection */
/** @typedef {import("../ModuleGraphConnection").ConnectionState***REMOVED*** ConnectionState */
/** @typedef {import("../RuntimeTemplate")***REMOVED*** RuntimeTemplate */
/** @typedef {import("../WebpackError")***REMOVED*** WebpackError */
/** @typedef {import("../javascript/JavascriptParser").ImportAttributes***REMOVED*** ImportAttributes */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext***REMOVED*** ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext***REMOVED*** ObjectSerializerContext */
/** @typedef {import("../util/Hash")***REMOVED*** Hash */
/** @typedef {import("../util/runtime").RuntimeSpec***REMOVED*** RuntimeSpec */
/** @typedef {import("./HarmonyImportDependency").ExportPresenceMode***REMOVED*** ExportPresenceMode */
/** @typedef {import("./processExportInfo").ReferencedExports***REMOVED*** ReferencedExports */

/** @typedef {"missing"|"unused"|"empty-star"|"reexport-dynamic-default"|"reexport-named-default"|"reexport-namespace-object"|"reexport-fake-namespace-object"|"reexport-undefined"|"normal-reexport"|"dynamic-reexport"***REMOVED*** ExportModeType */

const { ExportPresenceModes ***REMOVED*** = HarmonyImportDependency;

const idsSymbol = Symbol("HarmonyExportImportedSpecifierDependency.ids");

class NormalReexportItem {
	/**
	 * @param {string***REMOVED*** name export name
	 * @param {string[]***REMOVED*** ids reexported ids from other module
	 * @param {ExportInfo***REMOVED*** exportInfo export info from other module
	 * @param {boolean***REMOVED*** checked true, if it should be checked at runtime if this export exists
	 * @param {boolean***REMOVED*** hidden true, if it is hidden behind another active export in the same module
	 */
	constructor(name, ids, exportInfo, checked, hidden) {
		this.name = name;
		this.ids = ids;
		this.exportInfo = exportInfo;
		this.checked = checked;
		this.hidden = hidden;
	***REMOVED***
***REMOVED***

/** @typedef {Set<string>***REMOVED*** ExportModeIgnored */
/** @typedef {Set<string>***REMOVED*** ExportModeHidden */

class ExportMode {
	/**
	 * @param {ExportModeType***REMOVED*** type type of the mode
	 */
	constructor(type) {
		/** @type {ExportModeType***REMOVED*** */
		this.type = type;

		// for "normal-reexport":
		/** @type {NormalReexportItem[] | null***REMOVED*** */
		this.items = null;

		// for "reexport-named-default" | "reexport-fake-namespace-object" | "reexport-namespace-object"
		/** @type {string | null***REMOVED*** */
		this.name = null;
		/** @type {ExportInfo | null***REMOVED*** */
		this.partialNamespaceExportInfo = null;

		// for "dynamic-reexport":
		/** @type {ExportModeIgnored | null***REMOVED*** */
		this.ignored = null;

		// for "dynamic-reexport" | "empty-star":
		/** @type {ExportModeHidden | undefined | null***REMOVED*** */
		this.hidden = null;

		// for "missing":
		/** @type {string | null***REMOVED*** */
		this.userRequest = null;

		// for "reexport-fake-namespace-object":
		/** @type {number***REMOVED*** */
		this.fakeType = 0;
	***REMOVED***
***REMOVED***

/** @typedef {string[]***REMOVED*** Names */
/** @typedef {number[]***REMOVED*** DependencyIndices */

/**
 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
 * @param {HarmonyExportImportedSpecifierDependency[]***REMOVED*** dependencies dependencies
 * @param {TODO=***REMOVED*** additionalDependency additional dependency
 * @returns {{ names: Names, dependencyIndices: DependencyIndices ***REMOVED******REMOVED*** result
 */
const determineExportAssignments = (
	moduleGraph,
	dependencies,
	additionalDependency
) => {
	const names = new Set();
	/** @type {number[]***REMOVED*** */
	const dependencyIndices = [];

	if (additionalDependency) {
		dependencies = dependencies.concat(additionalDependency);
	***REMOVED***

	for (const dep of dependencies) {
		const i = dependencyIndices.length;
		dependencyIndices[i] = names.size;
		const otherImportedModule = moduleGraph.getModule(dep);
		if (otherImportedModule) {
			const exportsInfo = moduleGraph.getExportsInfo(otherImportedModule);
			for (const exportInfo of exportsInfo.exports) {
				if (
					exportInfo.provided === true &&
					exportInfo.name !== "default" &&
					!names.has(exportInfo.name)
				) {
					names.add(exportInfo.name);
					dependencyIndices[i] = names.size;
				***REMOVED***
			***REMOVED***
		***REMOVED***
	***REMOVED***
	dependencyIndices.push(names.size);

	return { names: Array.from(names), dependencyIndices ***REMOVED***;
***REMOVED***;

/**
 * @param {object***REMOVED*** options options
 * @param {Names***REMOVED*** options.names names
 * @param {DependencyIndices***REMOVED*** options.dependencyIndices dependency indices
 * @param {string***REMOVED*** name name
 * @param {Iterable<HarmonyExportImportedSpecifierDependency>***REMOVED*** dependencies dependencies
 * @returns {HarmonyExportImportedSpecifierDependency | undefined***REMOVED*** found dependency or nothing
 */
const findDependencyForName = (
	{ names, dependencyIndices ***REMOVED***,
	name,
	dependencies
) => {
	const dependenciesIt = dependencies[Symbol.iterator]();
	const dependencyIndicesIt = dependencyIndices[Symbol.iterator]();
	let dependenciesItResult = dependenciesIt.next();
	let dependencyIndicesItResult = dependencyIndicesIt.next();
	if (dependencyIndicesItResult.done) return;
	for (let i = 0; i < names.length; i++) {
		while (i >= dependencyIndicesItResult.value) {
			dependenciesItResult = dependenciesIt.next();
			dependencyIndicesItResult = dependencyIndicesIt.next();
			if (dependencyIndicesItResult.done) return;
		***REMOVED***
		if (names[i] === name) return dependenciesItResult.value;
	***REMOVED***
	return undefined;
***REMOVED***;

/**
 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
 * @param {HarmonyExportImportedSpecifierDependency***REMOVED*** dep the dependency
 * @param {string***REMOVED*** runtimeKey the runtime key
 * @returns {ExportMode***REMOVED*** the export mode
 */
const getMode = (moduleGraph, dep, runtimeKey) => {
	const importedModule = moduleGraph.getModule(dep);

	if (!importedModule) {
		const mode = new ExportMode("missing");

		mode.userRequest = dep.userRequest;

		return mode;
	***REMOVED***

	const name = dep.name;
	const runtime = keyToRuntime(runtimeKey);
	const parentModule = /** @type {Module***REMOVED*** */ (moduleGraph.getParentModule(dep));
	const exportsInfo = moduleGraph.getExportsInfo(parentModule);

	if (
		name
			? exportsInfo.getUsed(name, runtime) === UsageState.Unused
			: exportsInfo.isUsed(runtime) === false
	) {
		const mode = new ExportMode("unused");

		mode.name = name || "*";

		return mode;
	***REMOVED***

	const importedExportsType = importedModule.getExportsType(
		moduleGraph,
		/** @type {BuildMeta***REMOVED*** */
		(parentModule.buildMeta).strictHarmonyModule
	);

	const ids = dep.getIds(moduleGraph);

	// Special handling for reexporting the default export
	// from non-namespace modules
	if (name && ids.length > 0 && ids[0] === "default") {
		switch (importedExportsType) {
			case "dynamic": {
				const mode = new ExportMode("reexport-dynamic-default");

				mode.name = name;

				return mode;
			***REMOVED***
			case "default-only":
			case "default-with-named": {
				const exportInfo = exportsInfo.getReadOnlyExportInfo(name);
				const mode = new ExportMode("reexport-named-default");

				mode.name = name;
				mode.partialNamespaceExportInfo = exportInfo;

				return mode;
			***REMOVED***
		***REMOVED***
	***REMOVED***

	// reexporting with a fixed name
	if (name) {
		let mode;
		const exportInfo = exportsInfo.getReadOnlyExportInfo(name);

		if (ids.length > 0) {
			// export { name as name ***REMOVED***
			switch (importedExportsType) {
				case "default-only":
					mode = new ExportMode("reexport-undefined");
					mode.name = name;
					break;
				default:
					mode = new ExportMode("normal-reexport");
					mode.items = [
						new NormalReexportItem(name, ids, exportInfo, false, false)
					];
					break;
			***REMOVED***
		***REMOVED*** else {
			// export * as name
			switch (importedExportsType) {
				case "default-only":
					mode = new ExportMode("reexport-fake-namespace-object");
					mode.name = name;
					mode.partialNamespaceExportInfo = exportInfo;
					mode.fakeType = 0;
					break;
				case "default-with-named":
					mode = new ExportMode("reexport-fake-namespace-object");
					mode.name = name;
					mode.partialNamespaceExportInfo = exportInfo;
					mode.fakeType = 2;
					break;
				case "dynamic":
				default:
					mode = new ExportMode("reexport-namespace-object");
					mode.name = name;
					mode.partialNamespaceExportInfo = exportInfo;
			***REMOVED***
		***REMOVED***

		return mode;
	***REMOVED***

	// Star reexporting

	const { ignoredExports, exports, checked, hidden ***REMOVED*** = dep.getStarReexports(
		moduleGraph,
		runtime,
		exportsInfo,
		importedModule
	);
	if (!exports) {
		// We have too few info about the modules
		// Delegate the logic to the runtime code

		const mode = new ExportMode("dynamic-reexport");
		mode.ignored = ignoredExports;
		mode.hidden = hidden;

		return mode;
	***REMOVED***

	if (exports.size === 0) {
		const mode = new ExportMode("empty-star");
		mode.hidden = hidden;

		return mode;
	***REMOVED***

	const mode = new ExportMode("normal-reexport");

	mode.items = Array.from(
		exports,
		exportName =>
			new NormalReexportItem(
				exportName,
				[exportName],
				exportsInfo.getReadOnlyExportInfo(exportName),
				/** @type {Set<string>***REMOVED*** */
				(checked).has(exportName),
				false
			)
	);
	if (hidden !== undefined) {
		for (const exportName of hidden) {
			mode.items.push(
				new NormalReexportItem(
					exportName,
					[exportName],
					exportsInfo.getReadOnlyExportInfo(exportName),
					false,
					true
				)
			);
		***REMOVED***
	***REMOVED***

	return mode;
***REMOVED***;

/** @typedef {string[]***REMOVED*** Ids */
/** @typedef {Set<string>***REMOVED*** Exports */
/** @typedef {Set<string>***REMOVED*** Checked */
/** @typedef {Set<string>***REMOVED*** Hidden */
/** @typedef {Set<string>***REMOVED*** IgnoredExports */

class HarmonyExportImportedSpecifierDependency extends HarmonyImportDependency {
	/**
	 * @param {string***REMOVED*** request the request string
	 * @param {number***REMOVED*** sourceOrder the order in the original source file
	 * @param {Ids***REMOVED*** ids the requested export name of the imported module
	 * @param {string | null***REMOVED*** name the export name of for this module
	 * @param {Set<string>***REMOVED*** activeExports other named exports in the module
	 * @param {ReadonlyArray<HarmonyExportImportedSpecifierDependency> | Iterable<HarmonyExportImportedSpecifierDependency> | null***REMOVED*** otherStarExports other star exports in the module before this import
	 * @param {ExportPresenceMode***REMOVED*** exportPresenceMode mode of checking export names
	 * @param {HarmonyStarExportsList | null***REMOVED*** allStarExports all star exports in the module
	 * @param {ImportAttributes=***REMOVED*** attributes import attributes
	 */
	constructor(
		request,
		sourceOrder,
		ids,
		name,
		activeExports,
		otherStarExports,
		exportPresenceMode,
		allStarExports,
		attributes
	) {
		super(request, sourceOrder, attributes);

		this.ids = ids;
		this.name = name;
		this.activeExports = activeExports;
		this.otherStarExports = otherStarExports;
		this.exportPresenceMode = exportPresenceMode;
		this.allStarExports = allStarExports;
	***REMOVED***

	/**
	 * @returns {boolean | TRANSITIVE***REMOVED*** true, when changes to the referenced module could affect the referencing module; TRANSITIVE, when changes to the referenced module could affect referencing modules of the referencing module
	 */
	couldAffectReferencingModule() {
		return Dependency.TRANSITIVE;
	***REMOVED***

	// TODO webpack 6 remove
	get id() {
		throw new Error("id was renamed to ids and type changed to string[]");
	***REMOVED***

	// TODO webpack 6 remove
	getId() {
		throw new Error("id was renamed to ids and type changed to string[]");
	***REMOVED***

	// TODO webpack 6 remove
	setId() {
		throw new Error("id was renamed to ids and type changed to string[]");
	***REMOVED***

	get type() {
		return "harmony export imported specifier";
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @returns {Ids***REMOVED*** the imported id
	 */
	getIds(moduleGraph) {
		return moduleGraph.getMeta(this)[idsSymbol] || this.ids;
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @param {Ids***REMOVED*** ids the imported ids
	 * @returns {void***REMOVED***
	 */
	setIds(moduleGraph, ids) {
		moduleGraph.getMeta(this)[idsSymbol] = ids;
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @returns {ExportMode***REMOVED*** the export mode
	 */
	getMode(moduleGraph, runtime) {
		return moduleGraph.dependencyCacheProvide(
			this,
			getRuntimeKey(runtime),
			getMode
		);
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @param {ExportsInfo***REMOVED*** exportsInfo exports info about the current module (optional)
	 * @param {Module***REMOVED*** importedModule the imported module (optional)
	 * @returns {{exports?: Exports, checked?: Checked, ignoredExports: IgnoredExports, hidden?: Hidden***REMOVED******REMOVED*** information
	 */
	getStarReexports(
		moduleGraph,
		runtime,
		exportsInfo = moduleGraph.getExportsInfo(
			/** @type {Module***REMOVED*** */ (moduleGraph.getParentModule(this))
		),
		importedModule = /** @type {Module***REMOVED*** */ (moduleGraph.getModule(this))
	) {
		const importedExportsInfo = moduleGraph.getExportsInfo(importedModule);
		const noExtraExports =
			importedExportsInfo.otherExportsInfo.provided === false;
		const noExtraImports =
			exportsInfo.otherExportsInfo.getUsed(runtime) === UsageState.Unused;

		const ignoredExports = new Set(["default", ...this.activeExports]);

		let hiddenExports;
		const otherStarExports =
			this._discoverActiveExportsFromOtherStarExports(moduleGraph);
		if (otherStarExports !== undefined) {
			hiddenExports = new Set();
			for (let i = 0; i < otherStarExports.namesSlice; i++) {
				hiddenExports.add(otherStarExports.names[i]);
			***REMOVED***
			for (const e of ignoredExports) hiddenExports.delete(e);
		***REMOVED***

		if (!noExtraExports && !noExtraImports) {
			return {
				ignoredExports,
				hidden: hiddenExports
			***REMOVED***;
		***REMOVED***

		/** @type {Exports***REMOVED*** */
		const exports = new Set();
		/** @type {Checked***REMOVED*** */
		const checked = new Set();
		/** @type {Hidden | undefined***REMOVED*** */
		const hidden = hiddenExports !== undefined ? new Set() : undefined;

		if (noExtraImports) {
			for (const exportInfo of exportsInfo.orderedExports) {
				const name = exportInfo.name;
				if (ignoredExports.has(name)) continue;
				if (exportInfo.getUsed(runtime) === UsageState.Unused) continue;
				const importedExportInfo =
					importedExportsInfo.getReadOnlyExportInfo(name);
				if (importedExportInfo.provided === false) continue;
				if (hiddenExports !== undefined && hiddenExports.has(name)) {
					/** @type {Set<string>***REMOVED*** */
					(hidden).add(name);
					continue;
				***REMOVED***
				exports.add(name);
				if (importedExportInfo.provided === true) continue;
				checked.add(name);
			***REMOVED***
		***REMOVED*** else if (noExtraExports) {
			for (const importedExportInfo of importedExportsInfo.orderedExports) {
				const name = importedExportInfo.name;
				if (ignoredExports.has(name)) continue;
				if (importedExportInfo.provided === false) continue;
				const exportInfo = exportsInfo.getReadOnlyExportInfo(name);
				if (exportInfo.getUsed(runtime) === UsageState.Unused) continue;
				if (hiddenExports !== undefined && hiddenExports.has(name)) {
					/** @type {ExportModeHidden***REMOVED*** */
					(hidden).add(name);
					continue;
				***REMOVED***
				exports.add(name);
				if (importedExportInfo.provided === true) continue;
				checked.add(name);
			***REMOVED***
		***REMOVED***

		return { ignoredExports, exports, checked, hidden ***REMOVED***;
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @returns {null | false | GetConditionFn***REMOVED*** function to determine if the connection is active
	 */
	getCondition(moduleGraph) {
		return (connection, runtime) => {
			const mode = this.getMode(moduleGraph, runtime);
			return mode.type !== "unused" && mode.type !== "empty-star";
		***REMOVED***;
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @returns {ConnectionState***REMOVED*** how this dependency connects the module to referencing modules
	 */
	getModuleEvaluationSideEffectsState(moduleGraph) {
		return false;
	***REMOVED***

	/**
	 * Returns list of exports referenced by this dependency
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime for which the module is analysed
	 * @returns {(string[] | ReferencedExport)[]***REMOVED*** referenced exports
	 */
	getReferencedExports(moduleGraph, runtime) {
		const mode = this.getMode(moduleGraph, runtime);

		switch (mode.type) {
			case "missing":
			case "unused":
			case "empty-star":
			case "reexport-undefined":
				return Dependency.NO_EXPORTS_REFERENCED;

			case "reexport-dynamic-default":
				return Dependency.EXPORTS_OBJECT_REFERENCED;

			case "reexport-named-default": {
				if (!mode.partialNamespaceExportInfo)
					return Dependency.EXPORTS_OBJECT_REFERENCED;
				/** @type {ReferencedExports***REMOVED*** */
				const referencedExports = [];
				processExportInfo(
					runtime,
					referencedExports,
					[],
					/** @type {ExportInfo***REMOVED*** */ (mode.partialNamespaceExportInfo)
				);
				return referencedExports;
			***REMOVED***

			case "reexport-namespace-object":
			case "reexport-fake-namespace-object": {
				if (!mode.partialNamespaceExportInfo)
					return Dependency.EXPORTS_OBJECT_REFERENCED;
				/** @type {ReferencedExports***REMOVED*** */
				const referencedExports = [];
				processExportInfo(
					runtime,
					referencedExports,
					[],
					/** @type {ExportInfo***REMOVED*** */ (mode.partialNamespaceExportInfo),
					mode.type === "reexport-fake-namespace-object"
				);
				return referencedExports;
			***REMOVED***

			case "dynamic-reexport":
				return Dependency.EXPORTS_OBJECT_REFERENCED;

			case "normal-reexport": {
				/** @type {ReferencedExports***REMOVED*** */
				const referencedExports = [];
				for (const {
					ids,
					exportInfo,
					hidden
				***REMOVED*** of /** @type {NormalReexportItem[]***REMOVED*** */ (mode.items)) {
					if (hidden) continue;
					processExportInfo(runtime, referencedExports, ids, exportInfo, false);
				***REMOVED***
				return referencedExports;
			***REMOVED***

			default:
				throw new Error(`Unknown mode ${mode.type***REMOVED***`);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @returns {{ names: Names, namesSlice: number, dependencyIndices: DependencyIndices, dependencyIndex: number ***REMOVED*** | undefined***REMOVED*** exported names and their origin dependency
	 */
	_discoverActiveExportsFromOtherStarExports(moduleGraph) {
		if (!this.otherStarExports) return;

		const i =
			"length" in this.otherStarExports
				? this.otherStarExports.length
				: countIterable(this.otherStarExports);
		if (i === 0) return;

		if (this.allStarExports) {
			const { names, dependencyIndices ***REMOVED*** = moduleGraph.cached(
				determineExportAssignments,
				this.allStarExports.dependencies
			);

			return {
				names,
				namesSlice: dependencyIndices[i - 1],
				dependencyIndices,
				dependencyIndex: i
			***REMOVED***;
		***REMOVED***

		const { names, dependencyIndices ***REMOVED*** = moduleGraph.cached(
			determineExportAssignments,
			this.otherStarExports,
			this
		);

		return {
			names,
			namesSlice: dependencyIndices[i - 1],
			dependencyIndices,
			dependencyIndex: i
		***REMOVED***;
	***REMOVED***

	/**
	 * Returns the exported names
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @returns {ExportsSpec | undefined***REMOVED*** export names
	 */
	getExports(moduleGraph) {
		const mode = this.getMode(moduleGraph, undefined);

		switch (mode.type) {
			case "missing":
				return;
			case "dynamic-reexport": {
				const from =
					/** @type {ModuleGraphConnection***REMOVED*** */
					(moduleGraph.getConnection(this));
				return {
					exports: true,
					from,
					canMangle: false,
					excludeExports: mode.hidden
						? combine(
								/** @type {ExportModeIgnored***REMOVED*** */ (mode.ignored),
								mode.hidden
							)
						: /** @type {ExportModeIgnored***REMOVED*** */ (mode.ignored),
					hideExports: mode.hidden,
					dependencies: [from.module]
				***REMOVED***;
			***REMOVED***
			case "empty-star":
				return {
					exports: [],
					hideExports: mode.hidden,
					dependencies: [/** @type {Module***REMOVED*** */ (moduleGraph.getModule(this))]
				***REMOVED***;
			// falls through
			case "normal-reexport": {
				const from =
					/** @type {ModuleGraphConnection***REMOVED*** */
					(moduleGraph.getConnection(this));
				return {
					exports: Array.from(
						/** @type {NormalReexportItem[]***REMOVED*** */ (mode.items),
						item => ({
							name: item.name,
							from,
							export: item.ids,
							hidden: item.hidden
						***REMOVED***)
					),
					priority: 1,
					dependencies: [from.module]
				***REMOVED***;
			***REMOVED***
			case "reexport-dynamic-default": {
				const from =
					/** @type {ModuleGraphConnection***REMOVED*** */
					(moduleGraph.getConnection(this));
				return {
					exports: [
						{
							name: /** @type {string***REMOVED*** */ (mode.name),
							from,
							export: ["default"]
						***REMOVED***
					],
					priority: 1,
					dependencies: [from.module]
				***REMOVED***;
			***REMOVED***
			case "reexport-undefined":
				return {
					exports: [/** @type {string***REMOVED*** */ (mode.name)],
					dependencies: [/** @type {Module***REMOVED*** */ (moduleGraph.getModule(this))]
				***REMOVED***;
			case "reexport-fake-namespace-object": {
				const from =
					/** @type {ModuleGraphConnection***REMOVED*** */
					(moduleGraph.getConnection(this));
				return {
					exports: [
						{
							name: /** @type {string***REMOVED*** */ (mode.name),
							from,
							export: null,
							exports: [
								{
									name: "default",
									canMangle: false,
									from,
									export: null
								***REMOVED***
							]
						***REMOVED***
					],
					priority: 1,
					dependencies: [from.module]
				***REMOVED***;
			***REMOVED***
			case "reexport-namespace-object": {
				const from =
					/** @type {ModuleGraphConnection***REMOVED*** */
					(moduleGraph.getConnection(this));
				return {
					exports: [
						{
							name: /** @type {string***REMOVED*** */ (mode.name),
							from,
							export: null
						***REMOVED***
					],
					priority: 1,
					dependencies: [from.module]
				***REMOVED***;
			***REMOVED***
			case "reexport-named-default": {
				const from =
					/** @type {ModuleGraphConnection***REMOVED*** */
					(moduleGraph.getConnection(this));
				return {
					exports: [
						{
							name: /** @type {string***REMOVED*** */ (mode.name),
							from,
							export: ["default"]
						***REMOVED***
					],
					priority: 1,
					dependencies: [from.module]
				***REMOVED***;
			***REMOVED***
			default:
				throw new Error(`Unknown mode ${mode.type***REMOVED***`);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @returns {ExportPresenceMode***REMOVED*** effective mode
	 */
	_getEffectiveExportPresenceLevel(moduleGraph) {
		if (this.exportPresenceMode !== ExportPresenceModes.AUTO)
			return this.exportPresenceMode;
		const module = /** @type {Module***REMOVED*** */ (moduleGraph.getParentModule(this));
		return /** @type {BuildMeta***REMOVED*** */ (module.buildMeta).strictHarmonyModule
			? ExportPresenceModes.ERROR
			: ExportPresenceModes.WARN;
	***REMOVED***

	/**
	 * Returns warnings
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @returns {WebpackError[] | null | undefined***REMOVED*** warnings
	 */
	getWarnings(moduleGraph) {
		const exportsPresence = this._getEffectiveExportPresenceLevel(moduleGraph);
		if (exportsPresence === ExportPresenceModes.WARN) {
			return this._getErrors(moduleGraph);
		***REMOVED***
		return null;
	***REMOVED***

	/**
	 * Returns errors
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @returns {WebpackError[] | null | undefined***REMOVED*** errors
	 */
	getErrors(moduleGraph) {
		const exportsPresence = this._getEffectiveExportPresenceLevel(moduleGraph);
		if (exportsPresence === ExportPresenceModes.ERROR) {
			return this._getErrors(moduleGraph);
		***REMOVED***
		return null;
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @returns {WebpackError[] | undefined***REMOVED*** errors
	 */
	_getErrors(moduleGraph) {
		const ids = this.getIds(moduleGraph);
		let errors = this.getLinkingErrors(
			moduleGraph,
			ids,
			`(reexported as '${this.name***REMOVED***')`
		);
		if (ids.length === 0 && this.name === null) {
			const potentialConflicts =
				this._discoverActiveExportsFromOtherStarExports(moduleGraph);
			if (potentialConflicts && potentialConflicts.namesSlice > 0) {
				const ownNames = new Set(
					potentialConflicts.names.slice(
						potentialConflicts.namesSlice,
						potentialConflicts.dependencyIndices[
							potentialConflicts.dependencyIndex
						]
					)
				);
				const importedModule = moduleGraph.getModule(this);
				if (importedModule) {
					const exportsInfo = moduleGraph.getExportsInfo(importedModule);
					/** @type {Map<string, string[]>***REMOVED*** */
					const conflicts = new Map();
					for (const exportInfo of exportsInfo.orderedExports) {
						if (exportInfo.provided !== true) continue;
						if (exportInfo.name === "default") continue;
						if (this.activeExports.has(exportInfo.name)) continue;
						if (ownNames.has(exportInfo.name)) continue;
						const conflictingDependency = findDependencyForName(
							potentialConflicts,
							exportInfo.name,
							this.allStarExports
								? this.allStarExports.dependencies
								: [
										.../** @type {Iterable<HarmonyExportImportedSpecifierDependency>***REMOVED*** */
										(this.otherStarExports),
										this
									]
						);
						if (!conflictingDependency) continue;
						const target = exportInfo.getTerminalBinding(moduleGraph);
						if (!target) continue;
						const conflictingModule =
							/** @type {Module***REMOVED*** */
							(moduleGraph.getModule(conflictingDependency));
						if (conflictingModule === importedModule) continue;
						const conflictingExportInfo = moduleGraph.getExportInfo(
							conflictingModule,
							exportInfo.name
						);
						const conflictingTarget =
							conflictingExportInfo.getTerminalBinding(moduleGraph);
						if (!conflictingTarget) continue;
						if (target === conflictingTarget) continue;
						const list = conflicts.get(conflictingDependency.request);
						if (list === undefined) {
							conflicts.set(conflictingDependency.request, [exportInfo.name]);
						***REMOVED*** else {
							list.push(exportInfo.name);
						***REMOVED***
					***REMOVED***
					for (const [request, exports] of conflicts) {
						if (!errors) errors = [];
						errors.push(
							new HarmonyLinkingError(
								`The requested module '${
									this.request
								***REMOVED***' contains conflicting star exports for the ${
									exports.length > 1 ? "names" : "name"
								***REMOVED*** ${exports
									.map(e => `'${e***REMOVED***'`)
									.join(", ")***REMOVED*** with the previous requested module '${request***REMOVED***'`
							)
						);
					***REMOVED***
				***REMOVED***
			***REMOVED***
		***REMOVED***
		return errors;
	***REMOVED***

	/**
	 * @param {ObjectSerializerContext***REMOVED*** context context
	 */
	serialize(context) {
		const { write, setCircularReference ***REMOVED*** = context;

		setCircularReference(this);
		write(this.ids);
		write(this.name);
		write(this.activeExports);
		write(this.otherStarExports);
		write(this.exportPresenceMode);
		write(this.allStarExports);

		super.serialize(context);
	***REMOVED***

	/**
	 * @param {ObjectDeserializerContext***REMOVED*** context context
	 */
	deserialize(context) {
		const { read, setCircularReference ***REMOVED*** = context;

		setCircularReference(this);
		this.ids = read();
		this.name = read();
		this.activeExports = read();
		this.otherStarExports = read();
		this.exportPresenceMode = read();
		this.allStarExports = read();

		super.deserialize(context);
	***REMOVED***
***REMOVED***

makeSerializable(
	HarmonyExportImportedSpecifierDependency,
	"webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency"
);

module.exports = HarmonyExportImportedSpecifierDependency;

HarmonyExportImportedSpecifierDependency.Template = class HarmonyExportImportedSpecifierDependencyTemplate extends (
	HarmonyImportDependency.Template
) {
	/**
	 * @param {Dependency***REMOVED*** dependency the dependency for which the template should be applied
	 * @param {ReplaceSource***REMOVED*** source the current replace source which can be modified
	 * @param {DependencyTemplateContext***REMOVED*** templateContext the context object
	 * @returns {void***REMOVED***
	 */
	apply(dependency, source, templateContext) {
		const { moduleGraph, runtime, concatenationScope ***REMOVED*** = templateContext;

		const dep = /** @type {HarmonyExportImportedSpecifierDependency***REMOVED*** */ (
			dependency
		);

		const mode = dep.getMode(moduleGraph, runtime);

		if (concatenationScope) {
			switch (mode.type) {
				case "reexport-undefined":
					concatenationScope.registerRawExport(
						/** @type {NonNullable<ExportMode["name"]>***REMOVED*** */ (mode.name),
						"/* reexport non-default export from non-harmony */ undefined"
					);
			***REMOVED***
			return;
		***REMOVED***

		if (mode.type !== "unused" && mode.type !== "empty-star") {
			super.apply(dependency, source, templateContext);

			this._addExportFragments(
				templateContext.initFragments,
				dep,
				mode,
				templateContext.module,
				moduleGraph,
				runtime,
				templateContext.runtimeTemplate,
				templateContext.runtimeRequirements
			);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {InitFragment<GenerateContext>[]***REMOVED*** initFragments target array for init fragments
	 * @param {HarmonyExportImportedSpecifierDependency***REMOVED*** dep dependency
	 * @param {ExportMode***REMOVED*** mode the export mode
	 * @param {Module***REMOVED*** module the current module
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @param {RuntimeTemplate***REMOVED*** runtimeTemplate the runtime template
	 * @param {RuntimeRequirements***REMOVED*** runtimeRequirements runtime requirements
	 * @returns {void***REMOVED***
	 */
	_addExportFragments(
		initFragments,
		dep,
		mode,
		module,
		moduleGraph,
		runtime,
		runtimeTemplate,
		runtimeRequirements
	) {
		const importedModule = /** @type {Module***REMOVED*** */ (moduleGraph.getModule(dep));
		const importVar = dep.getImportVar(moduleGraph);

		switch (mode.type) {
			case "missing":
			case "empty-star":
				initFragments.push(
					new InitFragment(
						"/* empty/unused harmony star reexport */\n",
						InitFragment.STAGE_HARMONY_EXPORTS,
						1
					)
				);
				break;

			case "unused":
				initFragments.push(
					new InitFragment(
						`${Template.toNormalComment(
							`unused harmony reexport ${mode.name***REMOVED***`
						)***REMOVED***\n`,
						InitFragment.STAGE_HARMONY_EXPORTS,
						1
					)
				);
				break;

			case "reexport-dynamic-default":
				initFragments.push(
					this.getReexportFragment(
						module,
						"reexport default from dynamic",
						moduleGraph
							.getExportsInfo(module)
							.getUsedName(/** @type {string***REMOVED*** */ (mode.name), runtime),
						importVar,
						null,
						runtimeRequirements
					)
				);
				break;

			case "reexport-fake-namespace-object":
				initFragments.push(
					...this.getReexportFakeNamespaceObjectFragments(
						module,
						moduleGraph
							.getExportsInfo(module)
							.getUsedName(/** @type {string***REMOVED*** */ (mode.name), runtime),
						importVar,
						mode.fakeType,
						runtimeRequirements
					)
				);
				break;

			case "reexport-undefined":
				initFragments.push(
					this.getReexportFragment(
						module,
						"reexport non-default export from non-harmony",
						moduleGraph
							.getExportsInfo(module)
							.getUsedName(/** @type {string***REMOVED*** */ (mode.name), runtime),
						"undefined",
						"",
						runtimeRequirements
					)
				);
				break;

			case "reexport-named-default":
				initFragments.push(
					this.getReexportFragment(
						module,
						"reexport default export from named module",
						moduleGraph
							.getExportsInfo(module)
							.getUsedName(/** @type {string***REMOVED*** */ (mode.name), runtime),
						importVar,
						"",
						runtimeRequirements
					)
				);
				break;

			case "reexport-namespace-object":
				initFragments.push(
					this.getReexportFragment(
						module,
						"reexport module object",
						moduleGraph
							.getExportsInfo(module)
							.getUsedName(/** @type {string***REMOVED*** */ (mode.name), runtime),
						importVar,
						"",
						runtimeRequirements
					)
				);
				break;

			case "normal-reexport":
				for (const {
					name,
					ids,
					checked,
					hidden
				***REMOVED*** of /** @type {NormalReexportItem[]***REMOVED*** */ (mode.items)) {
					if (hidden) continue;
					if (checked) {
						const connection = moduleGraph.getConnection(dep);
						const key = `harmony reexport (checked) ${importVar***REMOVED*** ${name***REMOVED***`;
						const runtimeCondition = dep.weak
							? false
							: connection
								? filterRuntime(runtime, r => connection.isTargetActive(r))
								: true;
						initFragments.push(
							new ConditionalInitFragment(
								`/* harmony reexport (checked) */ ${this.getConditionalReexportStatement(
									module,
									name,
									importVar,
									ids,
									runtimeRequirements
								)***REMOVED***`,
								moduleGraph.isAsync(importedModule)
									? InitFragment.STAGE_ASYNC_HARMONY_IMPORTS
									: InitFragment.STAGE_HARMONY_IMPORTS,
								dep.sourceOrder,
								key,
								runtimeCondition
							)
						);
					***REMOVED*** else {
						initFragments.push(
							this.getReexportFragment(
								module,
								"reexport safe",
								moduleGraph.getExportsInfo(module).getUsedName(name, runtime),
								importVar,
								moduleGraph
									.getExportsInfo(importedModule)
									.getUsedName(ids, runtime),
								runtimeRequirements
							)
						);
					***REMOVED***
				***REMOVED***
				break;

			case "dynamic-reexport": {
				const ignored = mode.hidden
					? combine(
							/** @type {ExportModeIgnored***REMOVED*** */
							(mode.ignored),
							mode.hidden
						)
					: /** @type {ExportModeIgnored***REMOVED*** */ (mode.ignored);
				const modern =
					runtimeTemplate.supportsConst() &&
					runtimeTemplate.supportsArrowFunction();
				let content =
					"/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {***REMOVED***;\n" +
					`/* harmony reexport (unknown) */ for(${
						modern ? "const" : "var"
					***REMOVED*** __WEBPACK_IMPORT_KEY__ in ${importVar***REMOVED***) `;

				// Filter out exports which are defined by other exports
				// and filter out default export because it cannot be reexported with *
				if (ignored.size > 1) {
					content += `if(${JSON.stringify(
						Array.from(ignored)
					)***REMOVED***.indexOf(__WEBPACK_IMPORT_KEY__) < 0) `;
				***REMOVED*** else if (ignored.size === 1) {
					content += `if(__WEBPACK_IMPORT_KEY__ !== ${JSON.stringify(
						first(ignored)
					)***REMOVED***) `;
				***REMOVED***

				content += "__WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = ";
				content += modern
					? `() => ${importVar***REMOVED***[__WEBPACK_IMPORT_KEY__]`
					: `function(key) { return ${importVar***REMOVED***[key]; ***REMOVED***.bind(0, __WEBPACK_IMPORT_KEY__)`;

				runtimeRequirements.add(RuntimeGlobals.exports);
				runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);

				const exportsName = module.exportsArgument;
				initFragments.push(
					new InitFragment(
						`${content***REMOVED***\n/* harmony reexport (unknown) */ ${RuntimeGlobals.definePropertyGetters***REMOVED***(${exportsName***REMOVED***, __WEBPACK_REEXPORT_OBJECT__);\n`,
						moduleGraph.isAsync(importedModule)
							? InitFragment.STAGE_ASYNC_HARMONY_IMPORTS
							: InitFragment.STAGE_HARMONY_IMPORTS,
						dep.sourceOrder
					)
				);
				break;
			***REMOVED***

			default:
				throw new Error(`Unknown mode ${mode.type***REMOVED***`);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the current module
	 * @param {string***REMOVED*** comment comment
	 * @param {UsedName***REMOVED*** key key
	 * @param {string***REMOVED*** name name
	 * @param {string | string[] | null | false***REMOVED*** valueKey value key
	 * @param {RuntimeRequirements***REMOVED*** runtimeRequirements runtime requirements
	 * @returns {HarmonyExportInitFragment***REMOVED*** harmony export init fragment
	 */
	getReexportFragment(
		module,
		comment,
		key,
		name,
		valueKey,
		runtimeRequirements
	) {
		const returnValue = this.getReturnValue(name, valueKey);

		runtimeRequirements.add(RuntimeGlobals.exports);
		runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);

		const map = new Map();
		map.set(key, `/* ${comment***REMOVED*** */ ${returnValue***REMOVED***`);

		return new HarmonyExportInitFragment(module.exportsArgument, map);
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module module
	 * @param {string | string[] | false***REMOVED*** key key
	 * @param {string***REMOVED*** name name
	 * @param {number***REMOVED*** fakeType fake type
	 * @param {RuntimeRequirements***REMOVED*** runtimeRequirements runtime requirements
	 * @returns {[InitFragment<GenerateContext>, HarmonyExportInitFragment]***REMOVED*** init fragments
	 */
	getReexportFakeNamespaceObjectFragments(
		module,
		key,
		name,
		fakeType,
		runtimeRequirements
	) {
		runtimeRequirements.add(RuntimeGlobals.exports);
		runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);
		runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);

		const map = new Map();
		map.set(
			key,
			`/* reexport fake namespace object from non-harmony */ ${name***REMOVED***_namespace_cache || (${name***REMOVED***_namespace_cache = ${
				RuntimeGlobals.createFakeNamespaceObject
			***REMOVED***(${name***REMOVED***${fakeType ? `, ${fakeType***REMOVED***` : ""***REMOVED***))`
		);

		return [
			new InitFragment(
				`var ${name***REMOVED***_namespace_cache;\n`,
				InitFragment.STAGE_CONSTANTS,
				-1,
				`${name***REMOVED***_namespace_cache`
			),
			new HarmonyExportInitFragment(module.exportsArgument, map)
		];
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module module
	 * @param {string***REMOVED*** key key
	 * @param {string***REMOVED*** name name
	 * @param {string | string[] | false***REMOVED*** valueKey value key
	 * @param {RuntimeRequirements***REMOVED*** runtimeRequirements runtime requirements
	 * @returns {string***REMOVED*** result
	 */
	getConditionalReexportStatement(
		module,
		key,
		name,
		valueKey,
		runtimeRequirements
	) {
		if (valueKey === false) {
			return "/* unused export */\n";
		***REMOVED***

		const exportsName = module.exportsArgument;
		const returnValue = this.getReturnValue(name, valueKey);

		runtimeRequirements.add(RuntimeGlobals.exports);
		runtimeRequirements.add(RuntimeGlobals.definePropertyGetters);
		runtimeRequirements.add(RuntimeGlobals.hasOwnProperty);

		return `if(${RuntimeGlobals.hasOwnProperty***REMOVED***(${name***REMOVED***, ${JSON.stringify(
			valueKey[0]
		)***REMOVED***)) ${
			RuntimeGlobals.definePropertyGetters
		***REMOVED***(${exportsName***REMOVED***, { ${propertyName(
			key
		)***REMOVED***: function() { return ${returnValue***REMOVED***; ***REMOVED*** ***REMOVED***);\n`;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** name name
	 * @param {null | false | string | string[]***REMOVED*** valueKey value key
	 * @returns {string | undefined***REMOVED*** value
	 */
	getReturnValue(name, valueKey) {
		if (valueKey === null) {
			return `${name***REMOVED***_default.a`;
		***REMOVED***

		if (valueKey === "") {
			return name;
		***REMOVED***

		if (valueKey === false) {
			return "/* unused export */ undefined";
		***REMOVED***

		return `${name***REMOVED***${propertyAccess(valueKey)***REMOVED***`;
	***REMOVED***
***REMOVED***;

class HarmonyStarExportsList {
	constructor() {
		/** @type {HarmonyExportImportedSpecifierDependency[]***REMOVED*** */
		this.dependencies = [];
	***REMOVED***

	/**
	 * @param {HarmonyExportImportedSpecifierDependency***REMOVED*** dep dependency
	 * @returns {void***REMOVED***
	 */
	push(dep) {
		this.dependencies.push(dep);
	***REMOVED***

	slice() {
		return this.dependencies.slice();
	***REMOVED***

	/**
	 * @param {ObjectSerializerContext***REMOVED*** context context
	 */
	serialize({ write, setCircularReference ***REMOVED***) {
		setCircularReference(this);
		write(this.dependencies);
	***REMOVED***

	/**
	 * @param {ObjectDeserializerContext***REMOVED*** context context
	 */
	deserialize({ read, setCircularReference ***REMOVED***) {
		setCircularReference(this);
		this.dependencies = read();
	***REMOVED***
***REMOVED***

makeSerializable(
	HarmonyStarExportsList,
	"webpack/lib/dependencies/HarmonyExportImportedSpecifierDependency",
	"HarmonyStarExportsList"
);

module.exports.HarmonyStarExportsList = HarmonyStarExportsList;
