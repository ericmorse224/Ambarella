/**
 * @fileoverview Prefer destructuring from arrays and objects
 * @author Alex LaFroscia
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const PRECEDENCE_OF_ASSIGNMENT_EXPR = astUtils.getPrecedence({ type: "AssignmentExpression" ***REMOVED***);

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule***REMOVED*** */
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "Require destructuring from arrays and/or objects",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/prefer-destructuring"
        ***REMOVED***,

        fixable: "code",

        schema: [
            {

                /*
                 * old support {array: Boolean, object: Boolean***REMOVED***
                 * new support {VariableDeclarator: {***REMOVED***, AssignmentExpression: {***REMOVED******REMOVED***
                 */
                oneOf: [
                    {
                        type: "object",
                        properties: {
                            VariableDeclarator: {
                                type: "object",
                                properties: {
                                    array: {
                                        type: "boolean"
                                    ***REMOVED***,
                                    object: {
                                        type: "boolean"
                                    ***REMOVED***
                                ***REMOVED***,
                                additionalProperties: false
                            ***REMOVED***,
                            AssignmentExpression: {
                                type: "object",
                                properties: {
                                    array: {
                                        type: "boolean"
                                    ***REMOVED***,
                                    object: {
                                        type: "boolean"
                                    ***REMOVED***
                                ***REMOVED***,
                                additionalProperties: false
                            ***REMOVED***
                        ***REMOVED***,
                        additionalProperties: false
                    ***REMOVED***,
                    {
                        type: "object",
                        properties: {
                            array: {
                                type: "boolean"
                            ***REMOVED***,
                            object: {
                                type: "boolean"
                            ***REMOVED***
                        ***REMOVED***,
                        additionalProperties: false
                    ***REMOVED***
                ]
            ***REMOVED***,
            {
                type: "object",
                properties: {
                    enforceForRenamedProperties: {
                        type: "boolean"
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],

        messages: {
            preferDestructuring: "Use {{type***REMOVED******REMOVED*** destructuring."
        ***REMOVED***
    ***REMOVED***,
    create(context) {

        const enabledTypes = context.options[0];
        const enforceForRenamedProperties = context.options[1] && context.options[1].enforceForRenamedProperties;
        let normalizedOptions = {
            VariableDeclarator: { array: true, object: true ***REMOVED***,
            AssignmentExpression: { array: true, object: true ***REMOVED***
        ***REMOVED***;

        if (enabledTypes) {
            normalizedOptions = typeof enabledTypes.array !== "undefined" || typeof enabledTypes.object !== "undefined"
                ? { VariableDeclarator: enabledTypes, AssignmentExpression: enabledTypes ***REMOVED***
                : enabledTypes;
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Checks if destructuring type should be checked.
         * @param {string***REMOVED*** nodeType "AssignmentExpression" or "VariableDeclarator"
         * @param {string***REMOVED*** destructuringType "array" or "object"
         * @returns {boolean***REMOVED*** `true` if the destructuring type should be checked for the given node
         */
        function shouldCheck(nodeType, destructuringType) {
            return normalizedOptions &&
                normalizedOptions[nodeType] &&
                normalizedOptions[nodeType][destructuringType];
        ***REMOVED***

        /**
         * Determines if the given node is accessing an array index
         *
         * This is used to differentiate array index access from object property
         * access.
         * @param {ASTNode***REMOVED*** node the node to evaluate
         * @returns {boolean***REMOVED*** whether or not the node is an integer
         */
        function isArrayIndexAccess(node) {
            return Number.isInteger(node.property.value);
        ***REMOVED***

        /**
         * Report that the given node should use destructuring
         * @param {ASTNode***REMOVED*** reportNode the node to report
         * @param {string***REMOVED*** type the type of destructuring that should have been done
         * @param {Function|null***REMOVED*** fix the fix function or null to pass to context.report
         * @returns {void***REMOVED***
         */
        function report(reportNode, type, fix) {
            context.report({
                node: reportNode,
                messageId: "preferDestructuring",
                data: { type ***REMOVED***,
                fix
            ***REMOVED***);
        ***REMOVED***

        /**
         * Determines if a node should be fixed into object destructuring
         *
         * The fixer only fixes the simplest case of object destructuring,
         * like: `let x = a.x`;
         *
         * Assignment expression is not fixed.
         * Array destructuring is not fixed.
         * Renamed property is not fixed.
         * @param {ASTNode***REMOVED*** node the node to evaluate
         * @returns {boolean***REMOVED*** whether or not the node should be fixed
         */
        function shouldFix(node) {
            return node.type === "VariableDeclarator" &&
                node.id.type === "Identifier" &&
                node.init.type === "MemberExpression" &&
                !node.init.computed &&
                node.init.property.type === "Identifier" &&
                node.id.name === node.init.property.name;
        ***REMOVED***

        /**
         * Fix a node into object destructuring.
         * This function only handles the simplest case of object destructuring,
         * see {@link shouldFix***REMOVED***.
         * @param {SourceCodeFixer***REMOVED*** fixer the fixer object
         * @param {ASTNode***REMOVED*** node the node to be fixed.
         * @returns {Object***REMOVED*** a fix for the node
         */
        function fixIntoObjectDestructuring(fixer, node) {
            const rightNode = node.init;
            const sourceCode = context.sourceCode;

            // Don't fix if that would remove any comments. Only comments inside `rightNode.object` can be preserved.
            if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(rightNode.object).length) {
                return null;
            ***REMOVED***

            let objectText = sourceCode.getText(rightNode.object);

            if (astUtils.getPrecedence(rightNode.object) < PRECEDENCE_OF_ASSIGNMENT_EXPR) {
                objectText = `(${objectText***REMOVED***)`;
            ***REMOVED***

            return fixer.replaceText(
                node,
                `{${rightNode.property.name***REMOVED******REMOVED*** = ${objectText***REMOVED***`
            );
        ***REMOVED***

        /**
         * Check that the `prefer-destructuring` rules are followed based on the
         * given left- and right-hand side of the assignment.
         *
         * Pulled out into a separate method so that VariableDeclarators and
         * AssignmentExpressions can share the same verification logic.
         * @param {ASTNode***REMOVED*** leftNode the left-hand side of the assignment
         * @param {ASTNode***REMOVED*** rightNode the right-hand side of the assignment
         * @param {ASTNode***REMOVED*** reportNode the node to report the error on
         * @returns {void***REMOVED***
         */
        function performCheck(leftNode, rightNode, reportNode) {
            if (
                rightNode.type !== "MemberExpression" ||
                rightNode.object.type === "Super" ||
                rightNode.property.type === "PrivateIdentifier"
            ) {
                return;
            ***REMOVED***

            if (isArrayIndexAccess(rightNode)) {
                if (shouldCheck(reportNode.type, "array")) {
                    report(reportNode, "array", null);
                ***REMOVED***
                return;
            ***REMOVED***

            const fix = shouldFix(reportNode)
                ? fixer => fixIntoObjectDestructuring(fixer, reportNode)
                : null;

            if (shouldCheck(reportNode.type, "object") && enforceForRenamedProperties) {
                report(reportNode, "object", fix);
                return;
            ***REMOVED***

            if (shouldCheck(reportNode.type, "object")) {
                const property = rightNode.property;

                if (
                    (property.type === "Literal" && leftNode.name === property.value) ||
                    (property.type === "Identifier" && leftNode.name === property.name && !rightNode.computed)
                ) {
                    report(reportNode, "object", fix);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Check if a given variable declarator is coming from an property access
         * that should be using destructuring instead
         * @param {ASTNode***REMOVED*** node the variable declarator to check
         * @returns {void***REMOVED***
         */
        function checkVariableDeclarator(node) {

            // Skip if variable is declared without assignment
            if (!node.init) {
                return;
            ***REMOVED***

            // We only care about member expressions past this point
            if (node.init.type !== "MemberExpression") {
                return;
            ***REMOVED***

            performCheck(node.id, node.init, node);
        ***REMOVED***

        /**
         * Run the `prefer-destructuring` check on an AssignmentExpression
         * @param {ASTNode***REMOVED*** node the AssignmentExpression node
         * @returns {void***REMOVED***
         */
        function checkAssignmentExpression(node) {
            if (node.operator === "=") {
                performCheck(node.left, node.right, node);
            ***REMOVED***
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return {
            VariableDeclarator: checkVariableDeclarator,
            AssignmentExpression: checkAssignmentExpression
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
