/**
 * @fileoverview Rule to control usage of strict mode directives.
 * @author Brandon Mills
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Gets all of the Use Strict Directives in the Directive Prologue of a group of
 * statements.
 * @param {ASTNode[]***REMOVED*** statements Statements in the program or function body.
 * @returns {ASTNode[]***REMOVED*** All of the Use Strict Directives.
 */
function getUseStrictDirectives(statements) {
    const directives = [];

    for (let i = 0; i < statements.length; i++) {
        const statement = statements[i];

        if (
            statement.type === "ExpressionStatement" &&
            statement.expression.type === "Literal" &&
            statement.expression.value === "use strict"
        ) {
            directives[i] = statement;
        ***REMOVED*** else {
            break;
        ***REMOVED***
    ***REMOVED***

    return directives;
***REMOVED***

/**
 * Checks whether a given parameter is a simple parameter.
 * @param {ASTNode***REMOVED*** node A pattern node to check.
 * @returns {boolean***REMOVED*** `true` if the node is an Identifier node.
 */
function isSimpleParameter(node) {
    return node.type === "Identifier";
***REMOVED***

/**
 * Checks whether a given parameter list is a simple parameter list.
 * @param {ASTNode[]***REMOVED*** params A parameter list to check.
 * @returns {boolean***REMOVED*** `true` if the every parameter is an Identifier node.
 */
function isSimpleParameterList(params) {
    return params.every(isSimpleParameter);
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "require or disallow strict mode directives",
            category: "Strict Mode",
            recommended: false,
            url: "https://eslint.org/docs/rules/strict"
        ***REMOVED***,

        schema: [
            {
                enum: ["never", "global", "function", "safe"]
            ***REMOVED***
        ],

        fixable: "code",
        messages: {
            function: "Use the function form of 'use strict'.",
            global: "Use the global form of 'use strict'.",
            multiple: "Multiple 'use strict' directives.",
            never: "Strict mode is not permitted.",
            unnecessary: "Unnecessary 'use strict' directive.",
            module: "'use strict' is unnecessary inside of modules.",
            implied: "'use strict' is unnecessary when implied strict mode is enabled.",
            unnecessaryInClasses: "'use strict' is unnecessary inside of classes.",
            nonSimpleParameterList: "'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.",
            wrap: "Wrap {{name***REMOVED******REMOVED*** in a function with 'use strict' directive."
        ***REMOVED***
    ***REMOVED***,

    create(context) {

        const ecmaFeatures = context.parserOptions.ecmaFeatures || {***REMOVED***,
            scopes = [],
            classScopes = [];
        let mode = context.options[0] || "safe";

        if (ecmaFeatures.impliedStrict) {
            mode = "implied";
        ***REMOVED*** else if (mode === "safe") {
            mode = ecmaFeatures.globalReturn ? "global" : "function";
        ***REMOVED***

        /**
         * Determines whether a reported error should be fixed, depending on the error type.
         * @param {string***REMOVED*** errorType The type of error
         * @returns {boolean***REMOVED*** `true` if the reported error should be fixed
         */
        function shouldFix(errorType) {
            return errorType === "multiple" || errorType === "unnecessary" || errorType === "module" || errorType === "implied" || errorType === "unnecessaryInClasses";
        ***REMOVED***

        /**
         * Gets a fixer function to remove a given 'use strict' directive.
         * @param {ASTNode***REMOVED*** node The directive that should be removed
         * @returns {Function***REMOVED*** A fixer function
         */
        function getFixFunction(node) {
            return fixer => fixer.remove(node);
        ***REMOVED***

        /**
         * Report a slice of an array of nodes with a given message.
         * @param {ASTNode[]***REMOVED*** nodes Nodes.
         * @param {string***REMOVED*** start Index to start from.
         * @param {string***REMOVED*** end Index to end before.
         * @param {string***REMOVED*** messageId Message to display.
         * @param {boolean***REMOVED*** fix `true` if the directive should be fixed (i.e. removed)
         * @returns {void***REMOVED***
         */
        function reportSlice(nodes, start, end, messageId, fix) {
            nodes.slice(start, end).forEach(node => {
                context.report({ node, messageId, fix: fix ? getFixFunction(node) : null ***REMOVED***);
            ***REMOVED***);
        ***REMOVED***

        /**
         * Report all nodes in an array with a given message.
         * @param {ASTNode[]***REMOVED*** nodes Nodes.
         * @param {string***REMOVED*** messageId Message id to display.
         * @param {boolean***REMOVED*** fix `true` if the directive should be fixed (i.e. removed)
         * @returns {void***REMOVED***
         */
        function reportAll(nodes, messageId, fix) {
            reportSlice(nodes, 0, nodes.length, messageId, fix);
        ***REMOVED***

        /**
         * Report all nodes in an array, except the first, with a given message.
         * @param {ASTNode[]***REMOVED*** nodes Nodes.
         * @param {string***REMOVED*** messageId Message id to display.
         * @param {boolean***REMOVED*** fix `true` if the directive should be fixed (i.e. removed)
         * @returns {void***REMOVED***
         */
        function reportAllExceptFirst(nodes, messageId, fix) {
            reportSlice(nodes, 1, nodes.length, messageId, fix);
        ***REMOVED***

        /**
         * Entering a function in 'function' mode pushes a new nested scope onto the
         * stack. The new scope is true if the nested function is strict mode code.
         * @param {ASTNode***REMOVED*** node The function declaration or expression.
         * @param {ASTNode[]***REMOVED*** useStrictDirectives The Use Strict Directives of the node.
         * @returns {void***REMOVED***
         */
        function enterFunctionInFunctionMode(node, useStrictDirectives) {
            const isInClass = classScopes.length > 0,
                isParentGlobal = scopes.length === 0 && classScopes.length === 0,
                isParentStrict = scopes.length > 0 && scopes[scopes.length - 1],
                isStrict = useStrictDirectives.length > 0;

            if (isStrict) {
                if (!isSimpleParameterList(node.params)) {
                    context.report({ node: useStrictDirectives[0], messageId: "nonSimpleParameterList" ***REMOVED***);
                ***REMOVED*** else if (isParentStrict) {
                    context.report({ node: useStrictDirectives[0], messageId: "unnecessary", fix: getFixFunction(useStrictDirectives[0]) ***REMOVED***);
                ***REMOVED*** else if (isInClass) {
                    context.report({ node: useStrictDirectives[0], messageId: "unnecessaryInClasses", fix: getFixFunction(useStrictDirectives[0]) ***REMOVED***);
                ***REMOVED***

                reportAllExceptFirst(useStrictDirectives, "multiple", true);
            ***REMOVED*** else if (isParentGlobal) {
                if (isSimpleParameterList(node.params)) {
                    context.report({ node, messageId: "function" ***REMOVED***);
                ***REMOVED*** else {
                    context.report({
                        node,
                        messageId: "wrap",
                        data: { name: astUtils.getFunctionNameWithKind(node) ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***

            scopes.push(isParentStrict || isStrict);
        ***REMOVED***

        /**
         * Exiting a function in 'function' mode pops its scope off the stack.
         * @returns {void***REMOVED***
         */
        function exitFunctionInFunctionMode() {
            scopes.pop();
        ***REMOVED***

        /**
         * Enter a function and either:
         * - Push a new nested scope onto the stack (in 'function' mode).
         * - Report all the Use Strict Directives (in the other modes).
         * @param {ASTNode***REMOVED*** node The function declaration or expression.
         * @returns {void***REMOVED***
         */
        function enterFunction(node) {
            const isBlock = node.body.type === "BlockStatement",
                useStrictDirectives = isBlock
                    ? getUseStrictDirectives(node.body.body) : [];

            if (mode === "function") {
                enterFunctionInFunctionMode(node, useStrictDirectives);
            ***REMOVED*** else if (useStrictDirectives.length > 0) {
                if (isSimpleParameterList(node.params)) {
                    reportAll(useStrictDirectives, mode, shouldFix(mode));
                ***REMOVED*** else {
                    context.report({ node: useStrictDirectives[0], messageId: "nonSimpleParameterList" ***REMOVED***);
                    reportAllExceptFirst(useStrictDirectives, "multiple", true);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        const rule = {
            Program(node) {
                const useStrictDirectives = getUseStrictDirectives(node.body);

                if (node.sourceType === "module") {
                    mode = "module";
                ***REMOVED***

                if (mode === "global") {
                    if (node.body.length > 0 && useStrictDirectives.length === 0) {
                        context.report({ node, messageId: "global" ***REMOVED***);
                    ***REMOVED***
                    reportAllExceptFirst(useStrictDirectives, "multiple", true);
                ***REMOVED*** else {
                    reportAll(useStrictDirectives, mode, shouldFix(mode));
                ***REMOVED***
            ***REMOVED***,
            FunctionDeclaration: enterFunction,
            FunctionExpression: enterFunction,
            ArrowFunctionExpression: enterFunction
        ***REMOVED***;

        if (mode === "function") {
            Object.assign(rule, {

                // Inside of class bodies are always strict mode.
                ClassBody() {
                    classScopes.push(true);
                ***REMOVED***,
                "ClassBody:exit"() {
                    classScopes.pop();
                ***REMOVED***,

                "FunctionDeclaration:exit": exitFunctionInFunctionMode,
                "FunctionExpression:exit": exitFunctionInFunctionMode,
                "ArrowFunctionExpression:exit": exitFunctionInFunctionMode
            ***REMOVED***);
        ***REMOVED***

        return rule;
    ***REMOVED***
***REMOVED***;
