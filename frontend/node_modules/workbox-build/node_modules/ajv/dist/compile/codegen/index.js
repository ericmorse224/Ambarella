"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
const code_1 = require("./code");
const scope_1 = require("./scope");
var code_2 = require("./code");
Object.defineProperty(exports, "_", { enumerable: true, get: function () { return code_2._; ***REMOVED*** ***REMOVED***);
Object.defineProperty(exports, "str", { enumerable: true, get: function () { return code_2.str; ***REMOVED*** ***REMOVED***);
Object.defineProperty(exports, "strConcat", { enumerable: true, get: function () { return code_2.strConcat; ***REMOVED*** ***REMOVED***);
Object.defineProperty(exports, "nil", { enumerable: true, get: function () { return code_2.nil; ***REMOVED*** ***REMOVED***);
Object.defineProperty(exports, "getProperty", { enumerable: true, get: function () { return code_2.getProperty; ***REMOVED*** ***REMOVED***);
Object.defineProperty(exports, "stringify", { enumerable: true, get: function () { return code_2.stringify; ***REMOVED*** ***REMOVED***);
Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function () { return code_2.regexpCode; ***REMOVED*** ***REMOVED***);
Object.defineProperty(exports, "Name", { enumerable: true, get: function () { return code_2.Name; ***REMOVED*** ***REMOVED***);
var scope_2 = require("./scope");
Object.defineProperty(exports, "Scope", { enumerable: true, get: function () { return scope_2.Scope; ***REMOVED*** ***REMOVED***);
Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function () { return scope_2.ValueScope; ***REMOVED*** ***REMOVED***);
Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function () { return scope_2.ValueScopeName; ***REMOVED*** ***REMOVED***);
Object.defineProperty(exports, "varKinds", { enumerable: true, get: function () { return scope_2.varKinds; ***REMOVED*** ***REMOVED***);
exports.operators = {
    GT: new code_1._Code(">"),
    GTE: new code_1._Code(">="),
    LT: new code_1._Code("<"),
    LTE: new code_1._Code("<="),
    EQ: new code_1._Code("==="),
    NEQ: new code_1._Code("!=="),
    NOT: new code_1._Code("!"),
    OR: new code_1._Code("||"),
    AND: new code_1._Code("&&"),
    ADD: new code_1._Code("+"),
***REMOVED***;
class Node {
    optimizeNodes() {
        return this;
    ***REMOVED***
    optimizeNames(_names, _constants) {
        return this;
    ***REMOVED***
***REMOVED***
class Def extends Node {
    constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
    ***REMOVED***
    render({ es5, _n ***REMOVED***) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === undefined ? "" : ` = ${this.rhs***REMOVED***`;
        return `${varKind***REMOVED*** ${this.name***REMOVED***${rhs***REMOVED***;` + _n;
    ***REMOVED***
    optimizeNames(names, constants) {
        if (!names[this.name.str])
            return;
        if (this.rhs)
            this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
    ***REMOVED***
    get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {***REMOVED***;
    ***REMOVED***
***REMOVED***
class Assign extends Node {
    constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
    ***REMOVED***
    render({ _n ***REMOVED***) {
        return `${this.lhs***REMOVED*** = ${this.rhs***REMOVED***;` + _n;
    ***REMOVED***
    optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
            return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
    ***REMOVED***
    get names() {
        const names = this.lhs instanceof code_1.Name ? {***REMOVED*** : { ...this.lhs.names ***REMOVED***;
        return addExprNames(names, this.rhs);
    ***REMOVED***
***REMOVED***
class AssignOp extends Assign {
    constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
    ***REMOVED***
    render({ _n ***REMOVED***) {
        return `${this.lhs***REMOVED*** ${this.op***REMOVED***= ${this.rhs***REMOVED***;` + _n;
    ***REMOVED***
***REMOVED***
class Label extends Node {
    constructor(label) {
        super();
        this.label = label;
        this.names = {***REMOVED***;
    ***REMOVED***
    render({ _n ***REMOVED***) {
        return `${this.label***REMOVED***:` + _n;
    ***REMOVED***
***REMOVED***
class Break extends Node {
    constructor(label) {
        super();
        this.label = label;
        this.names = {***REMOVED***;
    ***REMOVED***
    render({ _n ***REMOVED***) {
        const label = this.label ? ` ${this.label***REMOVED***` : "";
        return `break${label***REMOVED***;` + _n;
    ***REMOVED***
***REMOVED***
class Throw extends Node {
    constructor(error) {
        super();
        this.error = error;
    ***REMOVED***
    render({ _n ***REMOVED***) {
        return `throw ${this.error***REMOVED***;` + _n;
    ***REMOVED***
    get names() {
        return this.error.names;
    ***REMOVED***
***REMOVED***
class AnyCode extends Node {
    constructor(code) {
        super();
        this.code = code;
    ***REMOVED***
    render({ _n ***REMOVED***) {
        return `${this.code***REMOVED***;` + _n;
    ***REMOVED***
    optimizeNodes() {
        return `${this.code***REMOVED***` ? this : undefined;
    ***REMOVED***
    optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
    ***REMOVED***
    get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {***REMOVED***;
    ***REMOVED***
***REMOVED***
class ParentNode extends Node {
    constructor(nodes = []) {
        super();
        this.nodes = nodes;
    ***REMOVED***
    render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
    ***REMOVED***
    optimizeNodes() {
        const { nodes ***REMOVED*** = this;
        let i = nodes.length;
        while (i--) {
            const n = nodes[i].optimizeNodes();
            if (Array.isArray(n))
                nodes.splice(i, 1, ...n);
            else if (n)
                nodes[i] = n;
            else
                nodes.splice(i, 1);
        ***REMOVED***
        return nodes.length > 0 ? this : undefined;
    ***REMOVED***
    optimizeNames(names, constants) {
        const { nodes ***REMOVED*** = this;
        let i = nodes.length;
        while (i--) {
            // iterating backwards improves 1-pass optimization
            const n = nodes[i];
            if (n.optimizeNames(names, constants))
                continue;
            subtractNames(names, n.names);
            nodes.splice(i, 1);
        ***REMOVED***
        return nodes.length > 0 ? this : undefined;
    ***REMOVED***
    get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {***REMOVED***);
    ***REMOVED***
***REMOVED***
class BlockNode extends ParentNode {
    render(opts) {
        return "{" + opts._n + super.render(opts) + "***REMOVED***" + opts._n;
    ***REMOVED***
***REMOVED***
class Root extends ParentNode {
***REMOVED***
class Else extends BlockNode {
***REMOVED***
Else.kind = "else";
class If extends BlockNode {
    constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
    ***REMOVED***
    render(opts) {
        let code = `if(${this.condition***REMOVED***)` + super.render(opts);
        if (this.else)
            code += "else " + this.else.render(opts);
        return code;
    ***REMOVED***
    optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
            return this.nodes; // else is ignored here
        let e = this.else;
        if (e) {
            const ns = e.optimizeNodes();
            e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        ***REMOVED***
        if (e) {
            if (cond === false)
                return e instanceof If ? e : e.nodes;
            if (this.nodes.length)
                return this;
            return new If(not(cond), e instanceof If ? [e] : e.nodes);
        ***REMOVED***
        if (cond === false || !this.nodes.length)
            return undefined;
        return this;
    ***REMOVED***
    optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
            return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
    ***REMOVED***
    get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
            addNames(names, this.else.names);
        return names;
    ***REMOVED***
***REMOVED***
If.kind = "if";
class For extends BlockNode {
***REMOVED***
For.kind = "for";
class ForLoop extends For {
    constructor(iteration) {
        super();
        this.iteration = iteration;
    ***REMOVED***
    render(opts) {
        return `for(${this.iteration***REMOVED***)` + super.render(opts);
    ***REMOVED***
    optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
            return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
    ***REMOVED***
    get names() {
        return addNames(super.names, this.iteration.names);
    ***REMOVED***
***REMOVED***
class ForRange extends For {
    constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
    ***REMOVED***
    render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to ***REMOVED*** = this;
        return `for(${varKind***REMOVED*** ${name***REMOVED***=${from***REMOVED***; ${name***REMOVED***<${to***REMOVED***; ${name***REMOVED***++)` + super.render(opts);
    ***REMOVED***
    get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
    ***REMOVED***
***REMOVED***
class ForIter extends For {
    constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
    ***REMOVED***
    render(opts) {
        return `for(${this.varKind***REMOVED*** ${this.name***REMOVED*** ${this.loop***REMOVED*** ${this.iterable***REMOVED***)` + super.render(opts);
    ***REMOVED***
    optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
            return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
    ***REMOVED***
    get names() {
        return addNames(super.names, this.iterable.names);
    ***REMOVED***
***REMOVED***
class Func extends BlockNode {
    constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
    ***REMOVED***
    render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async***REMOVED***function ${this.name***REMOVED***(${this.args***REMOVED***)` + super.render(opts);
    ***REMOVED***
***REMOVED***
Func.kind = "func";
class Return extends ParentNode {
    render(opts) {
        return "return " + super.render(opts);
    ***REMOVED***
***REMOVED***
Return.kind = "return";
class Try extends BlockNode {
    render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
            code += this.catch.render(opts);
        if (this.finally)
            code += this.finally.render(opts);
        return code;
    ***REMOVED***
    optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
    ***REMOVED***
    optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
    ***REMOVED***
    get names() {
        const names = super.names;
        if (this.catch)
            addNames(names, this.catch.names);
        if (this.finally)
            addNames(names, this.finally.names);
        return names;
    ***REMOVED***
***REMOVED***
class Catch extends BlockNode {
    constructor(error) {
        super();
        this.error = error;
    ***REMOVED***
    render(opts) {
        return `catch(${this.error***REMOVED***)` + super.render(opts);
    ***REMOVED***
***REMOVED***
Catch.kind = "catch";
class Finally extends BlockNode {
    render(opts) {
        return "finally" + super.render(opts);
    ***REMOVED***
***REMOVED***
Finally.kind = "finally";
class CodeGen {
    constructor(extScope, opts = {***REMOVED***) {
        this._values = {***REMOVED***;
        this._blockStarts = [];
        this._constants = {***REMOVED***;
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" ***REMOVED***;
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope ***REMOVED***);
        this._nodes = [new Root()];
    ***REMOVED***
    toString() {
        return this._root.render(this.opts);
    ***REMOVED***
    // returns unique name in the internal scope
    name(prefix) {
        return this._scope.name(prefix);
    ***REMOVED***
    // reserves unique name in the external scope
    scopeName(prefix) {
        return this._extScope.name(prefix);
    ***REMOVED***
    // reserves unique name in the external scope and assigns value to it
    scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = new Set());
        vs.add(name);
        return name;
    ***REMOVED***
    getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
    ***REMOVED***
    // return code that assigns values in the external scope to the names that are used internally
    // (same names that were returned by gen.scopeName or gen.scopeValue)
    scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
    ***REMOVED***
    scopeCode() {
        return this._extScope.scopeCode(this._values);
    ***REMOVED***
    _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== undefined && constant)
            this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
    ***REMOVED***
    // `const` declaration (`var` in es5 mode)
    const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
    ***REMOVED***
    // `let` declaration with optional assignment (`var` in es5 mode)
    let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
    ***REMOVED***
    // `var` declaration with optional assignment
    var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
    ***REMOVED***
    // assignment code
    assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
    ***REMOVED***
    // `+=` code
    add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
    ***REMOVED***
    // appends passed SafeExpr to code or executes Block
    code(c) {
        if (typeof c == "function")
            c();
        else if (c !== code_1.nil)
            this._leafNode(new AnyCode(c));
        return this;
    ***REMOVED***
    // returns code for object literal for the passed argument list of key-value pairs
    object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
            if (code.length > 1)
                code.push(",");
            code.push(key);
            if (key !== value || this.opts.es5) {
                code.push(":");
                (0, code_1.addCodeArg)(code, value);
            ***REMOVED***
        ***REMOVED***
        code.push("***REMOVED***");
        return new code_1._Code(code);
    ***REMOVED***
    // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
    if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
            this.code(thenBody).else().code(elseBody).endIf();
        ***REMOVED***
        else if (thenBody) {
            this.code(thenBody).endIf();
        ***REMOVED***
        else if (elseBody) {
            throw new Error('CodeGen: "else" body without "then" body');
        ***REMOVED***
        return this;
    ***REMOVED***
    // `else if` clause - invalid without `if` or after `else` clauses
    elseIf(condition) {
        return this._elseNode(new If(condition));
    ***REMOVED***
    // `else` clause - only valid after `if` or `else if` clauses
    else() {
        return this._elseNode(new Else());
    ***REMOVED***
    // end `if` statement (needed if gen.if was used only with condition)
    endIf() {
        return this._endBlockNode(If, Else);
    ***REMOVED***
    _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
            this.code(forBody).endFor();
        return this;
    ***REMOVED***
    // a generic `for` clause (or statement if `forBody` is passed)
    for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
    ***REMOVED***
    // `for` statement for a range of values
    forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
    ***REMOVED***
    // `for-of` statement (in es5 mode replace with a normal for loop)
    forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
            const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
            return this.forRange("_i", 0, (0, code_1._) `${arr***REMOVED***.length`, (i) => {
                this.var(name, (0, code_1._) `${arr***REMOVED***[${i***REMOVED***]`);
                forBody(name);
            ***REMOVED***);
        ***REMOVED***
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
    ***REMOVED***
    // `for-in` statement.
    // With option `ownProperties` replaced with a `for-of` loop for object keys
    forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
            return this.forOf(nameOrPrefix, (0, code_1._) `Object.keys(${obj***REMOVED***)`, forBody);
        ***REMOVED***
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
    ***REMOVED***
    // end `for` loop
    endFor() {
        return this._endBlockNode(For);
    ***REMOVED***
    // `label` statement
    label(label) {
        return this._leafNode(new Label(label));
    ***REMOVED***
    // `break` statement
    break(label) {
        return this._leafNode(new Break(label));
    ***REMOVED***
    // `return` statement
    return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
            throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
    ***REMOVED***
    // `try` statement
    try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
            throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
            const error = this.name("e");
            this._currNode = node.catch = new Catch(error);
            catchCode(error);
        ***REMOVED***
        if (finallyCode) {
            this._currNode = node.finally = new Finally();
            this.code(finallyCode);
        ***REMOVED***
        return this._endBlockNode(Catch, Finally);
    ***REMOVED***
    // `throw` statement
    throw(error) {
        return this._leafNode(new Throw(error));
    ***REMOVED***
    // start self-balancing block
    block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
            this.code(body).endBlock(nodeCount);
        return this;
    ***REMOVED***
    // end the current self-balancing block
    endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === undefined)
            throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || (nodeCount !== undefined && toClose !== nodeCount)) {
            throw new Error(`CodeGen: wrong number of nodes: ${toClose***REMOVED*** vs ${nodeCount***REMOVED*** expected`);
        ***REMOVED***
        this._nodes.length = len;
        return this;
    ***REMOVED***
    // `function` heading (or definition if funcBody is passed)
    func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
            this.code(funcBody).endFunc();
        return this;
    ***REMOVED***
    // end function definition
    endFunc() {
        return this._endBlockNode(Func);
    ***REMOVED***
    optimize(n = 1) {
        while (n-- > 0) {
            this._root.optimizeNodes();
            this._root.optimizeNames(this._root.names, this._constants);
        ***REMOVED***
    ***REMOVED***
    _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
    ***REMOVED***
    _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
    ***REMOVED***
    _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || (N2 && n instanceof N2)) {
            this._nodes.pop();
            return this;
        ***REMOVED***
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind***REMOVED***/${N2.kind***REMOVED***` : N1.kind***REMOVED***"`);
    ***REMOVED***
    _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
            throw new Error('CodeGen: "else" without "if"');
        ***REMOVED***
        this._currNode = n.else = node;
        return this;
    ***REMOVED***
    get _root() {
        return this._nodes[0];
    ***REMOVED***
    get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
    ***REMOVED***
    set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
    ***REMOVED***
***REMOVED***
exports.CodeGen = CodeGen;
function addNames(names, from) {
    for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
    return names;
***REMOVED***
function addExprNames(names, from) {
    return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
***REMOVED***
function optimizeExpr(expr, names, constants) {
    if (expr instanceof code_1.Name)
        return replaceName(expr);
    if (!canOptimize(expr))
        return expr;
    return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
            c = replaceName(c);
        if (c instanceof code_1._Code)
            items.push(...c._items);
        else
            items.push(c);
        return items;
    ***REMOVED***, []));
    function replaceName(n) {
        const c = constants[n.str];
        if (c === undefined || names[n.str] !== 1)
            return n;
        delete names[n.str];
        return c;
    ***REMOVED***
    function canOptimize(e) {
        return (e instanceof code_1._Code &&
            e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== undefined));
    ***REMOVED***
***REMOVED***
function subtractNames(names, from) {
    for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
***REMOVED***
function not(x) {
    return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._) `!${par(x)***REMOVED***`;
***REMOVED***
exports.not = not;
const andCode = mappend(exports.operators.AND);
// boolean AND (&&) expression with the passed arguments
function and(...args) {
    return args.reduce(andCode);
***REMOVED***
exports.and = and;
const orCode = mappend(exports.operators.OR);
// boolean OR (||) expression with the passed arguments
function or(...args) {
    return args.reduce(orCode);
***REMOVED***
exports.or = or;
function mappend(op) {
    return (x, y) => (x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._) `${par(x)***REMOVED*** ${op***REMOVED*** ${par(y)***REMOVED***`);
***REMOVED***
function par(x) {
    return x instanceof code_1.Name ? x : (0, code_1._) `(${x***REMOVED***)`;
***REMOVED***
//# sourceMappingURL=index.js.map