'use strict';

exports.__esModule = true;

/** @typedef {`.${string***REMOVED***`***REMOVED*** Extension  */
/** @typedef {NonNullable<import('eslint').Rule.RuleContext['settings']> & { 'import/extensions'?: Extension[], 'import/parsers'?: { [k: string]: Extension[] ***REMOVED***, 'import/cache'?: { lifetime: number | 'âˆž' | 'Infinity' ***REMOVED*** ***REMOVED******REMOVED*** ESLintSettings */

const moduleRequire = require('./module-require').default;
const extname = require('path').extname;
const fs = require('fs');

const log = require('debug')('eslint-plugin-import:parse');

/** @type {(parserPath: NonNullable<import('eslint').Rule.RuleContext['parserPath']>) => unknown***REMOVED*** */
function getBabelEslintVisitorKeys(parserPath) {
  if (parserPath.endsWith('index.js')) {
    const hypotheticalLocation = parserPath.replace('index.js', 'visitor-keys.js');
    if (fs.existsSync(hypotheticalLocation)) {
      const keys = moduleRequire(hypotheticalLocation);
      return keys.default || keys;
    ***REMOVED***
  ***REMOVED***
  return null;
***REMOVED***

/** @type {(parserPath: import('eslint').Rule.RuleContext['parserPath'], parserInstance: { VisitorKeys: unknown ***REMOVED***, parsedResult?: { visitorKeys?: unknown ***REMOVED***) => unknown***REMOVED*** */
function keysFromParser(parserPath, parserInstance, parsedResult) {
  // Exposed by @typescript-eslint/parser and @babel/eslint-parser
  if (parsedResult && parsedResult.visitorKeys) {
    return parsedResult.visitorKeys;
  ***REMOVED***
  // The old babel parser doesn't have a `parseForESLint` eslint function, so we don't end
  // up with a `parsedResult` here.  It also doesn't expose the visitor keys on the parser itself,
  // so we have to try and infer the visitor-keys module from the parserPath.
  // This is NOT supported in flat config!
  if (typeof parserPath === 'string' && (/.*babel-eslint.*/).test(parserPath)) {
    return getBabelEslintVisitorKeys(parserPath);
  ***REMOVED***
  // The espree parser doesn't have the `parseForESLint` function, so we don't end up with a
  // `parsedResult` here, but it does expose the visitor keys on the parser instance that we can use.
  if (parserInstance && parserInstance.VisitorKeys) {
    return parserInstance.VisitorKeys;
  ***REMOVED***
  return null;
***REMOVED***

// this exists to smooth over the unintentional breaking change in v2.7.
// TODO, semver-major: avoid mutating `ast` and return a plain object instead.
/** @type {<T extends import('eslint').AST.Program>(ast: T, visitorKeys: unknown) => T***REMOVED*** */
function makeParseReturn(ast, visitorKeys) {
  if (ast) {
    // @ts-expect-error see TODO
    ast.visitorKeys = visitorKeys;
    // @ts-expect-error see TODO
    ast.ast = ast;
  ***REMOVED***
  return ast;
***REMOVED***

/** @type {(text: string) => string***REMOVED*** */
function stripUnicodeBOM(text) {
  return text.charCodeAt(0) === 0xFEFF ? text.slice(1) : text;
***REMOVED***

/** @type {(text: string) => string***REMOVED*** */
function transformHashbang(text) {
  return text.replace(/^#!([^\r\n]+)/u, (_, captured) => `//${captured***REMOVED***`);
***REMOVED***

/** @type {(path: string, context: import('eslint').Rule.RuleContext & { settings?: ESLintSettings ***REMOVED***) => import('eslint').Rule.RuleContext['parserPath']***REMOVED*** */
function getParserPath(path, context) {
  const parsers = context.settings['import/parsers'];
  if (parsers != null) {
    // eslint-disable-next-line no-extra-parens
    const extension = /** @type {Extension***REMOVED*** */ (extname(path));
    for (const parserPath in parsers) {
      if (parsers[parserPath].indexOf(extension) > -1) {
        // use this alternate parser
        log('using alt parser:', parserPath);
        return parserPath;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  // default to use ESLint parser
  return context.parserPath;
***REMOVED***

/** @type {(path: string, context: import('eslint').Rule.RuleContext) => string | null | (import('eslint').Linter.ParserModule)***REMOVED*** */
function getParser(path, context) {
  const parserPath = getParserPath(path, context);
  if (parserPath) {
    return parserPath;
  ***REMOVED***
  if (
    !!context.languageOptions
    && !!context.languageOptions.parser
    && typeof context.languageOptions.parser !== 'string'
    && (
      // @ts-expect-error TODO: figure out a better type
      typeof context.languageOptions.parser.parse === 'function'
      // @ts-expect-error TODO: figure out a better type
      || typeof context.languageOptions.parser.parseForESLint === 'function'
    )
  ) {
    return context.languageOptions.parser;
  ***REMOVED***

  return null;
***REMOVED***

/** @type {import('./parse').default***REMOVED*** */
exports.default = function parse(path, content, context) {
  if (context == null) { throw new Error('need context to parse properly'); ***REMOVED***

  // ESLint in "flat" mode only sets context.languageOptions.parserOptions
  const languageOptions = context.languageOptions;
  let parserOptions = languageOptions && languageOptions.parserOptions || context.parserOptions;
  const parserOrPath = getParser(path, context);

  if (!parserOrPath) { throw new Error('parserPath or languageOptions.parser is required!'); ***REMOVED***

  // hack: espree blows up with frozen options
  parserOptions = Object.assign({***REMOVED***, parserOptions);
  parserOptions.ecmaFeatures = Object.assign({***REMOVED***, parserOptions.ecmaFeatures);

  // always include comments and tokens (for doc parsing)
  parserOptions.comment = true;
  parserOptions.attachComment = true;  // keeping this for backward-compat with  older parsers
  parserOptions.tokens = true;

  // attach node locations
  parserOptions.loc = true;
  parserOptions.range = true;

  // provide the `filePath` like eslint itself does, in `parserOptions`
  // https://github.com/eslint/eslint/blob/3ec436ee/lib/linter.js#L637
  parserOptions.filePath = path;

  // @typescript-eslint/parser will parse the entire project with typechecking if you provide
  // "project" or "projects" in parserOptions. Removing these options means the parser will
  // only parse one file in isolate mode, which is much, much faster.
  // https://github.com/import-js/eslint-plugin-import/issues/1408#issuecomment-509298962
  delete parserOptions.EXPERIMENTAL_useProjectService;
  delete parserOptions.projectService;
  delete parserOptions.project;
  delete parserOptions.projects;

  // If this is a flat config, we need to add ecmaVersion and sourceType (if present) from languageOptions
  if (languageOptions && languageOptions.ecmaVersion) {
    parserOptions.ecmaVersion = languageOptions.ecmaVersion;
  ***REMOVED***
  if (languageOptions && languageOptions.sourceType) {
    // @ts-expect-error languageOptions is from the flatConfig Linter type in 8.57 while parserOptions is not.
    // Non-flat config parserOptions.sourceType doesn't have "commonjs" in the type.  Once upgraded to v9 types,
    // they'll be the same and this expect-error should be removed.
    parserOptions.sourceType = languageOptions.sourceType;
  ***REMOVED***

  // require the parser relative to the main module (i.e., ESLint)
  const parser = typeof parserOrPath === 'string' ? moduleRequire(parserOrPath) : parserOrPath;

  // replicate bom strip and hashbang transform of ESLint
  // https://github.com/eslint/eslint/blob/b93af98b3c417225a027cabc964c38e779adb945/lib/linter/linter.js#L779
  content = transformHashbang(stripUnicodeBOM(String(content)));

  if (typeof parser.parseForESLint === 'function') {
    let ast;
    try {
      const parserRaw = parser.parseForESLint(content, parserOptions);
      ast = parserRaw.ast;
      // @ts-expect-error TODO: FIXME
      return makeParseReturn(ast, keysFromParser(parserOrPath, parser, parserRaw));
    ***REMOVED*** catch (e) {
      console.warn();
      console.warn('Error while parsing ' + parserOptions.filePath);
      // @ts-expect-error e is almost certainly an Error here
      console.warn('Line ' + e.lineNumber + ', column ' + e.column + ': ' + e.message);
    ***REMOVED***
    if (!ast || typeof ast !== 'object') {
      console.warn(
        // Can only be invalid for custom parser per imports/parser
        '`parseForESLint` from parser `' + (typeof parserOrPath === 'string' ? parserOrPath : 'context.languageOptions.parser') + '` is invalid and will just be ignored'
      );
    ***REMOVED*** else {
      // @ts-expect-error TODO: FIXME
      return makeParseReturn(ast, keysFromParser(parserOrPath, parser, undefined));
    ***REMOVED***
  ***REMOVED***

  const ast = parser.parse(content, parserOptions);
  // @ts-expect-error TODO: FIXME
  return makeParseReturn(ast, keysFromParser(parserOrPath, parser, undefined));
***REMOVED***;
