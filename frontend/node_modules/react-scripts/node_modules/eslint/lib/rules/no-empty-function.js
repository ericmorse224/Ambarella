/**
 * @fileoverview Rule to disallow empty functions.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const ALLOW_OPTIONS = Object.freeze([
    "functions",
    "arrowFunctions",
    "generatorFunctions",
    "methods",
    "generatorMethods",
    "getters",
    "setters",
    "constructors",
    "asyncFunctions",
    "asyncMethods"
]);

/**
 * Gets the kind of a given function node.
 * @param {ASTNode***REMOVED*** node A function node to get. This is one of
 *      an ArrowFunctionExpression, a FunctionDeclaration, or a
 *      FunctionExpression.
 * @returns {string***REMOVED*** The kind of the function. This is one of "functions",
 *      "arrowFunctions", "generatorFunctions", "asyncFunctions", "methods",
 *      "generatorMethods", "asyncMethods", "getters", "setters", and
 *      "constructors".
 */
function getKind(node) {
    const parent = node.parent;
    let kind = "";

    if (node.type === "ArrowFunctionExpression") {
        return "arrowFunctions";
    ***REMOVED***

    // Detects main kind.
    if (parent.type === "Property") {
        if (parent.kind === "get") {
            return "getters";
        ***REMOVED***
        if (parent.kind === "set") {
            return "setters";
        ***REMOVED***
        kind = parent.method ? "methods" : "functions";

    ***REMOVED*** else if (parent.type === "MethodDefinition") {
        if (parent.kind === "get") {
            return "getters";
        ***REMOVED***
        if (parent.kind === "set") {
            return "setters";
        ***REMOVED***
        if (parent.kind === "constructor") {
            return "constructors";
        ***REMOVED***
        kind = "methods";

    ***REMOVED*** else {
        kind = "functions";
    ***REMOVED***

    // Detects prefix.
    let prefix = "";

    if (node.generator) {
        prefix = "generator";
    ***REMOVED*** else if (node.async) {
        prefix = "async";
    ***REMOVED*** else {
        return kind;
    ***REMOVED***
    return prefix + kind[0].toUpperCase() + kind.slice(1);
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule***REMOVED*** */
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "Disallow empty functions",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/no-empty-function"
        ***REMOVED***,

        schema: [
            {
                type: "object",
                properties: {
                    allow: {
                        type: "array",
                        items: { enum: ALLOW_OPTIONS ***REMOVED***,
                        uniqueItems: true
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],

        messages: {
            unexpected: "Unexpected empty {{name***REMOVED******REMOVED***."
        ***REMOVED***
    ***REMOVED***,

    create(context) {
        const options = context.options[0] || {***REMOVED***;
        const allowed = options.allow || [];

        const sourceCode = context.sourceCode;

        /**
         * Reports a given function node if the node matches the following patterns.
         *
         * - Not allowed by options.
         * - The body is empty.
         * - The body doesn't have any comments.
         * @param {ASTNode***REMOVED*** node A function node to report. This is one of
         *      an ArrowFunctionExpression, a FunctionDeclaration, or a
         *      FunctionExpression.
         * @returns {void***REMOVED***
         */
        function reportIfEmpty(node) {
            const kind = getKind(node);
            const name = astUtils.getFunctionNameWithKind(node);
            const innerComments = sourceCode.getTokens(node.body, {
                includeComments: true,
                filter: astUtils.isCommentToken
            ***REMOVED***);

            if (!allowed.includes(kind) &&
                node.body.type === "BlockStatement" &&
                node.body.body.length === 0 &&
                innerComments.length === 0
            ) {
                context.report({
                    node,
                    loc: node.body.loc,
                    messageId: "unexpected",
                    data: { name ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        return {
            ArrowFunctionExpression: reportIfEmpty,
            FunctionDeclaration: reportIfEmpty,
            FunctionExpression: reportIfEmpty
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
