const hasOwnProperty = Object.prototype.hasOwnProperty;
const shape = {
    generic: true,
    types: appendOrAssign,
    atrules: {
        prelude: appendOrAssignOrNull,
        descriptors: appendOrAssignOrNull
    ***REMOVED***,
    properties: appendOrAssign,
    parseContext: assign,
    scope: deepAssign,
    atrule: ['parse'],
    pseudo: ['parse'],
    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
***REMOVED***;

function isObject(value) {
    return value && value.constructor === Object;
***REMOVED***

function copy(value) {
    return isObject(value)
        ? Object.assign({***REMOVED***, value)
        : value;
***REMOVED***

function assign(dest, src) {
    return Object.assign(dest, src);
***REMOVED***

function deepAssign(dest, src) {
    for (const key in src) {
        if (hasOwnProperty.call(src, key)) {
            if (isObject(dest[key])) {
                deepAssign(dest[key], copy(src[key]));
            ***REMOVED*** else {
                dest[key] = copy(src[key]);
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    return dest;
***REMOVED***

function append(a, b) {
    if (typeof b === 'string' && /^\s*\|/.test(b)) {
        return typeof a === 'string'
            ? a + b
            : b.replace(/^\s*\|\s*/, '');
    ***REMOVED***

    return b || null;
***REMOVED***

function appendOrAssign(a, b) {
    if (typeof b === 'string') {
        return append(a, b);
    ***REMOVED***

    const result = Object.assign({***REMOVED***, a);
    for (let key in b) {
        if (hasOwnProperty.call(b, key)) {
            result[key] = append(hasOwnProperty.call(a, key) ? a[key] : undefined, b[key]);
        ***REMOVED***
    ***REMOVED***

    return result;
***REMOVED***

function appendOrAssignOrNull(a, b) {
    const result = appendOrAssign(a, b);

    return !isObject(result) || Object.keys(result).length
        ? result
        : null;
***REMOVED***

function mix(dest, src, shape) {
    for (const key in shape) {
        if (hasOwnProperty.call(shape, key) === false) {
            continue;
        ***REMOVED***

        if (shape[key] === true) {
            if (key in src) {
                if (hasOwnProperty.call(src, key)) {
                    dest[key] = copy(src[key]);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED*** else if (shape[key]) {
            if (typeof shape[key] === 'function') {
                const fn = shape[key];
                dest[key] = fn({***REMOVED***, dest[key]);
                dest[key] = fn(dest[key] || {***REMOVED***, src[key]);
            ***REMOVED*** else if (isObject(shape[key])) {
                const result = {***REMOVED***;

                for (let name in dest[key]) {
                    result[name] = mix({***REMOVED***, dest[key][name], shape[key]);
                ***REMOVED***

                for (let name in src[key]) {
                    result[name] = mix(result[name] || {***REMOVED***, src[key][name], shape[key]);
                ***REMOVED***

                dest[key] = result;
            ***REMOVED*** else if (Array.isArray(shape[key])) {
                const res = {***REMOVED***;
                const innerShape = shape[key].reduce(function(s, k) {
                    s[k] = true;
                    return s;
                ***REMOVED***, {***REMOVED***);

                for (const [name, value] of Object.entries(dest[key] || {***REMOVED***)) {
                    res[name] = {***REMOVED***;
                    if (value) {
                        mix(res[name], value, innerShape);
                    ***REMOVED***
                ***REMOVED***

                for (const name in src[key]) {
                    if (hasOwnProperty.call(src[key], name)) {
                        if (!res[name]) {
                            res[name] = {***REMOVED***;
                        ***REMOVED***

                        if (src[key] && src[key][name]) {
                            mix(res[name], src[key][name], innerShape);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***

                dest[key] = res;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
    return dest;
***REMOVED***

module.exports = (dest, src) => mix(dest, src, shape);
