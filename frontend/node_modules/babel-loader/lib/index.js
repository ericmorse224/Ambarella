"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; ***REMOVED*** catch (error) { reject(error); return; ***REMOVED*** if (info.done) { resolve(value); ***REMOVED*** else { Promise.resolve(value).then(_next, _throw); ***REMOVED*** ***REMOVED***
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); ***REMOVED*** function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); ***REMOVED*** _next(undefined); ***REMOVED***); ***REMOVED***; ***REMOVED***
let babel;
try {
  babel = require("@babel/core");
***REMOVED*** catch (err) {
  if (err.code === "MODULE_NOT_FOUND") {
    err.message += "\n babel-loader@8 requires Babel 7.x (the package '@babel/core'). " + "If you'd like to use Babel 6.x ('babel-core'), you should install 'babel-loader@7'.";
  ***REMOVED***
  throw err;
***REMOVED***

// Since we've got the reverse bridge package at @babel/core@6.x, give
// people useful feedback if they try to use it alongside babel-loader.
if (/^6\./.test(babel.version)) {
  throw new Error("\n babel-loader@8 will not work with the '@babel/core@6' bridge package. " + "If you want to use Babel 6.x, install 'babel-loader@7'.");
***REMOVED***
const {
  version
***REMOVED*** = require("../package.json");
const cache = require("./cache");
const transform = require("./transform");
const injectCaller = require("./injectCaller");
const schema = require("./schema");
const {
  isAbsolute
***REMOVED*** = require("path");
const loaderUtils = require("loader-utils");
const validateOptions = require("schema-utils");
function subscribe(subscriber, metadata, context) {
  if (context[subscriber]) {
    context[subscriber](metadata);
  ***REMOVED***
***REMOVED***
module.exports = makeLoader();
module.exports.custom = makeLoader;
function makeLoader(callback) {
  const overrides = callback ? callback(babel) : undefined;
  return function (source, inputSourceMap) {
    // Make the loader async
    const callback = this.async();
    loader.call(this, source, inputSourceMap, overrides).then(args => callback(null, ...args), err => callback(err));
  ***REMOVED***;
***REMOVED***
function loader(_x, _x2, _x3) {
  return _loader.apply(this, arguments);
***REMOVED***
function _loader() {
  _loader = _asyncToGenerator(function* (source, inputSourceMap, overrides) {
    const filename = this.resourcePath;
    const logger = typeof this.getLogger === "function" ? this.getLogger("babel-loader") : {
      debug: () => {***REMOVED***
    ***REMOVED***;
    let loaderOptions = loaderUtils.getOptions(this);
    validateOptions(schema, loaderOptions, {
      name: "Babel loader"
    ***REMOVED***);
    if (loaderOptions.customize != null) {
      if (typeof loaderOptions.customize !== "string") {
        throw new Error("Customized loaders must be implemented as standalone modules.");
      ***REMOVED***
      if (!isAbsolute(loaderOptions.customize)) {
        throw new Error("Customized loaders must be passed as absolute paths, since " + "babel-loader has no way to know what they would be relative to.");
      ***REMOVED***
      if (overrides) {
        throw new Error("babel-loader's 'customize' option is not available when already " + "using a customized babel-loader wrapper.");
      ***REMOVED***
      logger.debug(`loading customize override: '${loaderOptions.customize***REMOVED***'`);
      let override = require(loaderOptions.customize);
      if (override.__esModule) override = override.default;
      if (typeof override !== "function") {
        throw new Error("Custom overrides must be functions.");
      ***REMOVED***
      logger.debug("applying customize override to @babel/core");
      overrides = override(babel);
    ***REMOVED***
    let customOptions;
    if (overrides && overrides.customOptions) {
      logger.debug("applying overrides customOptions() to loader options");
      const result = yield overrides.customOptions.call(this, loaderOptions, {
        source,
        map: inputSourceMap
      ***REMOVED***);
      customOptions = result.custom;
      loaderOptions = result.loader;
    ***REMOVED***

    // Deprecation handling
    if ("forceEnv" in loaderOptions) {
      console.warn("The option `forceEnv` has been removed in favor of `envName` in Babel 7.");
    ***REMOVED***
    if (typeof loaderOptions.babelrc === "string") {
      console.warn("The option `babelrc` should not be set to a string anymore in the babel-loader config. " + "Please update your configuration and set `babelrc` to true or false.\n" + "If you want to specify a specific babel config file to inherit config from " + "please use the `extends` option.\nFor more information about this options see " + "https://babeljs.io/docs/core-packages/#options");
    ***REMOVED***
    logger.debug("normalizing loader options");
    // Standardize on 'sourceMaps' as the key passed through to Webpack, so that
    // users may safely use either one alongside our default use of
    // 'this.sourceMap' below without getting error about conflicting aliases.
    if (Object.prototype.hasOwnProperty.call(loaderOptions, "sourceMap") && !Object.prototype.hasOwnProperty.call(loaderOptions, "sourceMaps")) {
      loaderOptions = Object.assign({***REMOVED***, loaderOptions, {
        sourceMaps: loaderOptions.sourceMap
      ***REMOVED***);
      delete loaderOptions.sourceMap;
    ***REMOVED***
    const programmaticOptions = Object.assign({***REMOVED***, loaderOptions, {
      filename,
      inputSourceMap: inputSourceMap || loaderOptions.inputSourceMap,
      // Set the default sourcemap behavior based on Webpack's mapping flag,
      // but allow users to override if they want.
      sourceMaps: loaderOptions.sourceMaps === undefined ? this.sourceMap : loaderOptions.sourceMaps,
      // Ensure that Webpack will get a full absolute path in the sourcemap
      // so that it can properly map the module back to its internal cached
      // modules.
      sourceFileName: filename
    ***REMOVED***);
    // Remove loader related options
    delete programmaticOptions.customize;
    delete programmaticOptions.cacheDirectory;
    delete programmaticOptions.cacheIdentifier;
    delete programmaticOptions.cacheCompression;
    delete programmaticOptions.metadataSubscribers;
    if (!babel.loadPartialConfig) {
      throw new Error(`babel-loader ^8.0.0-beta.3 requires @babel/core@7.0.0-beta.41, but ` + `you appear to be using "${babel.version***REMOVED***". Either update your ` + `@babel/core version, or pin you babel-loader version to 8.0.0-beta.2`);
    ***REMOVED***

    // babel.loadPartialConfigAsync is available in v7.8.0+
    const {
      loadPartialConfigAsync = babel.loadPartialConfig
    ***REMOVED*** = babel;
    logger.debug("resolving Babel configs");
    const config = yield loadPartialConfigAsync(injectCaller(programmaticOptions, this.target));
    if (config) {
      let options = config.options;
      if (overrides && overrides.config) {
        logger.debug("applying overrides config() to Babel config");
        options = yield overrides.config.call(this, config, {
          source,
          map: inputSourceMap,
          customOptions
        ***REMOVED***);
      ***REMOVED***
      if (options.sourceMaps === "inline") {
        // Babel has this weird behavior where if you set "inline", we
        // inline the sourcemap, and set 'result.map = null'. This results
        // in bad behavior from Babel since the maps get put into the code,
        // which Webpack does not expect, and because the map we return to
        // Webpack is null, which is also bad. To avoid that, we override the
        // behavior here so "inline" just behaves like 'true'.
        options.sourceMaps = true;
      ***REMOVED***
      const {
        cacheDirectory = null,
        cacheIdentifier = JSON.stringify({
          options,
          "@babel/core": transform.version,
          "@babel/loader": version
        ***REMOVED***),
        cacheCompression = true,
        metadataSubscribers = []
      ***REMOVED*** = loaderOptions;
      let result;
      if (cacheDirectory) {
        logger.debug("cache is enabled");
        result = yield cache({
          source,
          options,
          transform,
          cacheDirectory,
          cacheIdentifier,
          cacheCompression,
          logger
        ***REMOVED***);
      ***REMOVED*** else {
        logger.debug("cache is disabled, applying Babel transform");
        result = yield transform(source, options);
      ***REMOVED***

      // Availabe since Babel 7.12
      // https://github.com/babel/babel/pull/11907
      if (config.files) {
        config.files.forEach(configFile => {
          this.addDependency(configFile);
          logger.debug(`added '${configFile***REMOVED***' to webpack dependencies`);
        ***REMOVED***);
      ***REMOVED*** else {
        // .babelrc.json
        if (typeof config.babelrc === "string") {
          this.addDependency(config.babelrc);
          logger.debug(`added '${config.babelrc***REMOVED***' to webpack dependencies`);
        ***REMOVED***
        // babel.config.js
        if (config.config) {
          this.addDependency(config.config);
          logger.debug(`added '${config.config***REMOVED***' to webpack dependencies`);
        ***REMOVED***
      ***REMOVED***
      if (result) {
        if (overrides && overrides.result) {
          logger.debug("applying overrides result() to Babel transform results");
          result = yield overrides.result.call(this, result, {
            source,
            map: inputSourceMap,
            customOptions,
            config,
            options
          ***REMOVED***);
        ***REMOVED***
        const {
          code,
          map,
          metadata,
          externalDependencies
        ***REMOVED*** = result;
        externalDependencies == null ? void 0 : externalDependencies.forEach(dep => {
          this.addDependency(dep);
          logger.debug(`added '${dep***REMOVED***' to webpack dependencies`);
        ***REMOVED***);
        metadataSubscribers.forEach(subscriber => {
          subscribe(subscriber, metadata, this);
          logger.debug(`invoked metadata subscriber '${String(subscriber)***REMOVED***'`);
        ***REMOVED***);
        return [code, map];
      ***REMOVED***
    ***REMOVED***

    // If the file was ignored, pass through the original content.
    return [source, inputSourceMap];
  ***REMOVED***);
  return _loader.apply(this, arguments);
***REMOVED***