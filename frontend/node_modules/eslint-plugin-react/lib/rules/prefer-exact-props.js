/**
 * @fileoverview Prefer exact proptype definitions
 */

'use strict';

const Components = require('../util/Components');
const docsUrl = require('../util/docsUrl');
const astUtil = require('../util/ast');
const propsUtil = require('../util/props');
const propWrapperUtil = require('../util/propWrapper');
const variableUtil = require('../util/variable');
const report = require('../util/report');
const getText = require('../util/eslint').getText;

// -----------------------------------------------------------------------------
// Rule Definition
// -----------------------------------------------------------------------------

const messages = {
  propTypes: 'Component propTypes should be exact by using {{exactPropWrappers***REMOVED******REMOVED***.',
  flow: 'Component flow props should be set with exact objects.',
***REMOVED***;

/** @type {import('eslint').Rule.RuleModule***REMOVED*** */
module.exports = {
  meta: {
    docs: {
      description: 'Prefer exact proptype definitions',
      category: 'Possible Errors',
      recommended: false,
      url: docsUrl('prefer-exact-props'),
    ***REMOVED***,
    messages,
    schema: [],
  ***REMOVED***,

  create: Components.detect((context, components, utils) => {
    const typeAliases = {***REMOVED***;
    const exactWrappers = propWrapperUtil.getExactPropWrapperFunctions(context);

    function getPropTypesErrorMessage() {
      const formattedWrappers = propWrapperUtil.formatPropWrapperFunctions(exactWrappers);
      const message = exactWrappers.size > 1 ? `one of ${formattedWrappers***REMOVED***` : formattedWrappers;
      return { exactPropWrappers: message ***REMOVED***;
    ***REMOVED***

    function isNonExactObjectTypeAnnotation(node) {
      return (
        node
        && node.type === 'ObjectTypeAnnotation'
        && node.properties.length > 0
        && !node.exact
      );
    ***REMOVED***

    function hasNonExactObjectTypeAnnotation(node) {
      const typeAnnotation = node.typeAnnotation;
      return (
        typeAnnotation
        && typeAnnotation.typeAnnotation
        && isNonExactObjectTypeAnnotation(typeAnnotation.typeAnnotation)
      );
    ***REMOVED***

    function hasGenericTypeAnnotation(node) {
      const typeAnnotation = node.typeAnnotation;
      return (
        typeAnnotation
        && typeAnnotation.typeAnnotation
        && typeAnnotation.typeAnnotation.type === 'GenericTypeAnnotation'
      );
    ***REMOVED***

    function isNonEmptyObjectExpression(node) {
      return (
        node
        && node.type === 'ObjectExpression'
        && node.properties.length > 0
      );
    ***REMOVED***

    function isNonExactPropWrapperFunction(node) {
      return (
        astUtil.isCallExpression(node)
        && !propWrapperUtil.isExactPropWrapperFunction(context, getText(context, node.callee))
      );
    ***REMOVED***

    function reportPropTypesError(node) {
      report(context, messages.propTypes, 'propTypes', {
        node,
        data: getPropTypesErrorMessage(),
      ***REMOVED***);
    ***REMOVED***

    function reportFlowError(node) {
      report(context, messages.flow, 'flow', {
        node,
      ***REMOVED***);
    ***REMOVED***

    return {
      TypeAlias(node) {
        // working around an issue with eslint@3 and babel-eslint not finding the TypeAlias in scope
        typeAliases[node.id.name] = node;
      ***REMOVED***,

      'ClassProperty, PropertyDefinition'(node) {
        if (!propsUtil.isPropTypesDeclaration(node)) {
          return;
        ***REMOVED***

        if (hasNonExactObjectTypeAnnotation(node)) {
          reportFlowError(node);
        ***REMOVED*** else if (exactWrappers.size > 0 && isNonEmptyObjectExpression(node.value)) {
          reportPropTypesError(node);
        ***REMOVED*** else if (exactWrappers.size > 0 && isNonExactPropWrapperFunction(node.value)) {
          reportPropTypesError(node);
        ***REMOVED***
      ***REMOVED***,

      Identifier(node) {
        if (!utils.getStatelessComponent(node.parent)) {
          return;
        ***REMOVED***

        if (hasNonExactObjectTypeAnnotation(node)) {
          reportFlowError(node);
        ***REMOVED*** else if (hasGenericTypeAnnotation(node)) {
          const identifier = node.typeAnnotation.typeAnnotation.id.name;
          const typeAlias = typeAliases[identifier];
          const propsDefinition = typeAlias ? typeAlias.right : null;
          if (isNonExactObjectTypeAnnotation(propsDefinition)) {
            reportFlowError(node);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***,

      MemberExpression(node) {
        if (!propsUtil.isPropTypesDeclaration(node) || exactWrappers.size === 0) {
          return;
        ***REMOVED***

        const right = node.parent.right;
        if (isNonEmptyObjectExpression(right)) {
          reportPropTypesError(node);
        ***REMOVED*** else if (isNonExactPropWrapperFunction(right)) {
          reportPropTypesError(node);
        ***REMOVED*** else if (right.type === 'Identifier') {
          const identifier = right.name;
          const propsDefinition = variableUtil.findVariableByName(context, node, identifier);
          if (isNonEmptyObjectExpression(propsDefinition)) {
            reportPropTypesError(node);
          ***REMOVED*** else if (isNonExactPropWrapperFunction(propsDefinition)) {
            reportPropTypesError(node);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***,
    ***REMOVED***;
  ***REMOVED***),
***REMOVED***;
