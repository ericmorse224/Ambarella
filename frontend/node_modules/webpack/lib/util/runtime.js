/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const SortableSet = require("./SortableSet");

/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("../Entrypoint").EntryOptions***REMOVED*** EntryOptions */

/** @typedef {string | SortableSet<string> | undefined***REMOVED*** RuntimeSpec */
/** @typedef {RuntimeSpec | boolean***REMOVED*** RuntimeCondition */

/**
 * @param {Compilation***REMOVED*** compilation the compilation
 * @param {string***REMOVED*** name name of the entry
 * @param {EntryOptions=***REMOVED*** options optionally already received entry options
 * @returns {RuntimeSpec***REMOVED*** runtime
 */
module.exports.getEntryRuntime = (compilation, name, options) => {
	let dependOn;
	let runtime;
	if (options) {
		({ dependOn, runtime ***REMOVED*** = options);
	***REMOVED*** else {
		const entry = compilation.entries.get(name);
		if (!entry) return name;
		({ dependOn, runtime ***REMOVED*** = entry.options);
	***REMOVED***
	if (dependOn) {
		/** @type {RuntimeSpec***REMOVED*** */
		let result;
		const queue = new Set(dependOn);
		for (const name of queue) {
			const dep = compilation.entries.get(name);
			if (!dep) continue;
			const { dependOn, runtime ***REMOVED*** = dep.options;
			if (dependOn) {
				for (const name of dependOn) {
					queue.add(name);
				***REMOVED***
			***REMOVED*** else {
				result = mergeRuntimeOwned(result, runtime || name);
			***REMOVED***
		***REMOVED***
		return result || name;
	***REMOVED***
	return runtime || name;
***REMOVED***;

/**
 * @param {RuntimeSpec***REMOVED*** runtime runtime
 * @param {(runtime: string | undefined) => void***REMOVED*** fn functor
 * @param {boolean***REMOVED*** deterministicOrder enforce a deterministic order
 * @returns {void***REMOVED***
 */
const forEachRuntime = (runtime, fn, deterministicOrder = false) => {
	if (runtime === undefined) {
		fn(undefined);
	***REMOVED*** else if (typeof runtime === "string") {
		fn(runtime);
	***REMOVED*** else {
		if (deterministicOrder) runtime.sort();
		for (const r of runtime) {
			fn(r);
		***REMOVED***
	***REMOVED***
***REMOVED***;
module.exports.forEachRuntime = forEachRuntime;

/**
 * @template T
 * @param {SortableSet<T>***REMOVED*** set set
 * @returns {string***REMOVED*** runtime key
 */
const getRuntimesKey = set => {
	set.sort();
	return Array.from(set).join("\n");
***REMOVED***;

/**
 * @param {RuntimeSpec***REMOVED*** runtime runtime(s)
 * @returns {string***REMOVED*** key of runtimes
 */
const getRuntimeKey = runtime => {
	if (runtime === undefined) return "*";
	if (typeof runtime === "string") return runtime;
	return runtime.getFromUnorderedCache(getRuntimesKey);
***REMOVED***;
module.exports.getRuntimeKey = getRuntimeKey;

/**
 * @param {string***REMOVED*** key key of runtimes
 * @returns {RuntimeSpec***REMOVED*** runtime(s)
 */
const keyToRuntime = key => {
	if (key === "*") return;
	const items = key.split("\n");
	if (items.length === 1) return items[0];
	return new SortableSet(items);
***REMOVED***;
module.exports.keyToRuntime = keyToRuntime;

/**
 * @template T
 * @param {SortableSet<T>***REMOVED*** set set
 * @returns {string***REMOVED*** runtime string
 */
const getRuntimesString = set => {
	set.sort();
	return Array.from(set).join("+");
***REMOVED***;

/**
 * @param {RuntimeSpec***REMOVED*** runtime runtime(s)
 * @returns {string***REMOVED*** readable version
 */
const runtimeToString = runtime => {
	if (runtime === undefined) return "*";
	if (typeof runtime === "string") return runtime;
	return runtime.getFromUnorderedCache(getRuntimesString);
***REMOVED***;
module.exports.runtimeToString = runtimeToString;

/**
 * @param {RuntimeCondition***REMOVED*** runtimeCondition runtime condition
 * @returns {string***REMOVED*** readable version
 */
module.exports.runtimeConditionToString = runtimeCondition => {
	if (runtimeCondition === true) return "true";
	if (runtimeCondition === false) return "false";
	return runtimeToString(runtimeCondition);
***REMOVED***;

/**
 * @param {RuntimeSpec***REMOVED*** a first
 * @param {RuntimeSpec***REMOVED*** b second
 * @returns {boolean***REMOVED*** true, when they are equal
 */
const runtimeEqual = (a, b) => {
	if (a === b) {
		return true;
	***REMOVED*** else if (
		a === undefined ||
		b === undefined ||
		typeof a === "string" ||
		typeof b === "string"
	) {
		return false;
	***REMOVED*** else if (a.size !== b.size) {
		return false;
	***REMOVED***
	a.sort();
	b.sort();
	const aIt = a[Symbol.iterator]();
	const bIt = b[Symbol.iterator]();
	for (;;) {
		const aV = aIt.next();
		if (aV.done) return true;
		const bV = bIt.next();
		if (aV.value !== bV.value) return false;
	***REMOVED***
***REMOVED***;
module.exports.runtimeEqual = runtimeEqual;

/**
 * @param {RuntimeSpec***REMOVED*** a first
 * @param {RuntimeSpec***REMOVED*** b second
 * @returns {-1|0|1***REMOVED*** compare
 */
module.exports.compareRuntime = (a, b) => {
	if (a === b) {
		return 0;
	***REMOVED*** else if (a === undefined) {
		return -1;
	***REMOVED*** else if (b === undefined) {
		return 1;
	***REMOVED***
	const aKey = getRuntimeKey(a);
	const bKey = getRuntimeKey(b);
	if (aKey < bKey) return -1;
	if (aKey > bKey) return 1;
	return 0;
***REMOVED***;

/**
 * @param {RuntimeSpec***REMOVED*** a first
 * @param {RuntimeSpec***REMOVED*** b second
 * @returns {RuntimeSpec***REMOVED*** merged
 */
const mergeRuntime = (a, b) => {
	if (a === undefined) {
		return b;
	***REMOVED*** else if (b === undefined) {
		return a;
	***REMOVED*** else if (a === b) {
		return a;
	***REMOVED*** else if (typeof a === "string") {
		if (typeof b === "string") {
			const set = new SortableSet();
			set.add(a);
			set.add(b);
			return set;
		***REMOVED*** else if (b.has(a)) {
			return b;
		***REMOVED***
		const set = new SortableSet(b);
		set.add(a);
		return set;
	***REMOVED***
	if (typeof b === "string") {
		if (a.has(b)) return a;
		const set = new SortableSet(a);
		set.add(b);
		return set;
	***REMOVED***
	const set = new SortableSet(a);
	for (const item of b) set.add(item);
	if (set.size === a.size) return a;
	return set;
***REMOVED***;
module.exports.mergeRuntime = mergeRuntime;

/**
 * @param {RuntimeCondition***REMOVED*** a first
 * @param {RuntimeCondition***REMOVED*** b second
 * @param {RuntimeSpec***REMOVED*** runtime full runtime
 * @returns {RuntimeCondition***REMOVED*** result
 */
module.exports.mergeRuntimeCondition = (a, b, runtime) => {
	if (a === false) return b;
	if (b === false) return a;
	if (a === true || b === true) return true;
	const merged = mergeRuntime(a, b);
	if (merged === undefined) return;
	if (typeof merged === "string") {
		if (typeof runtime === "string" && merged === runtime) return true;
		return merged;
	***REMOVED***
	if (typeof runtime === "string" || runtime === undefined) return merged;
	if (merged.size === runtime.size) return true;
	return merged;
***REMOVED***;

/**
 * @param {RuntimeSpec | true***REMOVED*** a first
 * @param {RuntimeSpec | true***REMOVED*** b second
 * @param {RuntimeSpec***REMOVED*** runtime full runtime
 * @returns {RuntimeSpec | true***REMOVED*** result
 */
module.exports.mergeRuntimeConditionNonFalse = (a, b, runtime) => {
	if (a === true || b === true) return true;
	const merged = mergeRuntime(a, b);
	if (merged === undefined) return;
	if (typeof merged === "string") {
		if (typeof runtime === "string" && merged === runtime) return true;
		return merged;
	***REMOVED***
	if (typeof runtime === "string" || runtime === undefined) return merged;
	if (merged.size === runtime.size) return true;
	return merged;
***REMOVED***;

/**
 * @param {RuntimeSpec***REMOVED*** a first (may be modified)
 * @param {RuntimeSpec***REMOVED*** b second
 * @returns {RuntimeSpec***REMOVED*** merged
 */
const mergeRuntimeOwned = (a, b) => {
	if (b === undefined) {
		return a;
	***REMOVED*** else if (a === b) {
		return a;
	***REMOVED*** else if (a === undefined) {
		if (typeof b === "string") {
			return b;
		***REMOVED***
		return new SortableSet(b);
	***REMOVED*** else if (typeof a === "string") {
		if (typeof b === "string") {
			const set = new SortableSet();
			set.add(a);
			set.add(b);
			return set;
		***REMOVED***
		const set = new SortableSet(b);
		set.add(a);
		return set;
	***REMOVED***
	if (typeof b === "string") {
		a.add(b);
		return a;
	***REMOVED***
	for (const item of b) a.add(item);
	return a;
***REMOVED***;
module.exports.mergeRuntimeOwned = mergeRuntimeOwned;

/**
 * @param {RuntimeSpec***REMOVED*** a first
 * @param {RuntimeSpec***REMOVED*** b second
 * @returns {RuntimeSpec***REMOVED*** merged
 */
module.exports.intersectRuntime = (a, b) => {
	if (a === undefined) {
		return b;
	***REMOVED*** else if (b === undefined) {
		return a;
	***REMOVED*** else if (a === b) {
		return a;
	***REMOVED*** else if (typeof a === "string") {
		if (typeof b === "string") {
			return;
		***REMOVED*** else if (b.has(a)) {
			return a;
		***REMOVED***
		return;
	***REMOVED***
	if (typeof b === "string") {
		if (a.has(b)) return b;
		return;
	***REMOVED***
	const set = new SortableSet();
	for (const item of b) {
		if (a.has(item)) set.add(item);
	***REMOVED***
	if (set.size === 0) return;
	if (set.size === 1) {
		const [item] = set;
		return item;
	***REMOVED***
	return set;
***REMOVED***;

/**
 * @param {RuntimeSpec***REMOVED*** a first
 * @param {RuntimeSpec***REMOVED*** b second
 * @returns {RuntimeSpec***REMOVED*** result
 */
const subtractRuntime = (a, b) => {
	if (a === undefined) {
		return;
	***REMOVED*** else if (b === undefined) {
		return a;
	***REMOVED*** else if (a === b) {
		return;
	***REMOVED*** else if (typeof a === "string") {
		if (typeof b === "string") {
			return a;
		***REMOVED*** else if (b.has(a)) {
			return;
		***REMOVED***
		return a;
	***REMOVED***
	if (typeof b === "string") {
		if (!a.has(b)) return a;
		if (a.size === 2) {
			for (const item of a) {
				if (item !== b) return item;
			***REMOVED***
		***REMOVED***
		const set = new SortableSet(a);
		set.delete(b);
		return set;
	***REMOVED***
	const set = new SortableSet();
	for (const item of a) {
		if (!b.has(item)) set.add(item);
	***REMOVED***
	if (set.size === 0) return;
	if (set.size === 1) {
		const [item] = set;
		return item;
	***REMOVED***
	return set;
***REMOVED***;
module.exports.subtractRuntime = subtractRuntime;

/**
 * @param {RuntimeCondition***REMOVED*** a first
 * @param {RuntimeCondition***REMOVED*** b second
 * @param {RuntimeSpec***REMOVED*** runtime runtime
 * @returns {RuntimeCondition***REMOVED*** result
 */
module.exports.subtractRuntimeCondition = (a, b, runtime) => {
	if (b === true) return false;
	if (b === false) return a;
	if (a === false) return false;
	const result = subtractRuntime(a === true ? runtime : a, b);
	return result === undefined ? false : result;
***REMOVED***;

/**
 * @param {RuntimeSpec***REMOVED*** runtime runtime
 * @param {(runtime?: RuntimeSpec) => boolean***REMOVED*** filter filter function
 * @returns {boolean | RuntimeSpec***REMOVED*** true/false if filter is constant for all runtimes, otherwise runtimes that are active
 */
module.exports.filterRuntime = (runtime, filter) => {
	if (runtime === undefined) return filter();
	if (typeof runtime === "string") return filter(runtime);
	let some = false;
	let every = true;
	let result;
	for (const r of runtime) {
		const v = filter(r);
		if (v) {
			some = true;
			result = mergeRuntimeOwned(result, r);
		***REMOVED*** else {
			every = false;
		***REMOVED***
	***REMOVED***
	if (!some) return false;
	if (every) return true;
	return result;
***REMOVED***;

/**
 * @template T
 * @typedef {Map<string, T>***REMOVED*** RuntimeSpecMapInnerMap
 */

/**
 * @template T
 * @template [R=T]
 */
class RuntimeSpecMap {
	/**
	 * @param {RuntimeSpecMap<T, R>=***REMOVED*** clone copy form this
	 */
	constructor(clone) {
		/** @type {0 | 1 | 2***REMOVED*** */
		this._mode = clone ? clone._mode : 0; // 0 = empty, 1 = single entry, 2 = map
		/** @type {RuntimeSpec***REMOVED*** */
		this._singleRuntime = clone ? clone._singleRuntime : undefined;
		/** @type {R | undefined***REMOVED*** */
		this._singleValue = clone ? clone._singleValue : undefined;
		/** @type {RuntimeSpecMapInnerMap<R> | undefined***REMOVED*** */
		this._map = clone && clone._map ? new Map(clone._map) : undefined;
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime the runtimes
	 * @returns {R | undefined***REMOVED*** value
	 */
	get(runtime) {
		switch (this._mode) {
			case 0:
				return;
			case 1:
				return runtimeEqual(this._singleRuntime, runtime)
					? this._singleValue
					: undefined;
			default:
				return /** @type {RuntimeSpecMapInnerMap<R>***REMOVED*** */ (this._map).get(
					getRuntimeKey(runtime)
				);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime the runtimes
	 * @returns {boolean***REMOVED*** true, when the runtime is stored
	 */
	has(runtime) {
		switch (this._mode) {
			case 0:
				return false;
			case 1:
				return runtimeEqual(this._singleRuntime, runtime);
			default:
				return /** @type {RuntimeSpecMapInnerMap<R>***REMOVED*** */ (this._map).has(
					getRuntimeKey(runtime)
				);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime the runtimes
	 * @param {R***REMOVED*** value the value
	 */
	set(runtime, value) {
		switch (this._mode) {
			case 0:
				this._mode = 1;
				this._singleRuntime = runtime;
				this._singleValue = value;
				break;
			case 1:
				if (runtimeEqual(this._singleRuntime, runtime)) {
					this._singleValue = value;
					break;
				***REMOVED***
				this._mode = 2;
				this._map = new Map();
				this._map.set(
					getRuntimeKey(this._singleRuntime),
					/** @type {R***REMOVED*** */ (this._singleValue)
				);
				this._singleRuntime = undefined;
				this._singleValue = undefined;
			/* falls through */
			default:
				/** @type {RuntimeSpecMapInnerMap<R>***REMOVED*** */
				(this._map).set(getRuntimeKey(runtime), value);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime the runtimes
	 * @param {() => R***REMOVED*** computer function to compute the value
	 * @returns {R***REMOVED*** the new value
	 */
	provide(runtime, computer) {
		switch (this._mode) {
			case 0:
				this._mode = 1;
				this._singleRuntime = runtime;
				return (this._singleValue = computer());
			case 1: {
				if (runtimeEqual(this._singleRuntime, runtime)) {
					return /** @type {R***REMOVED*** */ (this._singleValue);
				***REMOVED***
				this._mode = 2;
				this._map = new Map();
				this._map.set(
					getRuntimeKey(this._singleRuntime),
					/** @type {R***REMOVED*** */
					(this._singleValue)
				);
				this._singleRuntime = undefined;
				this._singleValue = undefined;
				const newValue = computer();
				this._map.set(getRuntimeKey(runtime), newValue);
				return newValue;
			***REMOVED***
			default: {
				const key = getRuntimeKey(runtime);
				const value =
					/** @type {RuntimeSpecMapInnerMap<R>***REMOVED*** */
					(this._map).get(key);
				if (value !== undefined) return value;
				const newValue = computer();
				/** @type {RuntimeSpecMapInnerMap<R>***REMOVED*** */
				(this._map).set(key, newValue);
				return newValue;
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime the runtimes
	 */
	delete(runtime) {
		switch (this._mode) {
			case 0:
				return;
			case 1:
				if (runtimeEqual(this._singleRuntime, runtime)) {
					this._mode = 0;
					this._singleRuntime = undefined;
					this._singleValue = undefined;
				***REMOVED***
				return;
			default:
				/** @type {RuntimeSpecMapInnerMap<R>***REMOVED*** */
				(this._map).delete(getRuntimeKey(runtime));
		***REMOVED***
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime the runtimes
	 * @param {(value: R | undefined) => R***REMOVED*** fn function to update the value
	 */
	update(runtime, fn) {
		switch (this._mode) {
			case 0:
				throw new Error("runtime passed to update must exist");
			case 1: {
				if (runtimeEqual(this._singleRuntime, runtime)) {
					this._singleValue = fn(this._singleValue);
					break;
				***REMOVED***
				const newValue = fn(undefined);
				if (newValue !== undefined) {
					this._mode = 2;
					this._map = new Map();
					this._map.set(
						getRuntimeKey(this._singleRuntime),
						/** @type {R***REMOVED*** */
						(this._singleValue)
					);
					this._singleRuntime = undefined;
					this._singleValue = undefined;
					this._map.set(getRuntimeKey(runtime), newValue);
				***REMOVED***
				break;
			***REMOVED***
			default: {
				const key = getRuntimeKey(runtime);
				const oldValue =
					/** @type {RuntimeSpecMapInnerMap<R>***REMOVED*** */
					(this._map).get(key);
				const newValue = fn(oldValue);
				if (newValue !== oldValue)
					/** @type {RuntimeSpecMapInnerMap<R>***REMOVED*** */
					(this._map).set(key, newValue);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	keys() {
		switch (this._mode) {
			case 0:
				return [];
			case 1:
				return [this._singleRuntime];
			default:
				return Array.from(
					/** @type {RuntimeSpecMapInnerMap<R>***REMOVED*** */
					(this._map).keys(),
					keyToRuntime
				);
		***REMOVED***
	***REMOVED***

	/**
	 * @returns {IterableIterator<R>***REMOVED*** values
	 */
	values() {
		switch (this._mode) {
			case 0:
				return [][Symbol.iterator]();
			case 1:
				return [/** @type {R***REMOVED*** */ (this._singleValue)][Symbol.iterator]();
			default:
				return /** @type {RuntimeSpecMapInnerMap<R>***REMOVED*** */ (this._map).values();
		***REMOVED***
	***REMOVED***

	get size() {
		if (/** @type {number***REMOVED*** */ (this._mode) <= 1) {
			return /** @type {number***REMOVED*** */ (this._mode);
		***REMOVED***

		return /** @type {RuntimeSpecMapInnerMap<R>***REMOVED*** */ (this._map).size;
	***REMOVED***
***REMOVED***

module.exports.RuntimeSpecMap = RuntimeSpecMap;

class RuntimeSpecSet {
	/**
	 * @param {Iterable<RuntimeSpec>=***REMOVED*** iterable iterable
	 */
	constructor(iterable) {
		/** @type {Map<string, RuntimeSpec>***REMOVED*** */
		this._map = new Map();
		if (iterable) {
			for (const item of iterable) {
				this.add(item);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime runtime
	 */
	add(runtime) {
		this._map.set(getRuntimeKey(runtime), runtime);
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime runtime
	 * @returns {boolean***REMOVED*** true, when the runtime exists
	 */
	has(runtime) {
		return this._map.has(getRuntimeKey(runtime));
	***REMOVED***

	/**
	 * @returns {IterableIterator<RuntimeSpec>***REMOVED*** iterable iterator
	 */
	[Symbol.iterator]() {
		return this._map.values();
	***REMOVED***

	get size() {
		return this._map.size;
	***REMOVED***
***REMOVED***

module.exports.RuntimeSpecSet = RuntimeSpecSet;
