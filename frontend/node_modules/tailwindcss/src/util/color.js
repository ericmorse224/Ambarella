import namedColors from './colorNames'

let HEX = /^#([a-f\d]{2***REMOVED***)([a-f\d]{2***REMOVED***)([a-f\d]{2***REMOVED***)([a-f\d]{2***REMOVED***)?$/i
let SHORT_HEX = /^#([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i
let VALUE = /(?:\d+|\d*\.\d+)%?/
let SEP = /(?:\s*,\s*|\s+)/
let ALPHA_SEP = /\s*[,/]\s*/
let CUSTOM_PROPERTY = /var\(--(?:[^ )]*?)(?:,(?:[^ )]*?|var\(--[^ )]*?\)))?\)/

let RGB = new RegExp(
  `^(rgba?)\\(\\s*(${VALUE.source***REMOVED***|${CUSTOM_PROPERTY.source***REMOVED***)(?:${SEP.source***REMOVED***(${VALUE.source***REMOVED***|${CUSTOM_PROPERTY.source***REMOVED***))?(?:${SEP.source***REMOVED***(${VALUE.source***REMOVED***|${CUSTOM_PROPERTY.source***REMOVED***))?(?:${ALPHA_SEP.source***REMOVED***(${VALUE.source***REMOVED***|${CUSTOM_PROPERTY.source***REMOVED***))?\\s*\\)$`
)
let HSL = new RegExp(
  `^(hsla?)\\(\\s*((?:${VALUE.source***REMOVED***)(?:deg|rad|grad|turn)?|${CUSTOM_PROPERTY.source***REMOVED***)(?:${SEP.source***REMOVED***(${VALUE.source***REMOVED***|${CUSTOM_PROPERTY.source***REMOVED***))?(?:${SEP.source***REMOVED***(${VALUE.source***REMOVED***|${CUSTOM_PROPERTY.source***REMOVED***))?(?:${ALPHA_SEP.source***REMOVED***(${VALUE.source***REMOVED***|${CUSTOM_PROPERTY.source***REMOVED***))?\\s*\\)$`
)

// In "loose" mode the color may contain fewer than 3 parts, as long as at least
// one of the parts is variable.
export function parseColor(value, { loose = false ***REMOVED*** = {***REMOVED***) {
  if (typeof value !== 'string') {
    return null
  ***REMOVED***

  value = value.trim()
  if (value === 'transparent') {
    return { mode: 'rgb', color: ['0', '0', '0'], alpha: '0' ***REMOVED***
  ***REMOVED***

  if (value in namedColors) {
    return { mode: 'rgb', color: namedColors[value].map((v) => v.toString()) ***REMOVED***
  ***REMOVED***

  let hex = value
    .replace(SHORT_HEX, (_, r, g, b, a) => ['#', r, r, g, g, b, b, a ? a + a : ''].join(''))
    .match(HEX)

  if (hex !== null) {
    return {
      mode: 'rgb',
      color: [parseInt(hex[1], 16), parseInt(hex[2], 16), parseInt(hex[3], 16)].map((v) =>
        v.toString()
      ),
      alpha: hex[4] ? (parseInt(hex[4], 16) / 255).toString() : undefined,
    ***REMOVED***
  ***REMOVED***

  let match = value.match(RGB) ?? value.match(HSL)

  if (match === null) {
    return null
  ***REMOVED***

  let color = [match[2], match[3], match[4]].filter(Boolean).map((v) => v.toString())

  // rgba(var(--my-color), 0.1)
  // hsla(var(--my-color), 0.1)
  if (color.length === 2 && color[0].startsWith('var(')) {
    return {
      mode: match[1],
      color: [color[0]],
      alpha: color[1],
    ***REMOVED***
  ***REMOVED***

  if (!loose && color.length !== 3) {
    return null
  ***REMOVED***

  if (color.length < 3 && !color.some((part) => /^var\(.*?\)$/.test(part))) {
    return null
  ***REMOVED***

  return {
    mode: match[1],
    color,
    alpha: match[5]?.toString?.(),
  ***REMOVED***
***REMOVED***

export function formatColor({ mode, color, alpha ***REMOVED***) {
  let hasAlpha = alpha !== undefined

  if (mode === 'rgba' || mode === 'hsla') {
    return `${mode***REMOVED***(${color.join(', ')***REMOVED***${hasAlpha ? `, ${alpha***REMOVED***` : ''***REMOVED***)`
  ***REMOVED***

  return `${mode***REMOVED***(${color.join(' ')***REMOVED***${hasAlpha ? ` / ${alpha***REMOVED***` : ''***REMOVED***)`
***REMOVED***
