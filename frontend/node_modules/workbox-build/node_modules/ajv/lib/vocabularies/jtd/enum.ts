import type {CodeKeywordDefinition, KeywordErrorDefinition, ErrorObject***REMOVED*** from "../../types"
import type {KeywordCxt***REMOVED*** from "../../compile/validate"
import {_, or, and, Code***REMOVED*** from "../../compile/codegen"
import {checkMetadata***REMOVED*** from "./metadata"
import {checkNullable***REMOVED*** from "./nullable"

export type JTDEnumError = ErrorObject<"enum", {allowedValues: string[]***REMOVED***, string[]>

const error: KeywordErrorDefinition = {
  message: "must be equal to one of the allowed values",
  params: ({schemaCode***REMOVED***) => _`{allowedValues: ${schemaCode***REMOVED******REMOVED***`,
***REMOVED***

const def: CodeKeywordDefinition = {
  keyword: "enum",
  schemaType: "array",
  error,
  code(cxt: KeywordCxt) {
    checkMetadata(cxt)
    const {gen, data, schema, schemaValue, parentSchema, it***REMOVED*** = cxt
    if (schema.length === 0) throw new Error("enum must have non-empty array")
    if (schema.length !== new Set(schema).size) throw new Error("enum items must be unique")
    let valid: Code
    const isString = _`typeof ${data***REMOVED*** == "string"`
    if (schema.length >= it.opts.loopEnum) {
      let cond: Code
      ;[valid, cond] = checkNullable(cxt, isString)
      gen.if(cond, loopEnum)
    ***REMOVED*** else {
      /* istanbul ignore if */
      if (!Array.isArray(schema)) throw new Error("ajv implementation error")
      valid = and(isString, or(...schema.map((value: string) => _`${data***REMOVED*** === ${value***REMOVED***`)))
      if (parentSchema.nullable) valid = or(_`${data***REMOVED*** === null`, valid)
    ***REMOVED***
    cxt.pass(valid)

    function loopEnum(): void {
      gen.forOf("v", schemaValue as Code, (v) =>
        gen.if(_`${valid***REMOVED*** = ${data***REMOVED*** === ${v***REMOVED***`, () => gen.break())
      )
    ***REMOVED***
  ***REMOVED***,
***REMOVED***

export default def
