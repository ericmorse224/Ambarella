/**
 * @fileoverview Rule to flag statements that use != and == instead of !== and ===
 * @author Nicholas C. Zakas
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "suggestion",
		hasSuggestions: true,

		docs: {
			description: "Require the use of `===` and `!==`",
			recommended: false,
			url: "https://eslint.org/docs/latest/rules/eqeqeq",
		***REMOVED***,

		schema: {
			anyOf: [
				{
					type: "array",
					items: [
						{
							enum: ["always"],
						***REMOVED***,
						{
							type: "object",
							properties: {
								null: {
									enum: ["always", "never", "ignore"],
								***REMOVED***,
							***REMOVED***,
							additionalProperties: false,
						***REMOVED***,
					],
					additionalItems: false,
				***REMOVED***,
				{
					type: "array",
					items: [
						{
							enum: ["smart", "allow-null"],
						***REMOVED***,
					],
					additionalItems: false,
				***REMOVED***,
			],
		***REMOVED***,

		fixable: "code",

		messages: {
			unexpected:
				"Expected '{{expectedOperator***REMOVED******REMOVED***' and instead saw '{{actualOperator***REMOVED******REMOVED***'.",
			replaceOperator:
				"Use '{{expectedOperator***REMOVED******REMOVED***' instead of '{{actualOperator***REMOVED******REMOVED***'.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const config = context.options[0] || "always";
		const options = context.options[1] || {***REMOVED***;
		const sourceCode = context.sourceCode;

		const nullOption =
			config === "always" ? options.null || "always" : "ignore";
		const enforceRuleForNull = nullOption === "always";
		const enforceInverseRuleForNull = nullOption === "never";

		/**
		 * Checks if an expression is a typeof expression
		 * @param {ASTNode***REMOVED*** node The node to check
		 * @returns {boolean***REMOVED*** if the node is a typeof expression
		 */
		function isTypeOf(node) {
			return (
				node.type === "UnaryExpression" && node.operator === "typeof"
			);
		***REMOVED***

		/**
		 * Checks if either operand of a binary expression is a typeof operation
		 * @param {ASTNode***REMOVED*** node The node to check
		 * @returns {boolean***REMOVED*** if one of the operands is typeof
		 * @private
		 */
		function isTypeOfBinary(node) {
			return isTypeOf(node.left) || isTypeOf(node.right);
		***REMOVED***

		/**
		 * Checks if operands are literals of the same type (via typeof)
		 * @param {ASTNode***REMOVED*** node The node to check
		 * @returns {boolean***REMOVED*** if operands are of same type
		 * @private
		 */
		function areLiteralsAndSameType(node) {
			return (
				node.left.type === "Literal" &&
				node.right.type === "Literal" &&
				typeof node.left.value === typeof node.right.value
			);
		***REMOVED***

		/**
		 * Checks if one of the operands is a literal null
		 * @param {ASTNode***REMOVED*** node The node to check
		 * @returns {boolean***REMOVED*** if operands are null
		 * @private
		 */
		function isNullCheck(node) {
			return (
				astUtils.isNullLiteral(node.right) ||
				astUtils.isNullLiteral(node.left)
			);
		***REMOVED***

		/**
		 * Reports a message for this rule.
		 * @param {ASTNode***REMOVED*** node The binary expression node that was checked
		 * @param {string***REMOVED*** expectedOperator The operator that was expected (either '==', '!=', '===', or '!==')
		 * @returns {void***REMOVED***
		 * @private
		 */
		function report(node, expectedOperator) {
			const operatorToken = sourceCode.getFirstTokenBetween(
				node.left,
				node.right,
				token => token.value === node.operator,
			);

			const commonReportParams = {
				node,
				loc: operatorToken.loc,
				messageId: "unexpected",
				data: { expectedOperator, actualOperator: node.operator ***REMOVED***,
			***REMOVED***;

			if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {
				context.report({
					...commonReportParams,
					fix(fixer) {
						return fixer.replaceText(
							operatorToken,
							expectedOperator,
						);
					***REMOVED***,
				***REMOVED***);
			***REMOVED*** else {
				context.report({
					...commonReportParams,
					suggest: [
						{
							messageId: "replaceOperator",
							data: {
								expectedOperator,
								actualOperator: node.operator,
							***REMOVED***,
							fix: fixer =>
								fixer.replaceText(
									operatorToken,
									expectedOperator,
								),
						***REMOVED***,
					],
				***REMOVED***);
			***REMOVED***
		***REMOVED***

		return {
			BinaryExpression(node) {
				const isNull = isNullCheck(node);

				if (node.operator !== "==" && node.operator !== "!=") {
					if (enforceInverseRuleForNull && isNull) {
						report(node, node.operator.slice(0, -1));
					***REMOVED***
					return;
				***REMOVED***

				if (
					config === "smart" &&
					(isTypeOfBinary(node) ||
						areLiteralsAndSameType(node) ||
						isNull)
				) {
					return;
				***REMOVED***

				if (!enforceRuleForNull && isNull) {
					return;
				***REMOVED***

				report(node, `${node.operator***REMOVED***=`);
			***REMOVED***,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
