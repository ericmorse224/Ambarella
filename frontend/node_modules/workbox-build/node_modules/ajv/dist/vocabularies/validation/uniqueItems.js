"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const dataType_1 = require("../../compile/validate/dataType");
const codegen_1 = require("../../compile/codegen");
const util_1 = require("../../compile/util");
const equal_1 = require("../../runtime/equal");
const error = {
    message: ({ params: { i, j ***REMOVED*** ***REMOVED***) => (0, codegen_1.str) `must NOT have duplicate items (items ## ${j***REMOVED*** and ${i***REMOVED*** are identical)`,
    params: ({ params: { i, j ***REMOVED*** ***REMOVED***) => (0, codegen_1._) `{i: ${i***REMOVED***, j: ${j***REMOVED******REMOVED***`,
***REMOVED***;
const def = {
    keyword: "uniqueItems",
    type: "array",
    schemaType: "boolean",
    $data: true,
    error,
    code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it ***REMOVED*** = cxt;
        if (!$data && !schema)
            return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._) `${schemaCode***REMOVED*** === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
            const i = gen.let("i", (0, codegen_1._) `${data***REMOVED***.length`);
            const j = gen.let("j");
            cxt.setParams({ i, j ***REMOVED***);
            gen.assign(valid, true);
            gen.if((0, codegen_1._) `${i***REMOVED*** > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        ***REMOVED***
        function canOptimize() {
            return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        ***REMOVED***
        function loopN(i, j) {
            const item = gen.name("item");
            const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
            const indices = gen.const("indices", (0, codegen_1._) `{***REMOVED***`);
            gen.for((0, codegen_1._) `;${i***REMOVED***--;`, () => {
                gen.let(item, (0, codegen_1._) `${data***REMOVED***[${i***REMOVED***]`);
                gen.if(wrongType, (0, codegen_1._) `continue`);
                if (itemTypes.length > 1)
                    gen.if((0, codegen_1._) `typeof ${item***REMOVED*** == "string"`, (0, codegen_1._) `${item***REMOVED*** += "_"`);
                gen
                    .if((0, codegen_1._) `typeof ${indices***REMOVED***[${item***REMOVED***] == "number"`, () => {
                    gen.assign(j, (0, codegen_1._) `${indices***REMOVED***[${item***REMOVED***]`);
                    cxt.error();
                    gen.assign(valid, false).break();
                ***REMOVED***)
                    .code((0, codegen_1._) `${indices***REMOVED***[${item***REMOVED***] = ${i***REMOVED***`);
            ***REMOVED***);
        ***REMOVED***
        function loopN2(i, j) {
            const eql = (0, util_1.useFunc)(gen, equal_1.default);
            const outer = gen.name("outer");
            gen.label(outer).for((0, codegen_1._) `;${i***REMOVED***--;`, () => gen.for((0, codegen_1._) `${j***REMOVED*** = ${i***REMOVED***; ${j***REMOVED***--;`, () => gen.if((0, codegen_1._) `${eql***REMOVED***(${data***REMOVED***[${i***REMOVED***], ${data***REMOVED***[${j***REMOVED***])`, () => {
                cxt.error();
                gen.assign(valid, false).break(outer);
            ***REMOVED***)));
        ***REMOVED***
    ***REMOVED***,
***REMOVED***;
exports.default = def;
//# sourceMappingURL=uniqueItems.js.map