import type {CodeKeywordDefinition, KeywordErrorDefinition***REMOVED*** from "../../types"
import type {KeywordCxt***REMOVED*** from "../../compile/validate"
import {_, nil, or, Code***REMOVED*** from "../../compile/codegen"
import validTimestamp from "../../runtime/timestamp"
import {useFunc***REMOVED*** from "../../compile/util"
import {checkMetadata***REMOVED*** from "./metadata"
import {typeErrorMessage, typeErrorParams, _JTDTypeError***REMOVED*** from "./error"

export type JTDTypeError = _JTDTypeError<"type", JTDType, JTDType>

export type IntType = "int8" | "uint8" | "int16" | "uint16" | "int32" | "uint32"

export const intRange: {[T in IntType]: [number, number, number]***REMOVED*** = {
  int8: [-128, 127, 3],
  uint8: [0, 255, 3],
  int16: [-32768, 32767, 5],
  uint16: [0, 65535, 5],
  int32: [-2147483648, 2147483647, 10],
  uint32: [0, 4294967295, 10],
***REMOVED***

export type JTDType = "boolean" | "string" | "timestamp" | "float32" | "float64" | IntType

const error: KeywordErrorDefinition = {
  message: (cxt) => typeErrorMessage(cxt, cxt.schema),
  params: (cxt) => typeErrorParams(cxt, cxt.schema),
***REMOVED***

function timestampCode(cxt: KeywordCxt): Code {
  const {gen, data, it***REMOVED*** = cxt
  const {timestamp, allowDate***REMOVED*** = it.opts
  if (timestamp === "date") return _`${data***REMOVED*** instanceof Date `
  const vts = useFunc(gen, validTimestamp)
  const allowDateArg = allowDate ? _`, true` : nil
  const validString = _`typeof ${data***REMOVED*** == "string" && ${vts***REMOVED***(${data***REMOVED***${allowDateArg***REMOVED***)`
  return timestamp === "string" ? validString : or(_`${data***REMOVED*** instanceof Date`, validString)
***REMOVED***

const def: CodeKeywordDefinition = {
  keyword: "type",
  schemaType: "string",
  error,
  code(cxt: KeywordCxt) {
    checkMetadata(cxt)
    const {data, schema, parentSchema, it***REMOVED*** = cxt
    let cond: Code
    switch (schema) {
      case "boolean":
      case "string":
        cond = _`typeof ${data***REMOVED*** == ${schema***REMOVED***`
        break
      case "timestamp": {
        cond = timestampCode(cxt)
        break
      ***REMOVED***
      case "float32":
      case "float64":
        cond = _`typeof ${data***REMOVED*** == "number"`
        break
      default: {
        const sch = schema as IntType
        cond = _`typeof ${data***REMOVED*** == "number" && isFinite(${data***REMOVED***) && !(${data***REMOVED*** % 1)`
        if (!it.opts.int32range && (sch === "int32" || sch === "uint32")) {
          if (sch === "uint32") cond = _`${cond***REMOVED*** && ${data***REMOVED*** >= 0`
        ***REMOVED*** else {
          const [min, max] = intRange[sch]
          cond = _`${cond***REMOVED*** && ${data***REMOVED*** >= ${min***REMOVED*** && ${data***REMOVED*** <= ${max***REMOVED***`
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    cxt.pass(parentSchema.nullable ? or(_`${data***REMOVED*** === null`, cond) : cond)
  ***REMOVED***,
***REMOVED***

export default def
