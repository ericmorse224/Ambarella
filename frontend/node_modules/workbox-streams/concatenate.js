/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
import { assert ***REMOVED*** from 'workbox-core/_private/assert.js';
import { Deferred ***REMOVED*** from 'workbox-core/_private/Deferred.js';
import { logger ***REMOVED*** from 'workbox-core/_private/logger.js';
import { WorkboxError ***REMOVED*** from 'workbox-core/_private/WorkboxError.js';
import './_version.js';
/**
 * Takes either a Response, a ReadableStream, or a
 * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the
 * ReadableStreamReader object associated with it.
 *
 * @param {workbox-streams.StreamSource***REMOVED*** source
 * @return {ReadableStreamReader***REMOVED***
 * @private
 */
function _getReaderFromSource(source) {
    if (source instanceof Response) {
        // See https://github.com/GoogleChrome/workbox/issues/2998
        if (source.body) {
            return source.body.getReader();
        ***REMOVED***
        throw new WorkboxError('opaque-streams-source', { type: source.type ***REMOVED***);
    ***REMOVED***
    if (source instanceof ReadableStream) {
        return source.getReader();
    ***REMOVED***
    return new Response(source).body.getReader();
***REMOVED***
/**
 * Takes multiple source Promises, each of which could resolve to a Response, a
 * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).
 *
 * Returns an object exposing a ReadableStream with each individual stream's
 * data returned in sequence, along with a Promise which signals when the
 * stream is finished (useful for passing to a FetchEvent's waitUntil()).
 *
 * @param {Array<Promise<workbox-streams.StreamSource>>***REMOVED*** sourcePromises
 * @return {Object<{done: Promise, stream: ReadableStream***REMOVED***>***REMOVED***
 *
 * @memberof workbox-streams
 */
function concatenate(sourcePromises) {
    if (process.env.NODE_ENV !== 'production') {
        assert.isArray(sourcePromises, {
            moduleName: 'workbox-streams',
            funcName: 'concatenate',
            paramName: 'sourcePromises',
        ***REMOVED***);
    ***REMOVED***
    const readerPromises = sourcePromises.map((sourcePromise) => {
        return Promise.resolve(sourcePromise).then((source) => {
            return _getReaderFromSource(source);
        ***REMOVED***);
    ***REMOVED***);
    const streamDeferred = new Deferred();
    let i = 0;
    const logMessages = [];
    const stream = new ReadableStream({
        pull(controller) {
            return readerPromises[i]
                .then((reader) => {
                if (reader instanceof ReadableStreamDefaultReader) {
                    return reader.read();
                ***REMOVED***
                else {
                    return;
                ***REMOVED***
            ***REMOVED***)
                .then((result) => {
                if (result === null || result === void 0 ? void 0 : result.done) {
                    if (process.env.NODE_ENV !== 'production') {
                        logMessages.push([
                            'Reached the end of source:',
                            sourcePromises[i],
                        ]);
                    ***REMOVED***
                    i++;
                    if (i >= readerPromises.length) {
                        // Log all the messages in the group at once in a single group.
                        if (process.env.NODE_ENV !== 'production') {
                            logger.groupCollapsed(`Concatenating ${readerPromises.length***REMOVED*** sources.`);
                            for (const message of logMessages) {
                                if (Array.isArray(message)) {
                                    logger.log(...message);
                                ***REMOVED***
                                else {
                                    logger.log(message);
                                ***REMOVED***
                            ***REMOVED***
                            logger.log('Finished reading all sources.');
                            logger.groupEnd();
                        ***REMOVED***
                        controller.close();
                        streamDeferred.resolve();
                        return;
                    ***REMOVED***
                    // The `pull` method is defined because we're inside it.
                    return this.pull(controller);
                ***REMOVED***
                else {
                    controller.enqueue(result === null || result === void 0 ? void 0 : result.value);
                ***REMOVED***
            ***REMOVED***)
                .catch((error) => {
                if (process.env.NODE_ENV !== 'production') {
                    logger.error('An error occurred:', error);
                ***REMOVED***
                streamDeferred.reject(error);
                throw error;
            ***REMOVED***);
        ***REMOVED***,
        cancel() {
            if (process.env.NODE_ENV !== 'production') {
                logger.warn('The ReadableStream was cancelled.');
            ***REMOVED***
            streamDeferred.resolve();
        ***REMOVED***,
    ***REMOVED***);
    return { done: streamDeferred.promise, stream ***REMOVED***;
***REMOVED***
export { concatenate ***REMOVED***;
