/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { STAGE_ADVANCED ***REMOVED*** = require("../OptimizationStages");
const { intersect ***REMOVED*** = require("../util/SetHelpers");
const {
	compareModulesByIdentifier,
	compareChunks
***REMOVED*** = require("../util/comparators");
const createSchemaValidation = require("../util/create-schema-validation");
const identifierUtils = require("../util/identifier");

/** @typedef {import("../../declarations/plugins/optimize/AggressiveSplittingPlugin").AggressiveSplittingPluginOptions***REMOVED*** AggressiveSplittingPluginOptions */
/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../Module")***REMOVED*** Module */

const validate = createSchemaValidation(
	require("../../schemas/plugins/optimize/AggressiveSplittingPlugin.check.js"),
	() =>
		require("../../schemas/plugins/optimize/AggressiveSplittingPlugin.json"),
	{
		name: "Aggressive Splitting Plugin",
		baseDataPath: "options"
	***REMOVED***
);

/**
 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @param {Chunk***REMOVED*** oldChunk the old chunk
 * @param {Chunk***REMOVED*** newChunk the new chunk
 * @returns {(module: Module) => void***REMOVED*** function to move module between chunks
 */
const moveModuleBetween = (chunkGraph, oldChunk, newChunk) => module => {
	chunkGraph.disconnectChunkAndModule(oldChunk, module);
	chunkGraph.connectChunkAndModule(newChunk, module);
***REMOVED***;

/**
 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @param {Chunk***REMOVED*** chunk the chunk
 * @returns {(module: Module) => boolean***REMOVED*** filter for entry module
 */
const isNotAEntryModule = (chunkGraph, chunk) => module =>
	!chunkGraph.isEntryModuleInChunk(module, chunk);

/** @type {WeakSet<Chunk>***REMOVED*** */
const recordedChunks = new WeakSet();

const PLUGIN_NAME = "AggressiveSplittingPlugin";

class AggressiveSplittingPlugin {
	/**
	 * @param {AggressiveSplittingPluginOptions=***REMOVED*** options options object
	 */
	constructor(options = {***REMOVED***) {
		validate(options);

		this.options = options;
		if (typeof this.options.minSize !== "number") {
			this.options.minSize = 30 * 1024;
		***REMOVED***
		if (typeof this.options.maxSize !== "number") {
			this.options.maxSize = 50 * 1024;
		***REMOVED***
		if (typeof this.options.chunkOverhead !== "number") {
			this.options.chunkOverhead = 0;
		***REMOVED***
		if (typeof this.options.entryChunkMultiplicator !== "number") {
			this.options.entryChunkMultiplicator = 1;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk the chunk to test
	 * @returns {boolean***REMOVED*** true if the chunk was recorded
	 */
	static wasChunkRecorded(chunk) {
		return recordedChunks.has(chunk);
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		compiler.hooks.thisCompilation.tap(PLUGIN_NAME, compilation => {
			let needAdditionalSeal = false;
			/** @typedef {{ id?: NonNullable<Chunk["id"]>, hash?: NonNullable<Chunk["hash"]>, modules: Module[], size: number ***REMOVED******REMOVED*** SplitData */
			/** @type {SplitData[]***REMOVED*** */
			let newSplits;
			/** @type {Set<Chunk>***REMOVED*** */
			let fromAggressiveSplittingSet;
			/** @type {Map<Chunk, SplitData>***REMOVED*** */
			let chunkSplitDataMap;
			compilation.hooks.optimize.tap(PLUGIN_NAME, () => {
				newSplits = [];
				fromAggressiveSplittingSet = new Set();
				chunkSplitDataMap = new Map();
			***REMOVED***);
			compilation.hooks.optimizeChunks.tap(
				{
					name: PLUGIN_NAME,
					stage: STAGE_ADVANCED
				***REMOVED***,
				chunks => {
					const chunkGraph = compilation.chunkGraph;
					// Precompute stuff
					const nameToModuleMap = new Map();
					const moduleToNameMap = new Map();
					const makePathsRelative =
						identifierUtils.makePathsRelative.bindContextCache(
							compiler.context,
							compiler.root
						);
					for (const m of compilation.modules) {
						const name = makePathsRelative(m.identifier());
						nameToModuleMap.set(name, m);
						moduleToNameMap.set(m, name);
					***REMOVED***

					// Check used chunk ids
					const usedIds = new Set();
					for (const chunk of chunks) {
						usedIds.add(chunk.id);
					***REMOVED***

					const recordedSplits =
						(compilation.records && compilation.records.aggressiveSplits) || [];
					const usedSplits = newSplits
						? recordedSplits.concat(newSplits)
						: recordedSplits;

					const minSize = /** @type {number***REMOVED*** */ (this.options.minSize);
					const maxSize = /** @type {number***REMOVED*** */ (this.options.maxSize);

					/**
					 * @param {SplitData***REMOVED*** splitData split data
					 * @returns {boolean***REMOVED*** true when applied, otherwise false
					 */
					const applySplit = splitData => {
						// Cannot split if id is already taken
						if (splitData.id !== undefined && usedIds.has(splitData.id)) {
							return false;
						***REMOVED***

						// Get module objects from names
						const selectedModules = splitData.modules.map(name =>
							nameToModuleMap.get(name)
						);

						// Does the modules exist at all?
						if (!selectedModules.every(Boolean)) return false;

						// Check if size matches (faster than waiting for hash)
						let size = 0;
						for (const m of selectedModules) size += m.size();
						if (size !== splitData.size) return false;

						// get chunks with all modules
						const selectedChunks = intersect(
							selectedModules.map(
								m => new Set(chunkGraph.getModuleChunksIterable(m))
							)
						);

						// No relevant chunks found
						if (selectedChunks.size === 0) return false;

						// The found chunk is already the split or similar
						if (
							selectedChunks.size === 1 &&
							chunkGraph.getNumberOfChunkModules(
								Array.from(selectedChunks)[0]
							) === selectedModules.length
						) {
							const chunk = Array.from(selectedChunks)[0];
							if (fromAggressiveSplittingSet.has(chunk)) return false;
							fromAggressiveSplittingSet.add(chunk);
							chunkSplitDataMap.set(chunk, splitData);
							return true;
						***REMOVED***

						// split the chunk into two parts
						const newChunk = compilation.addChunk();
						newChunk.chunkReason = "aggressive splitted";
						for (const chunk of selectedChunks) {
							for (const module of selectedModules) {
								moveModuleBetween(chunkGraph, chunk, newChunk)(module);
							***REMOVED***
							chunk.split(newChunk);
							chunk.name = null;
						***REMOVED***
						fromAggressiveSplittingSet.add(newChunk);
						chunkSplitDataMap.set(newChunk, splitData);

						if (splitData.id !== null && splitData.id !== undefined) {
							newChunk.id = splitData.id;
							newChunk.ids = [splitData.id];
						***REMOVED***
						return true;
					***REMOVED***;

					// try to restore to recorded splitting
					let changed = false;
					for (let j = 0; j < usedSplits.length; j++) {
						const splitData = usedSplits[j];
						if (applySplit(splitData)) changed = true;
					***REMOVED***

					// for any chunk which isn't splitted yet, split it and create a new entry
					// start with the biggest chunk
					const cmpFn = compareChunks(chunkGraph);
					const sortedChunks = Array.from(chunks).sort((a, b) => {
						const diff1 =
							chunkGraph.getChunkModulesSize(b) -
							chunkGraph.getChunkModulesSize(a);
						if (diff1) return diff1;
						const diff2 =
							chunkGraph.getNumberOfChunkModules(a) -
							chunkGraph.getNumberOfChunkModules(b);
						if (diff2) return diff2;
						return cmpFn(a, b);
					***REMOVED***);
					for (const chunk of sortedChunks) {
						if (fromAggressiveSplittingSet.has(chunk)) continue;
						const size = chunkGraph.getChunkModulesSize(chunk);
						if (
							size > maxSize &&
							chunkGraph.getNumberOfChunkModules(chunk) > 1
						) {
							const modules = chunkGraph
								.getOrderedChunkModules(chunk, compareModulesByIdentifier)
								.filter(isNotAEntryModule(chunkGraph, chunk));
							const selectedModules = [];
							let selectedModulesSize = 0;
							for (let k = 0; k < modules.length; k++) {
								const module = modules[k];
								const newSize = selectedModulesSize + module.size();
								if (newSize > maxSize && selectedModulesSize >= minSize) {
									break;
								***REMOVED***
								selectedModulesSize = newSize;
								selectedModules.push(module);
							***REMOVED***
							if (selectedModules.length === 0) continue;
							/** @type {SplitData***REMOVED*** */
							const splitData = {
								modules: selectedModules
									.map(m => moduleToNameMap.get(m))
									.sort(),
								size: selectedModulesSize
							***REMOVED***;

							if (applySplit(splitData)) {
								newSplits = (newSplits || []).concat(splitData);
								changed = true;
							***REMOVED***
						***REMOVED***
					***REMOVED***
					if (changed) return true;
				***REMOVED***
			);
			compilation.hooks.recordHash.tap(PLUGIN_NAME, records => {
				// 4. save made splittings to records
				const allSplits = new Set();
				/** @type {Set<SplitData>***REMOVED*** */
				const invalidSplits = new Set();

				// Check if some splittings are invalid
				// We remove invalid splittings and try again
				for (const chunk of compilation.chunks) {
					const splitData = chunkSplitDataMap.get(chunk);
					if (
						splitData !== undefined &&
						splitData.hash &&
						chunk.hash !== splitData.hash
					) {
						// Split was successful, but hash doesn't equal
						// We can throw away the split since it's useless now
						invalidSplits.add(splitData);
					***REMOVED***
				***REMOVED***

				if (invalidSplits.size > 0) {
					records.aggressiveSplits =
						/** @type {SplitData[]***REMOVED*** */
						(records.aggressiveSplits).filter(
							splitData => !invalidSplits.has(splitData)
						);
					needAdditionalSeal = true;
				***REMOVED*** else {
					// set hash and id values on all (new) splittings
					for (const chunk of compilation.chunks) {
						const splitData = chunkSplitDataMap.get(chunk);
						if (splitData !== undefined) {
							splitData.hash =
								/** @type {NonNullable<Chunk["hash"]>***REMOVED*** */
								(chunk.hash);
							splitData.id =
								/** @type {NonNullable<Chunk["id"]>***REMOVED*** */
								(chunk.id);
							allSplits.add(splitData);
							// set flag for stats
							recordedChunks.add(chunk);
						***REMOVED***
					***REMOVED***

					// Also add all unused historical splits (after the used ones)
					// They can still be used in some future compilation
					const recordedSplits =
						compilation.records && compilation.records.aggressiveSplits;
					if (recordedSplits) {
						for (const splitData of recordedSplits) {
							if (!invalidSplits.has(splitData)) allSplits.add(splitData);
						***REMOVED***
					***REMOVED***

					// record all splits
					records.aggressiveSplits = Array.from(allSplits);

					needAdditionalSeal = false;
				***REMOVED***
			***REMOVED***);
			compilation.hooks.needAdditionalSeal.tap(PLUGIN_NAME, () => {
				if (needAdditionalSeal) {
					needAdditionalSeal = false;
					return true;
				***REMOVED***
			***REMOVED***);
		***REMOVED***);
	***REMOVED***
***REMOVED***
module.exports = AggressiveSplittingPlugin;
