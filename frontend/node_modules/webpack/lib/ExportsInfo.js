/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { equals ***REMOVED*** = require("./util/ArrayHelpers");
const SortableSet = require("./util/SortableSet");
const makeSerializable = require("./util/makeSerializable");
const { forEachRuntime ***REMOVED*** = require("./util/runtime");

/** @typedef {import("./Dependency")***REMOVED*** Dependency */
/** @typedef {import("./Dependency").RuntimeSpec***REMOVED*** RuntimeSpec */
/** @typedef {import("./Module")***REMOVED*** Module */
/** @typedef {import("./ModuleGraph")***REMOVED*** ModuleGraph */
/** @typedef {import("./ModuleGraphConnection")***REMOVED*** ModuleGraphConnection */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectDeserializerContext***REMOVED*** ObjectDeserializerContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectSerializerContext***REMOVED*** ObjectSerializerContext */
/** @typedef {import("./util/Hash")***REMOVED*** Hash */

/** @typedef {typeof UsageState.OnlyPropertiesUsed | typeof UsageState.NoInfo | typeof UsageState.Unknown | typeof UsageState.Used***REMOVED*** RuntimeUsageStateType */
/** @typedef {typeof UsageState.Unused | RuntimeUsageStateType***REMOVED*** UsageStateType */

const UsageState = Object.freeze({
	Unused: /** @type {0***REMOVED*** */ (0),
	OnlyPropertiesUsed: /** @type {1***REMOVED*** */ (1),
	NoInfo: /** @type {2***REMOVED*** */ (2),
	Unknown: /** @type {3***REMOVED*** */ (3),
	Used: /** @type {4***REMOVED*** */ (4)
***REMOVED***);

const RETURNS_TRUE = () => true;

const CIRCULAR = Symbol("circular target");

/**
 * @typedef {object***REMOVED*** RestoreProvidedDataExports
 * @property {ExportInfoName***REMOVED*** name
 * @property {ExportInfo["provided"]***REMOVED*** provided
 * @property {ExportInfo["canMangleProvide"]***REMOVED*** canMangleProvide
 * @property {ExportInfo["terminalBinding"]***REMOVED*** terminalBinding
 * @property {RestoreProvidedData | undefined***REMOVED*** exportsInfo
 */

class RestoreProvidedData {
	/**
	 * @param {RestoreProvidedDataExports[]***REMOVED*** exports exports
	 * @param {ExportInfo["provided"]***REMOVED*** otherProvided other provided
	 * @param {ExportInfo["canMangleProvide"]***REMOVED*** otherCanMangleProvide other can mangle provide
	 * @param {ExportInfo["terminalBinding"]***REMOVED*** otherTerminalBinding other terminal binding
	 */
	constructor(
		exports,
		otherProvided,
		otherCanMangleProvide,
		otherTerminalBinding
	) {
		this.exports = exports;
		this.otherProvided = otherProvided;
		this.otherCanMangleProvide = otherCanMangleProvide;
		this.otherTerminalBinding = otherTerminalBinding;
	***REMOVED***

	/**
	 * @param {ObjectSerializerContext***REMOVED*** context context
	 */
	serialize({ write ***REMOVED***) {
		write(this.exports);
		write(this.otherProvided);
		write(this.otherCanMangleProvide);
		write(this.otherTerminalBinding);
	***REMOVED***

	/**
	 * @param {ObjectDeserializerContext***REMOVED*** context context
	 * @returns {RestoreProvidedData***REMOVED*** RestoreProvidedData
	 */
	static deserialize({ read ***REMOVED***) {
		return new RestoreProvidedData(read(), read(), read(), read());
	***REMOVED***
***REMOVED***

makeSerializable(
	RestoreProvidedData,
	"webpack/lib/ModuleGraph",
	"RestoreProvidedData"
);

/** @typedef {Map<ExportInfoName, ExportInfo>***REMOVED*** Exports */
/** @typedef {string | string[] | false***REMOVED*** UsedName */

class ExportsInfo {
	constructor() {
		/** @type {Exports***REMOVED*** */
		this._exports = new Map();
		this._otherExportsInfo = new ExportInfo(/** @type {TODO***REMOVED*** */ (null));
		this._sideEffectsOnlyInfo = new ExportInfo("*side effects only*");
		this._exportsAreOrdered = false;
		/** @type {ExportsInfo=***REMOVED*** */
		this._redirectTo = undefined;
	***REMOVED***

	/**
	 * @returns {Iterable<ExportInfo>***REMOVED*** all owned exports in any order
	 */
	get ownedExports() {
		return this._exports.values();
	***REMOVED***

	/**
	 * @returns {Iterable<ExportInfo>***REMOVED*** all owned exports in order
	 */
	get orderedOwnedExports() {
		if (!this._exportsAreOrdered) {
			this._sortExports();
		***REMOVED***
		return this._exports.values();
	***REMOVED***

	/**
	 * @returns {Iterable<ExportInfo>***REMOVED*** all exports in any order
	 */
	get exports() {
		if (this._redirectTo !== undefined) {
			const map = new Map(this._redirectTo._exports);
			for (const [key, value] of this._exports) {
				map.set(key, value);
			***REMOVED***
			return map.values();
		***REMOVED***
		return this._exports.values();
	***REMOVED***

	/**
	 * @returns {Iterable<ExportInfo>***REMOVED*** all exports in order
	 */
	get orderedExports() {
		if (!this._exportsAreOrdered) {
			this._sortExports();
		***REMOVED***
		if (this._redirectTo !== undefined) {
			/** @type {Exports***REMOVED*** */
			const map = new Map(
				Array.from(this._redirectTo.orderedExports, item => [item.name, item])
			);
			for (const [key, value] of this._exports) {
				map.set(key, value);
			***REMOVED***
			// sorting should be pretty fast as map contains
			// a lot of presorted items
			this._sortExportsMap(map);
			return map.values();
		***REMOVED***
		return this._exports.values();
	***REMOVED***

	/**
	 * @returns {ExportInfo***REMOVED*** the export info of unlisted exports
	 */
	get otherExportsInfo() {
		if (this._redirectTo !== undefined)
			return this._redirectTo.otherExportsInfo;
		return this._otherExportsInfo;
	***REMOVED***

	/**
	 * @param {Exports***REMOVED*** exports exports
	 * @private
	 */
	_sortExportsMap(exports) {
		if (exports.size > 1) {
			/** @type {string[]***REMOVED*** */
			const namesInOrder = [];
			for (const entry of exports.values()) {
				namesInOrder.push(entry.name);
			***REMOVED***
			namesInOrder.sort();
			let i = 0;
			for (const entry of exports.values()) {
				const name = namesInOrder[i];
				if (entry.name !== name) break;
				i++;
			***REMOVED***
			for (; i < namesInOrder.length; i++) {
				const name = namesInOrder[i];
				const correctEntry = /** @type {ExportInfo***REMOVED*** */ (exports.get(name));
				exports.delete(name);
				exports.set(name, correctEntry);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	_sortExports() {
		this._sortExportsMap(this._exports);
		this._exportsAreOrdered = true;
	***REMOVED***

	/**
	 * @param {ExportsInfo | undefined***REMOVED*** exportsInfo exports info
	 * @returns {boolean***REMOVED*** result
	 */
	setRedirectNamedTo(exportsInfo) {
		if (this._redirectTo === exportsInfo) return false;
		this._redirectTo = exportsInfo;
		return true;
	***REMOVED***

	setHasProvideInfo() {
		for (const exportInfo of this._exports.values()) {
			if (exportInfo.provided === undefined) {
				exportInfo.provided = false;
			***REMOVED***
			if (exportInfo.canMangleProvide === undefined) {
				exportInfo.canMangleProvide = true;
			***REMOVED***
		***REMOVED***
		if (this._redirectTo !== undefined) {
			this._redirectTo.setHasProvideInfo();
		***REMOVED*** else {
			if (this._otherExportsInfo.provided === undefined) {
				this._otherExportsInfo.provided = false;
			***REMOVED***
			if (this._otherExportsInfo.canMangleProvide === undefined) {
				this._otherExportsInfo.canMangleProvide = true;
			***REMOVED***
		***REMOVED***
	***REMOVED***

	setHasUseInfo() {
		for (const exportInfo of this._exports.values()) {
			exportInfo.setHasUseInfo();
		***REMOVED***
		this._sideEffectsOnlyInfo.setHasUseInfo();
		if (this._redirectTo !== undefined) {
			this._redirectTo.setHasUseInfo();
		***REMOVED*** else {
			this._otherExportsInfo.setHasUseInfo();
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ExportInfoName***REMOVED*** name export name
	 * @returns {ExportInfo***REMOVED*** export info for this name
	 */
	getOwnExportInfo(name) {
		const info = this._exports.get(name);
		if (info !== undefined) return info;
		const newInfo = new ExportInfo(name, this._otherExportsInfo);
		this._exports.set(name, newInfo);
		this._exportsAreOrdered = false;
		return newInfo;
	***REMOVED***

	/**
	 * @param {ExportInfoName***REMOVED*** name export name
	 * @returns {ExportInfo***REMOVED*** export info for this name
	 */
	getExportInfo(name) {
		const info = this._exports.get(name);
		if (info !== undefined) return info;
		if (this._redirectTo !== undefined)
			return this._redirectTo.getExportInfo(name);
		const newInfo = new ExportInfo(name, this._otherExportsInfo);
		this._exports.set(name, newInfo);
		this._exportsAreOrdered = false;
		return newInfo;
	***REMOVED***

	/**
	 * @param {ExportInfoName***REMOVED*** name export name
	 * @returns {ExportInfo***REMOVED*** export info for this name
	 */
	getReadOnlyExportInfo(name) {
		const info = this._exports.get(name);
		if (info !== undefined) return info;
		if (this._redirectTo !== undefined)
			return this._redirectTo.getReadOnlyExportInfo(name);
		return this._otherExportsInfo;
	***REMOVED***

	/**
	 * @param {ExportInfoName[]***REMOVED*** name export name
	 * @returns {ExportInfo | undefined***REMOVED*** export info for this name
	 */
	getReadOnlyExportInfoRecursive(name) {
		const exportInfo = this.getReadOnlyExportInfo(name[0]);
		if (name.length === 1) return exportInfo;
		if (!exportInfo.exportsInfo) return;
		return exportInfo.exportsInfo.getReadOnlyExportInfoRecursive(name.slice(1));
	***REMOVED***

	/**
	 * @param {ExportInfoName[]=***REMOVED*** name the export name
	 * @returns {ExportsInfo | undefined***REMOVED*** the nested exports info
	 */
	getNestedExportsInfo(name) {
		if (Array.isArray(name) && name.length > 0) {
			const info = this.getReadOnlyExportInfo(name[0]);
			if (!info.exportsInfo) return;
			return info.exportsInfo.getNestedExportsInfo(name.slice(1));
		***REMOVED***
		return this;
	***REMOVED***

	/**
	 * @param {boolean=***REMOVED*** canMangle true, if exports can still be mangled (defaults to false)
	 * @param {Set<string>=***REMOVED*** excludeExports list of unaffected exports
	 * @param {Dependency=***REMOVED*** targetKey use this as key for the target
	 * @param {ModuleGraphConnection=***REMOVED*** targetModule set this module as target
	 * @param {number=***REMOVED*** priority priority
	 * @returns {boolean***REMOVED*** true, if this call changed something
	 */
	setUnknownExportsProvided(
		canMangle,
		excludeExports,
		targetKey,
		targetModule,
		priority
	) {
		let changed = false;
		if (excludeExports) {
			for (const name of excludeExports) {
				// Make sure these entries exist, so they can get different info
				this.getExportInfo(name);
			***REMOVED***
		***REMOVED***
		for (const exportInfo of this._exports.values()) {
			if (!canMangle && exportInfo.canMangleProvide !== false) {
				exportInfo.canMangleProvide = false;
				changed = true;
			***REMOVED***
			if (excludeExports && excludeExports.has(exportInfo.name)) continue;
			if (exportInfo.provided !== true && exportInfo.provided !== null) {
				exportInfo.provided = null;
				changed = true;
			***REMOVED***
			if (targetKey) {
				exportInfo.setTarget(
					targetKey,
					/** @type {ModuleGraphConnection***REMOVED*** */
					(targetModule),
					[exportInfo.name],
					-1
				);
			***REMOVED***
		***REMOVED***
		if (this._redirectTo !== undefined) {
			if (
				this._redirectTo.setUnknownExportsProvided(
					canMangle,
					excludeExports,
					targetKey,
					targetModule,
					priority
				)
			) {
				changed = true;
			***REMOVED***
		***REMOVED*** else {
			if (
				this._otherExportsInfo.provided !== true &&
				this._otherExportsInfo.provided !== null
			) {
				this._otherExportsInfo.provided = null;
				changed = true;
			***REMOVED***
			if (!canMangle && this._otherExportsInfo.canMangleProvide !== false) {
				this._otherExportsInfo.canMangleProvide = false;
				changed = true;
			***REMOVED***
			if (targetKey) {
				this._otherExportsInfo.setTarget(
					targetKey,
					/** @type {ModuleGraphConnection***REMOVED*** */ (targetModule),
					undefined,
					priority
				);
			***REMOVED***
		***REMOVED***
		return changed;
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @returns {boolean***REMOVED*** true, when something changed
	 */
	setUsedInUnknownWay(runtime) {
		let changed = false;
		for (const exportInfo of this._exports.values()) {
			if (exportInfo.setUsedInUnknownWay(runtime)) {
				changed = true;
			***REMOVED***
		***REMOVED***
		if (this._redirectTo !== undefined) {
			if (this._redirectTo.setUsedInUnknownWay(runtime)) {
				changed = true;
			***REMOVED***
		***REMOVED*** else {
			if (
				this._otherExportsInfo.setUsedConditionally(
					used => used < UsageState.Unknown,
					UsageState.Unknown,
					runtime
				)
			) {
				changed = true;
			***REMOVED***
			if (this._otherExportsInfo.canMangleUse !== false) {
				this._otherExportsInfo.canMangleUse = false;
				changed = true;
			***REMOVED***
		***REMOVED***
		return changed;
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @returns {boolean***REMOVED*** true, when something changed
	 */
	setUsedWithoutInfo(runtime) {
		let changed = false;
		for (const exportInfo of this._exports.values()) {
			if (exportInfo.setUsedWithoutInfo(runtime)) {
				changed = true;
			***REMOVED***
		***REMOVED***
		if (this._redirectTo !== undefined) {
			if (this._redirectTo.setUsedWithoutInfo(runtime)) {
				changed = true;
			***REMOVED***
		***REMOVED*** else {
			if (this._otherExportsInfo.setUsed(UsageState.NoInfo, runtime)) {
				changed = true;
			***REMOVED***
			if (this._otherExportsInfo.canMangleUse !== false) {
				this._otherExportsInfo.canMangleUse = false;
				changed = true;
			***REMOVED***
		***REMOVED***
		return changed;
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @returns {boolean***REMOVED*** true, when something changed
	 */
	setAllKnownExportsUsed(runtime) {
		let changed = false;
		for (const exportInfo of this._exports.values()) {
			if (!exportInfo.provided) continue;
			if (exportInfo.setUsed(UsageState.Used, runtime)) {
				changed = true;
			***REMOVED***
		***REMOVED***
		return changed;
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @returns {boolean***REMOVED*** true, when something changed
	 */
	setUsedForSideEffectsOnly(runtime) {
		return this._sideEffectsOnlyInfo.setUsedConditionally(
			used => used === UsageState.Unused,
			UsageState.Used,
			runtime
		);
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @returns {boolean***REMOVED*** true, when the module exports are used in any way
	 */
	isUsed(runtime) {
		if (this._redirectTo !== undefined) {
			if (this._redirectTo.isUsed(runtime)) {
				return true;
			***REMOVED***
		***REMOVED*** else if (this._otherExportsInfo.getUsed(runtime) !== UsageState.Unused) {
			return true;
		***REMOVED***
		for (const exportInfo of this._exports.values()) {
			if (exportInfo.getUsed(runtime) !== UsageState.Unused) {
				return true;
			***REMOVED***
		***REMOVED***
		return false;
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @returns {boolean***REMOVED*** true, when the module is used in any way
	 */
	isModuleUsed(runtime) {
		if (this.isUsed(runtime)) return true;
		if (this._sideEffectsOnlyInfo.getUsed(runtime) !== UsageState.Unused)
			return true;
		return false;
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @returns {SortableSet<string> | boolean | null***REMOVED*** set of used exports, or true (when namespace object is used), or false (when unused), or null (when unknown)
	 */
	getUsedExports(runtime) {
		// eslint-disable-next-line no-constant-binary-expression
		if (!this._redirectTo !== undefined) {
			switch (this._otherExportsInfo.getUsed(runtime)) {
				case UsageState.NoInfo:
					return null;
				case UsageState.Unknown:
				case UsageState.OnlyPropertiesUsed:
				case UsageState.Used:
					return true;
			***REMOVED***
		***REMOVED***
		const array = [];
		if (!this._exportsAreOrdered) this._sortExports();
		for (const exportInfo of this._exports.values()) {
			switch (exportInfo.getUsed(runtime)) {
				case UsageState.NoInfo:
					return null;
				case UsageState.Unknown:
					return true;
				case UsageState.OnlyPropertiesUsed:
				case UsageState.Used:
					array.push(exportInfo.name);
			***REMOVED***
		***REMOVED***
		if (this._redirectTo !== undefined) {
			const inner = this._redirectTo.getUsedExports(runtime);
			if (inner === null) return null;
			if (inner === true) return true;
			if (inner !== false) {
				for (const item of inner) {
					array.push(item);
				***REMOVED***
			***REMOVED***
		***REMOVED***
		if (array.length === 0) {
			switch (this._sideEffectsOnlyInfo.getUsed(runtime)) {
				case UsageState.NoInfo:
					return null;
				case UsageState.Unused:
					return false;
			***REMOVED***
		***REMOVED***
		return /** @type {SortableSet<string>***REMOVED*** */ (new SortableSet(array));
	***REMOVED***

	/**
	 * @returns {null | true | string[]***REMOVED*** list of exports when known
	 */
	getProvidedExports() {
		// eslint-disable-next-line no-constant-binary-expression
		if (!this._redirectTo !== undefined) {
			switch (this._otherExportsInfo.provided) {
				case undefined:
					return null;
				case null:
					return true;
				case true:
					return true;
			***REMOVED***
		***REMOVED***
		/** @type {string[]***REMOVED*** */
		const array = [];
		if (!this._exportsAreOrdered) this._sortExports();
		for (const exportInfo of this._exports.values()) {
			switch (exportInfo.provided) {
				case undefined:
					return null;
				case null:
					return true;
				case true:
					array.push(exportInfo.name);
			***REMOVED***
		***REMOVED***
		if (this._redirectTo !== undefined) {
			const inner = this._redirectTo.getProvidedExports();
			if (inner === null) return null;
			if (inner === true) return true;
			for (const item of inner) {
				if (!array.includes(item)) {
					array.push(item);
				***REMOVED***
			***REMOVED***
		***REMOVED***
		return array;
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @returns {ExportInfo[]***REMOVED*** exports that are relevant (not unused and potential provided)
	 */
	getRelevantExports(runtime) {
		const list = [];
		for (const exportInfo of this._exports.values()) {
			const used = exportInfo.getUsed(runtime);
			if (used === UsageState.Unused) continue;
			if (exportInfo.provided === false) continue;
			list.push(exportInfo);
		***REMOVED***
		if (this._redirectTo !== undefined) {
			for (const exportInfo of this._redirectTo.getRelevantExports(runtime)) {
				if (!this._exports.has(exportInfo.name)) list.push(exportInfo);
			***REMOVED***
		***REMOVED***
		if (
			this._otherExportsInfo.provided !== false &&
			this._otherExportsInfo.getUsed(runtime) !== UsageState.Unused
		) {
			list.push(this._otherExportsInfo);
		***REMOVED***
		return list;
	***REMOVED***

	/**
	 * @param {ExportInfoName | ExportInfoName[]***REMOVED*** name the name of the export
	 * @returns {boolean | undefined | null***REMOVED*** if the export is provided
	 */
	isExportProvided(name) {
		if (Array.isArray(name)) {
			const info = this.getReadOnlyExportInfo(name[0]);
			if (info.exportsInfo && name.length > 1) {
				return info.exportsInfo.isExportProvided(name.slice(1));
			***REMOVED***
			return info.provided ? name.length === 1 || undefined : info.provided;
		***REMOVED***
		const info = this.getReadOnlyExportInfo(name);
		return info.provided;
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime runtime
	 * @returns {string***REMOVED*** key representing the usage
	 */
	getUsageKey(runtime) {
		const key = [];
		if (this._redirectTo !== undefined) {
			key.push(this._redirectTo.getUsageKey(runtime));
		***REMOVED*** else {
			key.push(this._otherExportsInfo.getUsed(runtime));
		***REMOVED***
		key.push(this._sideEffectsOnlyInfo.getUsed(runtime));
		for (const exportInfo of this.orderedOwnedExports) {
			key.push(exportInfo.getUsed(runtime));
		***REMOVED***
		return key.join("|");
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtimeA first runtime
	 * @param {RuntimeSpec***REMOVED*** runtimeB second runtime
	 * @returns {boolean***REMOVED*** true, when equally used
	 */
	isEquallyUsed(runtimeA, runtimeB) {
		if (this._redirectTo !== undefined) {
			if (!this._redirectTo.isEquallyUsed(runtimeA, runtimeB)) return false;
		***REMOVED*** else if (
			this._otherExportsInfo.getUsed(runtimeA) !==
			this._otherExportsInfo.getUsed(runtimeB)
		) {
			return false;
		***REMOVED***
		if (
			this._sideEffectsOnlyInfo.getUsed(runtimeA) !==
			this._sideEffectsOnlyInfo.getUsed(runtimeB)
		) {
			return false;
		***REMOVED***
		for (const exportInfo of this.ownedExports) {
			if (exportInfo.getUsed(runtimeA) !== exportInfo.getUsed(runtimeB))
				return false;
		***REMOVED***
		return true;
	***REMOVED***

	/**
	 * @param {ExportInfoName | ExportInfoName[]***REMOVED*** name export name
	 * @param {RuntimeSpec***REMOVED*** runtime check usage for this runtime only
	 * @returns {UsageStateType***REMOVED*** usage status
	 */
	getUsed(name, runtime) {
		if (Array.isArray(name)) {
			if (name.length === 0) return this.otherExportsInfo.getUsed(runtime);
			const info = this.getReadOnlyExportInfo(name[0]);
			if (info.exportsInfo && name.length > 1) {
				return info.exportsInfo.getUsed(name.slice(1), runtime);
			***REMOVED***
			return info.getUsed(runtime);
		***REMOVED***
		const info = this.getReadOnlyExportInfo(name);
		return info.getUsed(runtime);
	***REMOVED***

	/**
	 * @param {ExportInfoName | ExportInfoName[]***REMOVED*** name the export name
	 * @param {RuntimeSpec***REMOVED*** runtime check usage for this runtime only
	 * @returns {UsedName***REMOVED*** the used name
	 */
	getUsedName(name, runtime) {
		if (Array.isArray(name)) {
			// TODO improve this
			if (name.length === 0) {
				if (!this.isUsed(runtime)) return false;
				return name;
			***REMOVED***
			const info = this.getReadOnlyExportInfo(name[0]);
			const x = info.getUsedName(name[0], runtime);
			if (x === false) return false;
			const arr =
				/** @type {ExportInfoName[]***REMOVED*** */
				(x === name[0] && name.length === 1 ? name : [x]);
			if (name.length === 1) {
				return arr;
			***REMOVED***
			if (
				info.exportsInfo &&
				info.getUsed(runtime) === UsageState.OnlyPropertiesUsed
			) {
				const nested = info.exportsInfo.getUsedName(name.slice(1), runtime);
				if (!nested) return false;
				return arr.concat(nested);
			***REMOVED***
			return arr.concat(name.slice(1));
		***REMOVED***
		const info = this.getReadOnlyExportInfo(name);
		const usedName = info.getUsedName(name, runtime);
		return usedName;
	***REMOVED***

	/**
	 * @param {Hash***REMOVED*** hash the hash
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @returns {void***REMOVED***
	 */
	updateHash(hash, runtime) {
		this._updateHash(hash, runtime, new Set());
	***REMOVED***

	/**
	 * @param {Hash***REMOVED*** hash the hash
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @param {Set<ExportsInfo>***REMOVED*** alreadyVisitedExportsInfo for circular references
	 * @returns {void***REMOVED***
	 */
	_updateHash(hash, runtime, alreadyVisitedExportsInfo) {
		const set = new Set(alreadyVisitedExportsInfo);
		set.add(this);
		for (const exportInfo of this.orderedExports) {
			if (exportInfo.hasInfo(this._otherExportsInfo, runtime)) {
				exportInfo._updateHash(hash, runtime, set);
			***REMOVED***
		***REMOVED***
		this._sideEffectsOnlyInfo._updateHash(hash, runtime, set);
		this._otherExportsInfo._updateHash(hash, runtime, set);
		if (this._redirectTo !== undefined) {
			this._redirectTo._updateHash(hash, runtime, set);
		***REMOVED***
	***REMOVED***

	/**
	 * @returns {RestoreProvidedData***REMOVED*** restore provided data
	 */
	getRestoreProvidedData() {
		const otherProvided = this._otherExportsInfo.provided;
		const otherCanMangleProvide = this._otherExportsInfo.canMangleProvide;
		const otherTerminalBinding = this._otherExportsInfo.terminalBinding;
		/** @type {RestoreProvidedDataExports[]***REMOVED*** */
		const exports = [];
		for (const exportInfo of this.orderedExports) {
			if (
				exportInfo.provided !== otherProvided ||
				exportInfo.canMangleProvide !== otherCanMangleProvide ||
				exportInfo.terminalBinding !== otherTerminalBinding ||
				exportInfo.exportsInfoOwned
			) {
				exports.push({
					name: exportInfo.name,
					provided: exportInfo.provided,
					canMangleProvide: exportInfo.canMangleProvide,
					terminalBinding: exportInfo.terminalBinding,
					exportsInfo: exportInfo.exportsInfoOwned
						? /** @type {NonNullable<ExportInfo["exportsInfo"]>***REMOVED*** */
							(exportInfo.exportsInfo).getRestoreProvidedData()
						: undefined
				***REMOVED***);
			***REMOVED***
		***REMOVED***
		return new RestoreProvidedData(
			exports,
			otherProvided,
			otherCanMangleProvide,
			otherTerminalBinding
		);
	***REMOVED***

	/**
	 * @param {RestoreProvidedData***REMOVED*** data data
	 */
	restoreProvided({
		otherProvided,
		otherCanMangleProvide,
		otherTerminalBinding,
		exports
	***REMOVED***) {
		let wasEmpty = true;
		for (const exportInfo of this._exports.values()) {
			wasEmpty = false;
			exportInfo.provided = otherProvided;
			exportInfo.canMangleProvide = otherCanMangleProvide;
			exportInfo.terminalBinding = otherTerminalBinding;
		***REMOVED***
		this._otherExportsInfo.provided = otherProvided;
		this._otherExportsInfo.canMangleProvide = otherCanMangleProvide;
		this._otherExportsInfo.terminalBinding = otherTerminalBinding;
		for (const exp of exports) {
			const exportInfo = this.getExportInfo(exp.name);
			exportInfo.provided = exp.provided;
			exportInfo.canMangleProvide = exp.canMangleProvide;
			exportInfo.terminalBinding = exp.terminalBinding;
			if (exp.exportsInfo) {
				const exportsInfo = exportInfo.createNestedExportsInfo();
				exportsInfo.restoreProvided(exp.exportsInfo);
			***REMOVED***
		***REMOVED***
		if (wasEmpty) this._exportsAreOrdered = true;
	***REMOVED***
***REMOVED***

/** @typedef {Map<string, RuntimeUsageStateType>***REMOVED*** UsedInRuntime */

/** @typedef {{ module: Module, export: string[] ***REMOVED******REMOVED*** TargetItemWithoutConnection */

/** @typedef {{ module: Module, connection: ModuleGraphConnection, export: string[] | undefined ***REMOVED******REMOVED*** TargetItemWithConnection */

/** @typedef {(target: TargetItemWithConnection) => boolean***REMOVED*** ResolveTargetFilter */

/** @typedef {(module: Module) => boolean***REMOVED*** ValidTargetModuleFilter */

/** @typedef {{ connection: ModuleGraphConnection, export: string[], priority: number ***REMOVED******REMOVED*** TargetItem */

/** @typedef {Map<Dependency | undefined, TargetItem>***REMOVED*** Target */

/** @typedef {string***REMOVED*** ExportInfoName */
/** @typedef {string | null***REMOVED*** ExportInfoUsedName */
/** @typedef {boolean | null***REMOVED*** ExportInfoProvided */

class ExportInfo {
	/**
	 * @param {ExportInfoName***REMOVED*** name the original name of the export
	 * @param {ExportInfo=***REMOVED*** initFrom init values from this ExportInfo
	 */
	constructor(name, initFrom) {
		/** @type {ExportInfoName***REMOVED*** */
		this.name = name;
		/**
		 * @private
		 * @type {ExportInfoUsedName***REMOVED***
		 */
		this._usedName = initFrom ? initFrom._usedName : null;
		/**
		 * @private
		 * @type {UsageStateType | undefined***REMOVED***
		 */
		this._globalUsed = initFrom ? initFrom._globalUsed : undefined;
		/**
		 * @private
		 * @type {UsedInRuntime | undefined***REMOVED***
		 */
		this._usedInRuntime =
			initFrom && initFrom._usedInRuntime
				? new Map(initFrom._usedInRuntime)
				: undefined;
		/**
		 * @private
		 * @type {boolean***REMOVED***
		 */
		this._hasUseInRuntimeInfo = initFrom
			? initFrom._hasUseInRuntimeInfo
			: false;
		/**
		 * true: it is provided
		 * false: it is not provided
		 * null: only the runtime knows if it is provided
		 * undefined: it was not determined if it is provided
		 * @type {ExportInfoProvided | undefined***REMOVED***
		 */
		this.provided = initFrom ? initFrom.provided : undefined;
		/**
		 * is the export a terminal binding that should be checked for export star conflicts
		 * @type {boolean***REMOVED***
		 */
		this.terminalBinding = initFrom ? initFrom.terminalBinding : false;
		/**
		 * true: it can be mangled
		 * false: is can not be mangled
		 * undefined: it was not determined if it can be mangled
		 * @type {boolean | undefined***REMOVED***
		 */
		this.canMangleProvide = initFrom ? initFrom.canMangleProvide : undefined;
		/**
		 * true: it can be mangled
		 * false: is can not be mangled
		 * undefined: it was not determined if it can be mangled
		 * @type {boolean | undefined***REMOVED***
		 */
		this.canMangleUse = initFrom ? initFrom.canMangleUse : undefined;
		/** @type {boolean***REMOVED*** */
		this.exportsInfoOwned = false;
		/** @type {ExportsInfo | undefined***REMOVED*** */
		this.exportsInfo = undefined;
		/** @type {Target | undefined***REMOVED*** */
		this._target = undefined;
		if (initFrom && initFrom._target) {
			this._target = new Map();
			for (const [key, value] of initFrom._target) {
				this._target.set(key, {
					connection: value.connection,
					export: value.export || [name],
					priority: value.priority
				***REMOVED***);
			***REMOVED***
		***REMOVED***
		/** @type {Target | undefined***REMOVED*** */
		this._maxTarget = undefined;
	***REMOVED***

	// TODO webpack 5 remove
	/**
	 * @private
	 * @param {EXPECTED_ANY***REMOVED*** v v
	 */
	set used(v) {
		throw new Error("REMOVED");
	***REMOVED***

	// TODO webpack 5 remove
	/** @private */
	get used() {
		throw new Error("REMOVED");
	***REMOVED***

	// TODO webpack 5 remove
	/**
	 * @private
	 * @param {EXPECTED_ANY***REMOVED*** v v
	 */
	set usedName(v) {
		throw new Error("REMOVED");
	***REMOVED***

	// TODO webpack 5 remove
	/** @private */
	get usedName() {
		throw new Error("REMOVED");
	***REMOVED***

	get canMangle() {
		switch (this.canMangleProvide) {
			case undefined:
				return this.canMangleUse === false ? false : undefined;
			case false:
				return false;
			case true:
				switch (this.canMangleUse) {
					case undefined:
						return undefined;
					case false:
						return false;
					case true:
						return true;
				***REMOVED***
		***REMOVED***
		throw new Error(
			`Unexpected flags for canMangle ${this.canMangleProvide***REMOVED*** ${this.canMangleUse***REMOVED***`
		);
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime only apply to this runtime
	 * @returns {boolean***REMOVED*** true, when something changed
	 */
	setUsedInUnknownWay(runtime) {
		let changed = false;
		if (
			this.setUsedConditionally(
				used => used < UsageState.Unknown,
				UsageState.Unknown,
				runtime
			)
		) {
			changed = true;
		***REMOVED***
		if (this.canMangleUse !== false) {
			this.canMangleUse = false;
			changed = true;
		***REMOVED***
		return changed;
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime only apply to this runtime
	 * @returns {boolean***REMOVED*** true, when something changed
	 */
	setUsedWithoutInfo(runtime) {
		let changed = false;
		if (this.setUsed(UsageState.NoInfo, runtime)) {
			changed = true;
		***REMOVED***
		if (this.canMangleUse !== false) {
			this.canMangleUse = false;
			changed = true;
		***REMOVED***
		return changed;
	***REMOVED***

	setHasUseInfo() {
		if (!this._hasUseInRuntimeInfo) {
			this._hasUseInRuntimeInfo = true;
		***REMOVED***
		if (this.canMangleUse === undefined) {
			this.canMangleUse = true;
		***REMOVED***
		if (this.exportsInfoOwned) {
			/** @type {ExportsInfo***REMOVED*** */
			(this.exportsInfo).setHasUseInfo();
		***REMOVED***
	***REMOVED***

	/**
	 * @param {(condition: UsageStateType) => boolean***REMOVED*** condition compare with old value
	 * @param {UsageStateType***REMOVED*** newValue set when condition is true
	 * @param {RuntimeSpec***REMOVED*** runtime only apply to this runtime
	 * @returns {boolean***REMOVED*** true when something has changed
	 */
	setUsedConditionally(condition, newValue, runtime) {
		if (runtime === undefined) {
			if (this._globalUsed === undefined) {
				this._globalUsed = newValue;
				return true;
			***REMOVED***
			if (this._globalUsed !== newValue && condition(this._globalUsed)) {
				this._globalUsed = newValue;
				return true;
			***REMOVED***
		***REMOVED*** else if (this._usedInRuntime === undefined) {
			if (newValue !== UsageState.Unused && condition(UsageState.Unused)) {
				this._usedInRuntime = new Map();
				forEachRuntime(runtime, runtime =>
					/** @type {UsedInRuntime***REMOVED*** */
					(this._usedInRuntime).set(/** @type {string***REMOVED*** */ (runtime), newValue)
				);
				return true;
			***REMOVED***
		***REMOVED*** else {
			let changed = false;
			forEachRuntime(runtime, _runtime => {
				const runtime = /** @type {string***REMOVED*** */ (_runtime);
				const usedInRuntime =
					/** @type {UsedInRuntime***REMOVED*** */
					(this._usedInRuntime);
				let oldValue =
					/** @type {UsageStateType***REMOVED*** */
					(usedInRuntime.get(runtime));
				if (oldValue === undefined) oldValue = UsageState.Unused;
				if (newValue !== oldValue && condition(oldValue)) {
					if (newValue === UsageState.Unused) {
						usedInRuntime.delete(runtime);
					***REMOVED*** else {
						usedInRuntime.set(runtime, newValue);
					***REMOVED***
					changed = true;
				***REMOVED***
			***REMOVED***);
			if (changed) {
				if (this._usedInRuntime.size === 0) this._usedInRuntime = undefined;
				return true;
			***REMOVED***
		***REMOVED***
		return false;
	***REMOVED***

	/**
	 * @param {UsageStateType***REMOVED*** newValue new value of the used state
	 * @param {RuntimeSpec***REMOVED*** runtime only apply to this runtime
	 * @returns {boolean***REMOVED*** true when something has changed
	 */
	setUsed(newValue, runtime) {
		if (runtime === undefined) {
			if (this._globalUsed !== newValue) {
				this._globalUsed = newValue;
				return true;
			***REMOVED***
		***REMOVED*** else if (this._usedInRuntime === undefined) {
			if (newValue !== UsageState.Unused) {
				this._usedInRuntime = new Map();
				forEachRuntime(runtime, runtime =>
					/** @type {UsedInRuntime***REMOVED*** */
					(this._usedInRuntime).set(/** @type {string***REMOVED*** */ (runtime), newValue)
				);
				return true;
			***REMOVED***
		***REMOVED*** else {
			let changed = false;
			forEachRuntime(runtime, _runtime => {
				const runtime = /** @type {string***REMOVED*** */ (_runtime);
				const usedInRuntime =
					/** @type {UsedInRuntime***REMOVED*** */
					(this._usedInRuntime);
				let oldValue =
					/** @type {UsageStateType***REMOVED*** */
					(usedInRuntime.get(runtime));
				if (oldValue === undefined) oldValue = UsageState.Unused;
				if (newValue !== oldValue) {
					if (newValue === UsageState.Unused) {
						usedInRuntime.delete(runtime);
					***REMOVED*** else {
						usedInRuntime.set(runtime, newValue);
					***REMOVED***
					changed = true;
				***REMOVED***
			***REMOVED***);
			if (changed) {
				if (this._usedInRuntime.size === 0) this._usedInRuntime = undefined;
				return true;
			***REMOVED***
		***REMOVED***
		return false;
	***REMOVED***

	/**
	 * @param {Dependency***REMOVED*** key the key
	 * @returns {boolean***REMOVED*** true, if something has changed
	 */
	unsetTarget(key) {
		if (!this._target) return false;
		if (this._target.delete(key)) {
			this._maxTarget = undefined;
			return true;
		***REMOVED***
		return false;
	***REMOVED***

	/**
	 * @param {Dependency***REMOVED*** key the key
	 * @param {ModuleGraphConnection***REMOVED*** connection the target module if a single one
	 * @param {(string[] | null)=***REMOVED*** exportName the exported name
	 * @param {number=***REMOVED*** priority priority
	 * @returns {boolean***REMOVED*** true, if something has changed
	 */
	setTarget(key, connection, exportName, priority = 0) {
		if (exportName) exportName = [...exportName];
		if (!this._target) {
			this._target = new Map();
			this._target.set(key, {
				connection,
				export: /** @type {string[]***REMOVED*** */ (exportName),
				priority
			***REMOVED***);
			return true;
		***REMOVED***
		const oldTarget = this._target.get(key);
		if (!oldTarget) {
			if (oldTarget === null && !connection) return false;
			this._target.set(key, {
				connection,
				export: /** @type {string[]***REMOVED*** */ (exportName),
				priority
			***REMOVED***);
			this._maxTarget = undefined;
			return true;
		***REMOVED***
		if (
			oldTarget.connection !== connection ||
			oldTarget.priority !== priority ||
			(exportName
				? !oldTarget.export || !equals(oldTarget.export, exportName)
				: oldTarget.export)
		) {
			oldTarget.connection = connection;
			oldTarget.export = /** @type {string[]***REMOVED*** */ (exportName);
			oldTarget.priority = priority;
			this._maxTarget = undefined;
			return true;
		***REMOVED***
		return false;
	***REMOVED***

	/**
	 * @param {RuntimeSpec***REMOVED*** runtime for this runtime
	 * @returns {UsageStateType***REMOVED*** usage state
	 */
	getUsed(runtime) {
		if (!this._hasUseInRuntimeInfo) return UsageState.NoInfo;
		if (this._globalUsed !== undefined) return this._globalUsed;
		if (this._usedInRuntime === undefined) {
			return UsageState.Unused;
		***REMOVED*** else if (typeof runtime === "string") {
			const value = this._usedInRuntime.get(runtime);
			return value === undefined ? UsageState.Unused : value;
		***REMOVED*** else if (runtime === undefined) {
			/** @type {UsageStateType***REMOVED*** */
			let max = UsageState.Unused;
			for (const value of this._usedInRuntime.values()) {
				if (value === UsageState.Used) {
					return UsageState.Used;
				***REMOVED***
				if (max < value) max = value;
			***REMOVED***
			return max;
		***REMOVED***

		/** @type {UsageStateType***REMOVED*** */
		let max = UsageState.Unused;
		for (const item of runtime) {
			const value = this._usedInRuntime.get(item);
			if (value !== undefined) {
				if (value === UsageState.Used) {
					return UsageState.Used;
				***REMOVED***
				if (max < value) max = value;
			***REMOVED***
		***REMOVED***
		return max;
	***REMOVED***

	/**
	 * get used name
	 * @param {string | undefined***REMOVED*** fallbackName fallback name for used exports with no name
	 * @param {RuntimeSpec***REMOVED*** runtime check usage for this runtime only
	 * @returns {string | false***REMOVED*** used name
	 */
	getUsedName(fallbackName, runtime) {
		if (this._hasUseInRuntimeInfo) {
			if (this._globalUsed !== undefined) {
				if (this._globalUsed === UsageState.Unused) return false;
			***REMOVED*** else {
				if (this._usedInRuntime === undefined) return false;
				if (typeof runtime === "string") {
					if (!this._usedInRuntime.has(runtime)) {
						return false;
					***REMOVED***
				***REMOVED*** else if (
					runtime !== undefined &&
					Array.from(runtime).every(
						runtime =>
							!(/** @type {UsedInRuntime***REMOVED*** */ (this._usedInRuntime).has(runtime))
					)
				) {
					return false;
				***REMOVED***
			***REMOVED***
		***REMOVED***
		if (this._usedName !== null) return this._usedName;
		return /** @type {string | false***REMOVED*** */ (this.name || fallbackName);
	***REMOVED***

	/**
	 * @returns {boolean***REMOVED*** true, when a mangled name of this export is set
	 */
	hasUsedName() {
		return this._usedName !== null;
	***REMOVED***

	/**
	 * Sets the mangled name of this export
	 * @param {string***REMOVED*** name the new name
	 * @returns {void***REMOVED***
	 */
	setUsedName(name) {
		this._usedName = name;
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @param {ResolveTargetFilter***REMOVED*** resolveTargetFilter filter function to further resolve target
	 * @returns {ExportInfo | ExportsInfo | undefined***REMOVED*** the terminal binding export(s) info if known
	 */
	getTerminalBinding(moduleGraph, resolveTargetFilter = RETURNS_TRUE) {
		if (this.terminalBinding) return this;
		const target = this.getTarget(moduleGraph, resolveTargetFilter);
		if (!target) return;
		const exportsInfo = moduleGraph.getExportsInfo(target.module);
		if (!target.export) return exportsInfo;
		return exportsInfo.getReadOnlyExportInfoRecursive(target.export);
	***REMOVED***

	isReexport() {
		return !this.terminalBinding && this._target && this._target.size > 0;
	***REMOVED***

	_getMaxTarget() {
		if (this._maxTarget !== undefined) return this._maxTarget;
		if (/** @type {Target***REMOVED*** */ (this._target).size <= 1)
			return (this._maxTarget = this._target);
		let maxPriority = -Infinity;
		let minPriority = Infinity;
		for (const { priority ***REMOVED*** of /** @type {Target***REMOVED*** */ (this._target).values()) {
			if (maxPriority < priority) maxPriority = priority;
			if (minPriority > priority) minPriority = priority;
		***REMOVED***
		// This should be very common
		if (maxPriority === minPriority) return (this._maxTarget = this._target);

		// This is an edge case
		/** @type {Target***REMOVED*** */
		const map = new Map();
		for (const [key, value] of /** @type {Target***REMOVED*** */ (this._target)) {
			if (maxPriority === value.priority) {
				map.set(key, value);
			***REMOVED***
		***REMOVED***
		this._maxTarget = map;
		return map;
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @param {ValidTargetModuleFilter***REMOVED*** validTargetModuleFilter a valid target module
	 * @returns {TargetItemWithoutConnection | null | undefined | false***REMOVED*** the target, undefined when there is no target, false when no target is valid
	 */
	findTarget(moduleGraph, validTargetModuleFilter) {
		return this._findTarget(moduleGraph, validTargetModuleFilter, new Set());
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @param {ValidTargetModuleFilter***REMOVED*** validTargetModuleFilter a valid target module
	 * @param {Set<ExportInfo>***REMOVED*** alreadyVisited set of already visited export info to avoid circular references
	 * @returns {TargetItemWithoutConnection | null | undefined | false***REMOVED*** the target, undefined when there is no target, false when no target is valid
	 */
	_findTarget(moduleGraph, validTargetModuleFilter, alreadyVisited) {
		if (!this._target || this._target.size === 0) return;
		const rawTarget =
			/** @type {Target***REMOVED*** */
			(this._getMaxTarget()).values().next().value;
		if (!rawTarget) return;
		/** @type {TargetItemWithoutConnection***REMOVED*** */
		let target = {
			module: rawTarget.connection.module,
			export: rawTarget.export
		***REMOVED***;
		for (;;) {
			if (validTargetModuleFilter(target.module)) return target;
			const exportsInfo = moduleGraph.getExportsInfo(target.module);
			const exportInfo = exportsInfo.getExportInfo(target.export[0]);
			if (alreadyVisited.has(exportInfo)) return null;
			const newTarget = exportInfo._findTarget(
				moduleGraph,
				validTargetModuleFilter,
				alreadyVisited
			);
			if (!newTarget) return false;
			if (target.export.length === 1) {
				target = newTarget;
			***REMOVED*** else {
				target = {
					module: newTarget.module,
					export: newTarget.export
						? newTarget.export.concat(target.export.slice(1))
						: target.export.slice(1)
				***REMOVED***;
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @param {ResolveTargetFilter***REMOVED*** resolveTargetFilter filter function to further resolve target
	 * @returns {TargetItemWithConnection | undefined***REMOVED*** the target
	 */
	getTarget(moduleGraph, resolveTargetFilter = RETURNS_TRUE) {
		const result = this._getTarget(moduleGraph, resolveTargetFilter, undefined);
		if (result === CIRCULAR) return;
		return result;
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @param {ResolveTargetFilter***REMOVED*** resolveTargetFilter filter function to further resolve target
	 * @param {Set<ExportInfo> | undefined***REMOVED*** alreadyVisited set of already visited export info to avoid circular references
	 * @returns {TargetItemWithConnection | CIRCULAR | undefined***REMOVED*** the target
	 */
	_getTarget(moduleGraph, resolveTargetFilter, alreadyVisited) {
		/**
		 * @param {TargetItem | undefined | null***REMOVED*** inputTarget unresolved target
		 * @param {Set<ExportInfo>***REMOVED*** alreadyVisited set of already visited export info to avoid circular references
		 * @returns {TargetItemWithConnection | CIRCULAR | null***REMOVED*** resolved target
		 */
		const resolveTarget = (inputTarget, alreadyVisited) => {
			if (!inputTarget) return null;
			if (!inputTarget.export) {
				return {
					module: inputTarget.connection.module,
					connection: inputTarget.connection,
					export: undefined
				***REMOVED***;
			***REMOVED***
			/** @type {TargetItemWithConnection***REMOVED*** */
			let target = {
				module: inputTarget.connection.module,
				connection: inputTarget.connection,
				export: inputTarget.export
			***REMOVED***;
			if (!resolveTargetFilter(target)) return target;
			let alreadyVisitedOwned = false;
			for (;;) {
				const exportsInfo = moduleGraph.getExportsInfo(target.module);
				const exportInfo = exportsInfo.getExportInfo(
					/** @type {NonNullable<TargetItemWithConnection["export"]>***REMOVED*** */
					(target.export)[0]
				);
				if (!exportInfo) return target;
				if (alreadyVisited.has(exportInfo)) return CIRCULAR;
				const newTarget = exportInfo._getTarget(
					moduleGraph,
					resolveTargetFilter,
					alreadyVisited
				);
				if (newTarget === CIRCULAR) return CIRCULAR;
				if (!newTarget) return target;
				if (
					/** @type {NonNullable<TargetItemWithConnection["export"]>***REMOVED*** */
					(target.export).length === 1
				) {
					target = newTarget;
					if (!target.export) return target;
				***REMOVED*** else {
					target = {
						module: newTarget.module,
						connection: newTarget.connection,
						export: newTarget.export
							? newTarget.export.concat(
									/** @type {NonNullable<TargetItemWithConnection["export"]>***REMOVED*** */
									(target.export).slice(1)
								)
							: /** @type {NonNullable<TargetItemWithConnection["export"]>***REMOVED*** */
								(target.export).slice(1)
					***REMOVED***;
				***REMOVED***
				if (!resolveTargetFilter(target)) return target;
				if (!alreadyVisitedOwned) {
					alreadyVisited = new Set(alreadyVisited);
					alreadyVisitedOwned = true;
				***REMOVED***
				alreadyVisited.add(exportInfo);
			***REMOVED***
		***REMOVED***;

		if (!this._target || this._target.size === 0) return;
		if (alreadyVisited && alreadyVisited.has(this)) return CIRCULAR;
		const newAlreadyVisited = new Set(alreadyVisited);
		newAlreadyVisited.add(this);
		const values = /** @type {Target***REMOVED*** */ (this._getMaxTarget()).values();
		const target = resolveTarget(values.next().value, newAlreadyVisited);
		if (target === CIRCULAR) return CIRCULAR;
		if (target === null) return;
		let result = values.next();
		while (!result.done) {
			const t = resolveTarget(result.value, newAlreadyVisited);
			if (t === CIRCULAR) return CIRCULAR;
			if (t === null) return;
			if (t.module !== target.module) return;
			if (!t.export !== !target.export) return;
			if (
				target.export &&
				!equals(/** @type {ArrayLike<string>***REMOVED*** */ (t.export), target.export)
			)
				return;
			result = values.next();
		***REMOVED***
		return target;
	***REMOVED***

	/**
	 * Move the target forward as long resolveTargetFilter is fulfilled
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @param {ResolveTargetFilter***REMOVED*** resolveTargetFilter filter function to further resolve target
	 * @param {(target: TargetItemWithConnection) => ModuleGraphConnection=***REMOVED*** updateOriginalConnection updates the original connection instead of using the target connection
	 * @returns {TargetItemWithConnection | undefined***REMOVED*** the resolved target when moved
	 */
	moveTarget(moduleGraph, resolveTargetFilter, updateOriginalConnection) {
		const target = this._getTarget(moduleGraph, resolveTargetFilter, undefined);
		if (target === CIRCULAR) return;
		if (!target) return;
		const originalTarget =
			/** @type {TargetItem***REMOVED*** */
			(
				/** @type {Target***REMOVED*** */
				(this._getMaxTarget()).values().next().value
			);
		if (
			originalTarget.connection === target.connection &&
			originalTarget.export === target.export
		) {
			return;
		***REMOVED***
		/** @type {Target***REMOVED*** */
		(this._target).clear();
		/** @type {Target***REMOVED*** */
		(this._target).set(undefined, {
			connection: updateOriginalConnection
				? updateOriginalConnection(target)
				: target.connection,
			export: /** @type {NonNullable<TargetItemWithConnection["export"]>***REMOVED*** */ (
				target.export
			),
			priority: 0
		***REMOVED***);
		return target;
	***REMOVED***

	/**
	 * @returns {ExportsInfo***REMOVED*** an exports info
	 */
	createNestedExportsInfo() {
		if (this.exportsInfoOwned)
			return /** @type {ExportsInfo***REMOVED*** */ (this.exportsInfo);
		this.exportsInfoOwned = true;
		const oldExportsInfo = this.exportsInfo;
		this.exportsInfo = new ExportsInfo();
		this.exportsInfo.setHasProvideInfo();
		if (oldExportsInfo) {
			this.exportsInfo.setRedirectNamedTo(oldExportsInfo);
		***REMOVED***
		return this.exportsInfo;
	***REMOVED***

	getNestedExportsInfo() {
		return this.exportsInfo;
	***REMOVED***

	/**
	 * @param {ExportInfo***REMOVED*** baseInfo base info
	 * @param {RuntimeSpec***REMOVED*** runtime runtime
	 * @returns {boolean***REMOVED*** true when has info, otherwise false
	 */
	hasInfo(baseInfo, runtime) {
		return (
			(this._usedName && this._usedName !== this.name) ||
			this.provided ||
			this.terminalBinding ||
			this.getUsed(runtime) !== baseInfo.getUsed(runtime)
		);
	***REMOVED***

	/**
	 * @param {Hash***REMOVED*** hash the hash
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @returns {void***REMOVED***
	 */
	updateHash(hash, runtime) {
		this._updateHash(hash, runtime, new Set());
	***REMOVED***

	/**
	 * @param {Hash***REMOVED*** hash the hash
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime
	 * @param {Set<ExportsInfo>***REMOVED*** alreadyVisitedExportsInfo for circular references
	 */
	_updateHash(hash, runtime, alreadyVisitedExportsInfo) {
		hash.update(
			`${this._usedName || this.name***REMOVED***${this.getUsed(runtime)***REMOVED***${this.provided***REMOVED***${
				this.terminalBinding
			***REMOVED***`
		);
		if (this.exportsInfo && !alreadyVisitedExportsInfo.has(this.exportsInfo)) {
			this.exportsInfo._updateHash(hash, runtime, alreadyVisitedExportsInfo);
		***REMOVED***
	***REMOVED***

	getUsedInfo() {
		if (this._globalUsed !== undefined) {
			switch (this._globalUsed) {
				case UsageState.Unused:
					return "unused";
				case UsageState.NoInfo:
					return "no usage info";
				case UsageState.Unknown:
					return "maybe used (runtime-defined)";
				case UsageState.Used:
					return "used";
				case UsageState.OnlyPropertiesUsed:
					return "only properties used";
			***REMOVED***
		***REMOVED*** else if (this._usedInRuntime !== undefined) {
			/** @type {Map<RuntimeUsageStateType, string[]>***REMOVED*** */
			const map = new Map();
			for (const [runtime, used] of this._usedInRuntime) {
				const list = map.get(used);
				if (list !== undefined) list.push(runtime);
				else map.set(used, [runtime]);
			***REMOVED***
			// eslint-disable-next-line array-callback-return
			const specificInfo = Array.from(map, ([used, runtimes]) => {
				switch (used) {
					case UsageState.NoInfo:
						return `no usage info in ${runtimes.join(", ")***REMOVED***`;
					case UsageState.Unknown:
						return `maybe used in ${runtimes.join(", ")***REMOVED*** (runtime-defined)`;
					case UsageState.Used:
						return `used in ${runtimes.join(", ")***REMOVED***`;
					case UsageState.OnlyPropertiesUsed:
						return `only properties used in ${runtimes.join(", ")***REMOVED***`;
				***REMOVED***
			***REMOVED***);
			if (specificInfo.length > 0) {
				return specificInfo.join("; ");
			***REMOVED***
		***REMOVED***
		return this._hasUseInRuntimeInfo ? "unused" : "no usage info";
	***REMOVED***

	getProvidedInfo() {
		switch (this.provided) {
			case undefined:
				return "no provided info";
			case null:
				return "maybe provided (runtime-defined)";
			case true:
				return "provided";
			case false:
				return "not provided";
		***REMOVED***
	***REMOVED***

	getRenameInfo() {
		if (this._usedName !== null && this._usedName !== this.name) {
			return `renamed to ${JSON.stringify(this._usedName).slice(1, -1)***REMOVED***`;
		***REMOVED***
		switch (this.canMangleProvide) {
			case undefined:
				switch (this.canMangleUse) {
					case undefined:
						return "missing provision and use info prevents renaming";
					case false:
						return "usage prevents renaming (no provision info)";
					case true:
						return "missing provision info prevents renaming";
				***REMOVED***
				break;
			case true:
				switch (this.canMangleUse) {
					case undefined:
						return "missing usage info prevents renaming";
					case false:
						return "usage prevents renaming";
					case true:
						return "could be renamed";
				***REMOVED***
				break;
			case false:
				switch (this.canMangleUse) {
					case undefined:
						return "provision prevents renaming (no use info)";
					case false:
						return "usage and provision prevents renaming";
					case true:
						return "provision prevents renaming";
				***REMOVED***
				break;
		***REMOVED***
		throw new Error(
			`Unexpected flags for getRenameInfo ${this.canMangleProvide***REMOVED*** ${this.canMangleUse***REMOVED***`
		);
	***REMOVED***
***REMOVED***

module.exports = ExportsInfo;
module.exports.ExportInfo = ExportInfo;
module.exports.UsageState = UsageState;
module.exports.RestoreProvidedData = RestoreProvidedData;
