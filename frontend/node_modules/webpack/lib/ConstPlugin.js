/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const {
	JAVASCRIPT_MODULE_TYPE_AUTO,
	JAVASCRIPT_MODULE_TYPE_DYNAMIC,
	JAVASCRIPT_MODULE_TYPE_ESM
***REMOVED*** = require("./ModuleTypeConstants");
const CachedConstDependency = require("./dependencies/CachedConstDependency");
const ConstDependency = require("./dependencies/ConstDependency");
const { evaluateToString ***REMOVED*** = require("./javascript/JavascriptParserHelpers");
const { parseResource ***REMOVED*** = require("./util/identifier");

/** @typedef {import("estree").AssignmentProperty***REMOVED*** AssignmentProperty */
/** @typedef {import("estree").Expression***REMOVED*** Expression */
/** @typedef {import("estree").Identifier***REMOVED*** Identifier */
/** @typedef {import("estree").Pattern***REMOVED*** Pattern */
/** @typedef {import("estree").SourceLocation***REMOVED*** SourceLocation */
/** @typedef {import("estree").Statement***REMOVED*** Statement */
/** @typedef {import("estree").Super***REMOVED*** Super */
/** @typedef {import("estree").VariableDeclaration***REMOVED*** VariableDeclaration */
/** @typedef {import("./Compiler")***REMOVED*** Compiler */
/** @typedef {import("./javascript/BasicEvaluatedExpression")***REMOVED*** BasicEvaluatedExpression */
/** @typedef {import("./javascript/JavascriptParser")***REMOVED*** JavascriptParser */
/** @typedef {import("./javascript/JavascriptParser").Range***REMOVED*** Range */

/**
 * @param {Set<string>***REMOVED*** declarations set of declarations
 * @param {Identifier | Pattern***REMOVED*** pattern pattern to collect declarations from
 */
const collectDeclaration = (declarations, pattern) => {
	const stack = [pattern];
	while (stack.length > 0) {
		const node = /** @type {Pattern***REMOVED*** */ (stack.pop());
		switch (node.type) {
			case "Identifier":
				declarations.add(node.name);
				break;
			case "ArrayPattern":
				for (const element of node.elements) {
					if (element) {
						stack.push(element);
					***REMOVED***
				***REMOVED***
				break;
			case "AssignmentPattern":
				stack.push(node.left);
				break;
			case "ObjectPattern":
				for (const property of node.properties) {
					stack.push(/** @type {AssignmentProperty***REMOVED*** */ (property).value);
				***REMOVED***
				break;
			case "RestElement":
				stack.push(node.argument);
				break;
		***REMOVED***
	***REMOVED***
***REMOVED***;

/**
 * @param {Statement***REMOVED*** branch branch to get hoisted declarations from
 * @param {boolean***REMOVED*** includeFunctionDeclarations whether to include function declarations
 * @returns {Array<string>***REMOVED*** hoisted declarations
 */
const getHoistedDeclarations = (branch, includeFunctionDeclarations) => {
	const declarations = new Set();
	/** @type {Array<Statement | null | undefined>***REMOVED*** */
	const stack = [branch];
	while (stack.length > 0) {
		const node = stack.pop();
		// Some node could be `null` or `undefined`.
		if (!node) continue;
		switch (node.type) {
			// Walk through control statements to look for hoisted declarations.
			// Some branches are skipped since they do not allow declarations.
			case "BlockStatement":
				for (const stmt of node.body) {
					stack.push(stmt);
				***REMOVED***
				break;
			case "IfStatement":
				stack.push(node.consequent);
				stack.push(node.alternate);
				break;
			case "ForStatement":
				stack.push(/** @type {VariableDeclaration***REMOVED*** */ (node.init));
				stack.push(node.body);
				break;
			case "ForInStatement":
			case "ForOfStatement":
				stack.push(/** @type {VariableDeclaration***REMOVED*** */ (node.left));
				stack.push(node.body);
				break;
			case "DoWhileStatement":
			case "WhileStatement":
			case "LabeledStatement":
				stack.push(node.body);
				break;
			case "SwitchStatement":
				for (const cs of node.cases) {
					for (const consequent of cs.consequent) {
						stack.push(consequent);
					***REMOVED***
				***REMOVED***
				break;
			case "TryStatement":
				stack.push(node.block);
				if (node.handler) {
					stack.push(node.handler.body);
				***REMOVED***
				stack.push(node.finalizer);
				break;
			case "FunctionDeclaration":
				if (includeFunctionDeclarations) {
					collectDeclaration(declarations, /** @type {Identifier***REMOVED*** */ (node.id));
				***REMOVED***
				break;
			case "VariableDeclaration":
				if (node.kind === "var") {
					for (const decl of node.declarations) {
						collectDeclaration(declarations, decl.id);
					***REMOVED***
				***REMOVED***
				break;
		***REMOVED***
	***REMOVED***
	return Array.from(declarations);
***REMOVED***;

const PLUGIN_NAME = "ConstPlugin";

class ConstPlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		const cachedParseResource = parseResource.bindCache(compiler.root);
		compiler.hooks.compilation.tap(
			PLUGIN_NAME,
			(compilation, { normalModuleFactory ***REMOVED***) => {
				compilation.dependencyTemplates.set(
					ConstDependency,
					new ConstDependency.Template()
				);

				compilation.dependencyTemplates.set(
					CachedConstDependency,
					new CachedConstDependency.Template()
				);

				/**
				 * @param {JavascriptParser***REMOVED*** parser the parser
				 */
				const handler = parser => {
					parser.hooks.terminate.tap(PLUGIN_NAME, statement => true);
					parser.hooks.statementIf.tap(PLUGIN_NAME, statement => {
						if (parser.scope.isAsmJs) return;
						const param = parser.evaluateExpression(statement.test);
						const bool = param.asBool();
						if (typeof bool === "boolean") {
							if (!param.couldHaveSideEffects()) {
								const dep = new ConstDependency(
									`${bool***REMOVED***`,
									/** @type {Range***REMOVED*** */ (param.range)
								);
								dep.loc = /** @type {SourceLocation***REMOVED*** */ (statement.loc);
								parser.state.module.addPresentationalDependency(dep);
							***REMOVED*** else {
								parser.walkExpression(statement.test);
							***REMOVED***
							const branchToRemove = bool
								? statement.alternate
								: statement.consequent;
							if (branchToRemove) {
								// Before removing the dead branch, the hoisted declarations
								// must be collected.
								//
								// Given the following code:
								//
								//     if (true) f() else g()
								//     if (false) {
								//       function f() {***REMOVED***
								//       const g = function g() {***REMOVED***
								//       if (someTest) {
								//         let a = 1
								//         var x, {y, z***REMOVED*** = obj
								//       ***REMOVED***
								//     ***REMOVED*** else {
								//       …
								//     ***REMOVED***
								//
								// the generated code is:
								//
								//     if (true) f() else {***REMOVED***
								//     if (false) {
								//       var f, x, y, z;   (in loose mode)
								//       var x, y, z;      (in strict mode)
								//     ***REMOVED*** else {
								//       …
								//     ***REMOVED***
								//
								// NOTE: When code runs in strict mode, `var` declarations
								// are hoisted but `function` declarations don't.
								//
								const declarations = parser.scope.isStrict
									? getHoistedDeclarations(branchToRemove, false)
									: getHoistedDeclarations(branchToRemove, true);
								const replacement =
									declarations.length > 0
										? `{ var ${declarations.join(", ")***REMOVED***; ***REMOVED***`
										: "{***REMOVED***";
								const dep = new ConstDependency(
									replacement,
									/** @type {Range***REMOVED*** */ (branchToRemove.range)
								);
								dep.loc = /** @type {SourceLocation***REMOVED*** */ (branchToRemove.loc);
								parser.state.module.addPresentationalDependency(dep);
							***REMOVED***
							return bool;
						***REMOVED***
					***REMOVED***);
					parser.hooks.expressionConditionalOperator.tap(
						PLUGIN_NAME,
						expression => {
							if (parser.scope.isAsmJs) return;
							const param = parser.evaluateExpression(expression.test);
							const bool = param.asBool();
							if (typeof bool === "boolean") {
								if (!param.couldHaveSideEffects()) {
									const dep = new ConstDependency(
										` ${bool***REMOVED***`,
										/** @type {Range***REMOVED*** */ (param.range)
									);
									dep.loc = /** @type {SourceLocation***REMOVED*** */ (expression.loc);
									parser.state.module.addPresentationalDependency(dep);
								***REMOVED*** else {
									parser.walkExpression(expression.test);
								***REMOVED***
								// Expressions do not hoist.
								// It is safe to remove the dead branch.
								//
								// Given the following code:
								//
								//   false ? someExpression() : otherExpression();
								//
								// the generated code is:
								//
								//   false ? 0 : otherExpression();
								//
								const branchToRemove = bool
									? expression.alternate
									: expression.consequent;
								const dep = new ConstDependency(
									"0",
									/** @type {Range***REMOVED*** */ (branchToRemove.range)
								);
								dep.loc = /** @type {SourceLocation***REMOVED*** */ (branchToRemove.loc);
								parser.state.module.addPresentationalDependency(dep);
								return bool;
							***REMOVED***
						***REMOVED***
					);
					parser.hooks.expressionLogicalOperator.tap(
						PLUGIN_NAME,
						expression => {
							if (parser.scope.isAsmJs) return;
							if (
								expression.operator === "&&" ||
								expression.operator === "||"
							) {
								const param = parser.evaluateExpression(expression.left);
								const bool = param.asBool();
								if (typeof bool === "boolean") {
									// Expressions do not hoist.
									// It is safe to remove the dead branch.
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   falsyExpression() && someExpression();
									//
									// the generated code is:
									//
									//   falsyExpression() && false;
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   truthyExpression() && someExpression();
									//
									// the generated code is:
									//
									//   true && someExpression();
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   truthyExpression() || someExpression();
									//
									// the generated code is:
									//
									//   truthyExpression() || false;
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   falsyExpression() || someExpression();
									//
									// the generated code is:
									//
									//   false && someExpression();
									//
									const keepRight =
										(expression.operator === "&&" && bool) ||
										(expression.operator === "||" && !bool);

									if (
										!param.couldHaveSideEffects() &&
										(param.isBoolean() || keepRight)
									) {
										// for case like
										//
										//   return'development'===process.env.NODE_ENV&&'foo'
										//
										// we need a space before the bool to prevent result like
										//
										//   returnfalse&&'foo'
										//
										const dep = new ConstDependency(
											` ${bool***REMOVED***`,
											/** @type {Range***REMOVED*** */ (param.range)
										);
										dep.loc = /** @type {SourceLocation***REMOVED*** */ (expression.loc);
										parser.state.module.addPresentationalDependency(dep);
									***REMOVED*** else {
										parser.walkExpression(expression.left);
									***REMOVED***
									if (!keepRight) {
										const dep = new ConstDependency(
											"0",
											/** @type {Range***REMOVED*** */ (expression.right.range)
										);
										dep.loc = /** @type {SourceLocation***REMOVED*** */ (expression.loc);
										parser.state.module.addPresentationalDependency(dep);
									***REMOVED***
									return keepRight;
								***REMOVED***
							***REMOVED*** else if (expression.operator === "??") {
								const param = parser.evaluateExpression(expression.left);
								const keepRight = param.asNullish();
								if (typeof keepRight === "boolean") {
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   nonNullish ?? someExpression();
									//
									// the generated code is:
									//
									//   nonNullish ?? 0;
									//
									// ------------------------------------------
									//
									// Given the following code:
									//
									//   nullish ?? someExpression();
									//
									// the generated code is:
									//
									//   null ?? someExpression();
									//
									if (!param.couldHaveSideEffects() && keepRight) {
										// cspell:word returnnull
										// for case like
										//
										//   return('development'===process.env.NODE_ENV&&null)??'foo'
										//
										// we need a space before the bool to prevent result like
										//
										//   returnnull??'foo'
										//
										const dep = new ConstDependency(
											" null",
											/** @type {Range***REMOVED*** */ (param.range)
										);
										dep.loc = /** @type {SourceLocation***REMOVED*** */ (expression.loc);
										parser.state.module.addPresentationalDependency(dep);
									***REMOVED*** else {
										const dep = new ConstDependency(
											"0",
											/** @type {Range***REMOVED*** */ (expression.right.range)
										);
										dep.loc = /** @type {SourceLocation***REMOVED*** */ (expression.loc);
										parser.state.module.addPresentationalDependency(dep);
										parser.walkExpression(expression.left);
									***REMOVED***

									return keepRight;
								***REMOVED***
							***REMOVED***
						***REMOVED***
					);
					parser.hooks.optionalChaining.tap(PLUGIN_NAME, expr => {
						/** @type {Expression[]***REMOVED*** */
						const optionalExpressionsStack = [];
						/** @type {Expression | Super***REMOVED*** */
						let next = expr.expression;

						while (
							next.type === "MemberExpression" ||
							next.type === "CallExpression"
						) {
							if (next.type === "MemberExpression") {
								if (next.optional) {
									// SuperNode can not be optional
									optionalExpressionsStack.push(
										/** @type {Expression***REMOVED*** */ (next.object)
									);
								***REMOVED***
								next = next.object;
							***REMOVED*** else {
								if (next.optional) {
									// SuperNode can not be optional
									optionalExpressionsStack.push(
										/** @type {Expression***REMOVED*** */ (next.callee)
									);
								***REMOVED***
								next = next.callee;
							***REMOVED***
						***REMOVED***

						while (optionalExpressionsStack.length) {
							const expression = optionalExpressionsStack.pop();
							const evaluated = parser.evaluateExpression(
								/** @type {Expression***REMOVED*** */ (expression)
							);

							if (evaluated.asNullish()) {
								// ------------------------------------------
								//
								// Given the following code:
								//
								//   nullishMemberChain?.a.b();
								//
								// the generated code is:
								//
								//   undefined;
								//
								// ------------------------------------------
								//
								const dep = new ConstDependency(
									" undefined",
									/** @type {Range***REMOVED*** */ (expr.range)
								);
								dep.loc = /** @type {SourceLocation***REMOVED*** */ (expr.loc);
								parser.state.module.addPresentationalDependency(dep);
								return true;
							***REMOVED***
						***REMOVED***
					***REMOVED***);
					parser.hooks.evaluateIdentifier
						.for("__resourceQuery")
						.tap(PLUGIN_NAME, expr => {
							if (parser.scope.isAsmJs) return;
							if (!parser.state.module) return;
							return evaluateToString(
								cachedParseResource(parser.state.module.resource).query
							)(expr);
						***REMOVED***);
					parser.hooks.expression
						.for("__resourceQuery")
						.tap(PLUGIN_NAME, expr => {
							if (parser.scope.isAsmJs) return;
							if (!parser.state.module) return;
							const dep = new CachedConstDependency(
								JSON.stringify(
									cachedParseResource(parser.state.module.resource).query
								),
								/** @type {Range***REMOVED*** */ (expr.range),
								"__resourceQuery"
							);
							dep.loc = /** @type {SourceLocation***REMOVED*** */ (expr.loc);
							parser.state.module.addPresentationalDependency(dep);
							return true;
						***REMOVED***);

					parser.hooks.evaluateIdentifier
						.for("__resourceFragment")
						.tap(PLUGIN_NAME, expr => {
							if (parser.scope.isAsmJs) return;
							if (!parser.state.module) return;
							return evaluateToString(
								cachedParseResource(parser.state.module.resource).fragment
							)(expr);
						***REMOVED***);
					parser.hooks.expression
						.for("__resourceFragment")
						.tap(PLUGIN_NAME, expr => {
							if (parser.scope.isAsmJs) return;
							if (!parser.state.module) return;
							const dep = new CachedConstDependency(
								JSON.stringify(
									cachedParseResource(parser.state.module.resource).fragment
								),
								/** @type {Range***REMOVED*** */ (expr.range),
								"__resourceFragment"
							);
							dep.loc = /** @type {SourceLocation***REMOVED*** */ (expr.loc);
							parser.state.module.addPresentationalDependency(dep);
							return true;
						***REMOVED***);
				***REMOVED***;

				normalModuleFactory.hooks.parser
					.for(JAVASCRIPT_MODULE_TYPE_AUTO)
					.tap(PLUGIN_NAME, handler);
				normalModuleFactory.hooks.parser
					.for(JAVASCRIPT_MODULE_TYPE_DYNAMIC)
					.tap(PLUGIN_NAME, handler);
				normalModuleFactory.hooks.parser
					.for(JAVASCRIPT_MODULE_TYPE_ESM)
					.tap(PLUGIN_NAME, handler);
			***REMOVED***
		);
	***REMOVED***
***REMOVED***

module.exports = ConstPlugin;
