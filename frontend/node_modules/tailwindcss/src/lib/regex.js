const REGEX_SPECIAL = /[\\^$.*+?()[\]{***REMOVED***|]/g
const REGEX_HAS_SPECIAL = RegExp(REGEX_SPECIAL.source)

/**
 * @param {string|RegExp|Array<string|RegExp>***REMOVED*** source
 */
function toSource(source) {
  source = Array.isArray(source) ? source : [source]

  source = source.map((item) => (item instanceof RegExp ? item.source : item))

  return source.join('')
***REMOVED***

/**
 * @param {string|RegExp|Array<string|RegExp>***REMOVED*** source
 */
export function pattern(source) {
  return new RegExp(toSource(source), 'g')
***REMOVED***

/**
 * @param {string|RegExp|Array<string|RegExp>***REMOVED*** source
 */
export function withoutCapturing(source) {
  return new RegExp(`(?:${toSource(source)***REMOVED***)`, 'g')
***REMOVED***

/**
 * @param {Array<string|RegExp>***REMOVED*** sources
 */
export function any(sources) {
  return `(?:${sources.map(toSource).join('|')***REMOVED***)`
***REMOVED***

/**
 * @param {string|RegExp***REMOVED*** source
 */
export function optional(source) {
  return `(?:${toSource(source)***REMOVED***)?`
***REMOVED***

/**
 * @param {string|RegExp|Array<string|RegExp>***REMOVED*** source
 */
export function zeroOrMore(source) {
  return `(?:${toSource(source)***REMOVED***)*`
***REMOVED***

/**
 * Generate a RegExp that matches balanced brackets for a given depth
 * We have to specify a depth because JS doesn't support recursive groups using ?R
 *
 * Based on https://stackoverflow.com/questions/17759004/how-to-match-string-within-parentheses-nested-in-java/17759264#17759264
 *
 * @param {string|RegExp|Array<string|RegExp>***REMOVED*** source
 */
export function nestedBrackets(open, close, depth = 1) {
  return withoutCapturing([
    escape(open),
    /[^\s]*/,
    depth === 1
      ? `[^${escape(open)***REMOVED***${escape(close)***REMOVED***\s]*`
      : any([`[^${escape(open)***REMOVED***${escape(close)***REMOVED***\s]*`, nestedBrackets(open, close, depth - 1)]),
    /[^\s]*/,
    escape(close),
  ])
***REMOVED***

export function escape(string) {
  return string && REGEX_HAS_SPECIAL.test(string)
    ? string.replace(REGEX_SPECIAL, '\\$&')
    : string || ''
***REMOVED***
