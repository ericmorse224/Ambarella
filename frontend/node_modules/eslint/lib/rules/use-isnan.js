/**
 * @fileoverview Rule to flag comparisons to the value NaN
 * @author James Allardice
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Determines if the given node is a NaN `Identifier` node.
 * @param {ASTNode|null***REMOVED*** node The node to check.
 * @returns {boolean***REMOVED*** `true` if the node is 'NaN' identifier.
 */
function isNaNIdentifier(node) {
	if (!node) {
		return false;
	***REMOVED***

	const nodeToCheck =
		node.type === "SequenceExpression" ? node.expressions.at(-1) : node;

	return (
		astUtils.isSpecificId(nodeToCheck, "NaN") ||
		astUtils.isSpecificMemberAccess(nodeToCheck, "Number", "NaN")
	);
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		hasSuggestions: true,
		type: "problem",

		docs: {
			description: "Require calls to `isNaN()` when checking for `NaN`",
			recommended: true,
			url: "https://eslint.org/docs/latest/rules/use-isnan",
		***REMOVED***,

		schema: [
			{
				type: "object",
				properties: {
					enforceForSwitchCase: {
						type: "boolean",
					***REMOVED***,
					enforceForIndexOf: {
						type: "boolean",
					***REMOVED***,
				***REMOVED***,
				additionalProperties: false,
			***REMOVED***,
		],

		defaultOptions: [
			{
				enforceForIndexOf: false,
				enforceForSwitchCase: true,
			***REMOVED***,
		],

		messages: {
			comparisonWithNaN: "Use the isNaN function to compare with NaN.",
			switchNaN:
				"'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.",
			caseNaN:
				"'case NaN' can never match. Use Number.isNaN before the switch.",
			indexOfNaN:
				"Array prototype method '{{ methodName ***REMOVED******REMOVED***' cannot find NaN.",
			replaceWithIsNaN: "Replace with Number.isNaN.",
			replaceWithCastingAndIsNaN:
				"Replace with Number.isNaN and cast to a Number.",
			replaceWithFindIndex:
				"Replace with Array.prototype.{{ methodName ***REMOVED******REMOVED***.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const [{ enforceForIndexOf, enforceForSwitchCase ***REMOVED***] = context.options;
		const sourceCode = context.sourceCode;

		const fixableOperators = new Set(["==", "===", "!=", "!=="]);
		const castableOperators = new Set(["==", "!="]);

		/**
		 * Get a fixer for a binary expression that compares to NaN.
		 * @param  {ASTNode***REMOVED*** node The node to fix.
		 * @param {function(string): string***REMOVED*** wrapValue A function that wraps the compared value with a fix.
		 * @returns {function(Fixer): Fix***REMOVED*** The fixer function.
		 */
		function getBinaryExpressionFixer(node, wrapValue) {
			return fixer => {
				const comparedValue = isNaNIdentifier(node.left)
					? node.right
					: node.left;
				const shouldWrap = comparedValue.type === "SequenceExpression";
				const shouldNegate = node.operator[0] === "!";

				const negation = shouldNegate ? "!" : "";
				let comparedValueText = sourceCode.getText(comparedValue);

				if (shouldWrap) {
					comparedValueText = `(${comparedValueText***REMOVED***)`;
				***REMOVED***

				const fixedValue = wrapValue(comparedValueText);

				return fixer.replaceText(node, `${negation***REMOVED***${fixedValue***REMOVED***`);
			***REMOVED***;
		***REMOVED***

		/**
		 * Checks the given `BinaryExpression` node for `foo === NaN` and other comparisons.
		 * @param {ASTNode***REMOVED*** node The node to check.
		 * @returns {void***REMOVED***
		 */
		function checkBinaryExpression(node) {
			if (
				/^(?:[<>]|[!=]=)=?$/u.test(node.operator) &&
				(isNaNIdentifier(node.left) || isNaNIdentifier(node.right))
			) {
				const suggestedFixes = [];
				const NaNNode = isNaNIdentifier(node.left)
					? node.left
					: node.right;

				const isSequenceExpression =
					NaNNode.type === "SequenceExpression";
				const isSuggestable =
					fixableOperators.has(node.operator) &&
					!isSequenceExpression;
				const isCastable = castableOperators.has(node.operator);

				if (isSuggestable) {
					suggestedFixes.push({
						messageId: "replaceWithIsNaN",
						fix: getBinaryExpressionFixer(
							node,
							value => `Number.isNaN(${value***REMOVED***)`,
						),
					***REMOVED***);

					if (isCastable) {
						suggestedFixes.push({
							messageId: "replaceWithCastingAndIsNaN",
							fix: getBinaryExpressionFixer(
								node,
								value => `Number.isNaN(Number(${value***REMOVED***))`,
							),
						***REMOVED***);
					***REMOVED***
				***REMOVED***

				context.report({
					node,
					messageId: "comparisonWithNaN",
					suggest: suggestedFixes,
				***REMOVED***);
			***REMOVED***
		***REMOVED***

		/**
		 * Checks the discriminant and all case clauses of the given `SwitchStatement` node for `switch(NaN)` and `case NaN:`
		 * @param {ASTNode***REMOVED*** node The node to check.
		 * @returns {void***REMOVED***
		 */
		function checkSwitchStatement(node) {
			if (isNaNIdentifier(node.discriminant)) {
				context.report({ node, messageId: "switchNaN" ***REMOVED***);
			***REMOVED***

			for (const switchCase of node.cases) {
				if (isNaNIdentifier(switchCase.test)) {
					context.report({ node: switchCase, messageId: "caseNaN" ***REMOVED***);
				***REMOVED***
			***REMOVED***
		***REMOVED***

		/**
		 * Checks the given `CallExpression` node for `.indexOf(NaN)` and `.lastIndexOf(NaN)`.
		 * @param {ASTNode***REMOVED*** node The node to check.
		 * @returns {void***REMOVED***
		 */
		function checkCallExpression(node) {
			const callee = astUtils.skipChainExpression(node.callee);

			if (callee.type === "MemberExpression") {
				const methodName = astUtils.getStaticPropertyName(callee);

				if (
					(methodName === "indexOf" ||
						methodName === "lastIndexOf") &&
					node.arguments.length <= 2 &&
					isNaNIdentifier(node.arguments[0])
				) {
					/*
					 * To retain side effects, it's essential to address `NaN` beforehand, which
					 * is not possible with fixes like `arr.findIndex(Number.isNaN)`.
					 */
					const isSuggestable =
						node.arguments[0].type !== "SequenceExpression" &&
						!node.arguments[1];
					const suggestedFixes = [];

					if (isSuggestable) {
						const shouldWrap = callee.computed;
						const findIndexMethod =
							methodName === "indexOf"
								? "findIndex"
								: "findLastIndex";
						const propertyName = shouldWrap
							? `"${findIndexMethod***REMOVED***"`
							: findIndexMethod;

						suggestedFixes.push({
							messageId: "replaceWithFindIndex",
							data: { methodName: findIndexMethod ***REMOVED***,
							fix: fixer => [
								fixer.replaceText(
									callee.property,
									propertyName,
								),
								fixer.replaceText(
									node.arguments[0],
									"Number.isNaN",
								),
							],
						***REMOVED***);
					***REMOVED***

					context.report({
						node,
						messageId: "indexOfNaN",
						data: { methodName ***REMOVED***,
						suggest: suggestedFixes,
					***REMOVED***);
				***REMOVED***
			***REMOVED***
		***REMOVED***

		const listeners = {
			BinaryExpression: checkBinaryExpression,
		***REMOVED***;

		if (enforceForSwitchCase) {
			listeners.SwitchStatement = checkSwitchStatement;
		***REMOVED***

		if (enforceForIndexOf) {
			listeners.CallExpression = checkCallExpression;
		***REMOVED***

		return listeners;
	***REMOVED***,
***REMOVED***;
