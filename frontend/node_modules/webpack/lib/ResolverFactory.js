/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const Factory = require("enhanced-resolve").ResolverFactory;
const { HookMap, SyncHook, SyncWaterfallHook ***REMOVED*** = require("tapable");
const {
	cachedCleverMerge,
	removeOperations,
	resolveByProperty
***REMOVED*** = require("./util/cleverMerge");

/** @typedef {import("enhanced-resolve").ResolveContext***REMOVED*** ResolveContext */
/** @typedef {import("enhanced-resolve").ResolveOptions***REMOVED*** ResolveOptions */
/** @typedef {import("enhanced-resolve").ResolveRequest***REMOVED*** ResolveRequest */
/** @typedef {import("enhanced-resolve").Resolver***REMOVED*** Resolver */
/** @typedef {import("../declarations/WebpackOptions").ResolveOptions***REMOVED*** WebpackResolveOptions */
/** @typedef {import("../declarations/WebpackOptions").ResolvePluginInstance***REMOVED*** ResolvePluginInstance */

/** @typedef {WebpackResolveOptions & { dependencyType?: string, resolveToContext?: boolean ***REMOVED******REMOVED*** ResolveOptionsWithDependencyType */
/**
 * @typedef {object***REMOVED*** WithOptions
 * @property {(options: Partial<ResolveOptionsWithDependencyType>) => ResolverWithOptions***REMOVED*** withOptions create a resolver with additional/different options
 */

/** @typedef {Resolver & WithOptions***REMOVED*** ResolverWithOptions */

// need to be hoisted on module level for caching identity
/** @type {ResolveOptionsWithDependencyType***REMOVED*** */
const EMPTY_RESOLVE_OPTIONS = {***REMOVED***;

/**
 * @param {ResolveOptionsWithDependencyType***REMOVED*** resolveOptionsWithDepType enhanced options
 * @returns {ResolveOptions***REMOVED*** merged options
 */
const convertToResolveOptions = resolveOptionsWithDepType => {
	const { dependencyType, plugins, ...remaining ***REMOVED*** = resolveOptionsWithDepType;

	// check type compat
	/** @type {Partial<ResolveOptionsWithDependencyType>***REMOVED*** */
	const partialOptions = {
		...remaining,
		plugins:
			plugins &&
			/** @type {ResolvePluginInstance[]***REMOVED*** */ (
				plugins.filter(item => item !== "...")
			)
	***REMOVED***;

	if (!partialOptions.fileSystem) {
		throw new Error(
			"fileSystem is missing in resolveOptions, but it's required for enhanced-resolve"
		);
	***REMOVED***
	// These weird types validate that we checked all non-optional properties
	const options =
		/** @type {Partial<ResolveOptionsWithDependencyType> & Pick<ResolveOptionsWithDependencyType, "fileSystem">***REMOVED*** */ (
			partialOptions
		);

	return /** @type {ResolveOptions***REMOVED*** */ (
		removeOperations(
			resolveByProperty(options, "byDependency", dependencyType),
			// Keep the `unsafeCache` because it can be a `Proxy`
			["unsafeCache"]
		)
	);
***REMOVED***;

/**
 * @typedef {object***REMOVED*** ResolverCache
 * @property {WeakMap<ResolveOptionsWithDependencyType, ResolverWithOptions>***REMOVED*** direct
 * @property {Map<string, ResolverWithOptions>***REMOVED*** stringified
 */

module.exports = class ResolverFactory {
	constructor() {
		this.hooks = Object.freeze({
			/** @type {HookMap<SyncWaterfallHook<[ResolveOptionsWithDependencyType]>>***REMOVED*** */
			resolveOptions: new HookMap(
				() => new SyncWaterfallHook(["resolveOptions"])
			),
			/** @type {HookMap<SyncHook<[Resolver, ResolveOptions, ResolveOptionsWithDependencyType]>>***REMOVED*** */
			resolver: new HookMap(
				() => new SyncHook(["resolver", "resolveOptions", "userResolveOptions"])
			)
		***REMOVED***);
		/** @type {Map<string, ResolverCache>***REMOVED*** */
		this.cache = new Map();
	***REMOVED***

	/**
	 * @param {string***REMOVED*** type type of resolver
	 * @param {ResolveOptionsWithDependencyType=***REMOVED*** resolveOptions options
	 * @returns {ResolverWithOptions***REMOVED*** the resolver
	 */
	get(type, resolveOptions = EMPTY_RESOLVE_OPTIONS) {
		let typedCaches = this.cache.get(type);
		if (!typedCaches) {
			typedCaches = {
				direct: new WeakMap(),
				stringified: new Map()
			***REMOVED***;
			this.cache.set(type, typedCaches);
		***REMOVED***
		const cachedResolver = typedCaches.direct.get(resolveOptions);
		if (cachedResolver) {
			return cachedResolver;
		***REMOVED***
		const ident = JSON.stringify(resolveOptions);
		const resolver = typedCaches.stringified.get(ident);
		if (resolver) {
			typedCaches.direct.set(resolveOptions, resolver);
			return resolver;
		***REMOVED***
		const newResolver = this._create(type, resolveOptions);
		typedCaches.direct.set(resolveOptions, newResolver);
		typedCaches.stringified.set(ident, newResolver);
		return newResolver;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** type type of resolver
	 * @param {ResolveOptionsWithDependencyType***REMOVED*** resolveOptionsWithDepType options
	 * @returns {ResolverWithOptions***REMOVED*** the resolver
	 */
	_create(type, resolveOptionsWithDepType) {
		/** @type {ResolveOptionsWithDependencyType***REMOVED*** */
		const originalResolveOptions = { ...resolveOptionsWithDepType ***REMOVED***;

		const resolveOptions = convertToResolveOptions(
			this.hooks.resolveOptions.for(type).call(resolveOptionsWithDepType)
		);
		const resolver = /** @type {ResolverWithOptions***REMOVED*** */ (
			Factory.createResolver(resolveOptions)
		);
		if (!resolver) {
			throw new Error("No resolver created");
		***REMOVED***
		/** @type {WeakMap<Partial<ResolveOptionsWithDependencyType>, ResolverWithOptions>***REMOVED*** */
		const childCache = new WeakMap();
		resolver.withOptions = options => {
			const cacheEntry = childCache.get(options);
			if (cacheEntry !== undefined) return cacheEntry;
			const mergedOptions = cachedCleverMerge(originalResolveOptions, options);
			const resolver = this.get(type, mergedOptions);
			childCache.set(options, resolver);
			return resolver;
		***REMOVED***;
		this.hooks.resolver
			.for(type)
			.call(resolver, resolveOptions, originalResolveOptions);
		return resolver;
	***REMOVED***
***REMOVED***;
