/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { RawSource ***REMOVED*** = require("webpack-sources");
const { UsageState ***REMOVED*** = require("../ExportsInfo");
const Generator = require("../Generator");
const InitFragment = require("../InitFragment");
const { WEBASSEMBLY_TYPES ***REMOVED*** = require("../ModuleSourceTypesConstants");
const RuntimeGlobals = require("../RuntimeGlobals");
const Template = require("../Template");
const ModuleDependency = require("../dependencies/ModuleDependency");
const WebAssemblyExportImportedDependency = require("../dependencies/WebAssemblyExportImportedDependency");
const WebAssemblyImportDependency = require("../dependencies/WebAssemblyImportDependency");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../Dependency")***REMOVED*** Dependency */
/** @typedef {import("../DependencyTemplates")***REMOVED*** DependencyTemplates */
/** @typedef {import("../Generator").GenerateContext***REMOVED*** GenerateContext */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../Module").SourceTypes***REMOVED*** SourceTypes */
/** @typedef {import("../NormalModule")***REMOVED*** NormalModule */
/** @typedef {import("../RuntimeTemplate")***REMOVED*** RuntimeTemplate */

class WebAssemblyJavascriptGenerator extends Generator {
	/**
	 * @param {NormalModule***REMOVED*** module fresh module
	 * @returns {SourceTypes***REMOVED*** available types (do not mutate)
	 */
	getTypes(module) {
		return WEBASSEMBLY_TYPES;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module the module
	 * @param {string=***REMOVED*** type source type
	 * @returns {number***REMOVED*** estimate size of the module
	 */
	getSize(module, type) {
		return 95 + module.dependencies.length * 5;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module module for which the code should be generated
	 * @param {GenerateContext***REMOVED*** generateContext context for generate
	 * @returns {Source | null***REMOVED*** generated code
	 */
	generate(module, generateContext) {
		const {
			runtimeTemplate,
			moduleGraph,
			chunkGraph,
			runtimeRequirements,
			runtime
		***REMOVED*** = generateContext;
		/** @type {InitFragment<InitFragment<string>>[]***REMOVED*** */
		const initFragments = [];

		const exportsInfo = moduleGraph.getExportsInfo(module);

		let needExportsCopy = false;
		const importedModules = new Map();
		const initParams = [];
		let index = 0;
		for (const dep of module.dependencies) {
			const moduleDep =
				dep && dep instanceof ModuleDependency ? dep : undefined;
			if (moduleGraph.getModule(dep)) {
				let importData = importedModules.get(moduleGraph.getModule(dep));
				if (importData === undefined) {
					importedModules.set(
						moduleGraph.getModule(dep),
						(importData = {
							importVar: `m${index***REMOVED***`,
							index,
							request: (moduleDep && moduleDep.userRequest) || undefined,
							names: new Set(),
							reexports: []
						***REMOVED***)
					);
					index++;
				***REMOVED***
				if (dep instanceof WebAssemblyImportDependency) {
					importData.names.add(dep.name);
					if (dep.description.type === "GlobalType") {
						const exportName = dep.name;
						const importedModule = moduleGraph.getModule(dep);

						if (importedModule) {
							const usedName = moduleGraph
								.getExportsInfo(importedModule)
								.getUsedName(exportName, runtime);
							if (usedName) {
								initParams.push(
									runtimeTemplate.exportFromImport({
										moduleGraph,
										module: importedModule,
										request: dep.request,
										importVar: importData.importVar,
										originModule: module,
										exportName: dep.name,
										asiSafe: true,
										isCall: false,
										callContext: null,
										defaultInterop: true,
										initFragments,
										runtime,
										runtimeRequirements
									***REMOVED***)
								);
							***REMOVED***
						***REMOVED***
					***REMOVED***
				***REMOVED***
				if (dep instanceof WebAssemblyExportImportedDependency) {
					importData.names.add(dep.name);
					const usedName = moduleGraph
						.getExportsInfo(module)
						.getUsedName(dep.exportName, runtime);
					if (usedName) {
						runtimeRequirements.add(RuntimeGlobals.exports);
						const exportProp = `${module.exportsArgument***REMOVED***[${JSON.stringify(
							usedName
						)***REMOVED***]`;
						const defineStatement = Template.asString([
							`${exportProp***REMOVED*** = ${runtimeTemplate.exportFromImport({
								moduleGraph,
								module: /** @type {Module***REMOVED*** */ (moduleGraph.getModule(dep)),
								request: dep.request,
								importVar: importData.importVar,
								originModule: module,
								exportName: dep.name,
								asiSafe: true,
								isCall: false,
								callContext: null,
								defaultInterop: true,
								initFragments,
								runtime,
								runtimeRequirements
							***REMOVED***)***REMOVED***;`,
							`if(WebAssembly.Global) ${exportProp***REMOVED*** = ` +
								`new WebAssembly.Global({ value: ${JSON.stringify(
									dep.valueType
								)***REMOVED*** ***REMOVED***, ${exportProp***REMOVED***);`
						]);
						importData.reexports.push(defineStatement);
						needExportsCopy = true;
					***REMOVED***
				***REMOVED***
			***REMOVED***
		***REMOVED***
		const importsCode = Template.asString(
			Array.from(
				importedModules,
				([module, { importVar, request, reexports ***REMOVED***]) => {
					const importStatement = runtimeTemplate.importStatement({
						module,
						chunkGraph,
						request,
						importVar,
						originModule: module,
						runtimeRequirements
					***REMOVED***);
					return importStatement[0] + importStatement[1] + reexports.join("\n");
				***REMOVED***
			)
		);

		const copyAllExports =
			exportsInfo.otherExportsInfo.getUsed(runtime) === UsageState.Unused &&
			!needExportsCopy;

		// need these globals
		runtimeRequirements.add(RuntimeGlobals.module);
		runtimeRequirements.add(RuntimeGlobals.moduleId);
		runtimeRequirements.add(RuntimeGlobals.wasmInstances);
		if (exportsInfo.otherExportsInfo.getUsed(runtime) !== UsageState.Unused) {
			runtimeRequirements.add(RuntimeGlobals.makeNamespaceObject);
			runtimeRequirements.add(RuntimeGlobals.exports);
		***REMOVED***
		if (!copyAllExports) {
			runtimeRequirements.add(RuntimeGlobals.exports);
		***REMOVED***

		// create source
		const source = new RawSource(
			[
				'"use strict";',
				"// Instantiate WebAssembly module",
				`var wasmExports = ${RuntimeGlobals.wasmInstances***REMOVED***[${module.moduleArgument***REMOVED***.id];`,

				exportsInfo.otherExportsInfo.getUsed(runtime) !== UsageState.Unused
					? `${RuntimeGlobals.makeNamespaceObject***REMOVED***(${module.exportsArgument***REMOVED***);`
					: "",

				// this must be before import for circular dependencies
				"// export exports from WebAssembly module",
				copyAllExports
					? `${module.moduleArgument***REMOVED***.exports = wasmExports;`
					: "for(var name in wasmExports) " +
						"if(name) " +
						`${module.exportsArgument***REMOVED***[name] = wasmExports[name];`,
				"// exec imports from WebAssembly module (for esm order)",
				importsCode,
				"",
				"// exec wasm module",
				`wasmExports[""](${initParams.join(", ")***REMOVED***)`
			].join("\n")
		);
		return InitFragment.addToSource(source, initFragments, generateContext);
	***REMOVED***

	/**
	 * @param {Error***REMOVED*** error the error
	 * @param {NormalModule***REMOVED*** module module for which the code should be generated
	 * @param {GenerateContext***REMOVED*** generateContext context for generate
	 * @returns {Source | null***REMOVED*** generated code
	 */
	generateError(error, module, generateContext) {
		return new RawSource(`throw new Error(${JSON.stringify(error.message)***REMOVED***);`);
	***REMOVED***
***REMOVED***

module.exports = WebAssemblyJavascriptGenerator;
