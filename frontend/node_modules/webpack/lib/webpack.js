/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const util = require("util");
const webpackOptionsSchemaCheck = require("../schemas/WebpackOptions.check.js");
const webpackOptionsSchema = require("../schemas/WebpackOptions.json");
const Compiler = require("./Compiler");
const MultiCompiler = require("./MultiCompiler");
const WebpackOptionsApply = require("./WebpackOptionsApply");
const {
	applyWebpackOptionsDefaults,
	applyWebpackOptionsBaseDefaults
***REMOVED*** = require("./config/defaults");
const { getNormalizedWebpackOptions ***REMOVED*** = require("./config/normalization");
const NodeEnvironmentPlugin = require("./node/NodeEnvironmentPlugin");
const memoize = require("./util/memoize");

/** @typedef {import("../declarations/WebpackOptions").WebpackOptions***REMOVED*** WebpackOptions */
/** @typedef {import("../declarations/WebpackOptions").WebpackPluginFunction***REMOVED*** WebpackPluginFunction */
/** @typedef {import("./Compiler").WatchOptions***REMOVED*** WatchOptions */
/** @typedef {import("./MultiCompiler").MultiCompilerOptions***REMOVED*** MultiCompilerOptions */
/** @typedef {import("./MultiStats")***REMOVED*** MultiStats */
/** @typedef {import("./Stats")***REMOVED*** Stats */

const getValidateSchema = memoize(() => require("./validateSchema"));

/**
 * @template T
 * @callback Callback
 * @param {Error | null***REMOVED*** err
 * @param {T=***REMOVED*** stats
 * @returns {void***REMOVED***
 */

/**
 * @param {ReadonlyArray<WebpackOptions>***REMOVED*** childOptions options array
 * @param {MultiCompilerOptions***REMOVED*** options options
 * @returns {MultiCompiler***REMOVED*** a multi-compiler
 */
const createMultiCompiler = (childOptions, options) => {
	const compilers = childOptions.map((options, index) =>
		createCompiler(options, index)
	);
	const compiler = new MultiCompiler(compilers, options);
	for (const childCompiler of compilers) {
		if (childCompiler.options.dependencies) {
			compiler.setDependencies(
				childCompiler,
				childCompiler.options.dependencies
			);
		***REMOVED***
	***REMOVED***
	return compiler;
***REMOVED***;

/**
 * @param {WebpackOptions***REMOVED*** rawOptions options object
 * @param {number=***REMOVED*** compilerIndex index of compiler
 * @returns {Compiler***REMOVED*** a compiler
 */
const createCompiler = (rawOptions, compilerIndex) => {
	const options = getNormalizedWebpackOptions(rawOptions);
	applyWebpackOptionsBaseDefaults(options);
	const compiler = new Compiler(
		/** @type {string***REMOVED*** */ (options.context),
		options
	);
	new NodeEnvironmentPlugin({
		infrastructureLogging: options.infrastructureLogging
	***REMOVED***).apply(compiler);
	if (Array.isArray(options.plugins)) {
		for (const plugin of options.plugins) {
			if (typeof plugin === "function") {
				/** @type {WebpackPluginFunction***REMOVED*** */
				(plugin).call(compiler, compiler);
			***REMOVED*** else if (plugin) {
				plugin.apply(compiler);
			***REMOVED***
		***REMOVED***
	***REMOVED***
	const resolvedDefaultOptions = applyWebpackOptionsDefaults(
		options,
		compilerIndex
	);
	if (resolvedDefaultOptions.platform) {
		compiler.platform = resolvedDefaultOptions.platform;
	***REMOVED***
	compiler.hooks.environment.call();
	compiler.hooks.afterEnvironment.call();
	new WebpackOptionsApply().process(options, compiler);
	compiler.hooks.initialize.call();
	return compiler;
***REMOVED***;

/**
 * @callback WebpackFunctionSingle
 * @param {WebpackOptions***REMOVED*** options options object
 * @param {Callback<Stats>=***REMOVED*** callback callback
 * @returns {Compiler***REMOVED*** the compiler object
 */

/**
 * @callback WebpackFunctionMulti
 * @param {ReadonlyArray<WebpackOptions> & MultiCompilerOptions***REMOVED*** options options objects
 * @param {Callback<MultiStats>=***REMOVED*** callback callback
 * @returns {MultiCompiler***REMOVED*** the multi compiler object
 */

/**
 * @template T
 * @param {Array<T> | T***REMOVED*** options options
 * @returns {Array<T>***REMOVED*** array of options
 */
const asArray = options =>
	Array.isArray(options) ? Array.from(options) : [options];

const webpack = /** @type {WebpackFunctionSingle & WebpackFunctionMulti***REMOVED*** */ (
	/**
	 * @param {WebpackOptions | (ReadonlyArray<WebpackOptions> & MultiCompilerOptions)***REMOVED*** options options
	 * @param {Callback<Stats> & Callback<MultiStats>=***REMOVED*** callback callback
	 * @returns {Compiler | MultiCompiler | null***REMOVED*** Compiler or MultiCompiler
	 */
	(options, callback) => {
		const create = () => {
			if (!asArray(options).every(webpackOptionsSchemaCheck)) {
				getValidateSchema()(webpackOptionsSchema, options);
				util.deprecate(
					() => {***REMOVED***,
					"webpack bug: Pre-compiled schema reports error while real schema is happy. This has performance drawbacks.",
					"DEP_WEBPACK_PRE_COMPILED_SCHEMA_INVALID"
				)();
			***REMOVED***
			/** @type {MultiCompiler|Compiler***REMOVED*** */
			let compiler;
			/** @type {boolean | undefined***REMOVED*** */
			let watch = false;
			/** @type {WatchOptions|WatchOptions[]***REMOVED*** */
			let watchOptions;
			if (Array.isArray(options)) {
				/** @type {MultiCompiler***REMOVED*** */
				compiler = createMultiCompiler(
					options,
					/** @type {MultiCompilerOptions***REMOVED*** */ (options)
				);
				watch = options.some(options => options.watch);
				watchOptions = options.map(options => options.watchOptions || {***REMOVED***);
			***REMOVED*** else {
				const webpackOptions = /** @type {WebpackOptions***REMOVED*** */ (options);
				/** @type {Compiler***REMOVED*** */
				compiler = createCompiler(webpackOptions);
				watch = webpackOptions.watch;
				watchOptions = webpackOptions.watchOptions || {***REMOVED***;
			***REMOVED***
			return { compiler, watch, watchOptions ***REMOVED***;
		***REMOVED***;
		if (callback) {
			try {
				const { compiler, watch, watchOptions ***REMOVED*** = create();
				if (watch) {
					compiler.watch(watchOptions, callback);
				***REMOVED*** else {
					compiler.run((err, stats) => {
						compiler.close(err2 => {
							callback(
								err || err2,
								/** @type {options extends WebpackOptions ? Stats : MultiStats***REMOVED*** */
								(stats)
							);
						***REMOVED***);
					***REMOVED***);
				***REMOVED***
				return compiler;
			***REMOVED*** catch (err) {
				process.nextTick(() => callback(/** @type {Error***REMOVED*** */ (err)));
				return null;
			***REMOVED***
		***REMOVED*** else {
			const { compiler, watch ***REMOVED*** = create();
			if (watch) {
				util.deprecate(
					() => {***REMOVED***,
					"A 'callback' argument needs to be provided to the 'webpack(options, callback)' function when the 'watch' option is set. There is no way to handle the 'watch' option without a callback.",
					"DEP_WEBPACK_WATCH_WITHOUT_CALLBACK"
				)();
			***REMOVED***
			return compiler;
		***REMOVED***
	***REMOVED***
);

module.exports = webpack;
