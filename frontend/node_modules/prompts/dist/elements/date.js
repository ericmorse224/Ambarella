'use strict';

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; ***REMOVED*** catch (error) { reject(error); return; ***REMOVED*** if (info.done) { resolve(value); ***REMOVED*** else { Promise.resolve(value).then(_next, _throw); ***REMOVED*** ***REMOVED***

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); ***REMOVED*** function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); ***REMOVED*** _next(undefined); ***REMOVED***); ***REMOVED***; ***REMOVED***

const color = require('kleur');

const Prompt = require('./prompt');

const _require = require('../util'),
      style = _require.style,
      clear = _require.clear,
      figures = _require.figures;

const _require2 = require('sisteransi'),
      erase = _require2.erase,
      cursor = _require2.cursor;

const _require3 = require('../dateparts'),
      DatePart = _require3.DatePart,
      Meridiem = _require3.Meridiem,
      Day = _require3.Day,
      Hours = _require3.Hours,
      Milliseconds = _require3.Milliseconds,
      Minutes = _require3.Minutes,
      Month = _require3.Month,
      Seconds = _require3.Seconds,
      Year = _require3.Year;

const regex = /\\(.)|"((?:\\["\\]|[^"])+)"|(D[Do]?|d{3,4***REMOVED***|d)|(M{1,4***REMOVED***)|(YY(?:YY)?)|([aA])|([Hh]{1,2***REMOVED***)|(m{1,2***REMOVED***)|(s{1,2***REMOVED***)|(S{1,4***REMOVED***)|./g;
const regexGroups = {
  1: ({
    token
  ***REMOVED***) => token.replace(/\\(.)/g, '$1'),
  2: opts => new Day(opts),
  // Day // TODO
  3: opts => new Month(opts),
  // Month
  4: opts => new Year(opts),
  // Year
  5: opts => new Meridiem(opts),
  // AM/PM // TODO (special)
  6: opts => new Hours(opts),
  // Hours
  7: opts => new Minutes(opts),
  // Minutes
  8: opts => new Seconds(opts),
  // Seconds
  9: opts => new Milliseconds(opts) // Fractional seconds

***REMOVED***;
const dfltLocales = {
  months: 'January,February,March,April,May,June,July,August,September,October,November,December'.split(','),
  monthsShort: 'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),
  weekdays: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),
  weekdaysShort: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(',')
***REMOVED***;
/**
 * DatePrompt Base Element
 * @param {Object***REMOVED*** opts Options
 * @param {String***REMOVED*** opts.message Message
 * @param {Number***REMOVED*** [opts.initial] Index of default value
 * @param {String***REMOVED*** [opts.mask] The format mask
 * @param {object***REMOVED*** [opts.locales] The date locales
 * @param {String***REMOVED*** [opts.error] The error message shown on invalid value
 * @param {Function***REMOVED*** [opts.validate] Function to validate the submitted value
 * @param {Stream***REMOVED*** [opts.stdin] The Readable stream to listen to
 * @param {Stream***REMOVED*** [opts.stdout] The Writable stream to write readline data to
 */

class DatePrompt extends Prompt {
  constructor(opts = {***REMOVED***) {
    super(opts);
    this.msg = opts.message;
    this.cursor = 0;
    this.typed = '';
    this.locales = Object.assign(dfltLocales, opts.locales);
    this._date = opts.initial || new Date();
    this.errorMsg = opts.error || 'Please Enter A Valid Value';

    this.validator = opts.validate || (() => true);

    this.mask = opts.mask || 'YYYY-MM-DD HH:mm:ss';
    this.clear = clear('', this.out.columns);
    this.render();
  ***REMOVED***

  get value() {
    return this.date;
  ***REMOVED***

  get date() {
    return this._date;
  ***REMOVED***

  set date(date) {
    if (date) this._date.setTime(date.getTime());
  ***REMOVED***

  set mask(mask) {
    let result;
    this.parts = [];

    while (result = regex.exec(mask)) {
      let match = result.shift();
      let idx = result.findIndex(gr => gr != null);
      this.parts.push(idx in regexGroups ? regexGroups[idx]({
        token: result[idx] || match,
        date: this.date,
        parts: this.parts,
        locales: this.locales
      ***REMOVED***) : result[idx] || match);
    ***REMOVED***

    let parts = this.parts.reduce((arr, i) => {
      if (typeof i === 'string' && typeof arr[arr.length - 1] === 'string') arr[arr.length - 1] += i;else arr.push(i);
      return arr;
    ***REMOVED***, []);
    this.parts.splice(0);
    this.parts.push(...parts);
    this.reset();
  ***REMOVED***

  moveCursor(n) {
    this.typed = '';
    this.cursor = n;
    this.fire();
  ***REMOVED***

  reset() {
    this.moveCursor(this.parts.findIndex(p => p instanceof DatePart));
    this.fire();
    this.render();
  ***REMOVED***

  exit() {
    this.abort();
  ***REMOVED***

  abort() {
    this.done = this.aborted = true;
    this.error = false;
    this.fire();
    this.render();
    this.out.write('\n');
    this.close();
  ***REMOVED***

  validate() {
    var _this = this;

    return _asyncToGenerator(function* () {
      let valid = yield _this.validator(_this.value);

      if (typeof valid === 'string') {
        _this.errorMsg = valid;
        valid = false;
      ***REMOVED***

      _this.error = !valid;
    ***REMOVED***)();
  ***REMOVED***

  submit() {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      yield _this2.validate();

      if (_this2.error) {
        _this2.color = 'red';

        _this2.fire();

        _this2.render();

        return;
      ***REMOVED***

      _this2.done = true;
      _this2.aborted = false;

      _this2.fire();

      _this2.render();

      _this2.out.write('\n');

      _this2.close();
    ***REMOVED***)();
  ***REMOVED***

  up() {
    this.typed = '';
    this.parts[this.cursor].up();
    this.render();
  ***REMOVED***

  down() {
    this.typed = '';
    this.parts[this.cursor].down();
    this.render();
  ***REMOVED***

  left() {
    let prev = this.parts[this.cursor].prev();
    if (prev == null) return this.bell();
    this.moveCursor(this.parts.indexOf(prev));
    this.render();
  ***REMOVED***

  right() {
    let next = this.parts[this.cursor].next();
    if (next == null) return this.bell();
    this.moveCursor(this.parts.indexOf(next));
    this.render();
  ***REMOVED***

  next() {
    let next = this.parts[this.cursor].next();
    this.moveCursor(next ? this.parts.indexOf(next) : this.parts.findIndex(part => part instanceof DatePart));
    this.render();
  ***REMOVED***

  _(c) {
    if (/\d/.test(c)) {
      this.typed += c;
      this.parts[this.cursor].setTo(this.typed);
      this.render();
    ***REMOVED***
  ***REMOVED***

  render() {
    if (this.closed) return;
    if (this.firstRender) this.out.write(cursor.hide);else this.out.write(clear(this.outputText, this.out.columns));
    super.render(); // Print prompt

    this.outputText = [style.symbol(this.done, this.aborted), color.bold(this.msg), style.delimiter(false), this.parts.reduce((arr, p, idx) => arr.concat(idx === this.cursor && !this.done ? color.cyan().underline(p.toString()) : p), []).join('')].join(' '); // Print error

    if (this.error) {
      this.outputText += this.errorMsg.split('\n').reduce((a, l, i) => a + `\n${i ? ` ` : figures.pointerSmall***REMOVED*** ${color.red().italic(l)***REMOVED***`, ``);
    ***REMOVED***

    this.out.write(erase.line + cursor.to(0) + this.outputText);
  ***REMOVED***

***REMOVED***

module.exports = DatePrompt;