"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.moduleContextFromModuleAST = moduleContextFromModuleAST;
exports.ModuleContext = void 0;

var _nodes = require("../../nodes.js");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); ***REMOVED*** ***REMOVED***

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); ***REMOVED*** ***REMOVED***

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; ***REMOVED***

function moduleContextFromModuleAST(m) {
  var moduleContext = new ModuleContext();

  if (!(m.type === "Module")) {
    throw new Error('m.type === "Module"' + " error: " + (undefined || "unknown"));
  ***REMOVED***

  m.fields.forEach(function (field) {
    switch (field.type) {
      case "Start":
        {
          moduleContext.setStart(field.index);
          break;
        ***REMOVED***

      case "TypeInstruction":
        {
          moduleContext.addType(field);
          break;
        ***REMOVED***

      case "Func":
        {
          moduleContext.addFunction(field);
          break;
        ***REMOVED***

      case "Global":
        {
          moduleContext.defineGlobal(field);
          break;
        ***REMOVED***

      case "ModuleImport":
        {
          switch (field.descr.type) {
            case "GlobalType":
              {
                moduleContext.importGlobal(field.descr.valtype, field.descr.mutability);
                break;
              ***REMOVED***

            case "Memory":
              {
                moduleContext.addMemory(field.descr.limits.min, field.descr.limits.max);
                break;
              ***REMOVED***

            case "FuncImportDescr":
              {
                moduleContext.importFunction(field.descr);
                break;
              ***REMOVED***

            case "Table":
              {
                // FIXME(sven): not implemented yet
                break;
              ***REMOVED***

            default:
              throw new Error("Unsupported ModuleImport of type " + JSON.stringify(field.descr.type));
          ***REMOVED***

          break;
        ***REMOVED***

      case "Memory":
        {
          moduleContext.addMemory(field.limits.min, field.limits.max);
          break;
        ***REMOVED***
    ***REMOVED***
  ***REMOVED***);
  return moduleContext;
***REMOVED***
/**
 * Module context for type checking
 */


var ModuleContext = /*#__PURE__*/function () {
  function ModuleContext() {
    _classCallCheck(this, ModuleContext);

    this.funcs = [];
    this.funcsOffsetByIdentifier = [];
    this.types = [];
    this.globals = [];
    this.globalsOffsetByIdentifier = [];
    this.mems = []; // Current stack frame

    this.locals = [];
    this.labels = [];
    this["return"] = [];
    this.debugName = "unknown";
    this.start = null;
  ***REMOVED***
  /**
   * Set start segment
   */


  _createClass(ModuleContext, [{
    key: "setStart",
    value: function setStart(index) {
      this.start = index.value;
    ***REMOVED***
    /**
     * Get start function
     */

  ***REMOVED***, {
    key: "getStart",
    value: function getStart() {
      return this.start;
    ***REMOVED***
    /**
     * Reset the active stack frame
     */

  ***REMOVED***, {
    key: "newContext",
    value: function newContext(debugName, expectedResult) {
      this.locals = [];
      this.labels = [expectedResult];
      this["return"] = expectedResult;
      this.debugName = debugName;
    ***REMOVED***
    /**
     * Functions
     */

  ***REMOVED***, {
    key: "addFunction",
    value: function addFunction(func) {
      /* eslint-disable */
      // $FlowIgnore
      var _ref = func.signature || {***REMOVED***,
          _ref$params = _ref.params,
          args = _ref$params === void 0 ? [] : _ref$params,
          _ref$results = _ref.results,
          result = _ref$results === void 0 ? [] : _ref$results;
      /* eslint-enable */


      args = args.map(function (arg) {
        return arg.valtype;
      ***REMOVED***);
      this.funcs.push({
        args: args,
        result: result
      ***REMOVED***);

      if (typeof func.name !== "undefined") {
        // $FlowIgnore
        this.funcsOffsetByIdentifier[func.name.value] = this.funcs.length - 1;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***, {
    key: "importFunction",
    value: function importFunction(funcimport) {
      if ((0, _nodes.isSignature)(funcimport.signature)) {
        // eslint-disable-next-line prefer-const
        var _funcimport$signature = funcimport.signature,
            args = _funcimport$signature.params,
            result = _funcimport$signature.results;
        args = args.map(function (arg) {
          return arg.valtype;
        ***REMOVED***);
        this.funcs.push({
          args: args,
          result: result
        ***REMOVED***);
      ***REMOVED*** else {
        if (!(0, _nodes.isNumberLiteral)(funcimport.signature)) {
          throw new Error('isNumberLiteral(funcimport.signature)' + " error: " + (undefined || "unknown"));
        ***REMOVED***

        var typeId = funcimport.signature.value;

        if (!this.hasType(typeId)) {
          throw new Error('this.hasType(typeId)' + " error: " + (undefined || "unknown"));
        ***REMOVED***

        var signature = this.getType(typeId);
        this.funcs.push({
          args: signature.params.map(function (arg) {
            return arg.valtype;
          ***REMOVED***),
          result: signature.results
        ***REMOVED***);
      ***REMOVED***

      if (typeof funcimport.id !== "undefined") {
        // imports are first, we can assume their index in the array
        this.funcsOffsetByIdentifier[funcimport.id.value] = this.funcs.length - 1;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***, {
    key: "hasFunction",
    value: function hasFunction(index) {
      return typeof this.getFunction(index) !== "undefined";
    ***REMOVED***
  ***REMOVED***, {
    key: "getFunction",
    value: function getFunction(index) {
      if (typeof index !== "number") {
        throw new Error("getFunction only supported for number index");
      ***REMOVED***

      return this.funcs[index];
    ***REMOVED***
  ***REMOVED***, {
    key: "getFunctionOffsetByIdentifier",
    value: function getFunctionOffsetByIdentifier(name) {
      if (!(typeof name === "string")) {
        throw new Error('typeof name === "string"' + " error: " + (undefined || "unknown"));
      ***REMOVED***

      return this.funcsOffsetByIdentifier[name];
    ***REMOVED***
    /**
     * Labels
     */

  ***REMOVED***, {
    key: "addLabel",
    value: function addLabel(result) {
      this.labels.unshift(result);
    ***REMOVED***
  ***REMOVED***, {
    key: "hasLabel",
    value: function hasLabel(index) {
      return this.labels.length > index && index >= 0;
    ***REMOVED***
  ***REMOVED***, {
    key: "getLabel",
    value: function getLabel(index) {
      return this.labels[index];
    ***REMOVED***
  ***REMOVED***, {
    key: "popLabel",
    value: function popLabel() {
      this.labels.shift();
    ***REMOVED***
    /**
     * Locals
     */

  ***REMOVED***, {
    key: "hasLocal",
    value: function hasLocal(index) {
      return typeof this.getLocal(index) !== "undefined";
    ***REMOVED***
  ***REMOVED***, {
    key: "getLocal",
    value: function getLocal(index) {
      return this.locals[index];
    ***REMOVED***
  ***REMOVED***, {
    key: "addLocal",
    value: function addLocal(type) {
      this.locals.push(type);
    ***REMOVED***
    /**
     * Types
     */

  ***REMOVED***, {
    key: "addType",
    value: function addType(type) {
      if (!(type.functype.type === "Signature")) {
        throw new Error('type.functype.type === "Signature"' + " error: " + (undefined || "unknown"));
      ***REMOVED***

      this.types.push(type.functype);
    ***REMOVED***
  ***REMOVED***, {
    key: "hasType",
    value: function hasType(index) {
      return this.types[index] !== undefined;
    ***REMOVED***
  ***REMOVED***, {
    key: "getType",
    value: function getType(index) {
      return this.types[index];
    ***REMOVED***
    /**
     * Globals
     */

  ***REMOVED***, {
    key: "hasGlobal",
    value: function hasGlobal(index) {
      return this.globals.length > index && index >= 0;
    ***REMOVED***
  ***REMOVED***, {
    key: "getGlobal",
    value: function getGlobal(index) {
      return this.globals[index].type;
    ***REMOVED***
  ***REMOVED***, {
    key: "getGlobalOffsetByIdentifier",
    value: function getGlobalOffsetByIdentifier(name) {
      if (!(typeof name === "string")) {
        throw new Error('typeof name === "string"' + " error: " + (undefined || "unknown"));
      ***REMOVED***

      // $FlowIgnore
      return this.globalsOffsetByIdentifier[name];
    ***REMOVED***
  ***REMOVED***, {
    key: "defineGlobal",
    value: function defineGlobal(global) {
      var type = global.globalType.valtype;
      var mutability = global.globalType.mutability;
      this.globals.push({
        type: type,
        mutability: mutability
      ***REMOVED***);

      if (typeof global.name !== "undefined") {
        // $FlowIgnore
        this.globalsOffsetByIdentifier[global.name.value] = this.globals.length - 1;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***, {
    key: "importGlobal",
    value: function importGlobal(type, mutability) {
      this.globals.push({
        type: type,
        mutability: mutability
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***, {
    key: "isMutableGlobal",
    value: function isMutableGlobal(index) {
      return this.globals[index].mutability === "var";
    ***REMOVED***
  ***REMOVED***, {
    key: "isImmutableGlobal",
    value: function isImmutableGlobal(index) {
      return this.globals[index].mutability === "const";
    ***REMOVED***
    /**
     * Memories
     */

  ***REMOVED***, {
    key: "hasMemory",
    value: function hasMemory(index) {
      return this.mems.length > index && index >= 0;
    ***REMOVED***
  ***REMOVED***, {
    key: "addMemory",
    value: function addMemory(min, max) {
      this.mems.push({
        min: min,
        max: max
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***, {
    key: "getMemory",
    value: function getMemory(index) {
      return this.mems[index];
    ***REMOVED***
  ***REMOVED***]);

  return ModuleContext;
***REMOVED***();

exports.ModuleContext = ModuleContext;