'use strict'

const check = require('check-types')
const error = require('./error')
const EventEmitter = require('events').EventEmitter
const events = require('./events')
const promise = require('./promise')

const terminators = {
  obj: '***REMOVED***',
  arr: ']'
***REMOVED***

const escapes = {
  /* eslint-disable quote-props */
  '"': '"',
  '\\': '\\',
  '/': '/',
  'b': '\b',
  'f': '\f',
  'n': '\n',
  'r': '\r',
  't': '\t'
  /* eslint-enable quote-props */
***REMOVED***

module.exports = initialise

/**
 * Public function `walk`.
 *
 * Returns an event emitter and asynchronously walks a stream of JSON data,
 * emitting events as it encounters tokens. The event emitter is decorated
 * with a `pause` method that can be called to pause processing.
 *
 * @param stream:     Readable instance representing the incoming JSON.
 *
 * @option yieldRate: The number of data items to process per timeslice,
 *                    default is 16384.
 *
 * @option Promise:   The promise constructor to use, defaults to bluebird.
 *
 * @option ndjson:    Set this to true to parse newline-delimited JSON.
 **/
function initialise (stream, options = {***REMOVED***) {
  check.assert.instanceStrict(stream, require('stream').Readable, 'Invalid stream argument')

  const currentPosition = {
    line: 1,
    column: 1
  ***REMOVED***
  const emitter = new EventEmitter()
  const handlers = {
    arr: value,
    obj: property
  ***REMOVED***
  const json = []
  const lengths = []
  const previousPosition = {***REMOVED***
  const Promise = promise(options)
  const scopes = []
  const yieldRate = options.yieldRate || 16384
  const shouldHandleNdjson = !! options.ndjson

  let index = 0
  let isStreamEnded = false
  let isWalkBegun = false
  let isWalkEnded = false
  let isWalkingString = false
  let hasEndedLine = true
  let count = 0
  let resumeFn
  let pause
  let cachedCharacter

  stream.setEncoding('utf8')
  stream.on('data', readStream)
  stream.on('end', endStream)
  stream.on('error', err => {
    emitter.emit(events.error, err)
    endStream()
  ***REMOVED***)

  emitter.pause = () => {
    let resolve
    pause = new Promise(res => resolve = res)
    return () => {
      pause = null
      count = 0

      if (shouldHandleNdjson && isStreamEnded && isWalkEnded) {
        emit(events.end)
      ***REMOVED*** else {
        resolve()
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return emitter

  function readStream (chunk) {
    addChunk(chunk)

    if (isWalkBegun) {
      return resume()
    ***REMOVED***

    isWalkBegun = true
    value()
  ***REMOVED***

  function addChunk (chunk) {
    json.push(chunk)

    const chunkLength = chunk.length
    lengths.push({
      item: chunkLength,
      aggregate: length() + chunkLength
    ***REMOVED***)
  ***REMOVED***

  function length () {
    const chunkCount = lengths.length

    if (chunkCount === 0) {
      return 0
    ***REMOVED***

    return lengths[chunkCount - 1].aggregate
  ***REMOVED***

  function value () {
    /* eslint-disable no-underscore-dangle */
    if (++count % yieldRate !== 0) {
      return _do()
    ***REMOVED***

    return new Promise(resolve => {
      setImmediate(() => _do().then(resolve))
    ***REMOVED***)

    function _do () {
      return awaitNonWhitespace()
        .then(next)
        .then(handleValue)
        .catch(() => {***REMOVED***)
    ***REMOVED***
    /* eslint-enable no-underscore-dangle */
  ***REMOVED***

  function awaitNonWhitespace () {
    return wait()

    function wait () {
      return awaitCharacter()
        .then(step)
    ***REMOVED***

    function step () {
      if (isWhitespace(character())) {
        return next().then(wait)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  function awaitCharacter () {
    let resolve, reject

    if (index < length()) {
      return Promise.resolve()
    ***REMOVED***

    if (isStreamEnded) {
      setImmediate(endWalk)
      return Promise.reject()
    ***REMOVED***

    resumeFn = after

    return new Promise((res, rej) => {
      resolve = res
      reject = rej
    ***REMOVED***)

    function after () {
      if (index < length()) {
        return resolve()
      ***REMOVED***

      reject()

      if (isStreamEnded) {
        setImmediate(endWalk)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  function character () {
    if (cachedCharacter) {
      return cachedCharacter
    ***REMOVED***

    if (lengths[0].item > index) {
      return cachedCharacter = json[0][index]
    ***REMOVED***

    const len = lengths.length
    for (let i = 1; i < len; ++i) {
      const { aggregate, item ***REMOVED*** = lengths[i]
      if (aggregate > index) {
        return cachedCharacter = json[i][index + item - aggregate]
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  function isWhitespace (char) {
    switch (char) {
      case '\n':
        if (shouldHandleNdjson && scopes.length === 0) {
          return false
        ***REMOVED***
      case ' ':
      case '\t':
      case '\r':
        return true
    ***REMOVED***

    return false
  ***REMOVED***

  function next () {
    return awaitCharacter().then(after)

    function after () {
      const result = character()

      cachedCharacter = null
      index += 1
      previousPosition.line = currentPosition.line
      previousPosition.column = currentPosition.column

      if (result === '\n') {
        currentPosition.line += 1
        currentPosition.column = 1
      ***REMOVED*** else {
        currentPosition.column += 1
      ***REMOVED***

      if (index > lengths[0].aggregate) {
        json.shift()

        const difference = lengths.shift().item
        index -= difference

        lengths.forEach(len => len.aggregate -= difference)
      ***REMOVED***

      return result
    ***REMOVED***
  ***REMOVED***

  function handleValue (char) {
    if (shouldHandleNdjson && scopes.length === 0) {
      if (char === '\n') {
        hasEndedLine = true
        return emit(events.endLine)
          .then(value)
      ***REMOVED***

      if (! hasEndedLine) {
        return fail(char, '\n', previousPosition)
          .then(value)
      ***REMOVED***

      hasEndedLine = false
    ***REMOVED***

    switch (char) {
      case '[':
        return array()
      case '{':
        return object()
      case '"':
        return string()
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case '-':
      case '.':
        return number(char)
      case 'f':
        return literalFalse()
      case 'n':
        return literalNull()
      case 't':
        return literalTrue()
      default:
        return fail(char, 'value', previousPosition)
          .then(value)
    ***REMOVED***
  ***REMOVED***

  function array () {
    return scope(events.array, value)
  ***REMOVED***

  function scope (event, contentHandler) {
    return emit(event)
      .then(() => {
        scopes.push(event)
        return endScope(event)
      ***REMOVED***)
      .then(contentHandler)
  ***REMOVED***

  function emit (...args) {
    return (pause || Promise.resolve())
      .then(() => {
        try {
          emitter.emit(...args)
        ***REMOVED*** catch (err) {
          try {
            emitter.emit(events.error, err)
          ***REMOVED*** catch (_) {
            // When calling user code, anything is possible
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***)
  ***REMOVED***

  function endScope (scp) {
    return awaitNonWhitespace()
      .then(() => {
        if (character() === terminators[scp]) {
          return emit(events.endPrefix + scp)
            .then(() => {
              scopes.pop()
              return next()
            ***REMOVED***)
            .then(endValue)
        ***REMOVED***
      ***REMOVED***)
      .catch(endWalk)
  ***REMOVED***

  function endValue () {
    return awaitNonWhitespace()
      .then(after)
      .catch(endWalk)

    function after () {
      if (scopes.length === 0) {
        if (shouldHandleNdjson) {
          return value()
        ***REMOVED***

        return fail(character(), 'EOF', currentPosition)
          .then(value)
      ***REMOVED***

      return checkScope()
    ***REMOVED***

    function checkScope () {
      const scp = scopes[scopes.length - 1]
      const handler = handlers[scp]

      return endScope(scp)
        .then(() => {
          if (scopes.length > 0) {
            return checkCharacter(character(), ',', currentPosition)
          ***REMOVED***
        ***REMOVED***)
        .then(result => {
          if (result) {
            return next()
          ***REMOVED***
        ***REMOVED***)
        .then(handler)
    ***REMOVED***
  ***REMOVED***

  function fail (actual, expected, position) {
    return emit(
      events.dataError,
      error.create(
        actual,
        expected,
        position.line,
        position.column
      )
    )
  ***REMOVED***

  function checkCharacter (char, expected, position) {
    if (char === expected) {
      return Promise.resolve(true)
    ***REMOVED***

    return fail(char, expected, position)
      .then(false)
  ***REMOVED***

  function object () {
    return scope(events.object, property)
  ***REMOVED***

  function property () {
    return awaitNonWhitespace()
      .then(next)
      .then(propertyName)
  ***REMOVED***

  function propertyName (char) {
    return checkCharacter(char, '"', previousPosition)
      .then(() => walkString(events.property))
      .then(awaitNonWhitespace)
      .then(next)
      .then(propertyValue)
  ***REMOVED***

  function propertyValue (char) {
    return checkCharacter(char, ':', previousPosition)
      .then(value)
  ***REMOVED***

  function walkString (event) {
    let isEscaping = false
    const str = []

    isWalkingString = true

    return next().then(step)

    function step (char) {
      if (isEscaping) {
        isEscaping = false

        return escape(char).then(escaped => {
          str.push(escaped)
          return next().then(step)
        ***REMOVED***)
      ***REMOVED***

      if (char === '\\') {
        isEscaping = true
        return next().then(step)
      ***REMOVED***

      if (char !== '"') {
        str.push(char)
        return next().then(step)
      ***REMOVED***

      isWalkingString = false
      return emit(event, str.join(''))
    ***REMOVED***
  ***REMOVED***

  function escape (char) {
    if (escapes[char]) {
      return Promise.resolve(escapes[char])
    ***REMOVED***

    if (char === 'u') {
      return escapeHex()
    ***REMOVED***

    return fail(char, 'escape character', previousPosition)
      .then(() => `\\${char***REMOVED***`)
  ***REMOVED***

  function escapeHex () {
    let hexits = []

    return next().then(step.bind(null, 0))

    function step (idx, char) {
      if (isHexit(char)) {
        hexits.push(char)
      ***REMOVED***

      if (idx < 3) {
        return next().then(step.bind(null, idx + 1))
      ***REMOVED***

      hexits = hexits.join('')

      if (hexits.length === 4) {
        return String.fromCharCode(parseInt(hexits, 16))
      ***REMOVED***

      return fail(char, 'hex digit', previousPosition)
        .then(() => `\\u${hexits***REMOVED***${char***REMOVED***`)
    ***REMOVED***
  ***REMOVED***

  function string () {
    return walkString(events.string).then(endValue)
  ***REMOVED***

  function number (firstCharacter) {
    let digits = [ firstCharacter ]

    return walkDigits().then(addDigits.bind(null, checkDecimalPlace))

    function addDigits (step, result) {
      digits = digits.concat(result.digits)

      if (result.atEnd) {
        return endNumber()
      ***REMOVED***

      return step()
    ***REMOVED***

    function checkDecimalPlace () {
      if (character() === '.') {
        return next()
          .then(char => {
            digits.push(char)
            return walkDigits()
          ***REMOVED***)
          .then(addDigits.bind(null, checkExponent))
      ***REMOVED***

      return checkExponent()
    ***REMOVED***

    function checkExponent () {
      if (character() === 'e' || character() === 'E') {
        return next()
          .then(char => {
            digits.push(char)
            return awaitCharacter()
          ***REMOVED***)
          .then(checkSign)
          .catch(fail.bind(null, 'EOF', 'exponent', currentPosition))
      ***REMOVED***

      return endNumber()
    ***REMOVED***

    function checkSign () {
      if (character() === '+' || character() === '-') {
        return next().then(char => {
          digits.push(char)
          return readExponent()
        ***REMOVED***)
      ***REMOVED***

      return readExponent()
    ***REMOVED***

    function readExponent () {
      return walkDigits().then(addDigits.bind(null, endNumber))
    ***REMOVED***

    function endNumber () {
      return emit(events.number, parseFloat(digits.join('')))
        .then(endValue)
    ***REMOVED***
  ***REMOVED***

  function walkDigits () {
    const digits = []

    return wait()

    function wait () {
      return awaitCharacter()
        .then(step)
        .catch(atEnd)
    ***REMOVED***

    function step () {
      if (isDigit(character())) {
        return next().then(char => {
          digits.push(char)
          return wait()
        ***REMOVED***)
      ***REMOVED***

      return { digits, atEnd: false ***REMOVED***
    ***REMOVED***

    function atEnd () {
      return { digits, atEnd: true ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  function literalFalse () {
    return literal([ 'a', 'l', 's', 'e' ], false)
  ***REMOVED***

  function literal (expectedCharacters, val) {
    let actual, expected, invalid

    return wait()

    function wait () {
      return awaitCharacter()
        .then(step)
        .catch(atEnd)
    ***REMOVED***

    function step () {
      if (invalid || expectedCharacters.length === 0) {
        return atEnd()
      ***REMOVED***

      return next().then(afterNext)
    ***REMOVED***

    function atEnd () {
      return Promise.resolve()
        .then(() => {
          if (invalid) {
            return fail(actual, expected, previousPosition)
          ***REMOVED***

          if (expectedCharacters.length > 0) {
            return fail('EOF', expectedCharacters.shift(), currentPosition)
          ***REMOVED***

          return done()
        ***REMOVED***)
        .then(endValue)
    ***REMOVED***

    function afterNext (char) {
      actual = char
      expected = expectedCharacters.shift()

      if (actual !== expected) {
        invalid = true
      ***REMOVED***

      return wait()
    ***REMOVED***

    function done () {
      return emit(events.literal, val)
    ***REMOVED***
  ***REMOVED***

  function literalNull () {
    return literal([ 'u', 'l', 'l' ], null)
  ***REMOVED***

  function literalTrue () {
    return literal([ 'r', 'u', 'e' ], true)
  ***REMOVED***

  function endStream () {
    isStreamEnded = true

    if (isWalkBegun) {
      return resume()
    ***REMOVED***

    endWalk()
  ***REMOVED***

  function resume () {
    if (resumeFn) {
      resumeFn()
      resumeFn = null
    ***REMOVED***
  ***REMOVED***

  function endWalk () {
    if (isWalkEnded) {
      return Promise.resolve()
    ***REMOVED***

    isWalkEnded = true

    return Promise.resolve()
      .then(() => {
        if (isWalkingString) {
          return fail('EOF', '"', currentPosition)
        ***REMOVED***
      ***REMOVED***)
      .then(popScopes)
      .then(() => emit(events.end))
  ***REMOVED***

  function popScopes () {
    if (scopes.length === 0) {
      return Promise.resolve()
    ***REMOVED***

    return fail('EOF', terminators[scopes.pop()], currentPosition)
      .then(popScopes)
  ***REMOVED***
***REMOVED***

function isHexit (character) {
  return isDigit(character) ||
    isInRange(character, 'A', 'F') ||
    isInRange(character, 'a', 'f')
***REMOVED***

function isDigit (character) {
  return isInRange(character, '0', '9')
***REMOVED***

function isInRange (character, lower, upper) {
  const code = character.charCodeAt(0)

  return code >= lower.charCodeAt(0) && code <= upper.charCodeAt(0)
***REMOVED***
