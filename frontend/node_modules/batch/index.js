/**
 * Module dependencies.
 */

try {
  var EventEmitter = require('events').EventEmitter;
  if (!EventEmitter) throw new Error();
***REMOVED*** catch (err) {
  var Emitter = require('emitter');
***REMOVED***

/**
 * Defer.
 */

var defer = typeof process !== 'undefined' && process && typeof process.nextTick === 'function'
  ? process.nextTick
  : function(fn){ setTimeout(fn); ***REMOVED***;

/**
 * Noop.
 */

function noop(){***REMOVED***

/**
 * Expose `Batch`.
 */

module.exports = Batch;

/**
 * Create a new Batch.
 */

function Batch() {
  if (!(this instanceof Batch)) return new Batch;
  this.fns = [];
  this.concurrency(Infinity);
  this.throws(true);
  for (var i = 0, len = arguments.length; i < len; ++i) {
    this.push(arguments[i]);
  ***REMOVED***
***REMOVED***

/**
 * Inherit from `EventEmitter.prototype`.
 */

if (EventEmitter) {
  Batch.prototype.__proto__ = EventEmitter.prototype;
***REMOVED*** else {
  Emitter(Batch.prototype);
***REMOVED***

/**
 * Set concurrency to `n`.
 *
 * @param {Number***REMOVED*** n
 * @return {Batch***REMOVED***
 * @api public
 */

Batch.prototype.concurrency = function(n){
  this.n = n;
  return this;
***REMOVED***;

/**
 * Queue a function.
 *
 * @param {Function***REMOVED*** fn
 * @return {Batch***REMOVED***
 * @api public
 */

Batch.prototype.push = function(fn){
  this.fns.push(fn);
  return this;
***REMOVED***;

/**
 * Set wether Batch will or will not throw up.
 *
 * @param  {Boolean***REMOVED*** throws
 * @return {Batch***REMOVED***
 * @api public
 */
Batch.prototype.throws = function(throws) {
  this.e = !!throws;
  return this;
***REMOVED***;

/**
 * Execute all queued functions in parallel,
 * executing `cb(err, results)`.
 *
 * @param {Function***REMOVED*** cb
 * @return {Batch***REMOVED***
 * @api public
 */

Batch.prototype.end = function(cb){
  var self = this
    , total = this.fns.length
    , pending = total
    , results = []
    , errors = []
    , cb = cb || noop
    , fns = this.fns
    , max = this.n
    , throws = this.e
    , index = 0
    , done;

  // empty
  if (!fns.length) return defer(function(){
    cb(null, results);
  ***REMOVED***);

  // process
  function next() {
    var i = index++;
    var fn = fns[i];
    if (!fn) return;
    var start = new Date;

    try {
      fn(callback);
    ***REMOVED*** catch (err) {
      callback(err);
    ***REMOVED***

    function callback(err, res){
      if (done) return;
      if (err && throws) return done = true, defer(function(){
        cb(err);
      ***REMOVED***);
      var complete = total - pending + 1;
      var end = new Date;

      results[i] = res;
      errors[i] = err;

      self.emit('progress', {
        index: i,
        value: res,
        error: err,
        pending: pending,
        total: total,
        complete: complete,
        percent: complete / total * 100 | 0,
        start: start,
        end: end,
        duration: end - start
      ***REMOVED***);

      if (--pending) next();
      else defer(function(){
        if(!throws) cb(errors, results);
        else cb(null, results);
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***

  // concurrency
  for (var i = 0; i < fns.length; i++) {
    if (i == max) break;
    next();
  ***REMOVED***

  return this;
***REMOVED***;
