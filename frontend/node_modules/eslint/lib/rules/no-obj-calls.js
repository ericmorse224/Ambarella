/**
 * @fileoverview Rule to flag use of an object property of the global object (Math and JSON) as a function
 * @author James Allardice
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const {
	CALL,
	CONSTRUCT,
	ReferenceTracker,
***REMOVED*** = require("@eslint-community/eslint-utils");
const getPropertyName = require("./utils/ast-utils").getStaticPropertyName;

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const nonCallableGlobals = ["Atomics", "JSON", "Math", "Reflect", "Intl"];

/**
 * Returns the name of the node to report
 * @param {ASTNode***REMOVED*** node A node to report
 * @returns {string***REMOVED*** name to report
 */
function getReportNodeName(node) {
	if (node.type === "ChainExpression") {
		return getReportNodeName(node.expression);
	***REMOVED***
	if (node.type === "MemberExpression") {
		return getPropertyName(node);
	***REMOVED***
	return node.name;
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "problem",

		docs: {
			description:
				"Disallow calling global object properties as functions",
			recommended: true,
			url: "https://eslint.org/docs/latest/rules/no-obj-calls",
		***REMOVED***,

		schema: [],

		messages: {
			unexpectedCall: "'{{name***REMOVED******REMOVED***' is not a function.",
			unexpectedRefCall:
				"'{{name***REMOVED******REMOVED***' is reference to '{{ref***REMOVED******REMOVED***', which is not a function.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const sourceCode = context.sourceCode;

		return {
			Program(node) {
				const scope = sourceCode.getScope(node);
				const tracker = new ReferenceTracker(scope);
				const traceMap = {***REMOVED***;

				for (const g of nonCallableGlobals) {
					traceMap[g] = {
						[CALL]: true,
						[CONSTRUCT]: true,
					***REMOVED***;
				***REMOVED***

				for (const {
					node: refNode,
					path,
				***REMOVED*** of tracker.iterateGlobalReferences(traceMap)) {
					const name = getReportNodeName(refNode.callee);
					const ref = path[0];
					const messageId =
						name === ref ? "unexpectedCall" : "unexpectedRefCall";

					context.report({
						node: refNode,
						messageId,
						data: { name, ref ***REMOVED***,
					***REMOVED***);
				***REMOVED***
			***REMOVED***,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
