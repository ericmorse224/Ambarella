"use strict";

/*
 * Based on the packages get-port https://www.npmjs.com/package/get-port
 * and portfinder https://www.npmjs.com/package/portfinder
 * The code structure is similar to get-port, but it searches
 * ports deterministically like portfinder
 */
const net = require("net");
const os = require("os");

const minPort = 1024;
const maxPort = 65_535;

/**
 * @return {Set<string|undefined>***REMOVED***
 */
const getLocalHosts = () => {
  const interfaces = os.networkInterfaces();

  // Add undefined value for createServer function to use default host,
  // and default IPv4 host in case createServer defaults to IPv6.
  // eslint-disable-next-line no-undefined
  const results = new Set([undefined, "0.0.0.0"]);

  for (const _interface of Object.values(interfaces)) {
    if (_interface) {
      for (const config of _interface) {
        results.add(config.address);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return results;
***REMOVED***;

/**
 * @param {number***REMOVED*** basePort
 * @param {string | undefined***REMOVED*** host
 * @return {Promise<number>***REMOVED***
 */
const checkAvailablePort = (basePort, host) =>
  new Promise((resolve, reject) => {
    const server = net.createServer();
    server.unref();
    server.on("error", reject);

    server.listen(basePort, host, () => {
      // Next line should return AdressInfo because we're calling it after listen() and before close()
      const { port ***REMOVED*** = /** @type {import("net").AddressInfo***REMOVED*** */ (
        server.address()
      );
      server.close(() => {
        resolve(port);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***);

/**
 * @param {number***REMOVED*** port
 * @param {Set<string|undefined>***REMOVED*** hosts
 * @return {Promise<number>***REMOVED***
 */
const getAvailablePort = async (port, hosts) => {
  /**
   * Errors that mean that host is not available.
   * @type {Set<string | undefined>***REMOVED***
   */
  const nonExistentInterfaceErrors = new Set(["EADDRNOTAVAIL", "EINVAL"]);
  /* Check if the post is available on every local host name */
  for (const host of hosts) {
    try {
      await checkAvailablePort(port, host); // eslint-disable-line no-await-in-loop
    ***REMOVED*** catch (error) {
      /* We throw an error only if the interface exists */
      if (
        !nonExistentInterfaceErrors.has(
          /** @type {NodeJS.ErrnoException***REMOVED*** */ (error).code
        )
      ) {
        throw error;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  return port;
***REMOVED***;

/**
 * @param {number***REMOVED*** basePort
 * @param {string=***REMOVED*** host
 * @return {Promise<number>***REMOVED***
 */
async function getPorts(basePort, host) {
  if (basePort < minPort || basePort > maxPort) {
    throw new Error(`Port number must lie between ${minPort***REMOVED*** and ${maxPort***REMOVED***`);
  ***REMOVED***

  let port = basePort;
  const localhosts = getLocalHosts();
  let hosts;
  if (host && !localhosts.has(host)) {
    hosts = new Set([host]);
  ***REMOVED*** else {
    /* If the host is equivalent to localhost
       we need to check every equivalent host
       else the port might falsely appear as available
       on some operating systems  */
    hosts = localhosts;
  ***REMOVED***
  /** @type {Set<string | undefined>***REMOVED*** */
  const portUnavailableErrors = new Set(["EADDRINUSE", "EACCES"]);
  while (port <= maxPort) {
    try {
      const availablePort = await getAvailablePort(port, hosts); // eslint-disable-line no-await-in-loop
      return availablePort;
    ***REMOVED*** catch (error) {
      /* Try next port if port is busy; throw for any other error */
      if (
        !portUnavailableErrors.has(
          /** @type {NodeJS.ErrnoException***REMOVED*** */ (error).code
        )
      ) {
        throw error;
      ***REMOVED***
      port += 1;
    ***REMOVED***
  ***REMOVED***

  throw new Error("No available ports found");
***REMOVED***

module.exports = getPorts;
