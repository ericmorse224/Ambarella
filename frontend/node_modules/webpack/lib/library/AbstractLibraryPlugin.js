/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const RuntimeGlobals = require("../RuntimeGlobals");
const JavascriptModulesPlugin = require("../javascript/JavascriptModulesPlugin");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../../declarations/WebpackOptions").LibraryOptions***REMOVED*** LibraryOptions */
/** @typedef {import("../../declarations/WebpackOptions").LibraryType***REMOVED*** LibraryType */
/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("../Compilation").ChunkHashContext***REMOVED*** ChunkHashContext */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../javascript/JavascriptModulesPlugin").RenderContext***REMOVED*** RenderContext */
/** @typedef {import("../javascript/JavascriptModulesPlugin").StartupRenderContext***REMOVED*** StartupRenderContext */
/** @typedef {import("../util/Hash")***REMOVED*** Hash */

const COMMON_LIBRARY_NAME_MESSAGE =
	"Common configuration options that specific library names are 'output.library[.name]', 'entry.xyz.library[.name]', 'ModuleFederationPlugin.name' and 'ModuleFederationPlugin.library[.name]'.";

/**
 * @template T
 * @typedef {object***REMOVED*** LibraryContext
 * @property {Compilation***REMOVED*** compilation
 * @property {ChunkGraph***REMOVED*** chunkGraph
 * @property {T***REMOVED*** options
 */

/**
 * @typedef {object***REMOVED*** AbstractLibraryPluginOptions
 * @property {string***REMOVED*** pluginName name of the plugin
 * @property {LibraryType***REMOVED*** type used library type
 */

/**
 * @template T
 */
class AbstractLibraryPlugin {
	/**
	 * @param {AbstractLibraryPluginOptions***REMOVED*** options options
	 */
	constructor({ pluginName, type ***REMOVED***) {
		this._pluginName = pluginName;
		this._type = type;
		this._parseCache = new WeakMap();
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		const { _pluginName ***REMOVED*** = this;
		compiler.hooks.thisCompilation.tap(_pluginName, compilation => {
			compilation.hooks.finishModules.tap(
				{ name: _pluginName, stage: 10 ***REMOVED***,
				() => {
					for (const [
						name,
						{
							dependencies: deps,
							options: { library ***REMOVED***
						***REMOVED***
					] of compilation.entries) {
						const options = this._parseOptionsCached(
							library !== undefined
								? library
								: compilation.outputOptions.library
						);
						if (options !== false) {
							const dep = deps[deps.length - 1];
							if (dep) {
								const module = compilation.moduleGraph.getModule(dep);
								if (module) {
									this.finishEntryModule(module, name, {
										options,
										compilation,
										chunkGraph: compilation.chunkGraph
									***REMOVED***);
								***REMOVED***
							***REMOVED***
						***REMOVED***
					***REMOVED***
				***REMOVED***
			);

			/**
			 * @param {Chunk***REMOVED*** chunk chunk
			 * @returns {T | false***REMOVED*** options for the chunk
			 */
			const getOptionsForChunk = chunk => {
				if (compilation.chunkGraph.getNumberOfEntryModules(chunk) === 0)
					return false;
				const options = chunk.getEntryOptions();
				const library = options && options.library;
				return this._parseOptionsCached(
					library !== undefined ? library : compilation.outputOptions.library
				);
			***REMOVED***;

			if (
				this.render !== AbstractLibraryPlugin.prototype.render ||
				this.runtimeRequirements !==
					AbstractLibraryPlugin.prototype.runtimeRequirements
			) {
				compilation.hooks.additionalChunkRuntimeRequirements.tap(
					_pluginName,
					(chunk, set, { chunkGraph ***REMOVED***) => {
						const options = getOptionsForChunk(chunk);
						if (options !== false) {
							this.runtimeRequirements(chunk, set, {
								options,
								compilation,
								chunkGraph
							***REMOVED***);
						***REMOVED***
					***REMOVED***
				);
			***REMOVED***

			const hooks = JavascriptModulesPlugin.getCompilationHooks(compilation);

			if (this.render !== AbstractLibraryPlugin.prototype.render) {
				hooks.render.tap(_pluginName, (source, renderContext) => {
					const options = getOptionsForChunk(renderContext.chunk);
					if (options === false) return source;
					return this.render(source, renderContext, {
						options,
						compilation,
						chunkGraph: compilation.chunkGraph
					***REMOVED***);
				***REMOVED***);
			***REMOVED***

			if (
				this.embedInRuntimeBailout !==
				AbstractLibraryPlugin.prototype.embedInRuntimeBailout
			) {
				hooks.embedInRuntimeBailout.tap(
					_pluginName,
					(module, renderContext) => {
						const options = getOptionsForChunk(renderContext.chunk);
						if (options === false) return;
						return this.embedInRuntimeBailout(module, renderContext, {
							options,
							compilation,
							chunkGraph: compilation.chunkGraph
						***REMOVED***);
					***REMOVED***
				);
			***REMOVED***

			if (
				this.strictRuntimeBailout !==
				AbstractLibraryPlugin.prototype.strictRuntimeBailout
			) {
				hooks.strictRuntimeBailout.tap(_pluginName, renderContext => {
					const options = getOptionsForChunk(renderContext.chunk);
					if (options === false) return;
					return this.strictRuntimeBailout(renderContext, {
						options,
						compilation,
						chunkGraph: compilation.chunkGraph
					***REMOVED***);
				***REMOVED***);
			***REMOVED***

			if (
				this.renderStartup !== AbstractLibraryPlugin.prototype.renderStartup
			) {
				hooks.renderStartup.tap(
					_pluginName,
					(source, module, renderContext) => {
						const options = getOptionsForChunk(renderContext.chunk);
						if (options === false) return source;
						return this.renderStartup(source, module, renderContext, {
							options,
							compilation,
							chunkGraph: compilation.chunkGraph
						***REMOVED***);
					***REMOVED***
				);
			***REMOVED***

			hooks.chunkHash.tap(_pluginName, (chunk, hash, context) => {
				const options = getOptionsForChunk(chunk);
				if (options === false) return;
				this.chunkHash(chunk, hash, context, {
					options,
					compilation,
					chunkGraph: compilation.chunkGraph
				***REMOVED***);
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {LibraryOptions=***REMOVED*** library normalized library option
	 * @returns {T | false***REMOVED*** preprocess as needed by overriding
	 */
	_parseOptionsCached(library) {
		if (!library) return false;
		if (library.type !== this._type) return false;
		const cacheEntry = this._parseCache.get(library);
		if (cacheEntry !== undefined) return cacheEntry;
		const result = this.parseOptions(library);
		this._parseCache.set(library, result);
		return result;
	***REMOVED***

	/* istanbul ignore next */
	/**
	 * @abstract
	 * @param {LibraryOptions***REMOVED*** library normalized library option
	 * @returns {T | false***REMOVED*** preprocess as needed by overriding
	 */
	parseOptions(library) {
		const AbstractMethodError = require("../AbstractMethodError");
		throw new AbstractMethodError();
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the exporting entry module
	 * @param {string***REMOVED*** entryName the name of the entrypoint
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {void***REMOVED***
	 */
	finishEntryModule(module, entryName, libraryContext) {***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the exporting entry module
	 * @param {RenderContext***REMOVED*** renderContext render context
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {string | undefined***REMOVED*** bailout reason
	 */
	embedInRuntimeBailout(module, renderContext, libraryContext) {
		return undefined;
	***REMOVED***

	/**
	 * @param {RenderContext***REMOVED*** renderContext render context
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {string | undefined***REMOVED*** bailout reason
	 */
	strictRuntimeBailout(renderContext, libraryContext) {
		return undefined;
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk the chunk
	 * @param {Set<string>***REMOVED*** set runtime requirements
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {void***REMOVED***
	 */
	runtimeRequirements(chunk, set, libraryContext) {
		if (this.render !== AbstractLibraryPlugin.prototype.render)
			set.add(RuntimeGlobals.returnExportsFromRuntime);
	***REMOVED***

	/**
	 * @param {Source***REMOVED*** source source
	 * @param {RenderContext***REMOVED*** renderContext render context
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {Source***REMOVED*** source with library export
	 */
	render(source, renderContext, libraryContext) {
		return source;
	***REMOVED***

	/**
	 * @param {Source***REMOVED*** source source
	 * @param {Module***REMOVED*** module module
	 * @param {StartupRenderContext***REMOVED*** renderContext render context
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {Source***REMOVED*** source with library export
	 */
	renderStartup(source, module, renderContext, libraryContext) {
		return source;
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk the chunk
	 * @param {Hash***REMOVED*** hash hash
	 * @param {ChunkHashContext***REMOVED*** chunkHashContext chunk hash context
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {void***REMOVED***
	 */
	chunkHash(chunk, hash, chunkHashContext, libraryContext) {
		const options = this._parseOptionsCached(
			libraryContext.compilation.outputOptions.library
		);
		hash.update(this._pluginName);
		hash.update(JSON.stringify(options));
	***REMOVED***
***REMOVED***

AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE = COMMON_LIBRARY_NAME_MESSAGE;
module.exports = AbstractLibraryPlugin;
