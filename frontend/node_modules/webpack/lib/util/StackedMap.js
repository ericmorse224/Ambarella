/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const TOMBSTONE = Symbol("tombstone");
const UNDEFINED_MARKER = Symbol("undefined");

/**
 * @template T
 * @typedef {T | undefined***REMOVED*** Cell<T>
 */

/**
 * @template T
 * @typedef {T | typeof TOMBSTONE | typeof UNDEFINED_MARKER***REMOVED*** InternalCell<T>
 */

/**
 * @template K
 * @template V
 * @param {[K, InternalCell<V>]***REMOVED*** pair the internal cell
 * @returns {[K, Cell<V>]***REMOVED*** its “safe” representation
 */
const extractPair = pair => {
	const key = pair[0];
	const val = pair[1];
	if (val === UNDEFINED_MARKER || val === TOMBSTONE) {
		return [key, undefined];
	***REMOVED***
	return /** @type {[K, Cell<V>]***REMOVED*** */ (pair);
***REMOVED***;

/**
 * @template K
 * @template V
 */
class StackedMap {
	/**
	 * @param {Map<K, InternalCell<V>>[]=***REMOVED*** parentStack an optional parent
	 */
	constructor(parentStack) {
		/** @type {Map<K, InternalCell<V>>***REMOVED*** */
		this.map = new Map();
		/** @type {Map<K, InternalCell<V>>[]***REMOVED*** */
		this.stack = parentStack === undefined ? [] : parentStack.slice();
		this.stack.push(this.map);
	***REMOVED***

	/**
	 * @param {K***REMOVED*** item the key of the element to add
	 * @param {V***REMOVED*** value the value of the element to add
	 * @returns {void***REMOVED***
	 */
	set(item, value) {
		this.map.set(item, value === undefined ? UNDEFINED_MARKER : value);
	***REMOVED***

	/**
	 * @param {K***REMOVED*** item the item to delete
	 * @returns {void***REMOVED***
	 */
	delete(item) {
		if (this.stack.length > 1) {
			this.map.set(item, TOMBSTONE);
		***REMOVED*** else {
			this.map.delete(item);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {K***REMOVED*** item the item to test
	 * @returns {boolean***REMOVED*** true if the item exists in this set
	 */
	has(item) {
		const topValue = this.map.get(item);
		if (topValue !== undefined) {
			return topValue !== TOMBSTONE;
		***REMOVED***
		if (this.stack.length > 1) {
			for (let i = this.stack.length - 2; i >= 0; i--) {
				const value = this.stack[i].get(item);
				if (value !== undefined) {
					this.map.set(item, value);
					return value !== TOMBSTONE;
				***REMOVED***
			***REMOVED***
			this.map.set(item, TOMBSTONE);
		***REMOVED***
		return false;
	***REMOVED***

	/**
	 * @param {K***REMOVED*** item the key of the element to return
	 * @returns {Cell<V>***REMOVED*** the value of the element
	 */
	get(item) {
		const topValue = this.map.get(item);
		if (topValue !== undefined) {
			return topValue === TOMBSTONE || topValue === UNDEFINED_MARKER
				? undefined
				: topValue;
		***REMOVED***
		if (this.stack.length > 1) {
			for (let i = this.stack.length - 2; i >= 0; i--) {
				const value = this.stack[i].get(item);
				if (value !== undefined) {
					this.map.set(item, value);
					return value === TOMBSTONE || value === UNDEFINED_MARKER
						? undefined
						: value;
				***REMOVED***
			***REMOVED***
			this.map.set(item, TOMBSTONE);
		***REMOVED***
	***REMOVED***

	_compress() {
		if (this.stack.length === 1) return;
		this.map = new Map();
		for (const data of this.stack) {
			for (const pair of data) {
				if (pair[1] === TOMBSTONE) {
					this.map.delete(pair[0]);
				***REMOVED*** else {
					this.map.set(pair[0], pair[1]);
				***REMOVED***
			***REMOVED***
		***REMOVED***
		this.stack = [this.map];
	***REMOVED***

	asArray() {
		this._compress();
		return Array.from(this.map.keys());
	***REMOVED***

	asSet() {
		this._compress();
		return new Set(this.map.keys());
	***REMOVED***

	asPairArray() {
		this._compress();
		return Array.from(this.map.entries(), extractPair);
	***REMOVED***

	asMap() {
		return new Map(this.asPairArray());
	***REMOVED***

	get size() {
		this._compress();
		return this.map.size;
	***REMOVED***

	createChild() {
		return new StackedMap(this.stack);
	***REMOVED***
***REMOVED***

module.exports = StackedMap;
