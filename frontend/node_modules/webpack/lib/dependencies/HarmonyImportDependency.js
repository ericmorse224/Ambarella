/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const ConditionalInitFragment = require("../ConditionalInitFragment");
const Dependency = require("../Dependency");
const HarmonyLinkingError = require("../HarmonyLinkingError");
const InitFragment = require("../InitFragment");
const Template = require("../Template");
const AwaitDependenciesInitFragment = require("../async-modules/AwaitDependenciesInitFragment");
const { filterRuntime, mergeRuntime ***REMOVED*** = require("../util/runtime");
const ModuleDependency = require("./ModuleDependency");

/** @typedef {import("webpack-sources").ReplaceSource***REMOVED*** ReplaceSource */
/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../Dependency").ReferencedExport***REMOVED*** ReferencedExport */
/** @typedef {import("../Dependency").UpdateHashContext***REMOVED*** UpdateHashContext */
/** @typedef {import("../DependencyTemplate").DependencyTemplateContext***REMOVED*** DependencyTemplateContext */
/** @typedef {import("../ExportsInfo")***REMOVED*** ExportsInfo */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../Module").BuildMeta***REMOVED*** BuildMeta */
/** @typedef {import("../ModuleGraph")***REMOVED*** ModuleGraph */
/** @typedef {import("../RuntimeTemplate")***REMOVED*** RuntimeTemplate */
/** @typedef {import("../WebpackError")***REMOVED*** WebpackError */
/** @typedef {import("../javascript/JavascriptParser").ImportAttributes***REMOVED*** ImportAttributes */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectDeserializerContext***REMOVED*** ObjectDeserializerContext */
/** @typedef {import("../serialization/ObjectMiddleware").ObjectSerializerContext***REMOVED*** ObjectSerializerContext */
/** @typedef {import("../util/Hash")***REMOVED*** Hash */
/** @typedef {import("../util/runtime").RuntimeSpec***REMOVED*** RuntimeSpec */

/** @typedef {0 | 1 | 2 | 3 | false***REMOVED*** ExportPresenceMode */

const ExportPresenceModes = {
	NONE: /** @type {ExportPresenceMode***REMOVED*** */ (0),
	WARN: /** @type {ExportPresenceMode***REMOVED*** */ (1),
	AUTO: /** @type {ExportPresenceMode***REMOVED*** */ (2),
	ERROR: /** @type {ExportPresenceMode***REMOVED*** */ (3),
	/**
	 * @param {string | false***REMOVED*** str param
	 * @returns {ExportPresenceMode***REMOVED*** result
	 */
	fromUserOption(str) {
		switch (str) {
			case "error":
				return ExportPresenceModes.ERROR;
			case "warn":
				return ExportPresenceModes.WARN;
			case "auto":
				return ExportPresenceModes.AUTO;
			case false:
				return ExportPresenceModes.NONE;
			default:
				throw new Error(`Invalid export presence value ${str***REMOVED***`);
		***REMOVED***
	***REMOVED***
***REMOVED***;

class HarmonyImportDependency extends ModuleDependency {
	/**
	 * @param {string***REMOVED*** request request string
	 * @param {number***REMOVED*** sourceOrder source order
	 * @param {ImportAttributes=***REMOVED*** attributes import attributes
	 */
	constructor(request, sourceOrder, attributes) {
		super(request);
		this.sourceOrder = sourceOrder;
		this.assertions = attributes;
	***REMOVED***

	get category() {
		return "esm";
	***REMOVED***

	/**
	 * Returns list of exports referenced by this dependency
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @param {RuntimeSpec***REMOVED*** runtime the runtime for which the module is analysed
	 * @returns {(string[] | ReferencedExport)[]***REMOVED*** referenced exports
	 */
	getReferencedExports(moduleGraph, runtime) {
		return Dependency.NO_EXPORTS_REFERENCED;
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @returns {string***REMOVED*** name of the variable for the import
	 */
	getImportVar(moduleGraph) {
		const module = /** @type {Module***REMOVED*** */ (moduleGraph.getParentModule(this));
		const meta = moduleGraph.getMeta(module);
		let importVarMap = meta.importVarMap;
		if (!importVarMap) meta.importVarMap = importVarMap = new Map();
		let importVar = importVarMap.get(
			/** @type {Module***REMOVED*** */ (moduleGraph.getModule(this))
		);
		if (importVar) return importVar;
		importVar = `${Template.toIdentifier(
			`${this.userRequest***REMOVED***`
		)***REMOVED***__WEBPACK_IMPORTED_MODULE_${importVarMap.size***REMOVED***__`;
		importVarMap.set(
			/** @type {Module***REMOVED*** */ (moduleGraph.getModule(this)),
			importVar
		);
		return importVar;
	***REMOVED***

	/**
	 * @param {boolean***REMOVED*** update create new variables or update existing one
	 * @param {DependencyTemplateContext***REMOVED*** templateContext the template context
	 * @returns {[string, string]***REMOVED*** the import statement and the compat statement
	 */
	getImportStatement(
		update,
		{ runtimeTemplate, module, moduleGraph, chunkGraph, runtimeRequirements ***REMOVED***
	) {
		return runtimeTemplate.importStatement({
			update,
			module: /** @type {Module***REMOVED*** */ (moduleGraph.getModule(this)),
			chunkGraph,
			importVar: this.getImportVar(moduleGraph),
			request: this.request,
			originModule: module,
			runtimeRequirements
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph module graph
	 * @param {string[]***REMOVED*** ids imported ids
	 * @param {string***REMOVED*** additionalMessage extra info included in the error message
	 * @returns {WebpackError[] | undefined***REMOVED*** errors
	 */
	getLinkingErrors(moduleGraph, ids, additionalMessage) {
		const importedModule = moduleGraph.getModule(this);
		// ignore errors for missing or failed modules
		if (!importedModule || importedModule.getNumberOfErrors() > 0) {
			return;
		***REMOVED***

		const parentModule =
			/** @type {Module***REMOVED*** */
			(moduleGraph.getParentModule(this));
		const exportsType = importedModule.getExportsType(
			moduleGraph,
			/** @type {BuildMeta***REMOVED*** */ (parentModule.buildMeta).strictHarmonyModule
		);
		if (exportsType === "namespace" || exportsType === "default-with-named") {
			if (ids.length === 0) {
				return;
			***REMOVED***

			if (
				(exportsType !== "default-with-named" || ids[0] !== "default") &&
				moduleGraph.isExportProvided(importedModule, ids) === false
			) {
				// We are sure that it's not provided

				// Try to provide detailed info in the error message
				let pos = 0;
				let exportsInfo = moduleGraph.getExportsInfo(importedModule);
				while (pos < ids.length && exportsInfo) {
					const id = ids[pos++];
					const exportInfo = exportsInfo.getReadOnlyExportInfo(id);
					if (exportInfo.provided === false) {
						// We are sure that it's not provided
						const providedExports = exportsInfo.getProvidedExports();
						const moreInfo = !Array.isArray(providedExports)
							? " (possible exports unknown)"
							: providedExports.length === 0
								? " (module has no exports)"
								: ` (possible exports: ${providedExports.join(", ")***REMOVED***)`;
						return [
							new HarmonyLinkingError(
								`export ${ids
									.slice(0, pos)
									.map(id => `'${id***REMOVED***'`)
									.join(".")***REMOVED*** ${additionalMessage***REMOVED*** was not found in '${
									this.userRequest
								***REMOVED***'${moreInfo***REMOVED***`
							)
						];
					***REMOVED***
					exportsInfo =
						/** @type {ExportsInfo***REMOVED*** */
						(exportInfo.getNestedExportsInfo());
				***REMOVED***

				// General error message
				return [
					new HarmonyLinkingError(
						`export ${ids
							.map(id => `'${id***REMOVED***'`)
							.join(".")***REMOVED*** ${additionalMessage***REMOVED*** was not found in '${
							this.userRequest
						***REMOVED***'`
					)
				];
			***REMOVED***
		***REMOVED***
		switch (exportsType) {
			case "default-only":
				// It's has only a default export
				if (ids.length > 0 && ids[0] !== "default") {
					// In strict harmony modules we only support the default export
					return [
						new HarmonyLinkingError(
							`Can't import the named export ${ids
								.map(id => `'${id***REMOVED***'`)
								.join(
									"."
								)***REMOVED*** ${additionalMessage***REMOVED*** from default-exporting module (only default export is available)`
						)
					];
				***REMOVED***
				break;
			case "default-with-named":
				// It has a default export and named properties redirect
				// In some cases we still want to warn here
				if (
					ids.length > 0 &&
					ids[0] !== "default" &&
					/** @type {BuildMeta***REMOVED*** */
					(importedModule.buildMeta).defaultObject === "redirect-warn"
				) {
					// For these modules only the default export is supported
					return [
						new HarmonyLinkingError(
							`Should not import the named export ${ids
								.map(id => `'${id***REMOVED***'`)
								.join(
									"."
								)***REMOVED*** ${additionalMessage***REMOVED*** from default-exporting module (only default export is available soon)`
						)
					];
				***REMOVED***
				break;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ObjectSerializerContext***REMOVED*** context context
	 */
	serialize(context) {
		const { write ***REMOVED*** = context;
		write(this.sourceOrder);
		write(this.assertions);
		super.serialize(context);
	***REMOVED***

	/**
	 * @param {ObjectDeserializerContext***REMOVED*** context context
	 */
	deserialize(context) {
		const { read ***REMOVED*** = context;
		this.sourceOrder = read();
		this.assertions = read();
		super.deserialize(context);
	***REMOVED***
***REMOVED***

module.exports = HarmonyImportDependency;

/** @type {WeakMap<Module, WeakMap<Module, RuntimeSpec | boolean>>***REMOVED*** */
const importEmittedMap = new WeakMap();

HarmonyImportDependency.Template = class HarmonyImportDependencyTemplate extends (
	ModuleDependency.Template
) {
	/**
	 * @param {Dependency***REMOVED*** dependency the dependency for which the template should be applied
	 * @param {ReplaceSource***REMOVED*** source the current replace source which can be modified
	 * @param {DependencyTemplateContext***REMOVED*** templateContext the context object
	 * @returns {void***REMOVED***
	 */
	apply(dependency, source, templateContext) {
		const dep = /** @type {HarmonyImportDependency***REMOVED*** */ (dependency);
		const { module, chunkGraph, moduleGraph, runtime ***REMOVED*** = templateContext;

		const connection = moduleGraph.getConnection(dep);
		if (connection && !connection.isTargetActive(runtime)) return;

		const referencedModule = connection && connection.module;

		if (
			connection &&
			connection.weak &&
			referencedModule &&
			chunkGraph.getModuleId(referencedModule) === null
		) {
			// in weak references, module might not be in any chunk
			// but that's ok, we don't need that logic in this case
			return;
		***REMOVED***

		const moduleKey = referencedModule
			? referencedModule.identifier()
			: dep.request;
		const key = `harmony import ${moduleKey***REMOVED***`;

		const runtimeCondition = dep.weak
			? false
			: connection
				? filterRuntime(runtime, r => connection.isTargetActive(r))
				: true;

		if (module && referencedModule) {
			let emittedModules = importEmittedMap.get(module);
			if (emittedModules === undefined) {
				emittedModules = new WeakMap();
				importEmittedMap.set(module, emittedModules);
			***REMOVED***
			let mergedRuntimeCondition = runtimeCondition;
			const oldRuntimeCondition = emittedModules.get(referencedModule) || false;
			if (oldRuntimeCondition !== false && mergedRuntimeCondition !== true) {
				if (mergedRuntimeCondition === false || oldRuntimeCondition === true) {
					mergedRuntimeCondition = oldRuntimeCondition;
				***REMOVED*** else {
					mergedRuntimeCondition = mergeRuntime(
						oldRuntimeCondition,
						mergedRuntimeCondition
					);
				***REMOVED***
			***REMOVED***
			emittedModules.set(referencedModule, mergedRuntimeCondition);
		***REMOVED***

		const importStatement = dep.getImportStatement(false, templateContext);
		if (
			referencedModule &&
			templateContext.moduleGraph.isAsync(referencedModule)
		) {
			templateContext.initFragments.push(
				new ConditionalInitFragment(
					importStatement[0],
					InitFragment.STAGE_HARMONY_IMPORTS,
					dep.sourceOrder,
					key,
					runtimeCondition
				)
			);
			templateContext.initFragments.push(
				new AwaitDependenciesInitFragment(
					new Set([dep.getImportVar(templateContext.moduleGraph)])
				)
			);
			templateContext.initFragments.push(
				new ConditionalInitFragment(
					importStatement[1],
					InitFragment.STAGE_ASYNC_HARMONY_IMPORTS,
					dep.sourceOrder,
					`${key***REMOVED*** compat`,
					runtimeCondition
				)
			);
		***REMOVED*** else {
			templateContext.initFragments.push(
				new ConditionalInitFragment(
					importStatement[0] + importStatement[1],
					InitFragment.STAGE_HARMONY_IMPORTS,
					dep.sourceOrder,
					key,
					runtimeCondition
				)
			);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the module
	 * @param {Module***REMOVED*** referencedModule the referenced module
	 * @returns {RuntimeSpec | boolean***REMOVED*** runtimeCondition in which this import has been emitted
	 */
	static getImportEmittedRuntime(module, referencedModule) {
		const emittedModules = importEmittedMap.get(module);
		if (emittedModules === undefined) return false;
		return emittedModules.get(referencedModule) || false;
	***REMOVED***
***REMOVED***;

module.exports.ExportPresenceModes = ExportPresenceModes;
