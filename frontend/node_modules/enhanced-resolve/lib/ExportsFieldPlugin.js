/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Ivan Kopeykin @vankop
*/

"use strict";

const DescriptionFileUtils = require("./DescriptionFileUtils");
const forEachBail = require("./forEachBail");
const { processExportsField ***REMOVED*** = require("./util/entrypoints");
const { parseIdentifier ***REMOVED*** = require("./util/identifier");
const {
	invalidSegmentRegEx,
	deprecatedInvalidSegmentRegEx
***REMOVED*** = require("./util/path");

/** @typedef {import("./Resolver")***REMOVED*** Resolver */
/** @typedef {import("./Resolver").JsonObject***REMOVED*** JsonObject */
/** @typedef {import("./Resolver").ResolveRequest***REMOVED*** ResolveRequest */
/** @typedef {import("./Resolver").ResolveStepHook***REMOVED*** ResolveStepHook */
/** @typedef {import("./util/entrypoints").ExportsField***REMOVED*** ExportsField */
/** @typedef {import("./util/entrypoints").FieldProcessor***REMOVED*** FieldProcessor */

module.exports = class ExportsFieldPlugin {
	/**
	 * @param {string | ResolveStepHook***REMOVED*** source source
	 * @param {Set<string>***REMOVED*** conditionNames condition names
	 * @param {string | string[]***REMOVED*** fieldNamePath name path
	 * @param {string | ResolveStepHook***REMOVED*** target target
	 */
	constructor(source, conditionNames, fieldNamePath, target) {
		this.source = source;
		this.target = target;
		this.conditionNames = conditionNames;
		this.fieldName = fieldNamePath;
		/** @type {WeakMap<JsonObject, FieldProcessor>***REMOVED*** */
		this.fieldProcessorCache = new WeakMap();
	***REMOVED***

	/**
	 * @param {Resolver***REMOVED*** resolver the resolver
	 * @returns {void***REMOVED***
	 */
	apply(resolver) {
		const target = resolver.ensureHook(this.target);
		resolver
			.getHook(this.source)
			.tapAsync("ExportsFieldPlugin", (request, resolveContext, callback) => {
				// When there is no description file, abort
				if (!request.descriptionFilePath) return callback();
				if (
					// When the description file is inherited from parent, abort
					// (There is no description file inside of this package)
					request.relativePath !== "." ||
					request.request === undefined
				)
					return callback();

				const remainingRequest =
					request.query || request.fragment
						? (request.request === "." ? "./" : request.request) +
						  request.query +
						  request.fragment
						: request.request;
				const exportsField =
					/** @type {ExportsField|null|undefined***REMOVED*** */
					(
						DescriptionFileUtils.getField(
							/** @type {JsonObject***REMOVED*** */ (request.descriptionFileData),
							this.fieldName
						)
					);
				if (!exportsField) return callback();

				if (request.directory) {
					return callback(
						new Error(
							`Resolving to directories is not possible with the exports field (request was ${remainingRequest***REMOVED***/)`
						)
					);
				***REMOVED***

				/** @type {string[]***REMOVED*** */
				let paths;
				/** @type {string | null***REMOVED*** */
				let usedField;

				try {
					// We attach the cache to the description file instead of the exportsField value
					// because we use a WeakMap and the exportsField could be a string too.
					// Description file is always an object when exports field can be accessed.
					let fieldProcessor = this.fieldProcessorCache.get(
						/** @type {JsonObject***REMOVED*** */ (request.descriptionFileData)
					);
					if (fieldProcessor === undefined) {
						fieldProcessor = processExportsField(exportsField);
						this.fieldProcessorCache.set(
							/** @type {JsonObject***REMOVED*** */ (request.descriptionFileData),
							fieldProcessor
						);
					***REMOVED***
					[paths, usedField] = fieldProcessor(
						remainingRequest,
						this.conditionNames
					);
				***REMOVED*** catch (/** @type {unknown***REMOVED*** */ err) {
					if (resolveContext.log) {
						resolveContext.log(
							`Exports field in ${request.descriptionFilePath***REMOVED*** can't be processed: ${err***REMOVED***`
						);
					***REMOVED***
					return callback(/** @type {Error***REMOVED*** */ (err));
				***REMOVED***

				if (paths.length === 0) {
					return callback(
						new Error(
							`Package path ${remainingRequest***REMOVED*** is not exported from package ${request.descriptionFileRoot***REMOVED*** (see exports field in ${request.descriptionFilePath***REMOVED***)`
						)
					);
				***REMOVED***

				forEachBail(
					paths,
					/**
					 * @param {string***REMOVED*** p path
					 * @param {(err?: null|Error, result?: null|ResolveRequest) => void***REMOVED*** callback callback
					 * @param {number***REMOVED*** i index
					 * @returns {void***REMOVED***
					 */
					(p, callback, i) => {
						const parsedIdentifier = parseIdentifier(p);

						if (!parsedIdentifier) return callback();

						const [relativePath, query, fragment] = parsedIdentifier;

						if (relativePath.length === 0 || !relativePath.startsWith("./")) {
							if (paths.length === i) {
								return callback(
									new Error(
										`Invalid "exports" target "${p***REMOVED***" defined for "${usedField***REMOVED***" in the package config ${request.descriptionFilePath***REMOVED***, targets must start with "./"`
									)
								);
							***REMOVED***

							return callback();
						***REMOVED***

						if (
							invalidSegmentRegEx.exec(relativePath.slice(2)) !== null &&
							deprecatedInvalidSegmentRegEx.test(relativePath.slice(2)) !== null
						) {
							if (paths.length === i) {
								return callback(
									new Error(
										`Invalid "exports" target "${p***REMOVED***" defined for "${usedField***REMOVED***" in the package config ${request.descriptionFilePath***REMOVED***, targets must start with "./"`
									)
								);
							***REMOVED***

							return callback();
						***REMOVED***

						/** @type {ResolveRequest***REMOVED*** */
						const obj = {
							...request,
							request: undefined,
							path: resolver.join(
								/** @type {string***REMOVED*** */ (request.descriptionFileRoot),
								relativePath
							),
							relativePath,
							query,
							fragment
						***REMOVED***;

						resolver.doResolve(
							target,
							obj,
							"using exports field: " + p,
							resolveContext,
							(err, result) => {
								if (err) return callback(err);
								// Don't allow to continue - https://github.com/webpack/enhanced-resolve/issues/400
								if (result === undefined) return callback(null, null);
								callback(null, result);
							***REMOVED***
						);
					***REMOVED***,
					/**
					 * @param {null|Error***REMOVED*** [err] error
					 * @param {null|ResolveRequest***REMOVED*** [result] result
					 * @returns {void***REMOVED***
					 */
					(err, result) => callback(err, result || null)
				);
			***REMOVED***);
	***REMOVED***
***REMOVED***;
