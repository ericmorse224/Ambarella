'use strict';

var callBind = require('call-bind');
var forEach = require('for-each');
var gOPD = require('gopd');
var hasProto = require('has-proto')();
var isTypedArray = require('is-typed-array');

var typedArrays = require('available-typed-arrays')();

/** @typedef {import('possible-typed-array-names')[number]***REMOVED*** TypedArrayName */
/** @typedef {(value: import('.').TypedArray) => number***REMOVED*** Getter */

/** @type {Partial<Record<TypedArrayName, Getter> & { __proto__: null ***REMOVED***>***REMOVED*** */
var getters = {
	__proto__: null
***REMOVED***;

var oDP = Object.defineProperty;
if (gOPD) {
	/** @type {Getter***REMOVED*** */
	var getByteLength = function (x) {
		return x.byteLength;
	***REMOVED***;
	forEach(typedArrays, function (typedArray) {
		// In Safari 7, Typed Array constructors are typeof object
		if (typeof global[typedArray] === 'function' || typeof global[typedArray] === 'object') {
			var TA = global[typedArray];
			/** @type {import('.').TypedArray***REMOVED*** */
			var Proto = TA.prototype;
			// @ts-expect-error TS doesn't narrow properly inside callbacks
			var descriptor = gOPD(Proto, 'byteLength');
			if (!descriptor && hasProto) {
				// @ts-expect-error hush, TS, every object has a dunder proto
				var superProto = Proto.__proto__; // eslint-disable-line no-proto
				// @ts-expect-error TS doesn't narrow properly inside callbacks
				descriptor = gOPD(superProto, 'byteLength');
			***REMOVED***
			// Opera 12.16 has a magic byteLength data property on instances AND on Proto
			if (descriptor && descriptor.get) {
				getters[typedArray] = callBind(descriptor.get);
			***REMOVED*** else if (oDP) {
				// this is likely an engine where instances have a magic byteLength data property
				var arr = new global[typedArray](2);
				// @ts-expect-error TS doesn't narrow properly inside callbacks
				descriptor = gOPD(arr, 'byteLength');
				if (descriptor && descriptor.configurable) {
					oDP(arr, 'length', { value: 3 ***REMOVED***);
				***REMOVED***
				if (arr.length === 2) {
					getters[typedArray] = getByteLength;
				***REMOVED***
			***REMOVED***
		***REMOVED***
	***REMOVED***);
***REMOVED***

/** @type {Getter***REMOVED*** */
var tryTypedArrays = function tryAllTypedArrays(value) {
	/** @type {number***REMOVED*** */ var foundByteLength;
	forEach(
		// eslint-disable-next-line no-extra-parens
		/** @type {Record<TypedArrayName, Getter>***REMOVED*** */ (getters),
		/** @type {(getter: Getter) => void***REMOVED*** */ function (getter) {
			if (typeof foundByteLength !== 'number') {
				try {
					var byteLength = getter(value);
					if (typeof byteLength === 'number') {
						foundByteLength = byteLength;
					***REMOVED***
				***REMOVED*** catch (e) {***REMOVED***
			***REMOVED***
		***REMOVED***
	);
	// @ts-expect-error TS can't guarantee the callback is invoked sync
	return foundByteLength;
***REMOVED***;

/** @type {import('.')***REMOVED*** */
module.exports = function typedArrayByteLength(value) {
	if (!isTypedArray(value)) {
		return false;
	***REMOVED***
	return tryTypedArrays(value);
***REMOVED***;
