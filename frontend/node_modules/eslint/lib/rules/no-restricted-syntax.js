/**
 * @fileoverview Rule to flag use of certain node types
 * @author Burak Yigit Kaya
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "suggestion",

		docs: {
			description: "Disallow specified syntax",
			recommended: false,
			url: "https://eslint.org/docs/latest/rules/no-restricted-syntax",
		***REMOVED***,

		schema: {
			type: "array",
			items: {
				oneOf: [
					{
						type: "string",
					***REMOVED***,
					{
						type: "object",
						properties: {
							selector: { type: "string" ***REMOVED***,
							message: { type: "string" ***REMOVED***,
						***REMOVED***,
						required: ["selector"],
						additionalProperties: false,
					***REMOVED***,
				],
			***REMOVED***,
			uniqueItems: true,
			minItems: 0,
		***REMOVED***,

		messages: {
			// eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
			restrictedSyntax: "{{message***REMOVED******REMOVED***",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		return context.options.reduce((result, selectorOrObject) => {
			const isStringFormat = typeof selectorOrObject === "string";
			const hasCustomMessage =
				!isStringFormat && Boolean(selectorOrObject.message);

			const selector = isStringFormat
				? selectorOrObject
				: selectorOrObject.selector;
			const message = hasCustomMessage
				? selectorOrObject.message
				: `Using '${selector***REMOVED***' is not allowed.`;

			return Object.assign(result, {
				[selector](node) {
					context.report({
						node,
						messageId: "restrictedSyntax",
						data: { message ***REMOVED***,
					***REMOVED***);
				***REMOVED***,
			***REMOVED***);
		***REMOVED***, {***REMOVED***);
	***REMOVED***,
***REMOVED***;
