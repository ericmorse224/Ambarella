/**
 * @fileoverview Enforce boolean attributes notation in JSX
 * @author Yannick Croissant
 */

'use strict';

const docsUrl = require('../util/docsUrl');
const report = require('../util/report');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

const exceptionsSchema = {
  type: 'array',
  items: { type: 'string', minLength: 1 ***REMOVED***,
  uniqueItems: true,
***REMOVED***;

const ALWAYS = 'always';
const NEVER = 'never';

/**
 * @param {string***REMOVED*** configuration
 * @param {Set<string>***REMOVED*** exceptions
 * @param {string***REMOVED*** propName
 * @returns {boolean***REMOVED*** propName
 */
function isAlways(configuration, exceptions, propName) {
  const isException = exceptions.has(propName);
  if (configuration === ALWAYS) {
    return !isException;
  ***REMOVED***
  return isException;
***REMOVED***
/**
 * @param {string***REMOVED*** configuration
 * @param {Set<string>***REMOVED*** exceptions
 * @param {string***REMOVED*** propName
 * @returns {boolean***REMOVED*** propName
 */
function isNever(configuration, exceptions, propName) {
  const isException = exceptions.has(propName);
  if (configuration === NEVER) {
    return !isException;
  ***REMOVED***
  return isException;
***REMOVED***

const messages = {
  omitBoolean: 'Value must be omitted for boolean attribute `{{propName***REMOVED******REMOVED***`',
  setBoolean: 'Value must be set for boolean attribute `{{propName***REMOVED******REMOVED***`',
  omitPropAndBoolean: 'Value must be omitted for `false` attribute: `{{propName***REMOVED******REMOVED***`',
***REMOVED***;

/** @type {import('eslint').Rule.RuleModule***REMOVED*** */
module.exports = {
  meta: {
    docs: {
      description: 'Enforce boolean attributes notation in JSX',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-boolean-value'),
    ***REMOVED***,
    fixable: 'code',

    messages,

    schema: {
      anyOf: [{
        type: 'array',
        items: [{ enum: [ALWAYS, NEVER] ***REMOVED***],
        additionalItems: false,
      ***REMOVED***, {
        type: 'array',
        items: [{
          enum: [ALWAYS],
        ***REMOVED***, {
          type: 'object',
          additionalProperties: false,
          properties: {
            [NEVER]: exceptionsSchema,
            assumeUndefinedIsFalse: {
              type: 'boolean',
            ***REMOVED***,
          ***REMOVED***,
        ***REMOVED***],
        additionalItems: false,
      ***REMOVED***, {
        type: 'array',
        items: [{
          enum: [NEVER],
        ***REMOVED***, {
          type: 'object',
          additionalProperties: false,
          properties: {
            [ALWAYS]: exceptionsSchema,
            assumeUndefinedIsFalse: {
              type: 'boolean',
            ***REMOVED***,
          ***REMOVED***,
        ***REMOVED***],
        additionalItems: false,
      ***REMOVED***],
    ***REMOVED***,
  ***REMOVED***,

  create(context) {
    const configuration = context.options[0] || NEVER;
    const configObject = context.options[1] || {***REMOVED***;
    const exceptions = new Set((configuration === ALWAYS ? configObject[NEVER] : configObject[ALWAYS]) || []);

    return {
      JSXAttribute(node) {
        const propName = node.name && node.name.name;
        const value = node.value;

        if (
          isAlways(configuration, exceptions, propName)
          && value === null
        ) {
          const messageId = 'setBoolean';
          const data = { propName ***REMOVED***;
          report(context, messages[messageId], messageId, {
            node,
            data,
            fix(fixer) {
              return fixer.insertTextAfter(node, '={true***REMOVED***');
            ***REMOVED***,
          ***REMOVED***);
        ***REMOVED***
        if (
          isNever(configuration, exceptions, propName)
          && value
          && value.type === 'JSXExpressionContainer'
          && value.expression.value === true
        ) {
          const messageId = 'omitBoolean';
          const data = { propName ***REMOVED***;
          report(context, messages[messageId], messageId, {
            node,
            data,
            fix(fixer) {
              return fixer.removeRange([node.name.range[1], value.range[1]]);
            ***REMOVED***,
          ***REMOVED***);
        ***REMOVED***
        if (
          isNever(configuration, exceptions, propName)
          && configObject.assumeUndefinedIsFalse
          && value
          && value.type === 'JSXExpressionContainer'
          && value.expression.value === false
        ) {
          const messageId = 'omitPropAndBoolean';
          const data = { propName ***REMOVED***;
          report(context, messages[messageId], messageId, {
            node,
            data,
            fix(fixer) {
              return fixer.removeRange([node.name.range[0], value.range[1]]);
            ***REMOVED***,
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***,
    ***REMOVED***;
  ***REMOVED***,
***REMOVED***;
