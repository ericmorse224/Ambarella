/**
 * @fileoverview Rule Validator
 * @author Nicholas C. Zakas
 */

"use strict";

//-----------------------------------------------------------------------------
// Requirements
//-----------------------------------------------------------------------------

const ajvImport = require("../shared/ajv");
const ajv = ajvImport();
const {
	parseRuleId,
	getRuleFromConfig,
	getRuleOptionsSchema,
***REMOVED*** = require("./flat-config-helpers");
const ruleReplacements = require("../../conf/replacements.json");

//-----------------------------------------------------------------------------
// Helpers
//-----------------------------------------------------------------------------

/**
 * Throws a helpful error when a rule cannot be found.
 * @param {Object***REMOVED*** ruleId The rule identifier.
 * @param {string***REMOVED*** ruleId.pluginName The ID of the rule to find.
 * @param {string***REMOVED*** ruleId.ruleName The ID of the rule to find.
 * @param {Object***REMOVED*** config The config to search in.
 * @throws {TypeError***REMOVED*** For missing plugin or rule.
 * @returns {void***REMOVED***
 */
function throwRuleNotFoundError({ pluginName, ruleName ***REMOVED***, config) {
	const ruleId = pluginName === "@" ? ruleName : `${pluginName***REMOVED***/${ruleName***REMOVED***`;

	const errorMessageHeader = `Key "rules": Key "${ruleId***REMOVED***"`;

	let errorMessage = `${errorMessageHeader***REMOVED***: Could not find plugin "${pluginName***REMOVED***" in configuration.`;

	const missingPluginErrorMessage = errorMessage;

	// if the plugin exists then we need to check if the rule exists
	if (config.plugins && config.plugins[pluginName]) {
		const replacementRuleName = ruleReplacements.rules[ruleName];

		if (pluginName === "@" && replacementRuleName) {
			errorMessage = `${errorMessageHeader***REMOVED***: Rule "${ruleName***REMOVED***" was removed and replaced by "${replacementRuleName***REMOVED***".`;
		***REMOVED*** else {
			errorMessage = `${errorMessageHeader***REMOVED***: Could not find "${ruleName***REMOVED***" in plugin "${pluginName***REMOVED***".`;

			// otherwise, let's see if we can find the rule name elsewhere
			for (const [otherPluginName, otherPlugin] of Object.entries(
				config.plugins,
			)) {
				if (otherPlugin.rules && otherPlugin.rules[ruleName]) {
					errorMessage += ` Did you mean "${otherPluginName***REMOVED***/${ruleName***REMOVED***"?`;
					break;
				***REMOVED***
			***REMOVED***
		***REMOVED***

		// falls through to throw error
	***REMOVED***

	const error = new TypeError(errorMessage);

	if (errorMessage === missingPluginErrorMessage) {
		error.messageTemplate = "config-plugin-missing";
		error.messageData = { pluginName, ruleId ***REMOVED***;
	***REMOVED***

	throw error;
***REMOVED***

/**
 * The error type when a rule has an invalid `meta.schema`.
 */
class InvalidRuleOptionsSchemaError extends Error {
	/**
	 * Creates a new instance.
	 * @param {string***REMOVED*** ruleId Id of the rule that has an invalid `meta.schema`.
	 * @param {Error***REMOVED*** processingError Error caught while processing the `meta.schema`.
	 */
	constructor(ruleId, processingError) {
		super(
			`Error while processing options validation schema of rule '${ruleId***REMOVED***': ${processingError.message***REMOVED***`,
			{ cause: processingError ***REMOVED***,
		);
		this.code = "ESLINT_INVALID_RULE_OPTIONS_SCHEMA";
	***REMOVED***
***REMOVED***

//-----------------------------------------------------------------------------
// Exports
//-----------------------------------------------------------------------------

/**
 * Implements validation functionality for the rules portion of a config.
 */
class RuleValidator {
	/**
	 * Creates a new instance.
	 */
	constructor() {
		/**
		 * A collection of compiled validators for rules that have already
		 * been validated.
		 * @type {WeakMap***REMOVED***
		 */
		this.validators = new WeakMap();
	***REMOVED***

	/**
	 * Validates all of the rule configurations in a config against each
	 * rule's schema.
	 * @param {Object***REMOVED*** config The full config to validate. This object must
	 *      contain both the rules section and the plugins section.
	 * @returns {void***REMOVED***
	 * @throws {Error***REMOVED*** If a rule's configuration does not match its schema.
	 */
	validate(config) {
		if (!config.rules) {
			return;
		***REMOVED***

		for (const [ruleId, ruleOptions] of Object.entries(config.rules)) {
			// check for edge case
			if (ruleId === "__proto__") {
				continue;
			***REMOVED***

			/*
			 * If a rule is disabled, we don't do any validation. This allows
			 * users to safely set any value to 0 or "off" without worrying
			 * that it will cause a validation error.
			 *
			 * Note: ruleOptions is always an array at this point because
			 * this validation occurs after FlatConfigArray has merged and
			 * normalized values.
			 */
			if (ruleOptions[0] === 0) {
				continue;
			***REMOVED***

			const rule = getRuleFromConfig(ruleId, config);

			if (!rule) {
				throwRuleNotFoundError(parseRuleId(ruleId), config);
			***REMOVED***

			// Precompile and cache validator the first time
			if (!this.validators.has(rule)) {
				try {
					const schema = getRuleOptionsSchema(rule);

					if (schema) {
						this.validators.set(rule, ajv.compile(schema));
					***REMOVED***
				***REMOVED*** catch (err) {
					throw new InvalidRuleOptionsSchemaError(ruleId, err);
				***REMOVED***
			***REMOVED***

			const validateRule = this.validators.get(rule);

			if (validateRule) {
				validateRule(ruleOptions.slice(1));

				if (validateRule.errors) {
					throw new Error(
						`Key "rules": Key "${ruleId***REMOVED***":\n${validateRule.errors
							.map(error => {
								if (
									error.keyword === "additionalProperties" &&
									error.schema === false &&
									typeof error.parentSchema?.properties ===
										"object" &&
									typeof error.params?.additionalProperty ===
										"string"
								) {
									const expectedProperties = Object.keys(
										error.parentSchema.properties,
									).map(property => `"${property***REMOVED***"`);

									return `\tValue ${JSON.stringify(error.data)***REMOVED*** ${error.message***REMOVED***.\n\t\tUnexpected property "${error.params.additionalProperty***REMOVED***". Expected properties: ${expectedProperties.join(", ")***REMOVED***.\n`;
								***REMOVED***

								return `\tValue ${JSON.stringify(error.data)***REMOVED*** ${error.message***REMOVED***.\n`;
							***REMOVED***)
							.join("")***REMOVED***`,
					);
				***REMOVED***
			***REMOVED***
		***REMOVED***
	***REMOVED***
***REMOVED***

exports.RuleValidator = RuleValidator;
