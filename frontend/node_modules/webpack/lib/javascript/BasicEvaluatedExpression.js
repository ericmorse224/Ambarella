/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

/** @typedef {import("estree").Node***REMOVED*** Node */
/** @typedef {import("./JavascriptParser").Range***REMOVED*** Range */
/** @typedef {import("./JavascriptParser").VariableInfo***REMOVED*** VariableInfo */

const TypeUnknown = 0;
const TypeUndefined = 1;
const TypeNull = 2;
const TypeString = 3;
const TypeNumber = 4;
const TypeBoolean = 5;
const TypeRegExp = 6;
const TypeConditional = 7;
const TypeArray = 8;
const TypeConstArray = 9;
const TypeIdentifier = 10;
const TypeWrapped = 11;
const TypeTemplateString = 12;
const TypeBigInt = 13;

class BasicEvaluatedExpression {
	constructor() {
		this.type = TypeUnknown;
		/** @type {Range | undefined***REMOVED*** */
		this.range = undefined;
		/** @type {boolean***REMOVED*** */
		this.falsy = false;
		/** @type {boolean***REMOVED*** */
		this.truthy = false;
		/** @type {boolean | undefined***REMOVED*** */
		this.nullish = undefined;
		/** @type {boolean***REMOVED*** */
		this.sideEffects = true;
		/** @type {boolean | undefined***REMOVED*** */
		this.bool = undefined;
		/** @type {number | undefined***REMOVED*** */
		this.number = undefined;
		/** @type {bigint | undefined***REMOVED*** */
		this.bigint = undefined;
		/** @type {RegExp | undefined***REMOVED*** */
		this.regExp = undefined;
		/** @type {string | undefined***REMOVED*** */
		this.string = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined***REMOVED*** */
		this.quasis = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined***REMOVED*** */
		this.parts = undefined;
		/** @type {EXPECTED_ANY[] | undefined***REMOVED*** */
		this.array = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined***REMOVED*** */
		this.items = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined***REMOVED*** */
		this.options = undefined;
		/** @type {BasicEvaluatedExpression | undefined | null***REMOVED*** */
		this.prefix = undefined;
		/** @type {BasicEvaluatedExpression | undefined | null***REMOVED*** */
		this.postfix = undefined;
		/** @type {BasicEvaluatedExpression[] | undefined***REMOVED*** */
		this.wrappedInnerExpressions = undefined;
		/** @type {string | VariableInfo | undefined***REMOVED*** */
		this.identifier = undefined;
		/** @type {string | VariableInfo | undefined***REMOVED*** */
		this.rootInfo = undefined;
		/** @type {(() => string[]) | undefined***REMOVED*** */
		this.getMembers = undefined;
		/** @type {(() => boolean[]) | undefined***REMOVED*** */
		this.getMembersOptionals = undefined;
		/** @type {(() => Range[]) | undefined***REMOVED*** */
		this.getMemberRanges = undefined;
		/** @type {Node | undefined***REMOVED*** */
		this.expression = undefined;
	***REMOVED***

	isUnknown() {
		return this.type === TypeUnknown;
	***REMOVED***

	isNull() {
		return this.type === TypeNull;
	***REMOVED***

	isUndefined() {
		return this.type === TypeUndefined;
	***REMOVED***

	isString() {
		return this.type === TypeString;
	***REMOVED***

	isNumber() {
		return this.type === TypeNumber;
	***REMOVED***

	isBigInt() {
		return this.type === TypeBigInt;
	***REMOVED***

	isBoolean() {
		return this.type === TypeBoolean;
	***REMOVED***

	isRegExp() {
		return this.type === TypeRegExp;
	***REMOVED***

	isConditional() {
		return this.type === TypeConditional;
	***REMOVED***

	isArray() {
		return this.type === TypeArray;
	***REMOVED***

	isConstArray() {
		return this.type === TypeConstArray;
	***REMOVED***

	isIdentifier() {
		return this.type === TypeIdentifier;
	***REMOVED***

	isWrapped() {
		return this.type === TypeWrapped;
	***REMOVED***

	isTemplateString() {
		return this.type === TypeTemplateString;
	***REMOVED***

	/**
	 * Is expression a primitive or an object type value?
	 * @returns {boolean | undefined***REMOVED*** true: primitive type, false: object type, undefined: unknown/runtime-defined
	 */
	isPrimitiveType() {
		switch (this.type) {
			case TypeUndefined:
			case TypeNull:
			case TypeString:
			case TypeNumber:
			case TypeBoolean:
			case TypeBigInt:
			case TypeWrapped:
			case TypeTemplateString:
				return true;
			case TypeRegExp:
			case TypeArray:
			case TypeConstArray:
				return false;
			default:
				return undefined;
		***REMOVED***
	***REMOVED***

	/**
	 * Is expression a runtime or compile-time value?
	 * @returns {boolean***REMOVED*** true: compile time value, false: runtime value
	 */
	isCompileTimeValue() {
		switch (this.type) {
			case TypeUndefined:
			case TypeNull:
			case TypeString:
			case TypeNumber:
			case TypeBoolean:
			case TypeRegExp:
			case TypeConstArray:
			case TypeBigInt:
				return true;
			default:
				return false;
		***REMOVED***
	***REMOVED***

	/**
	 * Gets the compile-time value of the expression
	 * @returns {undefined | null | string | number | boolean | RegExp | EXPECTED_ANY[] | bigint***REMOVED*** the javascript value
	 */
	asCompileTimeValue() {
		switch (this.type) {
			case TypeUndefined:
				return;
			case TypeNull:
				return null;
			case TypeString:
				return this.string;
			case TypeNumber:
				return this.number;
			case TypeBoolean:
				return this.bool;
			case TypeRegExp:
				return this.regExp;
			case TypeConstArray:
				return this.array;
			case TypeBigInt:
				return this.bigint;
			default:
				throw new Error(
					"asCompileTimeValue must only be called for compile-time values"
				);
		***REMOVED***
	***REMOVED***

	isTruthy() {
		return this.truthy;
	***REMOVED***

	isFalsy() {
		return this.falsy;
	***REMOVED***

	isNullish() {
		return this.nullish;
	***REMOVED***

	/**
	 * Can this expression have side effects?
	 * @returns {boolean***REMOVED*** false: never has side effects
	 */
	couldHaveSideEffects() {
		return this.sideEffects;
	***REMOVED***

	/**
	 * Creates a boolean representation of this evaluated expression.
	 * @returns {boolean | undefined***REMOVED*** true: truthy, false: falsy, undefined: unknown
	 */
	asBool() {
		if (this.truthy) return true;
		if (this.falsy || this.nullish) return false;
		if (this.isBoolean()) return this.bool;
		if (this.isNull()) return false;
		if (this.isUndefined()) return false;
		if (this.isString()) return this.string !== "";
		if (this.isNumber()) return this.number !== 0;
		if (this.isBigInt()) return this.bigint !== BigInt(0);
		if (this.isRegExp()) return true;
		if (this.isArray()) return true;
		if (this.isConstArray()) return true;
		if (this.isWrapped()) {
			return (this.prefix && this.prefix.asBool()) ||
				(this.postfix && this.postfix.asBool())
				? true
				: undefined;
		***REMOVED***
		if (this.isTemplateString()) {
			const str = this.asString();
			if (typeof str === "string") return str !== "";
		***REMOVED***
	***REMOVED***

	/**
	 * Creates a nullish coalescing representation of this evaluated expression.
	 * @returns {boolean | undefined***REMOVED*** true: nullish, false: not nullish, undefined: unknown
	 */
	asNullish() {
		const nullish = this.isNullish();

		if (nullish === true || this.isNull() || this.isUndefined()) return true;

		if (nullish === false) return false;
		if (this.isTruthy()) return false;
		if (this.isBoolean()) return false;
		if (this.isString()) return false;
		if (this.isNumber()) return false;
		if (this.isBigInt()) return false;
		if (this.isRegExp()) return false;
		if (this.isArray()) return false;
		if (this.isConstArray()) return false;
		if (this.isTemplateString()) return false;
		if (this.isRegExp()) return false;
	***REMOVED***

	/**
	 * Creates a string representation of this evaluated expression.
	 * @returns {string | undefined***REMOVED*** the string representation or undefined if not possible
	 */
	asString() {
		if (this.isBoolean()) return `${this.bool***REMOVED***`;
		if (this.isNull()) return "null";
		if (this.isUndefined()) return "undefined";
		if (this.isString()) return this.string;
		if (this.isNumber()) return `${this.number***REMOVED***`;
		if (this.isBigInt()) return `${this.bigint***REMOVED***`;
		if (this.isRegExp()) return `${this.regExp***REMOVED***`;
		if (this.isArray()) {
			const array = [];
			for (const item of /** @type {BasicEvaluatedExpression[]***REMOVED*** */ (
				this.items
			)) {
				const itemStr = item.asString();
				if (itemStr === undefined) return;
				array.push(itemStr);
			***REMOVED***
			return `${array***REMOVED***`;
		***REMOVED***
		if (this.isConstArray()) return `${this.array***REMOVED***`;
		if (this.isTemplateString()) {
			let str = "";
			for (const part of /** @type {BasicEvaluatedExpression[]***REMOVED*** */ (
				this.parts
			)) {
				const partStr = part.asString();
				if (partStr === undefined) return;
				str += partStr;
			***REMOVED***
			return str;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {string***REMOVED*** string value
	 * @returns {BasicEvaluatedExpression***REMOVED*** basic evaluated expression
	 */
	setString(string) {
		this.type = TypeString;
		this.string = string;
		this.sideEffects = false;
		return this;
	***REMOVED***

	setUndefined() {
		this.type = TypeUndefined;
		this.sideEffects = false;
		return this;
	***REMOVED***

	setNull() {
		this.type = TypeNull;
		this.sideEffects = false;
		return this;
	***REMOVED***

	/**
	 * Set's the value of this expression to a number
	 * @param {number***REMOVED*** number number to set
	 * @returns {this***REMOVED*** this
	 */
	setNumber(number) {
		this.type = TypeNumber;
		this.number = number;
		this.sideEffects = false;
		return this;
	***REMOVED***

	/**
	 * Set's the value of this expression to a BigInt
	 * @param {bigint***REMOVED*** bigint bigint to set
	 * @returns {this***REMOVED*** this
	 */
	setBigInt(bigint) {
		this.type = TypeBigInt;
		this.bigint = bigint;
		this.sideEffects = false;
		return this;
	***REMOVED***

	/**
	 * Set's the value of this expression to a boolean
	 * @param {boolean***REMOVED*** bool boolean to set
	 * @returns {this***REMOVED*** this
	 */
	setBoolean(bool) {
		this.type = TypeBoolean;
		this.bool = bool;
		this.sideEffects = false;
		return this;
	***REMOVED***

	/**
	 * Set's the value of this expression to a regular expression
	 * @param {RegExp***REMOVED*** regExp regular expression to set
	 * @returns {this***REMOVED*** this
	 */
	setRegExp(regExp) {
		this.type = TypeRegExp;
		this.regExp = regExp;
		this.sideEffects = false;
		return this;
	***REMOVED***

	/**
	 * Set's the value of this expression to a particular identifier and its members.
	 * @param {string | VariableInfo***REMOVED*** identifier identifier to set
	 * @param {string | VariableInfo***REMOVED*** rootInfo root info
	 * @param {() => string[]***REMOVED*** getMembers members
	 * @param {() => boolean[]=***REMOVED*** getMembersOptionals optional members
	 * @param {() => Range[]=***REMOVED*** getMemberRanges ranges of progressively increasing sub-expressions
	 * @returns {this***REMOVED*** this
	 */
	setIdentifier(
		identifier,
		rootInfo,
		getMembers,
		getMembersOptionals,
		getMemberRanges
	) {
		this.type = TypeIdentifier;
		this.identifier = identifier;
		this.rootInfo = rootInfo;
		this.getMembers = getMembers;
		this.getMembersOptionals = getMembersOptionals;
		this.getMemberRanges = getMemberRanges;
		this.sideEffects = true;
		return this;
	***REMOVED***

	/**
	 * Wraps an array of expressions with a prefix and postfix expression.
	 * @param {BasicEvaluatedExpression | null | undefined***REMOVED*** prefix Expression to be added before the innerExpressions
	 * @param {BasicEvaluatedExpression | null | undefined***REMOVED*** postfix Expression to be added after the innerExpressions
	 * @param {BasicEvaluatedExpression[] | undefined***REMOVED*** innerExpressions Expressions to be wrapped
	 * @returns {this***REMOVED*** this
	 */
	setWrapped(prefix, postfix, innerExpressions) {
		this.type = TypeWrapped;
		this.prefix = prefix;
		this.postfix = postfix;
		this.wrappedInnerExpressions = innerExpressions;
		this.sideEffects = true;
		return this;
	***REMOVED***

	/**
	 * Stores the options of a conditional expression.
	 * @param {BasicEvaluatedExpression[]***REMOVED*** options optional (consequent/alternate) expressions to be set
	 * @returns {this***REMOVED*** this
	 */
	setOptions(options) {
		this.type = TypeConditional;
		this.options = options;
		this.sideEffects = true;
		return this;
	***REMOVED***

	/**
	 * Adds options to a conditional expression.
	 * @param {BasicEvaluatedExpression[]***REMOVED*** options optional (consequent/alternate) expressions to be added
	 * @returns {this***REMOVED*** this
	 */
	addOptions(options) {
		if (!this.options) {
			this.type = TypeConditional;
			this.options = [];
			this.sideEffects = true;
		***REMOVED***
		for (const item of options) {
			this.options.push(item);
		***REMOVED***
		return this;
	***REMOVED***

	/**
	 * Set's the value of this expression to an array of expressions.
	 * @param {BasicEvaluatedExpression[]***REMOVED*** items expressions to set
	 * @returns {this***REMOVED*** this
	 */
	setItems(items) {
		this.type = TypeArray;
		this.items = items;
		this.sideEffects = items.some(i => i.couldHaveSideEffects());
		return this;
	***REMOVED***

	/**
	 * Set's the value of this expression to an array of strings.
	 * @param {string[]***REMOVED*** array array to set
	 * @returns {this***REMOVED*** this
	 */
	setArray(array) {
		this.type = TypeConstArray;
		this.array = array;
		this.sideEffects = false;
		return this;
	***REMOVED***

	/**
	 * Set's the value of this expression to a processed/unprocessed template string. Used
	 * for evaluating TemplateLiteral expressions in the JavaScript Parser.
	 * @param {BasicEvaluatedExpression[]***REMOVED*** quasis template string quasis
	 * @param {BasicEvaluatedExpression[]***REMOVED*** parts template string parts
	 * @param {"cooked" | "raw"***REMOVED*** kind template string kind
	 * @returns {this***REMOVED*** this
	 */
	setTemplateString(quasis, parts, kind) {
		this.type = TypeTemplateString;
		this.quasis = quasis;
		this.parts = parts;
		this.templateStringKind = kind;
		this.sideEffects = parts.some(p => p.sideEffects);
		return this;
	***REMOVED***

	setTruthy() {
		this.falsy = false;
		this.truthy = true;
		this.nullish = false;
		return this;
	***REMOVED***

	setFalsy() {
		this.falsy = true;
		this.truthy = false;
		return this;
	***REMOVED***

	/**
	 * Set's the value of the expression to nullish.
	 * @param {boolean***REMOVED*** value true, if the expression is nullish
	 * @returns {this***REMOVED*** this
	 */
	setNullish(value) {
		this.nullish = value;

		if (value) return this.setFalsy();

		return this;
	***REMOVED***

	/**
	 * Set's the range for the expression.
	 * @param {Range***REMOVED*** range range to set
	 * @returns {this***REMOVED*** this
	 */
	setRange(range) {
		this.range = range;
		return this;
	***REMOVED***

	/**
	 * Set whether or not the expression has side effects.
	 * @param {boolean***REMOVED*** sideEffects true, if the expression has side effects
	 * @returns {this***REMOVED*** this
	 */
	setSideEffects(sideEffects = true) {
		this.sideEffects = sideEffects;
		return this;
	***REMOVED***

	/**
	 * Set the expression node for the expression.
	 * @param {Node | undefined***REMOVED*** expression expression
	 * @returns {this***REMOVED*** this
	 */
	setExpression(expression) {
		this.expression = expression;
		return this;
	***REMOVED***
***REMOVED***

/**
 * @param {string***REMOVED*** flags regexp flags
 * @returns {boolean***REMOVED*** is valid flags
 */
BasicEvaluatedExpression.isValidRegExpFlags = flags => {
	const len = flags.length;

	if (len === 0) return true;
	if (len > 4) return false;

	// cspell:word gimy
	let remaining = 0b0000; // bit per RegExp flag: gimy

	for (let i = 0; i < len; i++)
		switch (flags.charCodeAt(i)) {
			case 103 /* g */:
				if (remaining & 0b1000) return false;
				remaining |= 0b1000;
				break;
			case 105 /* i */:
				if (remaining & 0b0100) return false;
				remaining |= 0b0100;
				break;
			case 109 /* m */:
				if (remaining & 0b0010) return false;
				remaining |= 0b0010;
				break;
			case 121 /* y */:
				if (remaining & 0b0001) return false;
				remaining |= 0b0001;
				break;
			default:
				return false;
		***REMOVED***

	return true;
***REMOVED***;

module.exports = BasicEvaluatedExpression;
