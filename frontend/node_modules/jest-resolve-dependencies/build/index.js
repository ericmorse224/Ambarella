'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
***REMOVED***);
exports.DependencyResolver = void 0;

function path() {
  const data = _interopRequireWildcard(require('path'));

  path = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

function _jestSnapshot() {
  const data = require('jest-snapshot');

  _jestSnapshot = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== 'function') return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  ***REMOVED***)(nodeInterop);
***REMOVED***

function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  ***REMOVED***
  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
    return {default: obj***REMOVED***;
  ***REMOVED***
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  ***REMOVED***
  var newObj = {***REMOVED***;
  var hasPropertyDescriptor =
    Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor
        ? Object.getOwnPropertyDescriptor(obj, key)
        : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      ***REMOVED*** else {
        newObj[key] = obj[key];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  ***REMOVED***
  return newObj;
***REMOVED***

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    ***REMOVED***);
  ***REMOVED*** else {
    obj[key] = value;
  ***REMOVED***
  return obj;
***REMOVED***

/**
 * DependencyResolver is used to resolve the direct dependencies of a module or
 * to retrieve a list of all transitive inverse dependencies.
 */
class DependencyResolver {
  constructor(resolver, hasteFS, snapshotResolver) {
    _defineProperty(this, '_hasteFS', void 0);

    _defineProperty(this, '_resolver', void 0);

    _defineProperty(this, '_snapshotResolver', void 0);

    this._resolver = resolver;
    this._hasteFS = hasteFS;
    this._snapshotResolver = snapshotResolver;
  ***REMOVED***

  resolve(file, options) {
    const dependencies = this._hasteFS.getDependencies(file);

    if (!dependencies) {
      return [];
    ***REMOVED***

    return dependencies.reduce((acc, dependency) => {
      if (this._resolver.isCoreModule(dependency)) {
        return acc;
      ***REMOVED***

      let resolvedDependency;
      let resolvedMockDependency;

      try {
        resolvedDependency = this._resolver.resolveModule(
          file,
          dependency,
          options
        );
      ***REMOVED*** catch {
        try {
          resolvedDependency = this._resolver.getMockModule(file, dependency);
        ***REMOVED*** catch {
          // leave resolvedDependency as undefined if nothing can be found
        ***REMOVED***
      ***REMOVED***

      if (!resolvedDependency) {
        return acc;
      ***REMOVED***

      acc.push(resolvedDependency); // If we resolve a dependency, then look for a mock dependency
      // of the same name in that dependency's directory.

      try {
        resolvedMockDependency = this._resolver.getMockModule(
          resolvedDependency,
          path().basename(dependency)
        );
      ***REMOVED*** catch {
        // leave resolvedMockDependency as undefined if nothing can be found
      ***REMOVED***

      if (resolvedMockDependency) {
        const dependencyMockDir = path().resolve(
          path().dirname(resolvedDependency),
          '__mocks__'
        );
        resolvedMockDependency = path().resolve(resolvedMockDependency); // make sure mock is in the correct directory

        if (dependencyMockDir === path().dirname(resolvedMockDependency)) {
          acc.push(resolvedMockDependency);
        ***REMOVED***
      ***REMOVED***

      return acc;
    ***REMOVED***, []);
  ***REMOVED***

  resolveInverseModuleMap(paths, filter, options) {
    if (!paths.size) {
      return [];
    ***REMOVED***

    const collectModules = (related, moduleMap, changed) => {
      const visitedModules = new Set();
      const result = [];

      while (changed.size) {
        changed = new Set(
          moduleMap.reduce((acc, module) => {
            if (
              visitedModules.has(module.file) ||
              !module.dependencies.some(dep => changed.has(dep))
            ) {
              return acc;
            ***REMOVED***

            const file = module.file;

            if (filter(file)) {
              result.push(module);
              related.delete(file);
            ***REMOVED***

            visitedModules.add(file);
            acc.push(file);
            return acc;
          ***REMOVED***, [])
        );
      ***REMOVED***

      return result.concat(
        Array.from(related).map(file => ({
          dependencies: [],
          file
        ***REMOVED***))
      );
    ***REMOVED***;

    const relatedPaths = new Set();
    const changed = new Set();

    for (const path of paths) {
      if (this._hasteFS.exists(path)) {
        const modulePath = (0, _jestSnapshot().isSnapshotPath)(path)
          ? this._snapshotResolver.resolveTestPath(path)
          : path;
        changed.add(modulePath);

        if (filter(modulePath)) {
          relatedPaths.add(modulePath);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    const modules = [];

    for (const file of this._hasteFS.getAbsoluteFileIterator()) {
      modules.push({
        dependencies: this.resolve(file, options),
        file
      ***REMOVED***);
    ***REMOVED***

    return collectModules(relatedPaths, modules, changed);
  ***REMOVED***

  resolveInverse(paths, filter, options) {
    return this.resolveInverseModuleMap(paths, filter, options).map(
      module => module.file
    );
  ***REMOVED***
***REMOVED***

exports.DependencyResolver = DependencyResolver;
