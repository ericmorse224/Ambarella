/**
 * @fileoverview Rule to check the spacing around the * in generator functions.
 * @author Jamund Ferguson
 * @deprecated in ESLint v8.53.0
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const OVERRIDE_SCHEMA = {
    oneOf: [
        {
            enum: ["before", "after", "both", "neither"]
        ***REMOVED***,
        {
            type: "object",
            properties: {
                before: { type: "boolean" ***REMOVED***,
                after: { type: "boolean" ***REMOVED***
            ***REMOVED***,
            additionalProperties: false
        ***REMOVED***
    ]
***REMOVED***;

/** @type {import('../shared/types').Rule***REMOVED*** */
module.exports = {
    meta: {
        deprecated: true,
        replacedBy: [],
        type: "layout",

        docs: {
            description: "Enforce consistent spacing around `*` operators in generator functions",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/generator-star-spacing"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            {
                oneOf: [
                    {
                        enum: ["before", "after", "both", "neither"]
                    ***REMOVED***,
                    {
                        type: "object",
                        properties: {
                            before: { type: "boolean" ***REMOVED***,
                            after: { type: "boolean" ***REMOVED***,
                            named: OVERRIDE_SCHEMA,
                            anonymous: OVERRIDE_SCHEMA,
                            method: OVERRIDE_SCHEMA
                        ***REMOVED***,
                        additionalProperties: false
                    ***REMOVED***
                ]
            ***REMOVED***
        ],

        messages: {
            missingBefore: "Missing space before *.",
            missingAfter: "Missing space after *.",
            unexpectedBefore: "Unexpected space before *.",
            unexpectedAfter: "Unexpected space after *."
        ***REMOVED***
    ***REMOVED***,

    create(context) {

        const optionDefinitions = {
            before: { before: true, after: false ***REMOVED***,
            after: { before: false, after: true ***REMOVED***,
            both: { before: true, after: true ***REMOVED***,
            neither: { before: false, after: false ***REMOVED***
        ***REMOVED***;

        /**
         * Returns resolved option definitions based on an option and defaults
         * @param {any***REMOVED*** option The option object or string value
         * @param {Object***REMOVED*** defaults The defaults to use if options are not present
         * @returns {Object***REMOVED*** the resolved object definition
         */
        function optionToDefinition(option, defaults) {
            if (!option) {
                return defaults;
            ***REMOVED***

            return typeof option === "string"
                ? optionDefinitions[option]
                : Object.assign({***REMOVED***, defaults, option);
        ***REMOVED***

        const modes = (function(option) {
            const defaults = optionToDefinition(option, optionDefinitions.before);

            return {
                named: optionToDefinition(option.named, defaults),
                anonymous: optionToDefinition(option.anonymous, defaults),
                method: optionToDefinition(option.method, defaults)
            ***REMOVED***;
        ***REMOVED***(context.options[0] || {***REMOVED***));

        const sourceCode = context.sourceCode;

        /**
         * Checks if the given token is a star token or not.
         * @param {Token***REMOVED*** token The token to check.
         * @returns {boolean***REMOVED*** `true` if the token is a star token.
         */
        function isStarToken(token) {
            return token.value === "*" && token.type === "Punctuator";
        ***REMOVED***

        /**
         * Gets the generator star token of the given function node.
         * @param {ASTNode***REMOVED*** node The function node to get.
         * @returns {Token***REMOVED*** Found star token.
         */
        function getStarToken(node) {
            return sourceCode.getFirstToken(
                (node.parent.method || node.parent.type === "MethodDefinition") ? node.parent : node,
                isStarToken
            );
        ***REMOVED***

        /**
         * capitalize a given string.
         * @param {string***REMOVED*** str the given string.
         * @returns {string***REMOVED*** the capitalized string.
         */
        function capitalize(str) {
            return str[0].toUpperCase() + str.slice(1);
        ***REMOVED***

        /**
         * Checks the spacing between two tokens before or after the star token.
         * @param {string***REMOVED*** kind Either "named", "anonymous", or "method"
         * @param {string***REMOVED*** side Either "before" or "after".
         * @param {Token***REMOVED*** leftToken `function` keyword token if side is "before", or
         *     star token if side is "after".
         * @param {Token***REMOVED*** rightToken Star token if side is "before", or identifier
         *     token if side is "after".
         * @returns {void***REMOVED***
         */
        function checkSpacing(kind, side, leftToken, rightToken) {
            if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {
                const after = leftToken.value === "*";
                const spaceRequired = modes[kind][side];
                const node = after ? leftToken : rightToken;
                const messageId = `${spaceRequired ? "missing" : "unexpected"***REMOVED***${capitalize(side)***REMOVED***`;

                context.report({
                    node,
                    messageId,
                    fix(fixer) {
                        if (spaceRequired) {
                            if (after) {
                                return fixer.insertTextAfter(node, " ");
                            ***REMOVED***
                            return fixer.insertTextBefore(node, " ");
                        ***REMOVED***
                        return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Enforces the spacing around the star if node is a generator function.
         * @param {ASTNode***REMOVED*** node A function expression or declaration node.
         * @returns {void***REMOVED***
         */
        function checkFunction(node) {
            if (!node.generator) {
                return;
            ***REMOVED***

            const starToken = getStarToken(node);
            const prevToken = sourceCode.getTokenBefore(starToken);
            const nextToken = sourceCode.getTokenAfter(starToken);

            let kind = "named";

            if (node.parent.type === "MethodDefinition" || (node.parent.type === "Property" && node.parent.method)) {
                kind = "method";
            ***REMOVED*** else if (!node.id) {
                kind = "anonymous";
            ***REMOVED***

            // Only check before when preceded by `function`|`static` keyword
            if (!(kind === "method" && starToken === sourceCode.getFirstToken(node.parent))) {
                checkSpacing(kind, "before", prevToken, starToken);
            ***REMOVED***

            checkSpacing(kind, "after", starToken, nextToken);
        ***REMOVED***

        return {
            FunctionDeclaration: checkFunction,
            FunctionExpression: checkFunction
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
