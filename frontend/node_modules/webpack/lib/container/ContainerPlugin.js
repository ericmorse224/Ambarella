/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra, Zackary Jackson @ScriptedAlchemy, Marais Rossouw @maraisr
*/

"use strict";

const createSchemaValidation = require("../util/create-schema-validation");
const memoize = require("../util/memoize");
const ContainerEntryDependency = require("./ContainerEntryDependency");
const ContainerEntryModuleFactory = require("./ContainerEntryModuleFactory");
const ContainerExposedDependency = require("./ContainerExposedDependency");
const { parseOptions ***REMOVED*** = require("./options");

/** @typedef {import("../../declarations/plugins/container/ContainerPlugin").ContainerPluginOptions***REMOVED*** ContainerPluginOptions */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("./ContainerEntryModule").ExposeOptions***REMOVED*** ExposeOptions */
/** @typedef {import("./ContainerEntryModule").ExposesList***REMOVED*** ExposesList */

const getModuleFederationPlugin = memoize(() =>
	require("./ModuleFederationPlugin")
);

const validate = createSchemaValidation(
	require("../../schemas/plugins/container/ContainerPlugin.check.js"),
	() => require("../../schemas/plugins/container/ContainerPlugin.json"),
	{
		name: "Container Plugin",
		baseDataPath: "options"
	***REMOVED***
);

const PLUGIN_NAME = "ContainerPlugin";

class ContainerPlugin {
	/**
	 * @param {ContainerPluginOptions***REMOVED*** options options
	 */
	constructor(options) {
		validate(options);

		this._options = {
			name: options.name,
			shareScope: options.shareScope || "default",
			library: options.library || {
				type: "var",
				name: options.name
			***REMOVED***,
			runtime: options.runtime,
			filename: options.filename || undefined,
			exposes: /** @type {ExposesList***REMOVED*** */ (
				parseOptions(
					options.exposes,
					item => ({
						import: Array.isArray(item) ? item : [item],
						name: undefined
					***REMOVED***),
					item => ({
						import: Array.isArray(item.import) ? item.import : [item.import],
						name: item.name || undefined
					***REMOVED***)
				)
			)
		***REMOVED***;
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		const { name, exposes, shareScope, filename, library, runtime ***REMOVED*** =
			this._options;

		if (!compiler.options.output.enabledLibraryTypes.includes(library.type)) {
			compiler.options.output.enabledLibraryTypes.push(library.type);
		***REMOVED***

		compiler.hooks.make.tapAsync(PLUGIN_NAME, (compilation, callback) => {
			const hooks =
				getModuleFederationPlugin().getCompilationHooks(compilation);
			const dep = new ContainerEntryDependency(name, exposes, shareScope);
			dep.loc = { name ***REMOVED***;
			compilation.addEntry(
				/** @type {string***REMOVED*** */ (compilation.options.context),
				dep,
				{
					name,
					filename,
					runtime,
					library
				***REMOVED***,
				error => {
					if (error) return callback(error);
					hooks.addContainerEntryDependency.call(dep);
					callback();
				***REMOVED***
			);
		***REMOVED***);

		compiler.hooks.thisCompilation.tap(
			PLUGIN_NAME,
			(compilation, { normalModuleFactory ***REMOVED***) => {
				compilation.dependencyFactories.set(
					ContainerEntryDependency,
					new ContainerEntryModuleFactory()
				);

				compilation.dependencyFactories.set(
					ContainerExposedDependency,
					normalModuleFactory
				);
			***REMOVED***
		);
	***REMOVED***
***REMOVED***

module.exports = ContainerPlugin;
