'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; ***REMOVED***)), keys.push.apply(keys, symbols); ***REMOVED*** return keys; ***REMOVED***
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {***REMOVED***; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); ***REMOVED***) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); ***REMOVED***); ***REMOVED*** return target; ***REMOVED***
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true ***REMOVED***); ***REMOVED*** else { obj[key] = value; ***REMOVED*** return obj; ***REMOVED***
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); ***REMOVED*** ***REMOVED***
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); ***REMOVED*** ***REMOVED***
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false ***REMOVED***); return Constructor; ***REMOVED***
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); ***REMOVED***
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); ***REMOVED*** return (hint === "string" ? String : Number)(input); ***REMOVED***
var _require = require('buffer'),
  Buffer = _require.Buffer;
var _require2 = require('util'),
  inspect = _require2.inspect;
var custom = inspect && inspect.custom || 'inspect';
function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
***REMOVED***
module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);
    this.head = null;
    this.tail = null;
    this.length = 0;
  ***REMOVED***
  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      ***REMOVED***;
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    ***REMOVED***
  ***REMOVED***, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      ***REMOVED***;
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    ***REMOVED***
  ***REMOVED***, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    ***REMOVED***
  ***REMOVED***, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    ***REMOVED***
  ***REMOVED***, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;
      while (p = p.next) ret += s + p.data;
      return ret;
    ***REMOVED***
  ***REMOVED***, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;
      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      ***REMOVED***
      return ret;
    ***REMOVED***

    // Consumes a specified amount of bytes or characters from the buffered data.
  ***REMOVED***, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;
      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      ***REMOVED*** else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      ***REMOVED*** else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      ***REMOVED***
      return ret;
    ***REMOVED***
  ***REMOVED***, {
    key: "first",
    value: function first() {
      return this.head.data;
    ***REMOVED***

    // Consumes a specified amount of characters from the buffered data.
  ***REMOVED***, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          ***REMOVED*** else {
            this.head = p;
            p.data = str.slice(nb);
          ***REMOVED***
          break;
        ***REMOVED***
        ++c;
      ***REMOVED***
      this.length -= c;
      return ret;
    ***REMOVED***

    // Consumes a specified amount of bytes from the buffered data.
  ***REMOVED***, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          ***REMOVED*** else {
            this.head = p;
            p.data = buf.slice(nb);
          ***REMOVED***
          break;
        ***REMOVED***
        ++c;
      ***REMOVED***
      this.length -= c;
      return ret;
    ***REMOVED***

    // Make sure the linked list only shows the minimal necessary information.
  ***REMOVED***, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread(_objectSpread({***REMOVED***, options), {***REMOVED***, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      ***REMOVED***));
    ***REMOVED***
  ***REMOVED***]);
  return BufferList;
***REMOVED***();