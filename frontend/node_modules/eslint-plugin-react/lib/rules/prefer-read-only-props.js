/**
 * @fileoverview Require component props to be typed as read-only.
 * @author Luke Zapart
 */

'use strict';

const flatMap = require('array.prototype.flatmap');
const values = require('object.values');

const Components = require('../util/Components');
const docsUrl = require('../util/docsUrl');
const report = require('../util/report');

function isFlowPropertyType(node) {
  return node.type === 'ObjectTypeProperty';
***REMOVED***

function isTypescriptPropertyType(node) {
  return node.type === 'TSPropertySignature';
***REMOVED***

function isCovariant(node) {
  return (node.variance && node.variance.kind === 'plus')
    || (
      node.parent
      && node.parent.parent
      && node.parent.parent.parent
      && node.parent.parent.parent.id
      && node.parent.parent.parent.id.name === '$ReadOnly'
    );
***REMOVED***

function isReadonly(node) {
  return (
    node.typeAnnotation
    && node.typeAnnotation.parent
    && node.typeAnnotation.parent.readonly
  );
***REMOVED***

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

const messages = {
  readOnlyProp: 'Prop \'{{name***REMOVED******REMOVED***\' should be read-only.',
***REMOVED***;

/** @type {import('eslint').Rule.RuleModule***REMOVED*** */
module.exports = {
  meta: {
    docs: {
      description: 'Enforce that props are read-only',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('prefer-read-only-props'),
    ***REMOVED***,
    fixable: 'code',

    messages,

    schema: [],
  ***REMOVED***,

  create: Components.detect((context, components) => {
    function reportReadOnlyProp(prop, propName, fixer) {
      report(context, messages.readOnlyProp, 'readOnlyProp', {
        node: prop.node,
        data: {
          name: propName,
        ***REMOVED***,
        fix: fixer,
      ***REMOVED***);
    ***REMOVED***

    return {
      'Program:exit'() {
        flatMap(
          values(components.list()),
          (component) => component.declaredPropTypes || []
        ).forEach((declaredPropTypes) => {
          Object.keys(declaredPropTypes).forEach((propName) => {
            const prop = declaredPropTypes[propName];
            if (!prop.node) {
              return;
            ***REMOVED***

            if (isFlowPropertyType(prop.node)) {
              if (!isCovariant(prop.node)) {
                reportReadOnlyProp(prop, propName, (fixer) => {
                  if (!prop.node.variance) {
                    // Insert covariance
                    return fixer.insertTextBefore(prop.node, '+');
                  ***REMOVED***

                  // Replace contravariance with covariance
                  return fixer.replaceText(prop.node.variance, '+');
                ***REMOVED***);
              ***REMOVED***

              return;
            ***REMOVED***

            if (isTypescriptPropertyType(prop.node)) {
              if (!isReadonly(prop.node)) {
                reportReadOnlyProp(prop, propName, (fixer) => (
                  fixer.insertTextBefore(prop.node, 'readonly ')
                ));
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***);
        ***REMOVED***);
      ***REMOVED***,
    ***REMOVED***;
  ***REMOVED***),
***REMOVED***;
