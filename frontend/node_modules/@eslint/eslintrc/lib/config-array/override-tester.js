/**
 * @fileoverview `OverrideTester` class.
 *
 * `OverrideTester` class handles `files` property and `excludedFiles` property
 * of `overrides` config.
 *
 * It provides one method.
 *
 * - `test(filePath)`
 *      Test if a file path matches the pair of `files` property and
 *      `excludedFiles` property. The `filePath` argument must be an absolute
 *      path.
 *
 * `ConfigArrayFactory` creates `OverrideTester` objects when it processes
 * `overrides` properties.
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */

import assert from "node:assert";
import path from "node:path";
import util from "node:util";
import minimatch from "minimatch";

const { Minimatch ***REMOVED*** = minimatch;

const minimatchOpts = { dot: true, matchBase: true ***REMOVED***;

/**
 * @typedef {Object***REMOVED*** Pattern
 * @property {InstanceType<Minimatch>[] | null***REMOVED*** includes The positive matchers.
 * @property {InstanceType<Minimatch>[] | null***REMOVED*** excludes The negative matchers.
 */

/**
 * Normalize a given pattern to an array.
 * @param {string|string[]|undefined***REMOVED*** patterns A glob pattern or an array of glob patterns.
 * @returns {string[]|null***REMOVED*** Normalized patterns.
 * @private
 */
function normalizePatterns(patterns) {
    if (Array.isArray(patterns)) {
        return patterns.filter(Boolean);
    ***REMOVED***
    if (typeof patterns === "string" && patterns) {
        return [patterns];
    ***REMOVED***
    return [];
***REMOVED***

/**
 * Create the matchers of given patterns.
 * @param {string[]***REMOVED*** patterns The patterns.
 * @returns {InstanceType<Minimatch>[] | null***REMOVED*** The matchers.
 */
function toMatcher(patterns) {
    if (patterns.length === 0) {
        return null;
    ***REMOVED***
    return patterns.map(pattern => {
        if (/^\.[/\\]/u.test(pattern)) {
            return new Minimatch(
                pattern.slice(2),

                // `./*.js` should not match with `subdir/foo.js`
                { ...minimatchOpts, matchBase: false ***REMOVED***
            );
        ***REMOVED***
        return new Minimatch(pattern, minimatchOpts);
    ***REMOVED***);
***REMOVED***

/**
 * Convert a given matcher to string.
 * @param {Pattern***REMOVED*** matchers The matchers.
 * @returns {string***REMOVED*** The string expression of the matcher.
 */
function patternToJson({ includes, excludes ***REMOVED***) {
    return {
        includes: includes && includes.map(m => m.pattern),
        excludes: excludes && excludes.map(m => m.pattern)
    ***REMOVED***;
***REMOVED***

/**
 * The class to test given paths are matched by the patterns.
 */
class OverrideTester {

    /**
     * Create a tester with given criteria.
     * If there are no criteria, returns `null`.
     * @param {string|string[]***REMOVED*** files The glob patterns for included files.
     * @param {string|string[]***REMOVED*** excludedFiles The glob patterns for excluded files.
     * @param {string***REMOVED*** basePath The path to the base directory to test paths.
     * @returns {OverrideTester|null***REMOVED*** The created instance or `null`.
     * @throws {Error***REMOVED*** When invalid patterns are given.
     */
    static create(files, excludedFiles, basePath) {
        const includePatterns = normalizePatterns(files);
        const excludePatterns = normalizePatterns(excludedFiles);
        let endsWithWildcard = false;

        if (includePatterns.length === 0) {
            return null;
        ***REMOVED***

        // Rejects absolute paths or relative paths to parents.
        for (const pattern of includePatterns) {
            if (path.isAbsolute(pattern) || pattern.includes("..")) {
                throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern***REMOVED***`);
            ***REMOVED***
            if (pattern.endsWith("*")) {
                endsWithWildcard = true;
            ***REMOVED***
        ***REMOVED***
        for (const pattern of excludePatterns) {
            if (path.isAbsolute(pattern) || pattern.includes("..")) {
                throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern***REMOVED***`);
            ***REMOVED***
        ***REMOVED***

        const includes = toMatcher(includePatterns);
        const excludes = toMatcher(excludePatterns);

        return new OverrideTester(
            [{ includes, excludes ***REMOVED***],
            basePath,
            endsWithWildcard
        );
    ***REMOVED***

    /**
     * Combine two testers by logical and.
     * If either of the testers was `null`, returns the other tester.
     * The `basePath` property of the two must be the same value.
     * @param {OverrideTester|null***REMOVED*** a A tester.
     * @param {OverrideTester|null***REMOVED*** b Another tester.
     * @returns {OverrideTester|null***REMOVED*** Combined tester.
     */
    static and(a, b) {
        if (!b) {
            return a && new OverrideTester(
                a.patterns,
                a.basePath,
                a.endsWithWildcard
            );
        ***REMOVED***
        if (!a) {
            return new OverrideTester(
                b.patterns,
                b.basePath,
                b.endsWithWildcard
            );
        ***REMOVED***

        assert.strictEqual(a.basePath, b.basePath);
        return new OverrideTester(
            a.patterns.concat(b.patterns),
            a.basePath,
            a.endsWithWildcard || b.endsWithWildcard
        );
    ***REMOVED***

    /**
     * Initialize this instance.
     * @param {Pattern[]***REMOVED*** patterns The matchers.
     * @param {string***REMOVED*** basePath The base path.
     * @param {boolean***REMOVED*** endsWithWildcard If `true` then a pattern ends with `*`.
     */
    constructor(patterns, basePath, endsWithWildcard = false) {

        /** @type {Pattern[]***REMOVED*** */
        this.patterns = patterns;

        /** @type {string***REMOVED*** */
        this.basePath = basePath;

        /** @type {boolean***REMOVED*** */
        this.endsWithWildcard = endsWithWildcard;
    ***REMOVED***

    /**
     * Test if a given path is matched or not.
     * @param {string***REMOVED*** filePath The absolute path to the target file.
     * @returns {boolean***REMOVED*** `true` if the path was matched.
     * @throws {Error***REMOVED*** When invalid `filePath` is given.
     */
    test(filePath) {
        if (typeof filePath !== "string" || !path.isAbsolute(filePath)) {
            throw new Error(`'filePath' should be an absolute path, but got ${filePath***REMOVED***.`);
        ***REMOVED***
        const relativePath = path.relative(this.basePath, filePath);

        return this.patterns.every(({ includes, excludes ***REMOVED***) => (
            (!includes || includes.some(m => m.match(relativePath))) &&
            (!excludes || !excludes.some(m => m.match(relativePath)))
        ));
    ***REMOVED***

    /**
     * Converts this instance to a JSON compatible object.
     * @returns {Object***REMOVED*** a JSON compatible object.
     */
    toJSON() {
        if (this.patterns.length === 1) {
            return {
                ...patternToJson(this.patterns[0]),
                basePath: this.basePath
            ***REMOVED***;
        ***REMOVED***
        return {
            AND: this.patterns.map(patternToJson),
            basePath: this.basePath
        ***REMOVED***;
    ***REMOVED***

    /**
     * Custom inspect method for Node.js `console.log()`.
     * @returns {Object***REMOVED*** an object to display by `console.log()`.
     */
    [util.inspect.custom]() {
        return this.toJSON();
    ***REMOVED***
***REMOVED***

export { OverrideTester ***REMOVED***;
