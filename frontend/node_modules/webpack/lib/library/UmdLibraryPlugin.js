/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { ConcatSource, OriginalSource ***REMOVED*** = require("webpack-sources");
const ExternalModule = require("../ExternalModule");
const Template = require("../Template");
const AbstractLibraryPlugin = require("./AbstractLibraryPlugin");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../../declarations/WebpackOptions").LibraryCustomUmdCommentObject***REMOVED*** LibraryCustomUmdCommentObject */
/** @typedef {import("../../declarations/WebpackOptions").LibraryCustomUmdObject***REMOVED*** LibraryCustomUmdObject */
/** @typedef {import("../../declarations/WebpackOptions").LibraryName***REMOVED*** LibraryName */
/** @typedef {import("../../declarations/WebpackOptions").LibraryOptions***REMOVED*** LibraryOptions */
/** @typedef {import("../../declarations/WebpackOptions").LibraryType***REMOVED*** LibraryType */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../javascript/JavascriptModulesPlugin").RenderContext***REMOVED*** RenderContext */
/** @typedef {import("../ExternalModule").RequestRecord***REMOVED*** RequestRecord */
/** @typedef {import("../util/Hash")***REMOVED*** Hash */
/**
 * @template T
 * @typedef {import("./AbstractLibraryPlugin").LibraryContext<T>***REMOVED***
 * LibraryContext<T>
 */

/**
 * @param {string[]***REMOVED*** accessor the accessor to convert to path
 * @returns {string***REMOVED*** the path
 */
const accessorToObjectAccess = accessor =>
	accessor.map(a => `[${JSON.stringify(a)***REMOVED***]`).join("");

/**
 * @param {string|undefined***REMOVED*** base the path prefix
 * @param {string|string[]***REMOVED*** accessor the accessor
 * @param {string=***REMOVED*** joinWith the element separator
 * @returns {string***REMOVED*** the path
 */
const accessorAccess = (base, accessor, joinWith = ", ") => {
	const accessors = Array.isArray(accessor) ? accessor : [accessor];
	return accessors
		.map((_, idx) => {
			const a = base
				? base + accessorToObjectAccess(accessors.slice(0, idx + 1))
				: accessors[0] + accessorToObjectAccess(accessors.slice(1, idx + 1));
			if (idx === accessors.length - 1) return a;
			if (idx === 0 && base === undefined)
				return `${a***REMOVED*** = typeof ${a***REMOVED*** === "object" ? ${a***REMOVED*** : {***REMOVED***`;
			return `${a***REMOVED*** = ${a***REMOVED*** || {***REMOVED***`;
		***REMOVED***)
		.join(joinWith);
***REMOVED***;

/** @typedef {string | string[] | LibraryCustomUmdObject***REMOVED*** UmdLibraryPluginName */

/**
 * @typedef {object***REMOVED*** UmdLibraryPluginOptions
 * @property {LibraryType***REMOVED*** type
 * @property {boolean=***REMOVED*** optionalAmdExternalAsGlobal
 */

/**
 * @typedef {object***REMOVED*** UmdLibraryPluginParsed
 * @property {string | string[] | undefined***REMOVED*** name
 * @property {LibraryCustomUmdObject***REMOVED*** names
 * @property {string | LibraryCustomUmdCommentObject | undefined***REMOVED*** auxiliaryComment
 * @property {boolean | undefined***REMOVED*** namedDefine
 */

/**
 * @typedef {UmdLibraryPluginParsed***REMOVED*** T
 * @extends {AbstractLibraryPlugin<UmdLibraryPluginParsed>***REMOVED***
 */
class UmdLibraryPlugin extends AbstractLibraryPlugin {
	/**
	 * @param {UmdLibraryPluginOptions***REMOVED*** options the plugin option
	 */
	constructor(options) {
		super({
			pluginName: "UmdLibraryPlugin",
			type: options.type
		***REMOVED***);

		this.optionalAmdExternalAsGlobal = options.optionalAmdExternalAsGlobal;
	***REMOVED***

	/**
	 * @param {LibraryOptions***REMOVED*** library normalized library option
	 * @returns {T | false***REMOVED*** preprocess as needed by overriding
	 */
	parseOptions(library) {
		/** @type {LibraryName | undefined***REMOVED*** */
		let name;
		/** @type {LibraryCustomUmdObject***REMOVED*** */
		let names;
		if (typeof library.name === "object" && !Array.isArray(library.name)) {
			name = library.name.root || library.name.amd || library.name.commonjs;
			names = library.name;
		***REMOVED*** else {
			name = library.name;
			const singleName = Array.isArray(name) ? name[0] : name;
			names = {
				commonjs: singleName,
				root: library.name,
				amd: singleName
			***REMOVED***;
		***REMOVED***
		return {
			name,
			names,
			auxiliaryComment: library.auxiliaryComment,
			namedDefine: library.umdNamedDefine
		***REMOVED***;
	***REMOVED***

	/**
	 * @param {Source***REMOVED*** source source
	 * @param {RenderContext***REMOVED*** renderContext render context
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {Source***REMOVED*** source with library export
	 */
	render(
		source,
		{ chunkGraph, runtimeTemplate, chunk, moduleGraph ***REMOVED***,
		{ options, compilation ***REMOVED***
	) {
		const modules = chunkGraph
			.getChunkModules(chunk)
			.filter(
				m =>
					m instanceof ExternalModule &&
					(m.externalType === "umd" || m.externalType === "umd2")
			);
		let externals = /** @type {ExternalModule[]***REMOVED*** */ (modules);
		/** @type {ExternalModule[]***REMOVED*** */
		const optionalExternals = [];
		/** @type {ExternalModule[]***REMOVED*** */
		let requiredExternals = [];
		if (this.optionalAmdExternalAsGlobal) {
			for (const m of externals) {
				if (m.isOptional(moduleGraph)) {
					optionalExternals.push(m);
				***REMOVED*** else {
					requiredExternals.push(m);
				***REMOVED***
			***REMOVED***
			externals = requiredExternals.concat(optionalExternals);
		***REMOVED*** else {
			requiredExternals = externals;
		***REMOVED***

		/**
		 * @param {string***REMOVED*** str the string to replace
		 * @returns {string***REMOVED*** the replaced keys
		 */
		const replaceKeys = str =>
			compilation.getPath(str, {
				chunk
			***REMOVED***);

		/**
		 * @param {ExternalModule[]***REMOVED*** modules external modules
		 * @returns {string***REMOVED*** result
		 */
		const externalsDepsArray = modules =>
			`[${replaceKeys(
				modules
					.map(m =>
						JSON.stringify(
							typeof m.request === "object"
								? /** @type {RequestRecord***REMOVED*** */
									(m.request).amd
								: m.request
						)
					)
					.join(", ")
			)***REMOVED***]`;

		/**
		 * @param {ExternalModule[]***REMOVED*** modules external modules
		 * @returns {string***REMOVED*** result
		 */
		const externalsRootArray = modules =>
			replaceKeys(
				modules
					.map(m => {
						let request = m.request;
						if (typeof request === "object")
							request =
								/** @type {RequestRecord***REMOVED*** */
								(request).root;
						return `root${accessorToObjectAccess(/** @type {string[]***REMOVED*** */ ([]).concat(request))***REMOVED***`;
					***REMOVED***)
					.join(", ")
			);

		/**
		 * @param {string***REMOVED*** type the type
		 * @returns {string***REMOVED*** external require array
		 */
		const externalsRequireArray = type =>
			replaceKeys(
				externals
					.map(m => {
						let expr;
						let request = m.request;
						if (typeof request === "object") {
							request =
								/** @type {RequestRecord***REMOVED*** */
								(request)[type];
						***REMOVED***
						if (request === undefined) {
							throw new Error(
								`Missing external configuration for type:${type***REMOVED***`
							);
						***REMOVED***
						expr = Array.isArray(request)
							? `require(${JSON.stringify(
									request[0]
								)***REMOVED***)${accessorToObjectAccess(request.slice(1))***REMOVED***`
							: `require(${JSON.stringify(request)***REMOVED***)`;
						if (m.isOptional(moduleGraph)) {
							expr = `(function webpackLoadOptionalExternalModule() { try { return ${expr***REMOVED***; ***REMOVED*** catch(e) {***REMOVED*** ***REMOVED***())`;
						***REMOVED***
						return expr;
					***REMOVED***)
					.join(", ")
			);

		/**
		 * @param {ExternalModule[]***REMOVED*** modules external modules
		 * @returns {string***REMOVED*** arguments
		 */
		const externalsArguments = modules =>
			modules
				.map(
					m =>
						`__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(
							`${chunkGraph.getModuleId(m)***REMOVED***`
						)***REMOVED***__`
				)
				.join(", ");

		/**
		 * @param {string| string[]***REMOVED*** library library name
		 * @returns {string***REMOVED*** stringified library name
		 */
		const libraryName = library =>
			JSON.stringify(
				replaceKeys(
					/** @type {string***REMOVED*** */
					(/** @type {string[]***REMOVED*** */ ([]).concat(library).pop())
				)
			);

		let amdFactory;
		if (optionalExternals.length > 0) {
			const wrapperArguments = externalsArguments(requiredExternals);
			const factoryArguments =
				requiredExternals.length > 0
					? `${externalsArguments(requiredExternals)***REMOVED***, ${externalsRootArray(
							optionalExternals
						)***REMOVED***`
					: externalsRootArray(optionalExternals);
			amdFactory =
				`function webpackLoadOptionalExternalModuleAmd(${wrapperArguments***REMOVED***) {\n` +
				`			return factory(${factoryArguments***REMOVED***);\n` +
				"		***REMOVED***";
		***REMOVED*** else {
			amdFactory = "factory";
		***REMOVED***

		const { auxiliaryComment, namedDefine, names ***REMOVED*** = options;

		/**
		 * @param {keyof LibraryCustomUmdCommentObject***REMOVED*** type type
		 * @returns {string***REMOVED*** comment
		 */
		const getAuxiliaryComment = type => {
			if (auxiliaryComment) {
				if (typeof auxiliaryComment === "string")
					return `\t//${auxiliaryComment***REMOVED***\n`;
				if (auxiliaryComment[type]) return `\t//${auxiliaryComment[type]***REMOVED***\n`;
			***REMOVED***
			return "";
		***REMOVED***;

		return new ConcatSource(
			new OriginalSource(
				`(function webpackUniversalModuleDefinition(root, factory) {\n${getAuxiliaryComment(
					"commonjs2"
				)***REMOVED***	if(typeof exports === 'object' && typeof module === 'object')\n` +
					`		module.exports = factory(${externalsRequireArray(
						"commonjs2"
					)***REMOVED***);\n${getAuxiliaryComment(
						"amd"
					)***REMOVED***	else if(typeof define === 'function' && define.amd)\n${
						requiredExternals.length > 0
							? names.amd && namedDefine === true
								? `		define(${libraryName(names.amd)***REMOVED***, ${externalsDepsArray(
										requiredExternals
									)***REMOVED***, ${amdFactory***REMOVED***);\n`
								: `		define(${externalsDepsArray(requiredExternals)***REMOVED***, ${
										amdFactory
									***REMOVED***);\n`
							: names.amd && namedDefine === true
								? `		define(${libraryName(names.amd)***REMOVED***, [], ${amdFactory***REMOVED***);\n`
								: `		define([], ${amdFactory***REMOVED***);\n`
					***REMOVED***${
						names.root || names.commonjs
							? `${getAuxiliaryComment(
									"commonjs"
								)***REMOVED***	else if(typeof exports === 'object')\n` +
								`		exports[${libraryName(
									/** @type {string | string[]***REMOVED*** */
									(names.commonjs || names.root)
								)***REMOVED***] = factory(${externalsRequireArray(
									"commonjs"
								)***REMOVED***);\n${getAuxiliaryComment("root")***REMOVED***	else\n` +
								`		${replaceKeys(
									accessorAccess(
										"root",
										/** @type {string | string[]***REMOVED*** */
										(names.root || names.commonjs)
									)
								)***REMOVED*** = factory(${externalsRootArray(externals)***REMOVED***);\n`
							: `	else {\n${
									externals.length > 0
										? `		var a = typeof exports === 'object' ? factory(${externalsRequireArray(
												"commonjs"
											)***REMOVED***) : factory(${externalsRootArray(externals)***REMOVED***);\n`
										: "		var a = factory();\n"
								***REMOVED***		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n` +
								"	***REMOVED***\n"
					***REMOVED******REMOVED***)(${runtimeTemplate.outputOptions.globalObject***REMOVED***, ${
						runtimeTemplate.supportsArrowFunction()
							? `(${externalsArguments(externals)***REMOVED***) =>`
							: `function(${externalsArguments(externals)***REMOVED***)`
					***REMOVED*** {\nreturn `,
				"webpack/universalModuleDefinition"
			),
			source,
			";\n***REMOVED***)"
		);
	***REMOVED***
***REMOVED***

module.exports = UmdLibraryPlugin;
