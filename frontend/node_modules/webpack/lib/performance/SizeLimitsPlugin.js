/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Sean Larkin @thelarkinn
*/

"use strict";

const { find ***REMOVED*** = require("../util/SetHelpers");
const AssetsOverSizeLimitWarning = require("./AssetsOverSizeLimitWarning");
const EntrypointsOverSizeLimitWarning = require("./EntrypointsOverSizeLimitWarning");
const NoAsyncChunksWarning = require("./NoAsyncChunksWarning");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../../declarations/WebpackOptions").PerformanceOptions***REMOVED*** PerformanceOptions */
/** @typedef {import("../ChunkGroup")***REMOVED*** ChunkGroup */
/** @typedef {import("../Compilation").Asset***REMOVED*** Asset */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../Entrypoint")***REMOVED*** Entrypoint */
/** @typedef {import("../WebpackError")***REMOVED*** WebpackError */

/**
 * @typedef {object***REMOVED*** AssetDetails
 * @property {string***REMOVED*** name
 * @property {number***REMOVED*** size
 */

/**
 * @typedef {object***REMOVED*** EntrypointDetails
 * @property {string***REMOVED*** name
 * @property {number***REMOVED*** size
 * @property {string[]***REMOVED*** files
 */

const isOverSizeLimitSet = new WeakSet();

/**
 * @param {Asset["name"]***REMOVED*** name the name
 * @param {Asset["source"]***REMOVED*** source the source
 * @param {Asset["info"]***REMOVED*** info the info
 * @returns {boolean***REMOVED*** result
 */
const excludeSourceMap = (name, source, info) => !info.development;

const PLUGIN_NAME = "SizeLimitsPlugin";

module.exports = class SizeLimitsPlugin {
	/**
	 * @param {PerformanceOptions***REMOVED*** options the plugin options
	 */
	constructor(options) {
		this.hints = options.hints;
		this.maxAssetSize = options.maxAssetSize;
		this.maxEntrypointSize = options.maxEntrypointSize;
		this.assetFilter = options.assetFilter;
	***REMOVED***

	/**
	 * @param {ChunkGroup | Source***REMOVED*** thing the resource to test
	 * @returns {boolean***REMOVED*** true if over the limit
	 */
	static isOverSizeLimit(thing) {
		return isOverSizeLimitSet.has(thing);
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		const entrypointSizeLimit = this.maxEntrypointSize;
		const assetSizeLimit = this.maxAssetSize;
		const hints = this.hints;
		const assetFilter = this.assetFilter || excludeSourceMap;

		compiler.hooks.afterEmit.tap(PLUGIN_NAME, compilation => {
			/** @type {WebpackError[]***REMOVED*** */
			const warnings = [];

			/**
			 * @param {Entrypoint***REMOVED*** entrypoint an entrypoint
			 * @returns {number***REMOVED*** the size of the entrypoint
			 */
			const getEntrypointSize = entrypoint => {
				let size = 0;
				for (const file of entrypoint.getFiles()) {
					const asset = compilation.getAsset(file);
					if (
						asset &&
						assetFilter(asset.name, asset.source, asset.info) &&
						asset.source
					) {
						size += asset.info.size || asset.source.size();
					***REMOVED***
				***REMOVED***
				return size;
			***REMOVED***;

			/** @type {AssetDetails[]***REMOVED*** */
			const assetsOverSizeLimit = [];
			for (const { name, source, info ***REMOVED*** of compilation.getAssets()) {
				if (!assetFilter(name, source, info) || !source) {
					continue;
				***REMOVED***

				const size = info.size || source.size();
				if (size > /** @type {number***REMOVED*** */ (assetSizeLimit)) {
					assetsOverSizeLimit.push({
						name,
						size
					***REMOVED***);
					isOverSizeLimitSet.add(source);
				***REMOVED***
			***REMOVED***

			/**
			 * @param {Asset["name"]***REMOVED*** name the name
			 * @returns {boolean | undefined***REMOVED*** result
			 */
			const fileFilter = name => {
				const asset = compilation.getAsset(name);
				return asset && assetFilter(asset.name, asset.source, asset.info);
			***REMOVED***;

			/** @type {EntrypointDetails[]***REMOVED*** */
			const entrypointsOverLimit = [];
			for (const [name, entry] of compilation.entrypoints) {
				const size = getEntrypointSize(entry);

				if (size > /** @type {number***REMOVED*** */ (entrypointSizeLimit)) {
					entrypointsOverLimit.push({
						name,
						size,
						files: entry.getFiles().filter(fileFilter)
					***REMOVED***);
					isOverSizeLimitSet.add(entry);
				***REMOVED***
			***REMOVED***

			if (hints) {
				// 1. Individual Chunk: Size < 250kb
				// 2. Collective Initial Chunks [entrypoint] (Each Set?): Size < 250kb
				// 3. No Async Chunks
				// if !1, then 2, if !2 return
				if (assetsOverSizeLimit.length > 0) {
					warnings.push(
						new AssetsOverSizeLimitWarning(
							assetsOverSizeLimit,
							/** @type {number***REMOVED*** */ (assetSizeLimit)
						)
					);
				***REMOVED***
				if (entrypointsOverLimit.length > 0) {
					warnings.push(
						new EntrypointsOverSizeLimitWarning(
							entrypointsOverLimit,
							/** @type {number***REMOVED*** */ (entrypointSizeLimit)
						)
					);
				***REMOVED***

				if (warnings.length > 0) {
					const someAsyncChunk = find(
						compilation.chunks,
						chunk => !chunk.canBeInitial()
					);

					if (!someAsyncChunk) {
						warnings.push(new NoAsyncChunksWarning());
					***REMOVED***

					if (hints === "error") {
						compilation.errors.push(...warnings);
					***REMOVED*** else {
						compilation.warnings.push(...warnings);
					***REMOVED***
				***REMOVED***
			***REMOVED***
		***REMOVED***);
	***REMOVED***
***REMOVED***;
