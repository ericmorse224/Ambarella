import type Ajv from "../../core"
import type {SchemaObject***REMOVED*** from "../../types"
import {jtdForms, JTDForm, SchemaObjectMap***REMOVED*** from "./types"
import {SchemaEnv, getCompilingSchema***REMOVED*** from ".."
import {_, str, and, or, nil, not, CodeGen, Code, Name, SafeExpr***REMOVED*** from "../codegen"
import MissingRefError from "../ref_error"
import N from "../names"
import {hasPropFunc***REMOVED*** from "../../vocabularies/code"
import {hasRef***REMOVED*** from "../../vocabularies/jtd/ref"
import {intRange, IntType***REMOVED*** from "../../vocabularies/jtd/type"
import {parseJson, parseJsonNumber, parseJsonString***REMOVED*** from "../../runtime/parseJson"
import {useFunc***REMOVED*** from "../util"
import validTimestamp from "../../runtime/timestamp"

type GenParse = (cxt: ParseCxt) => void

const genParse: {[F in JTDForm]: GenParse***REMOVED*** = {
  elements: parseElements,
  values: parseValues,
  discriminator: parseDiscriminator,
  properties: parseProperties,
  optionalProperties: parseProperties,
  enum: parseEnum,
  type: parseType,
  ref: parseRef,
***REMOVED***

interface ParseCxt {
  readonly gen: CodeGen
  readonly self: Ajv // current Ajv instance
  readonly schemaEnv: SchemaEnv
  readonly definitions: SchemaObjectMap
  schema: SchemaObject
  data: Code
  parseName: Name
  char: Name
***REMOVED***

export default function compileParser(
  this: Ajv,
  sch: SchemaEnv,
  definitions: SchemaObjectMap
): SchemaEnv {
  const _sch = getCompilingSchema.call(this, sch)
  if (_sch) return _sch
  const {es5, lines***REMOVED*** = this.opts.code
  const {ownProperties***REMOVED*** = this.opts
  const gen = new CodeGen(this.scope, {es5, lines, ownProperties***REMOVED***)
  const parseName = gen.scopeName("parse")
  const cxt: ParseCxt = {
    self: this,
    gen,
    schema: sch.schema as SchemaObject,
    schemaEnv: sch,
    definitions,
    data: N.data,
    parseName,
    char: gen.name("c"),
  ***REMOVED***

  let sourceCode: string | undefined
  try {
    this._compilations.add(sch)
    sch.parseName = parseName
    parserFunction(cxt)
    gen.optimize(this.opts.code.optimize)
    const parseFuncCode = gen.toString()
    sourceCode = `${gen.scopeRefs(N.scope)***REMOVED***return ${parseFuncCode***REMOVED***`
    const makeParse = new Function(`${N.scope***REMOVED***`, sourceCode)
    const parse: (json: string) => unknown = makeParse(this.scope.get())
    this.scope.value(parseName, {ref: parse***REMOVED***)
    sch.parse = parse
  ***REMOVED*** catch (e) {
    if (sourceCode) this.logger.error("Error compiling parser, function code:", sourceCode)
    delete sch.parse
    delete sch.parseName
    throw e
  ***REMOVED*** finally {
    this._compilations.delete(sch)
  ***REMOVED***
  return sch
***REMOVED***

const undef = _`undefined`

function parserFunction(cxt: ParseCxt): void {
  const {gen, parseName, char***REMOVED*** = cxt
  gen.func(parseName, _`${N.json***REMOVED***, ${N.jsonPos***REMOVED***, ${N.jsonPart***REMOVED***`, false, () => {
    gen.let(N.data)
    gen.let(char)
    gen.assign(_`${parseName***REMOVED***.message`, undef)
    gen.assign(_`${parseName***REMOVED***.position`, undef)
    gen.assign(N.jsonPos, _`${N.jsonPos***REMOVED*** || 0`)
    gen.const(N.jsonLen, _`${N.json***REMOVED***.length`)
    parseCode(cxt)
    skipWhitespace(cxt)
    gen.if(N.jsonPart, () => {
      gen.assign(_`${parseName***REMOVED***.position`, N.jsonPos)
      gen.return(N.data)
    ***REMOVED***)
    gen.if(_`${N.jsonPos***REMOVED*** === ${N.jsonLen***REMOVED***`, () => gen.return(N.data))
    jsonSyntaxError(cxt)
  ***REMOVED***)
***REMOVED***

function parseCode(cxt: ParseCxt): void {
  let form: JTDForm | undefined
  for (const key of jtdForms) {
    if (key in cxt.schema) {
      form = key
      break
    ***REMOVED***
  ***REMOVED***
  if (form) parseNullable(cxt, genParse[form])
  else parseEmpty(cxt)
***REMOVED***

const parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError))

function parseNullable(cxt: ParseCxt, parseForm: GenParse): void {
  const {gen, schema, data***REMOVED*** = cxt
  if (!schema.nullable) return parseForm(cxt)
  tryParseToken(cxt, "null", parseForm, () => gen.assign(data, null))
***REMOVED***

function parseElements(cxt: ParseCxt): void {
  const {gen, schema, data***REMOVED*** = cxt
  parseToken(cxt, "[")
  const ix = gen.let("i", 0)
  gen.assign(data, _`[]`)
  parseItems(cxt, "]", () => {
    const el = gen.let("el")
    parseCode({...cxt, schema: schema.elements, data: el***REMOVED***)
    gen.assign(_`${data***REMOVED***[${ix***REMOVED***++]`, el)
  ***REMOVED***)
***REMOVED***

function parseValues(cxt: ParseCxt): void {
  const {gen, schema, data***REMOVED*** = cxt
  parseToken(cxt, "{")
  gen.assign(data, _`{***REMOVED***`)
  parseItems(cxt, "***REMOVED***", () => parseKeyValue(cxt, schema.values))
***REMOVED***

function parseItems(cxt: ParseCxt, endToken: string, block: () => void): void {
  tryParseItems(cxt, endToken, block)
  parseToken(cxt, endToken)
***REMOVED***

function tryParseItems(cxt: ParseCxt, endToken: string, block: () => void): void {
  const {gen***REMOVED*** = cxt
  gen.for(_`;${N.jsonPos***REMOVED***<${N.jsonLen***REMOVED*** && ${jsonSlice(1)***REMOVED***!==${endToken***REMOVED***;`, () => {
    block()
    tryParseToken(cxt, ",", () => gen.break(), hasItem)
  ***REMOVED***)

  function hasItem(): void {
    tryParseToken(cxt, endToken, () => {***REMOVED***, jsonSyntaxError)
  ***REMOVED***
***REMOVED***

function parseKeyValue(cxt: ParseCxt, schema: SchemaObject): void {
  const {gen***REMOVED*** = cxt
  const key = gen.let("key")
  parseString({...cxt, data: key***REMOVED***)
  parseToken(cxt, ":")
  parsePropertyValue(cxt, key, schema)
***REMOVED***

function parseDiscriminator(cxt: ParseCxt): void {
  const {gen, data, schema***REMOVED*** = cxt
  const {discriminator, mapping***REMOVED*** = schema
  parseToken(cxt, "{")
  gen.assign(data, _`{***REMOVED***`)
  const startPos = gen.const("pos", N.jsonPos)
  const value = gen.let("value")
  const tag = gen.let("tag")
  tryParseItems(cxt, "***REMOVED***", () => {
    const key = gen.let("key")
    parseString({...cxt, data: key***REMOVED***)
    parseToken(cxt, ":")
    gen.if(
      _`${key***REMOVED*** === ${discriminator***REMOVED***`,
      () => {
        parseString({...cxt, data: tag***REMOVED***)
        gen.assign(_`${data***REMOVED***[${key***REMOVED***]`, tag)
        gen.break()
      ***REMOVED***,
      () => parseEmpty({...cxt, data: value***REMOVED***) // can be discarded/skipped
    )
  ***REMOVED***)
  gen.assign(N.jsonPos, startPos)
  gen.if(_`${tag***REMOVED*** === undefined`)
  parsingError(cxt, str`discriminator tag not found`)
  for (const tagValue in mapping) {
    gen.elseIf(_`${tag***REMOVED*** === ${tagValue***REMOVED***`)
    parseSchemaProperties({...cxt, schema: mapping[tagValue]***REMOVED***, discriminator)
  ***REMOVED***
  gen.else()
  parsingError(cxt, str`discriminator value not in schema`)
  gen.endIf()
***REMOVED***

function parseProperties(cxt: ParseCxt): void {
  const {gen, data***REMOVED*** = cxt
  parseToken(cxt, "{")
  gen.assign(data, _`{***REMOVED***`)
  parseSchemaProperties(cxt)
***REMOVED***

function parseSchemaProperties(cxt: ParseCxt, discriminator?: string): void {
  const {gen, schema, data***REMOVED*** = cxt
  const {properties, optionalProperties, additionalProperties***REMOVED*** = schema
  parseItems(cxt, "***REMOVED***", () => {
    const key = gen.let("key")
    parseString({...cxt, data: key***REMOVED***)
    parseToken(cxt, ":")
    gen.if(false)
    parseDefinedProperty(cxt, key, properties)
    parseDefinedProperty(cxt, key, optionalProperties)
    if (discriminator) {
      gen.elseIf(_`${key***REMOVED*** === ${discriminator***REMOVED***`)
      const tag = gen.let("tag")
      parseString({...cxt, data: tag***REMOVED***) // can be discarded, it is already assigned
    ***REMOVED***
    gen.else()
    if (additionalProperties) {
      parseEmpty({...cxt, data: _`${data***REMOVED***[${key***REMOVED***]`***REMOVED***)
    ***REMOVED*** else {
      parsingError(cxt, str`property ${key***REMOVED*** not allowed`)
    ***REMOVED***
    gen.endIf()
  ***REMOVED***)
  if (properties) {
    const hasProp = hasPropFunc(gen)
    const allProps: Code = and(
      ...Object.keys(properties).map((p): Code => _`${hasProp***REMOVED***.call(${data***REMOVED***, ${p***REMOVED***)`)
    )
    gen.if(not(allProps), () => parsingError(cxt, str`missing required properties`))
  ***REMOVED***
***REMOVED***

function parseDefinedProperty(cxt: ParseCxt, key: Name, schemas: SchemaObjectMap = {***REMOVED***): void {
  const {gen***REMOVED*** = cxt
  for (const prop in schemas) {
    gen.elseIf(_`${key***REMOVED*** === ${prop***REMOVED***`)
    parsePropertyValue(cxt, key, schemas[prop] as SchemaObject)
  ***REMOVED***
***REMOVED***

function parsePropertyValue(cxt: ParseCxt, key: Name, schema: SchemaObject): void {
  parseCode({...cxt, schema, data: _`${cxt.data***REMOVED***[${key***REMOVED***]`***REMOVED***)
***REMOVED***

function parseType(cxt: ParseCxt): void {
  const {gen, schema, data, self***REMOVED*** = cxt
  switch (schema.type) {
    case "boolean":
      parseBoolean(cxt)
      break
    case "string":
      parseString(cxt)
      break
    case "timestamp": {
      parseString(cxt)
      const vts = useFunc(gen, validTimestamp)
      const {allowDate, parseDate***REMOVED*** = self.opts
      const notValid = allowDate ? _`!${vts***REMOVED***(${data***REMOVED***, true)` : _`!${vts***REMOVED***(${data***REMOVED***)`
      const fail: Code = parseDate
        ? or(notValid, _`(${data***REMOVED*** = new Date(${data***REMOVED***), false)`, _`isNaN(${data***REMOVED***.valueOf())`)
        : notValid
      gen.if(fail, () => parsingError(cxt, str`invalid timestamp`))
      break
    ***REMOVED***
    case "float32":
    case "float64":
      parseNumber(cxt)
      break
    default: {
      const t = schema.type as IntType
      if (!self.opts.int32range && (t === "int32" || t === "uint32")) {
        parseNumber(cxt, 16) // 2 ** 53 - max safe integer
        if (t === "uint32") {
          gen.if(_`${data***REMOVED*** < 0`, () => parsingError(cxt, str`integer out of range`))
        ***REMOVED***
      ***REMOVED*** else {
        const [min, max, maxDigits] = intRange[t]
        parseNumber(cxt, maxDigits)
        gen.if(_`${data***REMOVED*** < ${min***REMOVED*** || ${data***REMOVED*** > ${max***REMOVED***`, () =>
          parsingError(cxt, str`integer out of range`)
        )
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function parseString(cxt: ParseCxt): void {
  parseToken(cxt, '"')
  parseWith(cxt, parseJsonString)
***REMOVED***

function parseEnum(cxt: ParseCxt): void {
  const {gen, data, schema***REMOVED*** = cxt
  const enumSch = schema.enum
  parseToken(cxt, '"')
  // TODO loopEnum
  gen.if(false)
  for (const value of enumSch) {
    const valueStr = JSON.stringify(value).slice(1) // remove starting quote
    gen.elseIf(_`${jsonSlice(valueStr.length)***REMOVED*** === ${valueStr***REMOVED***`)
    gen.assign(data, str`${value***REMOVED***`)
    gen.add(N.jsonPos, valueStr.length)
  ***REMOVED***
  gen.else()
  jsonSyntaxError(cxt)
  gen.endIf()
***REMOVED***

function parseNumber(cxt: ParseCxt, maxDigits?: number): void {
  const {gen***REMOVED*** = cxt
  skipWhitespace(cxt)
  gen.if(
    _`"-0123456789".indexOf(${jsonSlice(1)***REMOVED***) < 0`,
    () => jsonSyntaxError(cxt),
    () => parseWith(cxt, parseJsonNumber, maxDigits)
  )
***REMOVED***

function parseBooleanToken(bool: boolean, fail: GenParse): GenParse {
  return (cxt) => {
    const {gen, data***REMOVED*** = cxt
    tryParseToken(
      cxt,
      `${bool***REMOVED***`,
      () => fail(cxt),
      () => gen.assign(data, bool)
    )
  ***REMOVED***
***REMOVED***

function parseRef(cxt: ParseCxt): void {
  const {gen, self, definitions, schema, schemaEnv***REMOVED*** = cxt
  const {ref***REMOVED*** = schema
  const refSchema = definitions[ref]
  if (!refSchema) throw new MissingRefError(self.opts.uriResolver, "", ref, `No definition ${ref***REMOVED***`)
  if (!hasRef(refSchema)) return parseCode({...cxt, schema: refSchema***REMOVED***)
  const {root***REMOVED*** = schemaEnv
  const sch = compileParser.call(self, new SchemaEnv({schema: refSchema, root***REMOVED***), definitions)
  partialParse(cxt, getParser(gen, sch), true)
***REMOVED***

function getParser(gen: CodeGen, sch: SchemaEnv): Code {
  return sch.parse
    ? gen.scopeValue("parse", {ref: sch.parse***REMOVED***)
    : _`${gen.scopeValue("wrapper", {ref: sch***REMOVED***)***REMOVED***.parse`
***REMOVED***

function parseEmpty(cxt: ParseCxt): void {
  parseWith(cxt, parseJson)
***REMOVED***

function parseWith(cxt: ParseCxt, parseFunc: {code: string***REMOVED***, args?: SafeExpr): void {
  partialParse(cxt, useFunc(cxt.gen, parseFunc), args)
***REMOVED***

function partialParse(cxt: ParseCxt, parseFunc: Name, args?: SafeExpr): void {
  const {gen, data***REMOVED*** = cxt
  gen.assign(data, _`${parseFunc***REMOVED***(${N.json***REMOVED***, ${N.jsonPos***REMOVED***${args ? _`, ${args***REMOVED***` : nil***REMOVED***)`)
  gen.assign(N.jsonPos, _`${parseFunc***REMOVED***.position`)
  gen.if(_`${data***REMOVED*** === undefined`, () => parsingError(cxt, _`${parseFunc***REMOVED***.message`))
***REMOVED***

function parseToken(cxt: ParseCxt, tok: string): void {
  tryParseToken(cxt, tok, jsonSyntaxError)
***REMOVED***

function tryParseToken(cxt: ParseCxt, tok: string, fail: GenParse, success?: GenParse): void {
  const {gen***REMOVED*** = cxt
  const n = tok.length
  skipWhitespace(cxt)
  gen.if(
    _`${jsonSlice(n)***REMOVED*** === ${tok***REMOVED***`,
    () => {
      gen.add(N.jsonPos, n)
      success?.(cxt)
    ***REMOVED***,
    () => fail(cxt)
  )
***REMOVED***

function skipWhitespace({gen, char: c***REMOVED***: ParseCxt): void {
  gen.code(
    _`while((${c***REMOVED***=${N.json***REMOVED***[${N.jsonPos***REMOVED***],${c***REMOVED***===" "||${c***REMOVED***==="\\n"||${c***REMOVED***==="\\r"||${c***REMOVED***==="\\t"))${N.jsonPos***REMOVED***++;`
  )
***REMOVED***

function jsonSlice(len: number | Name): Code {
  return len === 1
    ? _`${N.json***REMOVED***[${N.jsonPos***REMOVED***]`
    : _`${N.json***REMOVED***.slice(${N.jsonPos***REMOVED***, ${N.jsonPos***REMOVED***+${len***REMOVED***)`
***REMOVED***

function jsonSyntaxError(cxt: ParseCxt): void {
  parsingError(cxt, _`"unexpected token " + ${N.json***REMOVED***[${N.jsonPos***REMOVED***]`)
***REMOVED***

function parsingError({gen, parseName***REMOVED***: ParseCxt, msg: Code): void {
  gen.assign(_`${parseName***REMOVED***.message`, msg)
  gen.assign(_`${parseName***REMOVED***.position`, N.jsonPos)
  gen.return(undef)
***REMOVED***
