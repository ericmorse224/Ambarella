"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); ***REMOVED***); ***REMOVED***
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); ***REMOVED*** catch (e) { reject(e); ***REMOVED*** ***REMOVED***
        function rejected(value) { try { step(generator["throw"](value)); ***REMOVED*** catch (e) { reject(e); ***REMOVED*** ***REMOVED***
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); ***REMOVED***
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    ***REMOVED***);
***REMOVED***;
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const child_process_1 = require("child_process");
const RpcIpcMessagePortClosedError_1 = require("./error/RpcIpcMessagePortClosedError");
function createRpcIpcMessagePort(process) {
    const messageListeners = new Set();
    const errorListeners = new Set();
    let closedError;
    const handleExit = (code, signal) => __awaiter(this, void 0, void 0, function* () {
        closedError = new RpcIpcMessagePortClosedError_1.RpcIpcMessagePortClosedError(code
            ? `Process ${process.pid***REMOVED*** exited with code "${code***REMOVED***" [${signal***REMOVED***]`
            : `Process ${process.pid***REMOVED*** exited [${signal***REMOVED***].`, code, signal);
        errorListeners.forEach((listener) => {
            if (closedError) {
                listener(closedError);
            ***REMOVED***
        ***REMOVED***);
        yield port.close();
    ***REMOVED***);
    const handleMessage = (message) => {
        messageListeners.forEach((listener) => {
            listener(message);
        ***REMOVED***);
    ***REMOVED***;
    process.on('message', handleMessage);
    process.on('exit', handleExit);
    const port = {
        dispatchMessage: (message) => __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (!process.connected) {
                    reject(closedError ||
                        new RpcIpcMessagePortClosedError_1.RpcIpcMessagePortClosedError(`Process ${process.pid***REMOVED*** doesn't have open IPC channels`));
                ***REMOVED***
                if (process.send) {
                    process.send(Object.assign(Object.assign({***REMOVED***, message), { source: process.pid ***REMOVED***), undefined, undefined, (sendError) => {
                        if (sendError) {
                            if (!closedError) {
                                closedError = new RpcIpcMessagePortClosedError_1.RpcIpcMessagePortClosedError(`Cannot send the message - the message port has been closed for the process ${process.pid***REMOVED***.`);
                            ***REMOVED***
                            reject(closedError);
                        ***REMOVED***
                        else {
                            resolve();
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
                else {
                    reject(new RpcIpcMessagePortClosedError_1.RpcIpcMessagePortClosedError(`Process ${process.pid***REMOVED*** doesn't have IPC channels`));
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***),
        addMessageListener: (listener) => {
            messageListeners.add(listener);
        ***REMOVED***,
        removeMessageListener: (listener) => {
            messageListeners.delete(listener);
        ***REMOVED***,
        addErrorListener: (listener) => {
            errorListeners.add(listener);
        ***REMOVED***,
        removeErrorListener: (listener) => {
            errorListeners.delete(listener);
        ***REMOVED***,
        isOpen: () => !!process.connected,
        open: () => __awaiter(this, void 0, void 0, function* () {
            if (!process.connected || closedError) {
                throw (closedError ||
                    new RpcIpcMessagePortClosedError_1.RpcIpcMessagePortClosedError(`Cannot open closed IPC channel for process ${process.pid***REMOVED***.`));
            ***REMOVED***
        ***REMOVED***),
        close: () => __awaiter(this, void 0, void 0, function* () {
            process.off('message', handleMessage);
            process.off('exit', handleExit);
            messageListeners.clear();
            errorListeners.clear();
            if (process.disconnect && process.connected) {
                process.disconnect();
            ***REMOVED***
        ***REMOVED***),
    ***REMOVED***;
    return port;
***REMOVED***
exports.createRpcIpcMessagePort = createRpcIpcMessagePort;
function createRpcIpcForkedProcessMessagePort(filePath, memoryLimit = 2048, autoRecreate = true) {
    function createChildProcess() {
        return child_process_1.fork(filePath, [], {
            execArgv: [`--max-old-space-size=${memoryLimit***REMOVED***`],
            stdio: ['inherit', 'inherit', 'inherit', 'ipc'],
        ***REMOVED***);
    ***REMOVED***
    const messageListeners = new Set();
    const errorListeners = new Set();
    let childProcess = createChildProcess();
    let port = createRpcIpcMessagePort(childProcess);
    return {
        dispatchMessage: (message) => port.dispatchMessage(message),
        addMessageListener: (listener) => {
            messageListeners.add(listener);
            return port.addMessageListener(listener);
        ***REMOVED***,
        removeMessageListener: (listener) => {
            messageListeners.delete(listener);
            return port.removeMessageListener(listener);
        ***REMOVED***,
        addErrorListener: (listener) => {
            errorListeners.add(listener);
            return port.addErrorListener(listener);
        ***REMOVED***,
        removeErrorListener: (listener) => {
            errorListeners.delete(listener);
            return port.removeErrorListener(listener);
        ***REMOVED***,
        isOpen: () => port.isOpen(),
        open: () => __awaiter(this, void 0, void 0, function* () {
            if (!port.isOpen() && autoRecreate) {
                // recreate the process and add existing message listeners
                childProcess = createChildProcess();
                port = createRpcIpcMessagePort(childProcess);
                messageListeners.forEach((listener) => {
                    port.addMessageListener(listener);
                ***REMOVED***);
                errorListeners.forEach((listener) => {
                    port.addErrorListener(listener);
                ***REMOVED***);
            ***REMOVED***
            else {
                return port.open();
            ***REMOVED***
        ***REMOVED***),
        close: () => __awaiter(this, void 0, void 0, function* () {
            yield port.close();
            messageListeners.clear();
            errorListeners.clear();
            if (childProcess) {
                childProcess.kill('SIGTERM');
                childProcess = undefined;
            ***REMOVED***
        ***REMOVED***),
    ***REMOVED***;
***REMOVED***
exports.createRpcIpcForkedProcessMessagePort = createRpcIpcForkedProcessMessagePort;
