/**
 * @author Toru Nagashima <https://github.com/mysticatea>
 * See LICENSE file in root directory for full license.
 */
import KEYS from "./visitor-keys.js";

/**
 * @typedef {import('./visitor-keys.js').VisitorKeys***REMOVED*** VisitorKeys
 */

// List to ignore keys.
const KEY_BLACKLIST = new Set([
    "parent",
    "leadingComments",
    "trailingComments"
]);

/**
 * Check whether a given key should be used or not.
 * @param {string***REMOVED*** key The key to check.
 * @returns {boolean***REMOVED*** `true` if the key should be used.
 */
function filterKey(key) {
    return !KEY_BLACKLIST.has(key) && key[0] !== "_";
***REMOVED***

/**
 * Get visitor keys of a given node.
 * @param {object***REMOVED*** node The AST node to get keys.
 * @returns {readonly string[]***REMOVED*** Visitor keys of the node.
 */
export function getKeys(node) {
    return Object.keys(node).filter(filterKey);
***REMOVED***

// Disable valid-jsdoc rule because it reports syntax error on the type of @returns.
// eslint-disable-next-line valid-jsdoc
/**
 * Make the union set with `KEYS` and given keys.
 * @param {VisitorKeys***REMOVED*** additionalKeys The additional keys.
 * @returns {VisitorKeys***REMOVED*** The union set.
 */
export function unionWith(additionalKeys) {
    const retv = /** @type {{
        [type: string]: ReadonlyArray<string>
    ***REMOVED******REMOVED*** */ (Object.assign({***REMOVED***, KEYS));

    for (const type of Object.keys(additionalKeys)) {
        if (Object.prototype.hasOwnProperty.call(retv, type)) {
            const keys = new Set(additionalKeys[type]);

            for (const key of retv[type]) {
                keys.add(key);
            ***REMOVED***

            retv[type] = Object.freeze(Array.from(keys));
        ***REMOVED*** else {
            retv[type] = Object.freeze(Array.from(additionalKeys[type]));
        ***REMOVED***
    ***REMOVED***

    return Object.freeze(retv);
***REMOVED***

export { KEYS ***REMOVED***;
