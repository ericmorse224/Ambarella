'use strict';
const ansiEscapes = module.exports;
// TODO: remove this in the next major version
module.exports.default = ansiEscapes;

const ESC = '\u001B[';
const OSC = '\u001B]';
const BEL = '\u0007';
const SEP = ';';
const isTerminalApp = process.env.TERM_PROGRAM === 'Apple_Terminal';

ansiEscapes.cursorTo = (x, y) => {
	if (typeof x !== 'number') {
		throw new TypeError('The `x` argument is required');
	***REMOVED***

	if (typeof y !== 'number') {
		return ESC + (x + 1) + 'G';
	***REMOVED***

	return ESC + (y + 1) + ';' + (x + 1) + 'H';
***REMOVED***;

ansiEscapes.cursorMove = (x, y) => {
	if (typeof x !== 'number') {
		throw new TypeError('The `x` argument is required');
	***REMOVED***

	let ret = '';

	if (x < 0) {
		ret += ESC + (-x) + 'D';
	***REMOVED*** else if (x > 0) {
		ret += ESC + x + 'C';
	***REMOVED***

	if (y < 0) {
		ret += ESC + (-y) + 'A';
	***REMOVED*** else if (y > 0) {
		ret += ESC + y + 'B';
	***REMOVED***

	return ret;
***REMOVED***;

ansiEscapes.cursorUp = (count = 1) => ESC + count + 'A';
ansiEscapes.cursorDown = (count = 1) => ESC + count + 'B';
ansiEscapes.cursorForward = (count = 1) => ESC + count + 'C';
ansiEscapes.cursorBackward = (count = 1) => ESC + count + 'D';

ansiEscapes.cursorLeft = ESC + 'G';
ansiEscapes.cursorSavePosition = isTerminalApp ? '\u001B7' : ESC + 's';
ansiEscapes.cursorRestorePosition = isTerminalApp ? '\u001B8' : ESC + 'u';
ansiEscapes.cursorGetPosition = ESC + '6n';
ansiEscapes.cursorNextLine = ESC + 'E';
ansiEscapes.cursorPrevLine = ESC + 'F';
ansiEscapes.cursorHide = ESC + '?25l';
ansiEscapes.cursorShow = ESC + '?25h';

ansiEscapes.eraseLines = count => {
	let clear = '';

	for (let i = 0; i < count; i++) {
		clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : '');
	***REMOVED***

	if (count) {
		clear += ansiEscapes.cursorLeft;
	***REMOVED***

	return clear;
***REMOVED***;

ansiEscapes.eraseEndLine = ESC + 'K';
ansiEscapes.eraseStartLine = ESC + '1K';
ansiEscapes.eraseLine = ESC + '2K';
ansiEscapes.eraseDown = ESC + 'J';
ansiEscapes.eraseUp = ESC + '1J';
ansiEscapes.eraseScreen = ESC + '2J';
ansiEscapes.scrollUp = ESC + 'S';
ansiEscapes.scrollDown = ESC + 'T';

ansiEscapes.clearScreen = '\u001Bc';

ansiEscapes.clearTerminal = process.platform === 'win32' ?
	`${ansiEscapes.eraseScreen***REMOVED***${ESC***REMOVED***0f` :
	// 1. Erases the screen (Only done in case `2` is not supported)
	// 2. Erases the whole screen including scrollback buffer
	// 3. Moves cursor to the top-left position
	// More info: https://www.real-world-systems.com/docs/ANSIcode.html
	`${ansiEscapes.eraseScreen***REMOVED***${ESC***REMOVED***3J${ESC***REMOVED***H`;

ansiEscapes.beep = BEL;

ansiEscapes.link = (text, url) => {
	return [
		OSC,
		'8',
		SEP,
		SEP,
		url,
		BEL,
		text,
		OSC,
		'8',
		SEP,
		SEP,
		BEL
	].join('');
***REMOVED***;

ansiEscapes.image = (buffer, options = {***REMOVED***) => {
	let ret = `${OSC***REMOVED***1337;File=inline=1`;

	if (options.width) {
		ret += `;width=${options.width***REMOVED***`;
	***REMOVED***

	if (options.height) {
		ret += `;height=${options.height***REMOVED***`;
	***REMOVED***

	if (options.preserveAspectRatio === false) {
		ret += ';preserveAspectRatio=0';
	***REMOVED***

	return ret + ':' + buffer.toString('base64') + BEL;
***REMOVED***;

ansiEscapes.iTerm = {
	setCwd: (cwd = process.cwd()) => `${OSC***REMOVED***50;CurrentDir=${cwd***REMOVED***${BEL***REMOVED***`,

	annotation: (message, options = {***REMOVED***) => {
		let ret = `${OSC***REMOVED***1337;`;

		const hasX = typeof options.x !== 'undefined';
		const hasY = typeof options.y !== 'undefined';
		if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== 'undefined')) {
			throw new Error('`x`, `y` and `length` must be defined when `x` or `y` is defined');
		***REMOVED***

		message = message.replace(/\|/g, '');

		ret += options.isHidden ? 'AddHiddenAnnotation=' : 'AddAnnotation=';

		if (options.length > 0) {
			ret +=
					(hasX ?
						[message, options.length, options.x, options.y] :
						[options.length, message]).join('|');
		***REMOVED*** else {
			ret += message;
		***REMOVED***

		return ret + BEL;
	***REMOVED***
***REMOVED***;
