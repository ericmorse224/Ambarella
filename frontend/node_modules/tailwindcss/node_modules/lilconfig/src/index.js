// @ts-check
const path = require('path');
const fs = require('fs');
const os = require('os');
const url = require('url');

const fsReadFileAsync = fs.promises.readFile;

/** @type {(name: string, sync: boolean) => string[]***REMOVED*** */
function getDefaultSearchPlaces(name, sync) {
	return [
		'package.json',
		`.${name***REMOVED***rc.json`,
		`.${name***REMOVED***rc.js`,
		`.${name***REMOVED***rc.cjs`,
		...(sync ? [] : [`.${name***REMOVED***rc.mjs`]),
		`.config/${name***REMOVED***rc`,
		`.config/${name***REMOVED***rc.json`,
		`.config/${name***REMOVED***rc.js`,
		`.config/${name***REMOVED***rc.cjs`,
		...(sync ? [] : [`.config/${name***REMOVED***rc.mjs`]),
		`${name***REMOVED***.config.js`,
		`${name***REMOVED***.config.cjs`,
		...(sync ? [] : [`${name***REMOVED***.config.mjs`]),
	];
***REMOVED***

/**
 * @type {(p: string) => string***REMOVED***
 *
 * see #17
 * On *nix, if cwd is not under homedir,
 * the last path will be '', ('/build' -> '')
 * but it should be '/' actually.
 * And on Windows, this will never happen. ('C:\build' -> 'C:')
 */
function parentDir(p) {
	return path.dirname(p) || path.sep;
***REMOVED***

/** @type {import('./index').LoaderSync***REMOVED*** */
const jsonLoader = (_, content) => JSON.parse(content);
// Use plain require in webpack context for dynamic import
const requireFunc =
	typeof __webpack_require__ === 'function' ? __non_webpack_require__ : require;
/** @type {import('./index').LoadersSync***REMOVED*** */
const defaultLoadersSync = Object.freeze({
	'.js': requireFunc,
	'.json': requireFunc,
	'.cjs': requireFunc,
	noExt: jsonLoader,
***REMOVED***);
module.exports.defaultLoadersSync = defaultLoadersSync;

/** @type {import('./index').Loader***REMOVED*** */
const dynamicImport = async id => {
	try {
		const fileUrl = url.pathToFileURL(id).href;
		const mod = await import(/* webpackIgnore: true */ fileUrl);

		return mod.default;
	***REMOVED*** catch (e) {
		try {
			return requireFunc(id);
		***REMOVED*** catch (/** @type {any***REMOVED*** */ requireE) {
			if (
				requireE.code === 'ERR_REQUIRE_ESM' ||
				(requireE instanceof SyntaxError &&
					requireE
						.toString()
						.includes('Cannot use import statement outside a module'))
			) {
				throw e;
			***REMOVED***
			throw requireE;
		***REMOVED***
	***REMOVED***
***REMOVED***;

/** @type {import('./index').Loaders***REMOVED*** */
const defaultLoaders = Object.freeze({
	'.js': dynamicImport,
	'.mjs': dynamicImport,
	'.cjs': dynamicImport,
	'.json': jsonLoader,
	noExt: jsonLoader,
***REMOVED***);
module.exports.defaultLoaders = defaultLoaders;

/**
 * @param {string***REMOVED*** name
 * @param {import('./index').Options | import('./index').OptionsSync***REMOVED*** options
 * @param {boolean***REMOVED*** sync
 * @returns {Required<import('./index').Options | import('./index').OptionsSync>***REMOVED***
 */
function getOptions(name, options, sync) {
	/** @type {Required<import('./index').Options>***REMOVED*** */
	const conf = {
		stopDir: os.homedir(),
		searchPlaces: getDefaultSearchPlaces(name, sync),
		ignoreEmptySearchPlaces: true,
		cache: true,
		transform: x => x,
		packageProp: [name],
		...options,
		loaders: {
			...(sync ? defaultLoadersSync : defaultLoaders),
			...options.loaders,
		***REMOVED***,
	***REMOVED***;
	conf.searchPlaces.forEach(place => {
		const key = path.extname(place) || 'noExt';
		const loader = conf.loaders[key];
		if (!loader) {
			throw new Error(`Missing loader for extension "${place***REMOVED***"`);
		***REMOVED***

		if (typeof loader !== 'function') {
			throw new Error(
				`Loader for extension "${place***REMOVED***" is not a function: Received ${typeof loader***REMOVED***.`,
			);
		***REMOVED***
	***REMOVED***);

	return conf;
***REMOVED***

/** @type {(props: string | string[], obj: Record<string, any>) => unknown***REMOVED*** */
function getPackageProp(props, obj) {
	if (typeof props === 'string' && props in obj) return obj[props];
	return (
		(Array.isArray(props) ? props : props.split('.')).reduce(
			(acc, prop) => (acc === undefined ? acc : acc[prop]),
			obj,
		) || null
	);
***REMOVED***

/** @param {string***REMOVED*** filepath */
function validateFilePath(filepath) {
	if (!filepath) throw new Error('load must pass a non-empty string');
***REMOVED***

/** @type {(loader: import('./index').Loader, ext: string) => void***REMOVED*** */
function validateLoader(loader, ext) {
	if (!loader) throw new Error(`No loader specified for extension "${ext***REMOVED***"`);
	if (typeof loader !== 'function') throw new Error('loader is not a function');
***REMOVED***

/** @type {(enableCache: boolean) => <T>(c: Map<string, T>, filepath: string, res: T) => T***REMOVED*** */
const makeEmplace = enableCache => (c, filepath, res) => {
	if (enableCache) c.set(filepath, res);
	return res;
***REMOVED***;

/** @type {import('./index').lilconfig***REMOVED*** */
module.exports.lilconfig = function lilconfig(name, options) {
	const {
		ignoreEmptySearchPlaces,
		loaders,
		packageProp,
		searchPlaces,
		stopDir,
		transform,
		cache,
	***REMOVED*** = getOptions(name, options ?? {***REMOVED***, false);
	const searchCache = new Map();
	const loadCache = new Map();
	const emplace = makeEmplace(cache);

	return {
		async search(searchFrom = process.cwd()) {
			/** @type {import('./index').LilconfigResult***REMOVED*** */
			const result = {
				config: null,
				filepath: '',
			***REMOVED***;

			/** @type {Set<string>***REMOVED*** */
			const visited = new Set();
			let dir = searchFrom;
			dirLoop: while (true) {
				if (cache) {
					const r = searchCache.get(dir);
					if (r !== undefined) {
						for (const p of visited) searchCache.set(p, r);
						return r;
					***REMOVED***
					visited.add(dir);
				***REMOVED***

				for (const searchPlace of searchPlaces) {
					const filepath = path.join(dir, searchPlace);
					try {
						await fs.promises.access(filepath);
					***REMOVED*** catch {
						continue;
					***REMOVED***
					const content = String(await fsReadFileAsync(filepath));
					const loaderKey = path.extname(searchPlace) || 'noExt';
					const loader = loaders[loaderKey];

					// handle package.json
					if (searchPlace === 'package.json') {
						const pkg = await loader(filepath, content);
						const maybeConfig = getPackageProp(packageProp, pkg);
						if (maybeConfig != null) {
							result.config = maybeConfig;
							result.filepath = filepath;
							break dirLoop;
						***REMOVED***

						continue;
					***REMOVED***

					// handle other type of configs
					const isEmpty = content.trim() === '';
					if (isEmpty && ignoreEmptySearchPlaces) continue;

					if (isEmpty) {
						result.isEmpty = true;
						result.config = undefined;
					***REMOVED*** else {
						validateLoader(loader, loaderKey);
						result.config = await loader(filepath, content);
					***REMOVED***
					result.filepath = filepath;
					break dirLoop;
				***REMOVED***
				if (dir === stopDir || dir === parentDir(dir)) break dirLoop;
				dir = parentDir(dir);
			***REMOVED***

			const transformed =
				// not found
				result.filepath === '' && result.config === null
					? transform(null)
					: transform(result);

			if (cache) {
				for (const p of visited) searchCache.set(p, transformed);
			***REMOVED***

			return transformed;
		***REMOVED***,
		async load(filepath) {
			validateFilePath(filepath);
			const absPath = path.resolve(process.cwd(), filepath);
			if (cache && loadCache.has(absPath)) {
				return loadCache.get(absPath);
			***REMOVED***
			const {base, ext***REMOVED*** = path.parse(absPath);
			const loaderKey = ext || 'noExt';
			const loader = loaders[loaderKey];
			validateLoader(loader, loaderKey);
			const content = String(await fsReadFileAsync(absPath));

			if (base === 'package.json') {
				const pkg = await loader(absPath, content);
				return emplace(
					loadCache,
					absPath,
					transform({
						config: getPackageProp(packageProp, pkg),
						filepath: absPath,
					***REMOVED***),
				);
			***REMOVED***
			/** @type {import('./index').LilconfigResult***REMOVED*** */
			const result = {
				config: null,
				filepath: absPath,
			***REMOVED***;
			// handle other type of configs
			const isEmpty = content.trim() === '';
			if (isEmpty && ignoreEmptySearchPlaces)
				return emplace(
					loadCache,
					absPath,
					transform({
						config: undefined,
						filepath: absPath,
						isEmpty: true,
					***REMOVED***),
				);

			// cosmiconfig returns undefined for empty files
			result.config = isEmpty ? undefined : await loader(absPath, content);

			return emplace(
				loadCache,
				absPath,
				transform(isEmpty ? {...result, isEmpty, config: undefined***REMOVED*** : result),
			);
		***REMOVED***,
		clearLoadCache() {
			if (cache) loadCache.clear();
		***REMOVED***,
		clearSearchCache() {
			if (cache) searchCache.clear();
		***REMOVED***,
		clearCaches() {
			if (cache) {
				loadCache.clear();
				searchCache.clear();
			***REMOVED***
		***REMOVED***,
	***REMOVED***;
***REMOVED***;

/** @type {import('./index').lilconfigSync***REMOVED*** */
module.exports.lilconfigSync = function lilconfigSync(name, options) {
	const {
		ignoreEmptySearchPlaces,
		loaders,
		packageProp,
		searchPlaces,
		stopDir,
		transform,
		cache,
	***REMOVED*** = getOptions(name, options ?? {***REMOVED***, true);
	const searchCache = new Map();
	const loadCache = new Map();
	const emplace = makeEmplace(cache);

	return {
		search(searchFrom = process.cwd()) {
			/** @type {import('./index').LilconfigResult***REMOVED*** */
			const result = {
				config: null,
				filepath: '',
			***REMOVED***;

			/** @type {Set<string>***REMOVED*** */
			const visited = new Set();
			let dir = searchFrom;
			dirLoop: while (true) {
				if (cache) {
					const r = searchCache.get(dir);
					if (r !== undefined) {
						for (const p of visited) searchCache.set(p, r);
						return r;
					***REMOVED***
					visited.add(dir);
				***REMOVED***

				for (const searchPlace of searchPlaces) {
					const filepath = path.join(dir, searchPlace);
					try {
						fs.accessSync(filepath);
					***REMOVED*** catch {
						continue;
					***REMOVED***
					const loaderKey = path.extname(searchPlace) || 'noExt';
					const loader = loaders[loaderKey];
					const content = String(fs.readFileSync(filepath));

					// handle package.json
					if (searchPlace === 'package.json') {
						const pkg = loader(filepath, content);
						const maybeConfig = getPackageProp(packageProp, pkg);
						if (maybeConfig != null) {
							result.config = maybeConfig;
							result.filepath = filepath;
							break dirLoop;
						***REMOVED***

						continue;
					***REMOVED***

					// handle other type of configs
					const isEmpty = content.trim() === '';
					if (isEmpty && ignoreEmptySearchPlaces) continue;

					if (isEmpty) {
						result.isEmpty = true;
						result.config = undefined;
					***REMOVED*** else {
						validateLoader(loader, loaderKey);
						result.config = loader(filepath, content);
					***REMOVED***
					result.filepath = filepath;
					break dirLoop;
				***REMOVED***
				if (dir === stopDir || dir === parentDir(dir)) break dirLoop;
				dir = parentDir(dir);
			***REMOVED***

			const transformed =
				// not found
				result.filepath === '' && result.config === null
					? transform(null)
					: transform(result);

			if (cache) {
				for (const p of visited) searchCache.set(p, transformed);
			***REMOVED***

			return transformed;
		***REMOVED***,
		load(filepath) {
			validateFilePath(filepath);
			const absPath = path.resolve(process.cwd(), filepath);
			if (cache && loadCache.has(absPath)) {
				return loadCache.get(absPath);
			***REMOVED***
			const {base, ext***REMOVED*** = path.parse(absPath);
			const loaderKey = ext || 'noExt';
			const loader = loaders[loaderKey];
			validateLoader(loader, loaderKey);

			const content = String(fs.readFileSync(absPath));

			if (base === 'package.json') {
				const pkg = loader(absPath, content);
				return transform({
					config: getPackageProp(packageProp, pkg),
					filepath: absPath,
				***REMOVED***);
			***REMOVED***
			const result = {
				config: null,
				filepath: absPath,
			***REMOVED***;
			// handle other type of configs
			const isEmpty = content.trim() === '';
			if (isEmpty && ignoreEmptySearchPlaces)
				return emplace(
					loadCache,
					absPath,
					transform({
						filepath: absPath,
						config: undefined,
						isEmpty: true,
					***REMOVED***),
				);

			// cosmiconfig returns undefined for empty files
			result.config = isEmpty ? undefined : loader(absPath, content);

			return emplace(
				loadCache,
				absPath,
				transform(isEmpty ? {...result, isEmpty, config: undefined***REMOVED*** : result),
			);
		***REMOVED***,
		clearLoadCache() {
			if (cache) loadCache.clear();
		***REMOVED***,
		clearSearchCache() {
			if (cache) searchCache.clear();
		***REMOVED***,
		clearCaches() {
			if (cache) {
				loadCache.clear();
				searchCache.clear();
			***REMOVED***
		***REMOVED***,
	***REMOVED***;
***REMOVED***;
