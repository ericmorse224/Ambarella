/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/

import {oneLine as ol***REMOVED*** from 'common-tags';

import {errors***REMOVED*** from './errors';
import {ModuleRegistry***REMOVED*** from './module-registry';
import {RuntimeCaching***REMOVED*** from '../types';
import {stringifyWithoutComments***REMOVED*** from './stringify-without-comments';

/**
 * Given a set of options that configures runtime caching behavior, convert it
 * to the equivalent Workbox method calls.
 *
 * @param {ModuleRegistry***REMOVED*** moduleRegistry
 * @param {Object***REMOVED*** options See
 *        https://developers.google.com/web/tools/workbox/modules/workbox-build#generateSW-runtimeCaching
 * @return {string***REMOVED*** A JSON string representing the equivalent options.
 *
 * @private
 */
function getOptionsString(
  moduleRegistry: ModuleRegistry,
  options: RuntimeCaching['options'] = {***REMOVED***,
) {
  const plugins: Array<string> = [];
  const handlerOptions: {[key in keyof typeof options]: any***REMOVED*** = {***REMOVED***;

  for (const optionName of Object.keys(options) as Array<
    keyof typeof options
  >) {
    if (options[optionName] === undefined) {
      continue;
    ***REMOVED***

    switch (optionName) {
      // Using a library here because JSON.stringify won't handle functions.
      case 'plugins': {
        plugins.push(...options.plugins!.map(stringifyWithoutComments));
        break;
      ***REMOVED***

      // These are the option properties that we want to pull out, so that
      // they're passed to the handler constructor.
      case 'cacheName':
      case 'networkTimeoutSeconds':
      case 'fetchOptions':
      case 'matchOptions': {
        handlerOptions[optionName] = options[optionName];
        break;
      ***REMOVED***

      // The following cases are all shorthands for creating a plugin with a
      // given configuration.
      case 'backgroundSync': {
        const name = options.backgroundSync!.name;
        const plugin = moduleRegistry.use(
          'workbox-background-sync',
          'BackgroundSyncPlugin',
        );

        let pluginCode = `new ${plugin***REMOVED***(${JSON.stringify(name)***REMOVED***`;
        if (options.backgroundSync!.options) {
          pluginCode += `, ${stringifyWithoutComments(
            options.backgroundSync!.options,
          )***REMOVED***`;
        ***REMOVED***
        pluginCode += `)`;

        plugins.push(pluginCode);
        break;
      ***REMOVED***

      case 'broadcastUpdate': {
        const channelName = options.broadcastUpdate!.channelName;
        const opts = Object.assign(
          {channelName***REMOVED***,
          options.broadcastUpdate!.options,
        );
        const plugin = moduleRegistry.use(
          'workbox-broadcast-update',
          'BroadcastUpdatePlugin',
        );

        plugins.push(`new ${plugin***REMOVED***(${stringifyWithoutComments(opts)***REMOVED***)`);
        break;
      ***REMOVED***

      case 'cacheableResponse': {
        const plugin = moduleRegistry.use(
          'workbox-cacheable-response',
          'CacheableResponsePlugin',
        );

        plugins.push(
          `new ${plugin***REMOVED***(${stringifyWithoutComments(
            options.cacheableResponse!,
          )***REMOVED***)`,
        );
        break;
      ***REMOVED***

      case 'expiration': {
        const plugin = moduleRegistry.use(
          'workbox-expiration',
          'ExpirationPlugin',
        );

        plugins.push(
          `new ${plugin***REMOVED***(${stringifyWithoutComments(options.expiration!)***REMOVED***)`,
        );
        break;
      ***REMOVED***

      case 'precacheFallback': {
        const plugin = moduleRegistry.use(
          'workbox-precaching',
          'PrecacheFallbackPlugin',
        );

        plugins.push(
          `new ${plugin***REMOVED***(${stringifyWithoutComments(
            options.precacheFallback!,
          )***REMOVED***)`,
        );
        break;
      ***REMOVED***

      case 'rangeRequests': {
        const plugin = moduleRegistry.use(
          'workbox-range-requests',
          'RangeRequestsPlugin',
        );

        // There are no configuration options for the constructor.
        plugins.push(`new ${plugin***REMOVED***()`);
        break;
      ***REMOVED***

      default: {
        throw new Error(
          // In the default case optionName is typed as 'never'.
          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
          `${errors['bad-runtime-caching-config']***REMOVED*** ${optionName***REMOVED***`,
        );
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  if (Object.keys(handlerOptions).length > 0 || plugins.length > 0) {
    const optionsString = JSON.stringify(handlerOptions).slice(1, -1);
    return ol`{
      ${optionsString ? optionsString + ',' : ''***REMOVED***
      plugins: [${plugins.join(', ')***REMOVED***]
    ***REMOVED***`;
  ***REMOVED*** else {
    return '';
  ***REMOVED***
***REMOVED***

export function runtimeCachingConverter(
  moduleRegistry: ModuleRegistry,
  runtimeCaching: Array<RuntimeCaching>,
): Array<string> {
  return runtimeCaching
    .map((entry) => {
      const method = entry.method || 'GET';

      if (!entry.urlPattern) {
        throw new Error(errors['urlPattern-is-required']);
      ***REMOVED***

      if (!entry.handler) {
        throw new Error(errors['handler-is-required']);
      ***REMOVED***

      if (
        entry.options &&
        entry.options.networkTimeoutSeconds &&
        entry.handler !== 'NetworkFirst'
      ) {
        throw new Error(errors['invalid-network-timeout-seconds']);
      ***REMOVED***

      // urlPattern might be a string, a RegExp object, or a function.
      // If it's a string, it needs to be quoted.
      const matcher =
        typeof entry.urlPattern === 'string'
          ? JSON.stringify(entry.urlPattern)
          : entry.urlPattern;

      const registerRoute = moduleRegistry.use(
        'workbox-routing',
        'registerRoute',
      );
      if (typeof entry.handler === 'string') {
        const optionsString = getOptionsString(moduleRegistry, entry.options);
        const handler = moduleRegistry.use('workbox-strategies', entry.handler);
        const strategyString = `new ${handler***REMOVED***(${optionsString***REMOVED***)`;

        return `${registerRoute***REMOVED***(${matcher.toString()***REMOVED***, ${strategyString***REMOVED***, '${method***REMOVED***');\n`;
      ***REMOVED*** else if (typeof entry.handler === 'function') {
        return `${registerRoute***REMOVED***(${matcher.toString()***REMOVED***, ${entry.handler.toString()***REMOVED***, '${method***REMOVED***');\n`;
      ***REMOVED***

      // '' will be filtered out.
      return '';
    ***REMOVED***)
    .filter((entry) => Boolean(entry));
***REMOVED***
