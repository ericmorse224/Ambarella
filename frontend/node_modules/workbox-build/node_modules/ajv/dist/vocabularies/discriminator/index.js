"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const codegen_1 = require("../../compile/codegen");
const types_1 = require("../discriminator/types");
const compile_1 = require("../../compile");
const ref_error_1 = require("../../compile/ref_error");
const util_1 = require("../../compile/util");
const error = {
    message: ({ params: { discrError, tagName ***REMOVED*** ***REMOVED***) => discrError === types_1.DiscrError.Tag
        ? `tag "${tagName***REMOVED***" must be string`
        : `value of tag "${tagName***REMOVED***" must be in oneOf`,
    params: ({ params: { discrError, tag, tagName ***REMOVED*** ***REMOVED***) => (0, codegen_1._) `{error: ${discrError***REMOVED***, tag: ${tagName***REMOVED***, tagValue: ${tag***REMOVED******REMOVED***`,
***REMOVED***;
const def = {
    keyword: "discriminator",
    type: "object",
    schemaType: "object",
    error,
    code(cxt) {
        const { gen, data, schema, parentSchema, it ***REMOVED*** = cxt;
        const { oneOf ***REMOVED*** = parentSchema;
        if (!it.opts.discriminator) {
            throw new Error("discriminator: requires discriminator option");
        ***REMOVED***
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
            throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
            throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
            throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._) `${data***REMOVED***${(0, codegen_1.getProperty)(tagName)***REMOVED***`);
        gen.if((0, codegen_1._) `typeof ${tag***REMOVED*** == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName ***REMOVED***));
        cxt.ok(valid);
        function validateMapping() {
            const mapping = getMapping();
            gen.if(false);
            for (const tagValue in mapping) {
                gen.elseIf((0, codegen_1._) `${tag***REMOVED*** === ${tagValue***REMOVED***`);
                gen.assign(valid, applyTagSchema(mapping[tagValue]));
            ***REMOVED***
            gen.else();
            cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName ***REMOVED***);
            gen.endIf();
        ***REMOVED***
        function applyTagSchema(schemaProp) {
            const _valid = gen.name("valid");
            const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp ***REMOVED***, _valid);
            cxt.mergeEvaluated(schCxt, codegen_1.Name);
            return _valid;
        ***REMOVED***
        function getMapping() {
            var _a;
            const oneOfMapping = {***REMOVED***;
            const topRequired = hasRequired(parentSchema);
            let tagRequired = true;
            for (let i = 0; i < oneOf.length; i++) {
                let sch = oneOf[i];
                if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
                    const ref = sch.$ref;
                    sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
                    if (sch instanceof compile_1.SchemaEnv)
                        sch = sch.schema;
                    if (sch === undefined)
                        throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
                ***REMOVED***
                const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
                if (typeof propSch != "object") {
                    throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName***REMOVED***"`);
                ***REMOVED***
                tagRequired = tagRequired && (topRequired || hasRequired(sch));
                addMappings(propSch, i);
            ***REMOVED***
            if (!tagRequired)
                throw new Error(`discriminator: "${tagName***REMOVED***" must be required`);
            return oneOfMapping;
            function hasRequired({ required ***REMOVED***) {
                return Array.isArray(required) && required.includes(tagName);
            ***REMOVED***
            function addMappings(sch, i) {
                if (sch.const) {
                    addMapping(sch.const, i);
                ***REMOVED***
                else if (sch.enum) {
                    for (const tagValue of sch.enum) {
                        addMapping(tagValue, i);
                    ***REMOVED***
                ***REMOVED***
                else {
                    throw new Error(`discriminator: "properties/${tagName***REMOVED***" must have "const" or "enum"`);
                ***REMOVED***
            ***REMOVED***
            function addMapping(tagValue, i) {
                if (typeof tagValue != "string" || tagValue in oneOfMapping) {
                    throw new Error(`discriminator: "${tagName***REMOVED***" values must be unique strings`);
                ***REMOVED***
                oneOfMapping[tagValue] = i;
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***,
***REMOVED***;
exports.default = def;
//# sourceMappingURL=index.js.map