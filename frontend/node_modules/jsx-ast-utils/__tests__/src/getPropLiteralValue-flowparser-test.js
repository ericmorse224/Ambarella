/* eslint-env mocha */
/* eslint no-template-curly-in-string: 0 */
import assert from 'assert';
import {
  extractProp,
  describeIfNotBabylon,
  changePlugins,
  setParserName,
***REMOVED*** from '../helper';
import { getLiteralPropValue ***REMOVED*** from '../../src/getPropValue';

describe('getLiteralPropValue', () => {
  beforeEach(() => {
    setParserName('flow');
  ***REMOVED***);
  it('should export a function', () => {
    const expected = 'function';
    const actual = typeof getLiteralPropValue;

    assert.equal(actual, expected);
  ***REMOVED***);

  it('should return undefined when not provided with a JSXAttribute', () => {
    const expected = undefined;
    const actual = getLiteralPropValue(1);

    assert.equal(actual, expected);
  ***REMOVED***);

  it('should not throw error when trying to get value from unknown node type', () => {
    const prop = {
      type: 'JSXAttribute',
      value: {
        type: 'JSXExpressionContainer',
      ***REMOVED***,
    ***REMOVED***;
    let counter = 0;
    // eslint-disable-next-line no-console
    const errorOrig = console.error;
    // eslint-disable-next-line no-console
    console.error = () => {
      counter += 1;
    ***REMOVED***;
    let value;
    assert.doesNotThrow(() => {
      value = getLiteralPropValue(prop);
    ***REMOVED***, Error);

    assert.equal(null, value);
    assert.equal(counter, 1);
    // eslint-disable-next-line no-console
    console.error = errorOrig;
  ***REMOVED***);

  describe('Null', () => {
    it('should return true when no value is given', () => {
      const prop = extractProp('<div foo />');

      const expected = true;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('Literal', () => {
    it('should return correct string if value is a string', () => {
      const prop = extractProp('<div foo="bar" />');

      const expected = 'bar';
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should return correct string if value is a string expression', () => {
      const prop = extractProp('<div foo={"bar"***REMOVED*** />');

      const expected = 'bar';
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should return correct integer if value is a integer expression', () => {
      const prop = extractProp('<div foo={1***REMOVED*** />');

      const expected = 1;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should convert "true" to boolean type', () => {
      const prop = extractProp('<div foo="true" />');

      const expected = true;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should convert "TrUE" to boolean type', () => {
      const prop = extractProp('<div foo="TrUE" />');

      const expected = true;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should convert "false" to boolean type', () => {
      const prop = extractProp('<div foo="false" />');

      const expected = false;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should convert "FaLsE" to boolean type', () => {
      const prop = extractProp('<div foo="FaLsE" />');

      const expected = false;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should return String null when value is null', () => {
      const prop = extractProp('<div foo={null***REMOVED*** />');

      const expected = 'null';
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('JSXElement', () => {
    it('should return null', () => {
      const prop = extractProp('<div foo={<bar />***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('Identifier', () => {
    it('should return null', () => {
      const prop = extractProp('<div foo={bar***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should return undefined when identifier is literally `undefined`', () => {
      const prop = extractProp('<div foo={undefined***REMOVED*** />');

      const expected = undefined;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('Template literal', () => {
    it('should return template literal with vars wrapped in curly braces', () => {
      const prop = extractProp('<div foo={`bar ${baz***REMOVED***`***REMOVED*** />');

      const expected = 'bar {baz***REMOVED***';
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should return string "undefined" for expressions that evaluate to undefined', () => {
      const prop = extractProp('<div foo={`bar ${undefined***REMOVED***`***REMOVED*** />');

      const expected = 'bar undefined';
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('Tagged Template literal', () => {
    it('should return template literal with vars wrapped in curly braces', () => {
      const prop = extractProp('<div foo={noop`bar ${baz***REMOVED***`***REMOVED*** />');

      const expected = 'bar {baz***REMOVED***';
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should return string "undefined" for expressions that evaluate to undefined', () => {
      const prop = extractProp('<div foo={noop`bar ${undefined***REMOVED***`***REMOVED*** />');

      const expected = 'bar undefined';
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('Arrow function expression', () => {
    it('should return null', () => {
      const prop = extractProp('<div foo={ () => { return "bar"; ***REMOVED******REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('Function expression', () => {
    it('should return null', () => {
      const prop = extractProp('<div foo={ function() { return "bar"; ***REMOVED*** ***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('Logical expression', () => {
    it('should return null for && operator', () => {
      const prop = extractProp('<div foo={bar && baz***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should return null for || operator', () => {
      const prop = extractProp('<div foo={bar || baz***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('Member expression', () => {
    it('should return null', () => {
      const prop = extractProp('<div foo={bar.baz***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('Call expression', () => {
    it('should return null', () => {
      const prop = extractProp('<div foo={bar()***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('Unary expression', () => {
    it('should correctly evaluate an expression that prefixes with -', () => {
      const prop = extractProp('<div foo={-bar***REMOVED*** />');

      // -"bar" => NaN
      const expected = true;
      const actual = Number.isNaN(getLiteralPropValue(prop));

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with -', () => {
      const prop = extractProp('<div foo={-42***REMOVED*** />');

      const expected = -42;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with +', () => {
      const prop = extractProp('<div foo={+bar***REMOVED*** />');

      // +"bar" => NaN
      const expected = true;
      const actual = Number.isNaN(getLiteralPropValue(prop));

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with +', () => {
      const prop = extractProp('<div foo={+42***REMOVED*** />');

      const expected = 42;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with !', () => {
      const prop = extractProp('<div foo={!bar***REMOVED*** />');

      const expected = false; // !"bar" === false
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with ~', () => {
      const prop = extractProp('<div foo={~bar***REMOVED*** />');

      const expected = -1; // ~"bar" === -1
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should return true when evaluating `delete foo`', () => {
      const prop = extractProp('<div foo={delete x***REMOVED*** />');

      const expected = true;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should return undefined when evaluating `void foo`', () => {
      const prop = extractProp('<div foo={void x***REMOVED*** />');

      const expected = undefined;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    // TODO: We should fix this to check to see if we can evaluate it.
    it('should return undefined when evaluating `typeof foo`', () => {
      const prop = extractProp('<div foo={typeof x***REMOVED*** />');

      const expected = undefined;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('Update expression', () => {
    it('should correctly evaluate an expression that prefixes with ++', () => {
      const prop = extractProp('<div foo={++bar***REMOVED*** />');

      // ++"bar" => NaN
      const expected = true;
      const actual = Number.isNaN(getLiteralPropValue(prop));

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should correctly evaluate an expression that prefixes with --', () => {
      const prop = extractProp('<div foo={--bar***REMOVED*** />');

      // --"bar" => NaN
      const expected = true;
      const actual = Number.isNaN(getLiteralPropValue(prop));

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should correctly evaluate an expression that suffixes with ++', () => {
      const prop = extractProp('<div foo={bar++***REMOVED*** />');

      // "bar"++ => NaN
      const expected = true;
      const actual = Number.isNaN(getLiteralPropValue(prop));

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should correctly evaluate an expression that suffixes with --', () => {
      const prop = extractProp('<div foo={bar--***REMOVED*** />');

      // "bar"-- => NaN
      const expected = true;
      const actual = Number.isNaN(getLiteralPropValue(prop));

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('This expression', () => {
    it('should return null', () => {
      const prop = extractProp('<div foo={this***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('Conditional expression', () => {
    it('should return null', () => {
      const prop = extractProp('<div foo={bar ? baz : bam***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('Binary expression', () => {
    it('should return null', () => {
      const prop = extractProp('<div foo={1 == "1"***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('Object expression', () => {
    it('should return null', () => {
      const prop = extractProp('<div foo={ { bar: "baz" ***REMOVED*** ***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.deepEqual(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('New expression', () => {
    it('should return null', () => {
      const prop = extractProp('<div foo={new Bar()***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.deepEqual(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describe('Array expression', () => {
    it('should evaluate to correct representation of the the array in props', () => {
      const prop = extractProp('<div foo={["bar", 42, null]***REMOVED*** />');

      const expected = ['bar', 42];
      const actual = getLiteralPropValue(prop);

      assert.deepEqual(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  it('should return an empty array provided an empty array in props', () => {
    const prop = extractProp('<div foo={[]***REMOVED*** />');

    const expected = [];
    const actual = getLiteralPropValue(prop);

    assert.deepEqual(actual, expected);
  ***REMOVED***);

  describe('Bind expression', () => {
    it('should return null', () => {
      const prop = extractProp('<div foo={::this.handleClick***REMOVED*** />');

      const expected = 'null';
      const actual = getLiteralPropValue(prop);

      assert.deepEqual(actual, expected);
    ***REMOVED***);
  ***REMOVED***);

  describeIfNotBabylon('Typescript', () => {
    beforeEach(() => {
      changePlugins((pls) => [...pls, 'typescript']);
    ***REMOVED***);

    it('should return string representation of variable identifier wrapped in a Typescript non-null assertion', () => {
      const prop = extractProp('<div foo={bar!***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should return string representation of variable identifier wrapped in a deep Typescript non-null assertion', () => {
      const prop = extractProp('<div foo={(bar!)!***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);

    it('should return string representation of variable identifier wrapped in a Typescript type coercion', () => {
      changePlugins((pls) => [...pls, 'typescript']);
      const prop = extractProp('<div foo={bar as any***REMOVED*** />');

      const expected = null;
      const actual = getLiteralPropValue(prop);

      assert.equal(actual, expected);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***);
