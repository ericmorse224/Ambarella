'use strict';

const Select = require('./select');
const Form = require('./form');
const form = Form.prototype;

class Editable extends Select {
  constructor(options) {
    super({ ...options, multiple: true ***REMOVED***);
    this.align = [this.options.align, 'left'].find(v => v != null);
    this.emptyError = '';
    this.values = {***REMOVED***;
  ***REMOVED***

  dispatch(char, key) {
    let choice = this.focused;
    let parent = choice.parent || {***REMOVED***;
    if (!choice.editable && !parent.editable) {
      if (char === 'a' || char === 'i') return super[char]();
    ***REMOVED***
    return form.dispatch.call(this, char, key);
  ***REMOVED***

  append(char, key) {
    return form.append.call(this, char, key);
  ***REMOVED***

  delete(char, key) {
    return form.delete.call(this, char, key);
  ***REMOVED***

  space(char) {
    return this.focused.editable ? this.append(char) : super.space();
  ***REMOVED***

  number(char) {
    return this.focused.editable ? this.append(char) : super.number(char);
  ***REMOVED***

  next() {
    return this.focused.editable ? form.next.call(this) : super.next();
  ***REMOVED***

  prev() {
    return this.focused.editable ? form.prev.call(this) : super.prev();
  ***REMOVED***

  async indicator(choice, i) {
    let symbol = choice.indicator || '';
    let value = choice.editable ? symbol : super.indicator(choice, i);
    return await this.resolve(value, this.state, choice, i) || '';
  ***REMOVED***

  indent(choice) {
    return choice.role === 'heading' ? '' : (choice.editable ? ' ' : '  ');
  ***REMOVED***

  async renderChoice(choice, i) {
    choice.indent = '';
    if (choice.editable) return form.renderChoice.call(this, choice, i);
    return super.renderChoice(choice, i);
  ***REMOVED***

  error() {
    return '';
  ***REMOVED***

  footer() {
    return this.state.error;
  ***REMOVED***

  async validate() {
    let result = true;

    for (let choice of this.choices) {
      if (typeof choice.validate !== 'function') {
        continue;
      ***REMOVED***

      if (choice.role === 'heading') {
        continue;
      ***REMOVED***

      let val = choice.parent ? this.value[choice.parent.name] : this.value;

      if (choice.editable) {
        val = choice.value === choice.name ? choice.initial || '' : choice.value;
      ***REMOVED*** else if (!this.isDisabled(choice)) {
        val = choice.enabled === true;
      ***REMOVED***

      result = await choice.validate(val, this.state);

      if (result !== true) {
        break;
      ***REMOVED***
    ***REMOVED***

    if (result !== true) {
      this.state.error = typeof result === 'string' ? result : 'Invalid Input';
    ***REMOVED***

    return result;
  ***REMOVED***

  submit() {
    if (this.focused.newChoice === true) return super.submit();
    if (this.choices.some(ch => ch.newChoice)) {
      return this.alert();
    ***REMOVED***

    this.value = {***REMOVED***;

    for (let choice of this.choices) {
      let val = choice.parent ? this.value[choice.parent.name] : this.value;

      if (choice.role === 'heading') {
        this.value[choice.name] = {***REMOVED***;
        continue;
      ***REMOVED***

      if (choice.editable) {
        val[choice.name] = choice.value === choice.name
          ? (choice.initial || '')
          : choice.value;

      ***REMOVED*** else if (!this.isDisabled(choice)) {
        val[choice.name] = choice.enabled === true;
      ***REMOVED***
    ***REMOVED***

    return this.base.submit.call(this);
  ***REMOVED***
***REMOVED***

module.exports = Editable;
