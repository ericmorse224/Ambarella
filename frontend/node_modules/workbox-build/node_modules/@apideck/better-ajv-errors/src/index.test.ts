import Ajv from 'ajv';
import { JSONSchema6 ***REMOVED*** from 'json-schema';
import { betterAjvErrors ***REMOVED*** from './index';

describe('betterAjvErrors', () => {
  let ajv: Ajv;
  let schema: JSONSchema6;
  let data: Record<string, unknown>;

  beforeEach(() => {
    ajv = new Ajv({ allErrors: true ***REMOVED***);
    schema = {
      type: 'object',
      required: ['str'],
      properties: {
        str: {
          type: 'string',
        ***REMOVED***,
        enum: {
          type: 'string',
          enum: ['one', 'two'],
        ***REMOVED***,
        bounds: {
          type: 'number',
          minimum: 2,
          maximum: 4,
        ***REMOVED***,
        nested: {
          type: 'object',
          required: ['deepReq'],
          properties: {
            deepReq: {
              type: 'boolean',
            ***REMOVED***,
            deep: {
              type: 'string',
            ***REMOVED***,
          ***REMOVED***,
          additionalProperties: false,
        ***REMOVED***,
      ***REMOVED***,
      additionalProperties: false,
    ***REMOVED***;
  ***REMOVED***);

  describe('additionalProperties', () => {
    it('should handle additionalProperties=false', () => {
      data = {
        str: 'str',
        foo: 'bar',
      ***REMOVED***;
      ajv.validate(schema, data);
      const errors = betterAjvErrors({ data, schema, errors: ajv.errors ***REMOVED***);
      expect(errors).toEqual([
        {
          context: {
            errorType: 'additionalProperties',
          ***REMOVED***,
          message: "'foo' property is not expected to be here",
          path: '{base***REMOVED***',
        ***REMOVED***,
      ]);
    ***REMOVED***);

    it('should handle additionalProperties=true', () => {
      data = {
        str: 'str',
        foo: 'bar',
      ***REMOVED***;
      schema.additionalProperties = true;
      ajv.validate(schema, data);
      const errors = betterAjvErrors({ data, schema, errors: ajv.errors ***REMOVED***);
      expect(errors).toEqual([]);
    ***REMOVED***);

    it('should give suggestions when relevant', () => {
      data = {
        str: 'str',
        bonds: 'bar',
      ***REMOVED***;
      ajv.validate(schema, data);
      const errors = betterAjvErrors({ data, schema, errors: ajv.errors ***REMOVED***);
      expect(errors).toEqual([
        {
          context: {
            errorType: 'additionalProperties',
          ***REMOVED***,
          message: "'bonds' property is not expected to be here",
          path: '{base***REMOVED***',
          suggestion: "Did you mean property 'bounds'?",
        ***REMOVED***,
      ]);
    ***REMOVED***);

    it('should handle object schemas without properties', () => {
      data = {
        empty: { foo: 1 ***REMOVED***,
      ***REMOVED***;
      schema = {
        type: 'object',
        properties: {
          empty: {
            type: 'object',
            additionalProperties: false,
          ***REMOVED***,
        ***REMOVED***,
      ***REMOVED***;
      ajv.validate(schema, data);
      const errors = betterAjvErrors({ data, schema, errors: ajv.errors ***REMOVED***);
      expect(errors).toEqual([
        {
          context: {
            errorType: 'additionalProperties',
          ***REMOVED***,
          message: "'foo' property is not expected to be here",
          path: '{base***REMOVED***.empty',
        ***REMOVED***,
      ]);
    ***REMOVED***);
  ***REMOVED***);

  describe('required', () => {
    it('should handle required properties', () => {
      data = {
        nested: {***REMOVED***,
      ***REMOVED***;
      ajv.validate(schema, data);
      const errors = betterAjvErrors({ data, schema, errors: ajv.errors ***REMOVED***);
      expect(errors).toEqual([
        {
          context: {
            errorType: 'required',
          ***REMOVED***,
          message: "{base***REMOVED*** must have required property 'str'",
          path: '{base***REMOVED***',
        ***REMOVED***,
        {
          context: {
            errorType: 'required',
          ***REMOVED***,
          message: "{base***REMOVED***.nested must have required property 'deepReq'",
          path: '{base***REMOVED***.nested',
        ***REMOVED***,
      ]);
    ***REMOVED***);

    it('should handle multiple required properties', () => {
      schema = {
        type: 'object',
        required: ['req1', 'req2'],
        properties: {
          req1: {
            type: 'string',
          ***REMOVED***,
          req2: {
            type: 'string',
          ***REMOVED***,
        ***REMOVED***,
      ***REMOVED***;
      data = {***REMOVED***;
      ajv.validate(schema, data);
      const errors = betterAjvErrors({ data, schema, errors: ajv.errors ***REMOVED***);
      expect(errors).toEqual([
        {
          context: {
            errorType: 'required',
          ***REMOVED***,
          message: "{base***REMOVED*** must have required property 'req1'",
          path: '{base***REMOVED***',
        ***REMOVED***,
        {
          context: {
            errorType: 'required',
          ***REMOVED***,
          message: "{base***REMOVED*** must have required property 'req2'",
          path: '{base***REMOVED***',
        ***REMOVED***,
      ]);
    ***REMOVED***);
  ***REMOVED***);

  describe('type', () => {
    it('should handle type errors', () => {
      data = {
        str: 123,
      ***REMOVED***;
      ajv.validate(schema, data);
      const errors = betterAjvErrors({ data, schema, errors: ajv.errors ***REMOVED***);
      expect(errors).toEqual([
        {
          context: {
            errorType: 'type',
          ***REMOVED***,
          message: "'str' property type must be string",
          path: '{base***REMOVED***.str',
        ***REMOVED***,
      ]);
    ***REMOVED***);
  ***REMOVED***);

  describe('minimum/maximum', () => {
    it('should handle minimum/maximum errors', () => {
      data = {
        str: 'str',
        bounds: 123,
      ***REMOVED***;
      ajv.validate(schema, data);
      const errors = betterAjvErrors({ data, schema, errors: ajv.errors ***REMOVED***);
      expect(errors).toEqual([
        {
          context: {
            errorType: 'maximum',
          ***REMOVED***,
          message: "property 'bounds' must be <= 4",
          path: '{base***REMOVED***.bounds',
        ***REMOVED***,
      ]);
    ***REMOVED***);
  ***REMOVED***);

  describe('enum', () => {
    it('should handle enum errors', () => {
      data = {
        str: 'str',
        enum: 'zzzz',
      ***REMOVED***;
      ajv.validate(schema, data);
      const errors = betterAjvErrors({ data, schema, errors: ajv.errors ***REMOVED***);
      expect(errors).toEqual([
        {
          context: {
            errorType: 'enum',
            allowedValues: ['one', 'two'],
          ***REMOVED***,
          message: "'enum' property must be equal to one of the allowed values",
          path: '{base***REMOVED***.enum',
        ***REMOVED***,
      ]);
    ***REMOVED***);

    it('should provide suggestions when relevant', () => {
      data = {
        str: 'str',
        enum: 'pne',
      ***REMOVED***;
      ajv.validate(schema, data);
      const errors = betterAjvErrors({ data, schema, errors: ajv.errors ***REMOVED***);
      expect(errors).toEqual([
        {
          context: {
            errorType: 'enum',
            allowedValues: ['one', 'two'],
          ***REMOVED***,
          message: "'enum' property must be equal to one of the allowed values",
          path: '{base***REMOVED***.enum',
          suggestion: "Did you mean 'one'?",
        ***REMOVED***,
      ]);
    ***REMOVED***);

    it('should not crash on null value', () => {
      data = {
        type: null,
      ***REMOVED***;
      schema = {
        type: 'object',
        properties: {
          type: {
            type: 'string',
            enum: ['primary', 'secondary'],
          ***REMOVED***,
        ***REMOVED***,
      ***REMOVED***;
      ajv.validate(schema, data);
      const errors = betterAjvErrors({ data, schema, errors: ajv.errors ***REMOVED***);
      expect(errors).toEqual([
        {
          context: {
            allowedValues: ['primary', 'secondary'],
            errorType: 'enum',
          ***REMOVED***,
          message: "'type' property must be equal to one of the allowed values",
          path: '{base***REMOVED***.type',
        ***REMOVED***,
      ]);
    ***REMOVED***);
  ***REMOVED***);

  it('should handle array paths', () => {
    data = {
      custom: [{ foo: 'bar' ***REMOVED***, { aaa: 'zzz' ***REMOVED***],
    ***REMOVED***;
    schema = {
      type: 'object',
      properties: {
        custom: {
          type: 'array',
          items: {
            type: 'object',
            additionalProperties: false,
            properties: {
              id: {
                type: 'string',
              ***REMOVED***,
              title: {
                type: 'string',
              ***REMOVED***,
            ***REMOVED***,
          ***REMOVED***,
        ***REMOVED***,
      ***REMOVED***,
    ***REMOVED***;
    ajv.validate(schema, data);
    const errors = betterAjvErrors({ data, schema, errors: ajv.errors ***REMOVED***);
    expect(errors).toEqual([
      {
        context: {
          errorType: 'additionalProperties',
        ***REMOVED***,
        message: "'foo' property is not expected to be here",
        path: '{base***REMOVED***.custom.0',
      ***REMOVED***,
      {
        context: {
          errorType: 'additionalProperties',
        ***REMOVED***,
        message: "'aaa' property is not expected to be here",
        path: '{base***REMOVED***.custom.1',
      ***REMOVED***,
    ]);
  ***REMOVED***);

  it('should handle file $refs', () => {
    data = {
      child: [{ foo: 'bar' ***REMOVED***, { aaa: 'zzz' ***REMOVED***],
    ***REMOVED***;
    schema = {
      $id: 'http://example.com/schemas/Main.json',
      type: 'object',
      properties: {
        child: {
          type: 'array',
          items: {
            $ref: './Child.json',
          ***REMOVED***,
        ***REMOVED***,
      ***REMOVED***,
    ***REMOVED***;
    ajv.addSchema({
      $id: 'http://example.com/schemas/Child.json',
      additionalProperties: false,
      type: 'object',
      properties: {
        id: {
          type: 'string',
        ***REMOVED***,
      ***REMOVED***,
    ***REMOVED***);
    ajv.validate(schema, data);
    const errors = betterAjvErrors({ data, schema, errors: ajv.errors ***REMOVED***);
    expect(errors).toEqual([
      {
        context: {
          errorType: 'additionalProperties',
        ***REMOVED***,
        message: "'foo' property is not expected to be here",
        path: '{base***REMOVED***.child.0',
      ***REMOVED***,
      {
        context: {
          errorType: 'additionalProperties',
        ***REMOVED***,
        message: "'aaa' property is not expected to be here",
        path: '{base***REMOVED***.child.1',
      ***REMOVED***,
    ]);
  ***REMOVED***);

  it('should handle number enums', () => {
    data = {
      isLive: 2,
    ***REMOVED***;
    schema = {
      type: 'object',
      properties: {
        isLive: {
          type: 'integer',
          enum: [0, 1],
        ***REMOVED***,
      ***REMOVED***,
    ***REMOVED***;
    ajv.validate(schema, data);
    const errors = betterAjvErrors({ data, schema, errors: ajv.errors ***REMOVED***);
    expect(errors).toEqual([
      {
        context: {
          allowedValues: [0, 1],
          errorType: 'enum',
        ***REMOVED***,
        message: "'isLive' property must be equal to one of the allowed values",
        path: '{base***REMOVED***.isLive',
      ***REMOVED***,
    ]);
  ***REMOVED***);

  describe('const', () => {
    it('should handle const errors', () => {
      data = {
        const: 2,
      ***REMOVED***;
      schema = {
        type: 'object',
        properties: {
          const: {
            type: 'integer',
            const: 42,
          ***REMOVED***,
        ***REMOVED***,
      ***REMOVED***;
      ajv.validate(schema, data);
      const errors = betterAjvErrors({ data, schema, errors: ajv.errors ***REMOVED***);
      expect(errors).toEqual([
        {
          context: {
            allowedValue: 42,
            errorType: 'const',
          ***REMOVED***,
          message: "'const' property must be equal to the allowed value",
          path: '{base***REMOVED***.const',
        ***REMOVED***,
      ]);
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***);
