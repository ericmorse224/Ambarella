/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/

"use strict";

const RuntimeGlobals = require("../RuntimeGlobals");
const RuntimeModule = require("../RuntimeModule");
const Template = require("../Template");
const {
	chunkHasJs,
	getChunkFilenameTemplate
***REMOVED*** = require("../javascript/JavascriptModulesPlugin");
const { getInitialChunkIds ***REMOVED*** = require("../javascript/StartupHelpers");
const compileBooleanMatcher = require("../util/compileBooleanMatcher");
const { getUndoPath ***REMOVED*** = require("../util/identifier");

/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("../Module").ReadOnlyRuntimeRequirements***REMOVED*** ReadOnlyRuntimeRequirements */

class RequireChunkLoadingRuntimeModule extends RuntimeModule {
	/**
	 * @param {ReadOnlyRuntimeRequirements***REMOVED*** runtimeRequirements runtime requirements
	 */
	constructor(runtimeRequirements) {
		super("require chunk loading", RuntimeModule.STAGE_ATTACH);
		this.runtimeRequirements = runtimeRequirements;
	***REMOVED***

	/**
	 * @private
	 * @param {Chunk***REMOVED*** chunk chunk
	 * @param {string***REMOVED*** rootOutputDir root output directory
	 * @returns {string***REMOVED*** generated code
	 */
	_generateBaseUri(chunk, rootOutputDir) {
		const options = chunk.getEntryOptions();
		if (options && options.baseUri) {
			return `${RuntimeGlobals.baseURI***REMOVED*** = ${JSON.stringify(options.baseUri)***REMOVED***;`;
		***REMOVED***

		return `${RuntimeGlobals.baseURI***REMOVED*** = require("url").pathToFileURL(${
			rootOutputDir !== "./"
				? `__dirname + ${JSON.stringify(`/${rootOutputDir***REMOVED***`)***REMOVED***`
				: "__filename"
		***REMOVED***);`;
	***REMOVED***

	/**
	 * @returns {string | null***REMOVED*** runtime code
	 */
	generate() {
		const compilation = /** @type {Compilation***REMOVED*** */ (this.compilation);
		const chunkGraph = /** @type {ChunkGraph***REMOVED*** */ (this.chunkGraph);
		const chunk = /** @type {Chunk***REMOVED*** */ (this.chunk);
		const { runtimeTemplate ***REMOVED*** = compilation;
		const fn = RuntimeGlobals.ensureChunkHandlers;
		const withBaseURI = this.runtimeRequirements.has(RuntimeGlobals.baseURI);
		const withExternalInstallChunk = this.runtimeRequirements.has(
			RuntimeGlobals.externalInstallChunk
		);
		const withOnChunkLoad = this.runtimeRequirements.has(
			RuntimeGlobals.onChunksLoaded
		);
		const withLoading = this.runtimeRequirements.has(
			RuntimeGlobals.ensureChunkHandlers
		);
		const withHmr = this.runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadUpdateHandlers
		);
		const withHmrManifest = this.runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadManifest
		);
		const conditionMap = chunkGraph.getChunkConditionMap(chunk, chunkHasJs);
		const hasJsMatcher = compileBooleanMatcher(conditionMap);
		const initialChunkIds = getInitialChunkIds(chunk, chunkGraph, chunkHasJs);

		const outputName = compilation.getPath(
			getChunkFilenameTemplate(chunk, compilation.outputOptions),
			{
				chunk,
				contentHashType: "javascript"
			***REMOVED***
		);
		const rootOutputDir = getUndoPath(
			outputName,
			/** @type {string***REMOVED*** */ (compilation.outputOptions.path),
			true
		);

		const stateExpression = withHmr
			? `${RuntimeGlobals.hmrRuntimeStatePrefix***REMOVED***_require`
			: undefined;

		return Template.asString([
			withBaseURI
				? this._generateBaseUri(chunk, rootOutputDir)
				: "// no baseURI",
			"",
			"// object to store loaded chunks",
			'// "1" means "loaded", otherwise not loaded yet',
			`var installedChunks = ${
				stateExpression ? `${stateExpression***REMOVED*** = ${stateExpression***REMOVED*** || ` : ""
			***REMOVED***{`,
			Template.indent(
				Array.from(initialChunkIds, id => `${JSON.stringify(id)***REMOVED***: 1`).join(
					",\n"
				)
			),
			"***REMOVED***;",
			"",
			withOnChunkLoad
				? `${
						RuntimeGlobals.onChunksLoaded
					***REMOVED***.require = ${runtimeTemplate.returningFunction(
						"installedChunks[chunkId]",
						"chunkId"
					)***REMOVED***;`
				: "// no on chunks loaded",
			"",
			withLoading || withExternalInstallChunk
				? `var installChunk = ${runtimeTemplate.basicFunction("chunk", [
						"var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;",
						"for(var moduleId in moreModules) {",
						Template.indent([
							`if(${RuntimeGlobals.hasOwnProperty***REMOVED***(moreModules, moduleId)) {`,
							Template.indent([
								`${RuntimeGlobals.moduleFactories***REMOVED***[moduleId] = moreModules[moduleId];`
							]),
							"***REMOVED***"
						]),
						"***REMOVED***",
						`if(runtime) runtime(${RuntimeGlobals.require***REMOVED***);`,
						"for(var i = 0; i < chunkIds.length; i++)",
						Template.indent("installedChunks[chunkIds[i]] = 1;"),
						withOnChunkLoad ? `${RuntimeGlobals.onChunksLoaded***REMOVED***();` : ""
					])***REMOVED***;`
				: "// no chunk install function needed",
			"",
			withLoading
				? Template.asString([
						"// require() chunk loading for javascript",
						`${fn***REMOVED***.require = ${runtimeTemplate.basicFunction(
							"chunkId, promises",
							hasJsMatcher !== false
								? [
										'// "1" is the signal for "already loaded"',
										"if(!installedChunks[chunkId]) {",
										Template.indent([
											hasJsMatcher === true
												? "if(true) { // all chunks have JS"
												: `if(${hasJsMatcher("chunkId")***REMOVED***) {`,
											Template.indent([
												`installChunk(require(${JSON.stringify(
													rootOutputDir
												)***REMOVED*** + ${
													RuntimeGlobals.getChunkScriptFilename
												***REMOVED***(chunkId)));`
											]),
											"***REMOVED*** else installedChunks[chunkId] = 1;",
											""
										]),
										"***REMOVED***"
									]
								: "installedChunks[chunkId] = 1;"
						)***REMOVED***;`
					])
				: "// no chunk loading",
			"",
			withExternalInstallChunk
				? Template.asString([
						`module.exports = ${RuntimeGlobals.require***REMOVED***;`,
						`${RuntimeGlobals.externalInstallChunk***REMOVED*** = installChunk;`
					])
				: "// no external install chunk",
			"",
			withHmr
				? Template.asString([
						"function loadUpdateChunk(chunkId, updatedModulesList) {",
						Template.indent([
							`var update = require(${JSON.stringify(rootOutputDir)***REMOVED*** + ${
								RuntimeGlobals.getChunkUpdateScriptFilename
							***REMOVED***(chunkId));`,
							"var updatedModules = update.modules;",
							"var runtime = update.runtime;",
							"for(var moduleId in updatedModules) {",
							Template.indent([
								`if(${RuntimeGlobals.hasOwnProperty***REMOVED***(updatedModules, moduleId)) {`,
								Template.indent([
									"currentUpdate[moduleId] = updatedModules[moduleId];",
									"if(updatedModulesList) updatedModulesList.push(moduleId);"
								]),
								"***REMOVED***"
							]),
							"***REMOVED***",
							"if(runtime) currentUpdateRuntime.push(runtime);"
						]),
						"***REMOVED***",
						"",
						Template.getFunctionContent(
							require("../hmr/JavascriptHotModuleReplacement.runtime.js")
						)
							.replace(/\$key\$/g, "require")
							.replace(/\$installedChunks\$/g, "installedChunks")
							.replace(/\$loadUpdateChunk\$/g, "loadUpdateChunk")
							.replace(/\$moduleCache\$/g, RuntimeGlobals.moduleCache)
							.replace(/\$moduleFactories\$/g, RuntimeGlobals.moduleFactories)
							.replace(
								/\$ensureChunkHandlers\$/g,
								RuntimeGlobals.ensureChunkHandlers
							)
							.replace(/\$hasOwnProperty\$/g, RuntimeGlobals.hasOwnProperty)
							.replace(/\$hmrModuleData\$/g, RuntimeGlobals.hmrModuleData)
							.replace(
								/\$hmrDownloadUpdateHandlers\$/g,
								RuntimeGlobals.hmrDownloadUpdateHandlers
							)
							.replace(
								/\$hmrInvalidateModuleHandlers\$/g,
								RuntimeGlobals.hmrInvalidateModuleHandlers
							)
					])
				: "// no HMR",
			"",
			withHmrManifest
				? Template.asString([
						`${RuntimeGlobals.hmrDownloadManifest***REMOVED*** = function() {`,
						Template.indent([
							"return Promise.resolve().then(function() {",
							Template.indent([
								`return require(${JSON.stringify(rootOutputDir)***REMOVED*** + ${
									RuntimeGlobals.getUpdateManifestFilename
								***REMOVED***());`
							]),
							"***REMOVED***)['catch'](function(err) { if(err.code !== 'MODULE_NOT_FOUND') throw err; ***REMOVED***);"
						]),
						"***REMOVED***"
					])
				: "// no HMR manifest"
		]);
	***REMOVED***
***REMOVED***

module.exports = RequireChunkLoadingRuntimeModule;
