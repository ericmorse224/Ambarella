"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const types_1 = require("./types");
const __1 = require("..");
const codegen_1 = require("../codegen");
const ref_error_1 = require("../ref_error");
const names_1 = require("../names");
const code_1 = require("../../vocabularies/code");
const ref_1 = require("../../vocabularies/jtd/ref");
const util_1 = require("../util");
const quote_1 = require("../../runtime/quote");
const genSerialize = {
    elements: serializeElements,
    values: serializeValues,
    discriminator: serializeDiscriminator,
    properties: serializeProperties,
    optionalProperties: serializeProperties,
    enum: serializeString,
    type: serializeType,
    ref: serializeRef,
***REMOVED***;
function compileSerializer(sch, definitions) {
    const _sch = __1.getCompilingSchema.call(this, sch);
    if (_sch)
        return _sch;
    const { es5, lines ***REMOVED*** = this.opts.code;
    const { ownProperties ***REMOVED*** = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties ***REMOVED***);
    const serializeName = gen.scopeName("serialize");
    const cxt = {
        self: this,
        gen,
        schema: sch.schema,
        schemaEnv: sch,
        definitions,
        data: names_1.default.data,
    ***REMOVED***;
    let sourceCode;
    try {
        this._compilations.add(sch);
        sch.serializeName = serializeName;
        gen.func(serializeName, names_1.default.data, false, () => {
            gen.let(names_1.default.json, (0, codegen_1.str) ``);
            serializeCode(cxt);
            gen.return(names_1.default.json);
        ***REMOVED***);
        gen.optimize(this.opts.code.optimize);
        const serializeFuncCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)***REMOVED***return ${serializeFuncCode***REMOVED***`;
        const makeSerialize = new Function(`${names_1.default.scope***REMOVED***`, sourceCode);
        const serialize = makeSerialize(this.scope.get());
        this.scope.value(serializeName, { ref: serialize ***REMOVED***);
        sch.serialize = serialize;
    ***REMOVED***
    catch (e) {
        if (sourceCode)
            this.logger.error("Error compiling serializer, function code:", sourceCode);
        delete sch.serialize;
        delete sch.serializeName;
        throw e;
    ***REMOVED***
    finally {
        this._compilations.delete(sch);
    ***REMOVED***
    return sch;
***REMOVED***
exports.default = compileSerializer;
function serializeCode(cxt) {
    let form;
    for (const key of types_1.jtdForms) {
        if (key in cxt.schema) {
            form = key;
            break;
        ***REMOVED***
    ***REMOVED***
    serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty);
***REMOVED***
function serializeNullable(cxt, serializeForm) {
    const { gen, schema, data ***REMOVED*** = cxt;
    if (!schema.nullable)
        return serializeForm(cxt);
    gen.if((0, codegen_1._) `${data***REMOVED*** === undefined || ${data***REMOVED*** === null`, () => gen.add(names_1.default.json, (0, codegen_1._) `"null"`), () => serializeForm(cxt));
***REMOVED***
function serializeElements(cxt) {
    const { gen, schema, data ***REMOVED*** = cxt;
    gen.add(names_1.default.json, (0, codegen_1.str) `[`);
    const first = gen.let("first", true);
    gen.forOf("el", data, (el) => {
        addComma(cxt, first);
        serializeCode({ ...cxt, schema: schema.elements, data: el ***REMOVED***);
    ***REMOVED***);
    gen.add(names_1.default.json, (0, codegen_1.str) `]`);
***REMOVED***
function serializeValues(cxt) {
    const { gen, schema, data ***REMOVED*** = cxt;
    gen.add(names_1.default.json, (0, codegen_1.str) `{`);
    const first = gen.let("first", true);
    gen.forIn("key", data, (key) => serializeKeyValue(cxt, key, schema.values, first));
    gen.add(names_1.default.json, (0, codegen_1.str) `***REMOVED***`);
***REMOVED***
function serializeKeyValue(cxt, key, schema, first) {
    const { gen, data ***REMOVED*** = cxt;
    addComma(cxt, first);
    serializeString({ ...cxt, data: key ***REMOVED***);
    gen.add(names_1.default.json, (0, codegen_1.str) `:`);
    const value = gen.const("value", (0, codegen_1._) `${data***REMOVED***${(0, codegen_1.getProperty)(key)***REMOVED***`);
    serializeCode({ ...cxt, schema, data: value ***REMOVED***);
***REMOVED***
function serializeDiscriminator(cxt) {
    const { gen, schema, data ***REMOVED*** = cxt;
    const { discriminator ***REMOVED*** = schema;
    gen.add(names_1.default.json, (0, codegen_1.str) `{${JSON.stringify(discriminator)***REMOVED***:`);
    const tag = gen.const("tag", (0, codegen_1._) `${data***REMOVED***${(0, codegen_1.getProperty)(discriminator)***REMOVED***`);
    serializeString({ ...cxt, data: tag ***REMOVED***);
    gen.if(false);
    for (const tagValue in schema.mapping) {
        gen.elseIf((0, codegen_1._) `${tag***REMOVED*** === ${tagValue***REMOVED***`);
        const sch = schema.mapping[tagValue];
        serializeSchemaProperties({ ...cxt, schema: sch ***REMOVED***, discriminator);
    ***REMOVED***
    gen.endIf();
    gen.add(names_1.default.json, (0, codegen_1.str) `***REMOVED***`);
***REMOVED***
function serializeProperties(cxt) {
    const { gen ***REMOVED*** = cxt;
    gen.add(names_1.default.json, (0, codegen_1.str) `{`);
    serializeSchemaProperties(cxt);
    gen.add(names_1.default.json, (0, codegen_1.str) `***REMOVED***`);
***REMOVED***
function serializeSchemaProperties(cxt, discriminator) {
    const { gen, schema, data ***REMOVED*** = cxt;
    const { properties, optionalProperties ***REMOVED*** = schema;
    const props = keys(properties);
    const optProps = keys(optionalProperties);
    const allProps = allProperties(props.concat(optProps));
    let first = !discriminator;
    let firstProp;
    for (const key of props) {
        if (first)
            first = false;
        else
            gen.add(names_1.default.json, (0, codegen_1.str) `,`);
        serializeProperty(key, properties[key], keyValue(key));
    ***REMOVED***
    if (first)
        firstProp = gen.let("first", true);
    for (const key of optProps) {
        const value = keyValue(key);
        gen.if((0, codegen_1.and)((0, codegen_1._) `${value***REMOVED*** !== undefined`, (0, code_1.isOwnProperty)(gen, data, key)), () => {
            addComma(cxt, firstProp);
            serializeProperty(key, optionalProperties[key], value);
        ***REMOVED***);
    ***REMOVED***
    if (schema.additionalProperties) {
        gen.forIn("key", data, (key) => gen.if(isAdditional(key, allProps), () => serializeKeyValue(cxt, key, {***REMOVED***, firstProp)));
    ***REMOVED***
    function keys(ps) {
        return ps ? Object.keys(ps) : [];
    ***REMOVED***
    function allProperties(ps) {
        if (discriminator)
            ps.push(discriminator);
        if (new Set(ps).size !== ps.length) {
            throw new Error("JTD: properties/optionalProperties/disciminator overlap");
        ***REMOVED***
        return ps;
    ***REMOVED***
    function keyValue(key) {
        return gen.const("value", (0, codegen_1._) `${data***REMOVED***${(0, codegen_1.getProperty)(key)***REMOVED***`);
    ***REMOVED***
    function serializeProperty(key, propSchema, value) {
        gen.add(names_1.default.json, (0, codegen_1.str) `${JSON.stringify(key)***REMOVED***:`);
        serializeCode({ ...cxt, schema: propSchema, data: value ***REMOVED***);
    ***REMOVED***
    function isAdditional(key, ps) {
        return ps.length ? (0, codegen_1.and)(...ps.map((p) => (0, codegen_1._) `${key***REMOVED*** !== ${p***REMOVED***`)) : true;
    ***REMOVED***
***REMOVED***
function serializeType(cxt) {
    const { gen, schema, data ***REMOVED*** = cxt;
    switch (schema.type) {
        case "boolean":
            gen.add(names_1.default.json, (0, codegen_1._) `${data***REMOVED*** ? "true" : "false"`);
            break;
        case "string":
            serializeString(cxt);
            break;
        case "timestamp":
            gen.if((0, codegen_1._) `${data***REMOVED*** instanceof Date`, () => gen.add(names_1.default.json, (0, codegen_1._) `'"' + ${data***REMOVED***.toISOString() + '"'`), () => serializeString(cxt));
            break;
        default:
            serializeNumber(cxt);
    ***REMOVED***
***REMOVED***
function serializeString({ gen, data ***REMOVED***) {
    gen.add(names_1.default.json, (0, codegen_1._) `${(0, util_1.useFunc)(gen, quote_1.default)***REMOVED***(${data***REMOVED***)`);
***REMOVED***
function serializeNumber({ gen, data ***REMOVED***) {
    gen.add(names_1.default.json, (0, codegen_1._) `"" + ${data***REMOVED***`);
***REMOVED***
function serializeRef(cxt) {
    const { gen, self, data, definitions, schema, schemaEnv ***REMOVED*** = cxt;
    const { ref ***REMOVED*** = schema;
    const refSchema = definitions[ref];
    if (!refSchema)
        throw new ref_error_1.default(self.opts.uriResolver, "", ref, `No definition ${ref***REMOVED***`);
    if (!(0, ref_1.hasRef)(refSchema))
        return serializeCode({ ...cxt, schema: refSchema ***REMOVED***);
    const { root ***REMOVED*** = schemaEnv;
    const sch = compileSerializer.call(self, new __1.SchemaEnv({ schema: refSchema, root ***REMOVED***), definitions);
    gen.add(names_1.default.json, (0, codegen_1._) `${getSerialize(gen, sch)***REMOVED***(${data***REMOVED***)`);
***REMOVED***
function getSerialize(gen, sch) {
    return sch.serialize
        ? gen.scopeValue("serialize", { ref: sch.serialize ***REMOVED***)
        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch ***REMOVED***)***REMOVED***.serialize`;
***REMOVED***
function serializeEmpty({ gen, data ***REMOVED***) {
    gen.add(names_1.default.json, (0, codegen_1._) `JSON.stringify(${data***REMOVED***)`);
***REMOVED***
function addComma({ gen ***REMOVED***, first) {
    if (first) {
        gen.if(first, () => gen.assign(first, false), () => gen.add(names_1.default.json, (0, codegen_1.str) `,`));
    ***REMOVED***
    else {
        gen.add(names_1.default.json, (0, codegen_1.str) `,`);
    ***REMOVED***
***REMOVED***
//# sourceMappingURL=serialize.js.map