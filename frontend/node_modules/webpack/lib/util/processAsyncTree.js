/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

/**
 * @template T
 * @template {Error***REMOVED*** E
 * @param {Iterable<T>***REMOVED*** items initial items
 * @param {number***REMOVED*** concurrency number of items running in parallel
 * @param {(item: T, push: (item: T) => void, callback: (err?: E) => void) => void***REMOVED*** processor worker which pushes more items
 * @param {(err?: E) => void***REMOVED*** callback all items processed
 * @returns {void***REMOVED***
 */
const processAsyncTree = (items, concurrency, processor, callback) => {
	const queue = Array.from(items);
	if (queue.length === 0) return callback();
	let processing = 0;
	let finished = false;
	let processScheduled = true;

	/**
	 * @param {T***REMOVED*** item item
	 */
	const push = item => {
		queue.push(item);
		if (!processScheduled && processing < concurrency) {
			processScheduled = true;
			process.nextTick(processQueue);
		***REMOVED***
	***REMOVED***;

	/**
	 * @param {E | null | undefined***REMOVED*** err error
	 */
	const processorCallback = err => {
		processing--;
		if (err && !finished) {
			finished = true;
			callback(err);
			return;
		***REMOVED***
		if (!processScheduled) {
			processScheduled = true;
			process.nextTick(processQueue);
		***REMOVED***
	***REMOVED***;

	const processQueue = () => {
		if (finished) return;
		while (processing < concurrency && queue.length > 0) {
			processing++;
			const item = /** @type {T***REMOVED*** */ (queue.pop());
			processor(item, push, processorCallback);
		***REMOVED***
		processScheduled = false;
		if (queue.length === 0 && processing === 0 && !finished) {
			finished = true;
			callback();
		***REMOVED***
	***REMOVED***;

	processQueue();
***REMOVED***;

module.exports = processAsyncTree;
