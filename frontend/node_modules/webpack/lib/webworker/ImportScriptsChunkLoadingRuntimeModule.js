/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/

"use strict";

const RuntimeGlobals = require("../RuntimeGlobals");
const RuntimeModule = require("../RuntimeModule");
const Template = require("../Template");
const {
	getChunkFilenameTemplate,
	chunkHasJs
***REMOVED*** = require("../javascript/JavascriptModulesPlugin");
const { getInitialChunkIds ***REMOVED*** = require("../javascript/StartupHelpers");
const compileBooleanMatcher = require("../util/compileBooleanMatcher");
const { getUndoPath ***REMOVED*** = require("../util/identifier");

/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("../Module").ReadOnlyRuntimeRequirements***REMOVED*** ReadOnlyRuntimeRequirements */

class ImportScriptsChunkLoadingRuntimeModule extends RuntimeModule {
	/**
	 * @param {ReadOnlyRuntimeRequirements***REMOVED*** runtimeRequirements runtime requirements
	 * @param {boolean***REMOVED*** withCreateScriptUrl with createScriptUrl support
	 */
	constructor(runtimeRequirements, withCreateScriptUrl) {
		super("importScripts chunk loading", RuntimeModule.STAGE_ATTACH);
		this.runtimeRequirements = runtimeRequirements;
		this._withCreateScriptUrl = withCreateScriptUrl;
	***REMOVED***

	/**
	 * @private
	 * @param {Chunk***REMOVED*** chunk chunk
	 * @returns {string***REMOVED*** generated code
	 */
	_generateBaseUri(chunk) {
		const options = chunk.getEntryOptions();
		if (options && options.baseUri) {
			return `${RuntimeGlobals.baseURI***REMOVED*** = ${JSON.stringify(options.baseUri)***REMOVED***;`;
		***REMOVED***
		const compilation = /** @type {Compilation***REMOVED*** */ (this.compilation);
		const outputName = compilation.getPath(
			getChunkFilenameTemplate(chunk, compilation.outputOptions),
			{
				chunk,
				contentHashType: "javascript"
			***REMOVED***
		);
		const rootOutputDir = getUndoPath(
			outputName,
			/** @type {string***REMOVED*** */ (compilation.outputOptions.path),
			false
		);
		return `${RuntimeGlobals.baseURI***REMOVED*** = self.location + ${JSON.stringify(
			rootOutputDir ? `/../${rootOutputDir***REMOVED***` : ""
		)***REMOVED***;`;
	***REMOVED***

	/**
	 * @returns {string | null***REMOVED*** runtime code
	 */
	generate() {
		const compilation = /** @type {Compilation***REMOVED*** */ (this.compilation);
		const fn = RuntimeGlobals.ensureChunkHandlers;
		const withBaseURI = this.runtimeRequirements.has(RuntimeGlobals.baseURI);
		const withLoading = this.runtimeRequirements.has(
			RuntimeGlobals.ensureChunkHandlers
		);
		const withCallback = this.runtimeRequirements.has(
			RuntimeGlobals.chunkCallback
		);
		const withHmr = this.runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadUpdateHandlers
		);
		const withHmrManifest = this.runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadManifest
		);
		const globalObject = compilation.runtimeTemplate.globalObject;
		const chunkLoadingGlobalExpr = `${globalObject***REMOVED***[${JSON.stringify(
			compilation.outputOptions.chunkLoadingGlobal
		)***REMOVED***]`;
		const chunkGraph = /** @type {ChunkGraph***REMOVED*** */ (this.chunkGraph);
		const chunk = /** @type {Chunk***REMOVED*** */ (this.chunk);
		const hasJsMatcher = compileBooleanMatcher(
			chunkGraph.getChunkConditionMap(chunk, chunkHasJs)
		);
		const initialChunkIds = getInitialChunkIds(chunk, chunkGraph, chunkHasJs);

		const stateExpression = withHmr
			? `${RuntimeGlobals.hmrRuntimeStatePrefix***REMOVED***_importScripts`
			: undefined;
		const runtimeTemplate = compilation.runtimeTemplate;
		const { _withCreateScriptUrl: withCreateScriptUrl ***REMOVED*** = this;

		return Template.asString([
			withBaseURI ? this._generateBaseUri(chunk) : "// no baseURI",
			"",
			"// object to store loaded chunks",
			'// "1" means "already loaded"',
			`var installedChunks = ${
				stateExpression ? `${stateExpression***REMOVED*** = ${stateExpression***REMOVED*** || ` : ""
			***REMOVED***{`,
			Template.indent(
				Array.from(initialChunkIds, id => `${JSON.stringify(id)***REMOVED***: 1`).join(
					",\n"
				)
			),
			"***REMOVED***;",
			"",
			withCallback || withLoading
				? Template.asString([
						"// importScripts chunk loading",
						`var installChunk = ${runtimeTemplate.basicFunction("data", [
							runtimeTemplate.destructureArray(
								["chunkIds", "moreModules", "runtime"],
								"data"
							),
							"for(var moduleId in moreModules) {",
							Template.indent([
								`if(${RuntimeGlobals.hasOwnProperty***REMOVED***(moreModules, moduleId)) {`,
								Template.indent(
									`${RuntimeGlobals.moduleFactories***REMOVED***[moduleId] = moreModules[moduleId];`
								),
								"***REMOVED***"
							]),
							"***REMOVED***",
							`if(runtime) runtime(${RuntimeGlobals.require***REMOVED***);`,
							"while(chunkIds.length)",
							Template.indent("installedChunks[chunkIds.pop()] = 1;"),
							"parentChunkLoadingFunction(data);"
						])***REMOVED***;`
					])
				: "// no chunk install function needed",
			withCallback || withLoading
				? Template.asString([
						withLoading
							? `${fn***REMOVED***.i = ${runtimeTemplate.basicFunction(
									"chunkId, promises",
									hasJsMatcher !== false
										? [
												'// "1" is the signal for "already loaded"',
												"if(!installedChunks[chunkId]) {",
												Template.indent([
													hasJsMatcher === true
														? "if(true) { // all chunks have JS"
														: `if(${hasJsMatcher("chunkId")***REMOVED***) {`,
													Template.indent(
														`importScripts(${
															withCreateScriptUrl
																? `${RuntimeGlobals.createScriptUrl***REMOVED***(${RuntimeGlobals.publicPath***REMOVED*** + ${RuntimeGlobals.getChunkScriptFilename***REMOVED***(chunkId))`
																: `${RuntimeGlobals.publicPath***REMOVED*** + ${RuntimeGlobals.getChunkScriptFilename***REMOVED***(chunkId)`
														***REMOVED***);`
													),
													"***REMOVED***"
												]),
												"***REMOVED***"
											]
										: "installedChunks[chunkId] = 1;"
								)***REMOVED***;`
							: "",
						"",
						`var chunkLoadingGlobal = ${chunkLoadingGlobalExpr***REMOVED*** = ${chunkLoadingGlobalExpr***REMOVED*** || [];`,
						"var parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);",
						"chunkLoadingGlobal.push = installChunk;"
					])
				: "// no chunk loading",
			"",
			withHmr
				? Template.asString([
						"function loadUpdateChunk(chunkId, updatedModulesList) {",
						Template.indent([
							"var success = false;",
							`${globalObject***REMOVED***[${JSON.stringify(
								compilation.outputOptions.hotUpdateGlobal
							)***REMOVED***] = ${runtimeTemplate.basicFunction("_, moreModules, runtime", [
								"for(var moduleId in moreModules) {",
								Template.indent([
									`if(${RuntimeGlobals.hasOwnProperty***REMOVED***(moreModules, moduleId)) {`,
									Template.indent([
										"currentUpdate[moduleId] = moreModules[moduleId];",
										"if(updatedModulesList) updatedModulesList.push(moduleId);"
									]),
									"***REMOVED***"
								]),
								"***REMOVED***",
								"if(runtime) currentUpdateRuntime.push(runtime);",
								"success = true;"
							])***REMOVED***;`,
							"// start update chunk loading",
							`importScripts(${
								withCreateScriptUrl
									? `${RuntimeGlobals.createScriptUrl***REMOVED***(${RuntimeGlobals.publicPath***REMOVED*** + ${RuntimeGlobals.getChunkUpdateScriptFilename***REMOVED***(chunkId))`
									: `${RuntimeGlobals.publicPath***REMOVED*** + ${RuntimeGlobals.getChunkUpdateScriptFilename***REMOVED***(chunkId)`
							***REMOVED***);`,
							'if(!success) throw new Error("Loading update chunk failed for unknown reason");'
						]),
						"***REMOVED***",
						"",
						Template.getFunctionContent(
							require("../hmr/JavascriptHotModuleReplacement.runtime.js")
						)
							.replace(/\$key\$/g, "importScripts")
							.replace(/\$installedChunks\$/g, "installedChunks")
							.replace(/\$loadUpdateChunk\$/g, "loadUpdateChunk")
							.replace(/\$moduleCache\$/g, RuntimeGlobals.moduleCache)
							.replace(/\$moduleFactories\$/g, RuntimeGlobals.moduleFactories)
							.replace(
								/\$ensureChunkHandlers\$/g,
								RuntimeGlobals.ensureChunkHandlers
							)
							.replace(/\$hasOwnProperty\$/g, RuntimeGlobals.hasOwnProperty)
							.replace(/\$hmrModuleData\$/g, RuntimeGlobals.hmrModuleData)
							.replace(
								/\$hmrDownloadUpdateHandlers\$/g,
								RuntimeGlobals.hmrDownloadUpdateHandlers
							)
							.replace(
								/\$hmrInvalidateModuleHandlers\$/g,
								RuntimeGlobals.hmrInvalidateModuleHandlers
							)
					])
				: "// no HMR",
			"",
			withHmrManifest
				? Template.asString([
						`${
							RuntimeGlobals.hmrDownloadManifest
						***REMOVED*** = ${runtimeTemplate.basicFunction("", [
							'if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");',
							`return fetch(${RuntimeGlobals.publicPath***REMOVED*** + ${
								RuntimeGlobals.getUpdateManifestFilename
							***REMOVED***()).then(${runtimeTemplate.basicFunction("response", [
								"if(response.status === 404) return; // no update available",
								'if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);',
								"return response.json();"
							])***REMOVED***);`
						])***REMOVED***;`
					])
				: "// no HMR manifest"
		]);
	***REMOVED***
***REMOVED***

module.exports = ImportScriptsChunkLoadingRuntimeModule;
