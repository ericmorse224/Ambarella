"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
const codegen_1 = require("../compile/codegen");
const util_1 = require("../compile/util");
const names_1 = require("../compile/names");
const util_2 = require("../compile/util");
function checkReportMissingProp(cxt, prop) {
    const { gen, data, it ***REMOVED*** = cxt;
    gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._) `${prop***REMOVED***` ***REMOVED***, true);
        cxt.error();
    ***REMOVED***);
***REMOVED***
exports.checkReportMissingProp = checkReportMissingProp;
function checkMissingProp({ gen, data, it: { opts ***REMOVED*** ***REMOVED***, properties, missing) {
    return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._) `${missing***REMOVED*** = ${prop***REMOVED***`)));
***REMOVED***
exports.checkMissingProp = checkMissingProp;
function reportMissingProp(cxt, missing) {
    cxt.setParams({ missingProperty: missing ***REMOVED***, true);
    cxt.error();
***REMOVED***
exports.reportMissingProp = reportMissingProp;
function hasPropFunc(gen) {
    return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._) `Object.prototype.hasOwnProperty`,
    ***REMOVED***);
***REMOVED***
exports.hasPropFunc = hasPropFunc;
function isOwnProperty(gen, data, property) {
    return (0, codegen_1._) `${hasPropFunc(gen)***REMOVED***.call(${data***REMOVED***, ${property***REMOVED***)`;
***REMOVED***
exports.isOwnProperty = isOwnProperty;
function propertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._) `${data***REMOVED***${(0, codegen_1.getProperty)(property)***REMOVED*** !== undefined`;
    return ownProperties ? (0, codegen_1._) `${cond***REMOVED*** && ${isOwnProperty(gen, data, property)***REMOVED***` : cond;
***REMOVED***
exports.propertyInData = propertyInData;
function noPropertyInData(gen, data, property, ownProperties) {
    const cond = (0, codegen_1._) `${data***REMOVED***${(0, codegen_1.getProperty)(property)***REMOVED*** === undefined`;
    return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
***REMOVED***
exports.noPropertyInData = noPropertyInData;
function allSchemaProperties(schemaMap) {
    return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
***REMOVED***
exports.allSchemaProperties = allSchemaProperties;
function schemaProperties(it, schemaMap) {
    return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
***REMOVED***
exports.schemaProperties = schemaProperties;
function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath ***REMOVED***, it ***REMOVED***, func, context, passSchema) {
    const dataAndSchema = passSchema ? (0, codegen_1._) `${schemaCode***REMOVED***, ${data***REMOVED***, ${topSchemaRef***REMOVED***${schemaPath***REMOVED***` : data;
    const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData],
    ];
    if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
    const args = (0, codegen_1._) `${dataAndSchema***REMOVED***, ${gen.object(...valCxt)***REMOVED***`;
    return context !== codegen_1.nil ? (0, codegen_1._) `${func***REMOVED***.call(${context***REMOVED***, ${args***REMOVED***)` : (0, codegen_1._) `${func***REMOVED***(${args***REMOVED***)`;
***REMOVED***
exports.callValidateCode = callValidateCode;
const newRegExp = (0, codegen_1._) `new RegExp`;
function usePattern({ gen, it: { opts ***REMOVED*** ***REMOVED***, pattern) {
    const u = opts.unicodeRegExp ? "u" : "";
    const { regExp ***REMOVED*** = opts.code;
    const rx = regExp(pattern, u);
    return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._) `${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)***REMOVED***(${pattern***REMOVED***, ${u***REMOVED***)`,
    ***REMOVED***);
***REMOVED***
exports.usePattern = usePattern;
function validateArray(cxt) {
    const { gen, data, keyword, it ***REMOVED*** = cxt;
    const valid = gen.name("valid");
    if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
    ***REMOVED***
    gen.var(valid, true);
    validateItems(() => gen.break());
    return valid;
    function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._) `${data***REMOVED***.length`);
        gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
                keyword,
                dataProp: i,
                dataPropType: util_1.Type.Num,
            ***REMOVED***, valid);
            gen.if((0, codegen_1.not)(valid), notValid);
        ***REMOVED***);
    ***REMOVED***
***REMOVED***
exports.validateArray = validateArray;
function validateUnion(cxt) {
    const { gen, schema, keyword, it ***REMOVED*** = cxt;
    /* istanbul ignore if */
    if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
    const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
    if (alwaysValid && !it.opts.unevaluated)
        return;
    const valid = gen.let("valid", false);
    const schValid = gen.name("_valid");
    gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
            keyword,
            schemaProp: i,
            compositeRule: true,
        ***REMOVED***, schValid);
        gen.assign(valid, (0, codegen_1._) `${valid***REMOVED*** || ${schValid***REMOVED***`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        // can short-circuit if `unevaluatedProperties/Items` not supported (opts.unevaluated !== true)
        // or if all properties and items were evaluated (it.props === true && it.items === true)
        if (!merged)
            gen.if((0, codegen_1.not)(valid));
    ***REMOVED***));
    cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
***REMOVED***
exports.validateUnion = validateUnion;
//# sourceMappingURL=code.js.map