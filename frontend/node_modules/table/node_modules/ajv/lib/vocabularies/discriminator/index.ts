import type {CodeKeywordDefinition, AnySchemaObject, KeywordErrorDefinition***REMOVED*** from "../../types"
import type {KeywordCxt***REMOVED*** from "../../compile/validate"
import {_, getProperty, Name***REMOVED*** from "../../compile/codegen"
import {DiscrError, DiscrErrorObj***REMOVED*** from "../discriminator/types"
import {resolveRef, SchemaEnv***REMOVED*** from "../../compile"
import MissingRefError from "../../compile/ref_error"
import {schemaHasRulesButRef***REMOVED*** from "../../compile/util"

export type DiscriminatorError = DiscrErrorObj<DiscrError.Tag> | DiscrErrorObj<DiscrError.Mapping>

const error: KeywordErrorDefinition = {
  message: ({params: {discrError, tagName***REMOVED******REMOVED***) =>
    discrError === DiscrError.Tag
      ? `tag "${tagName***REMOVED***" must be string`
      : `value of tag "${tagName***REMOVED***" must be in oneOf`,
  params: ({params: {discrError, tag, tagName***REMOVED******REMOVED***) =>
    _`{error: ${discrError***REMOVED***, tag: ${tagName***REMOVED***, tagValue: ${tag***REMOVED******REMOVED***`,
***REMOVED***

const def: CodeKeywordDefinition = {
  keyword: "discriminator",
  type: "object",
  schemaType: "object",
  error,
  code(cxt: KeywordCxt) {
    const {gen, data, schema, parentSchema, it***REMOVED*** = cxt
    const {oneOf***REMOVED*** = parentSchema
    if (!it.opts.discriminator) {
      throw new Error("discriminator: requires discriminator option")
    ***REMOVED***
    const tagName = schema.propertyName
    if (typeof tagName != "string") throw new Error("discriminator: requires propertyName")
    if (schema.mapping) throw new Error("discriminator: mapping is not supported")
    if (!oneOf) throw new Error("discriminator: requires oneOf keyword")
    const valid = gen.let("valid", false)
    const tag = gen.const("tag", _`${data***REMOVED***${getProperty(tagName)***REMOVED***`)
    gen.if(
      _`typeof ${tag***REMOVED*** == "string"`,
      () => validateMapping(),
      () => cxt.error(false, {discrError: DiscrError.Tag, tag, tagName***REMOVED***)
    )
    cxt.ok(valid)

    function validateMapping(): void {
      const mapping = getMapping()
      gen.if(false)
      for (const tagValue in mapping) {
        gen.elseIf(_`${tag***REMOVED*** === ${tagValue***REMOVED***`)
        gen.assign(valid, applyTagSchema(mapping[tagValue]))
      ***REMOVED***
      gen.else()
      cxt.error(false, {discrError: DiscrError.Mapping, tag, tagName***REMOVED***)
      gen.endIf()
    ***REMOVED***

    function applyTagSchema(schemaProp?: number): Name {
      const _valid = gen.name("valid")
      const schCxt = cxt.subschema({keyword: "oneOf", schemaProp***REMOVED***, _valid)
      cxt.mergeEvaluated(schCxt, Name)
      return _valid
    ***REMOVED***

    function getMapping(): {[T in string]?: number***REMOVED*** {
      const oneOfMapping: {[T in string]?: number***REMOVED*** = {***REMOVED***
      const topRequired = hasRequired(parentSchema)
      let tagRequired = true
      for (let i = 0; i < oneOf.length; i++) {
        let sch = oneOf[i]
        if (sch?.$ref && !schemaHasRulesButRef(sch, it.self.RULES)) {
          const ref = sch.$ref
          sch = resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref)
          if (sch instanceof SchemaEnv) sch = sch.schema
          if (sch === undefined) throw new MissingRefError(it.opts.uriResolver, it.baseId, ref)
        ***REMOVED***
        const propSch = sch?.properties?.[tagName]
        if (typeof propSch != "object") {
          throw new Error(
            `discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName***REMOVED***"`
          )
        ***REMOVED***
        tagRequired = tagRequired && (topRequired || hasRequired(sch))
        addMappings(propSch, i)
      ***REMOVED***
      if (!tagRequired) throw new Error(`discriminator: "${tagName***REMOVED***" must be required`)
      return oneOfMapping

      function hasRequired({required***REMOVED***: AnySchemaObject): boolean {
        return Array.isArray(required) && required.includes(tagName)
      ***REMOVED***

      function addMappings(sch: AnySchemaObject, i: number): void {
        if (sch.const) {
          addMapping(sch.const, i)
        ***REMOVED*** else if (sch.enum) {
          for (const tagValue of sch.enum) {
            addMapping(tagValue, i)
          ***REMOVED***
        ***REMOVED*** else {
          throw new Error(`discriminator: "properties/${tagName***REMOVED***" must have "const" or "enum"`)
        ***REMOVED***
      ***REMOVED***

      function addMapping(tagValue: unknown, i: number): void {
        if (typeof tagValue != "string" || tagValue in oneOfMapping) {
          throw new Error(`discriminator: "${tagName***REMOVED***" values must be unique strings`)
        ***REMOVED***
        oneOfMapping[tagValue] = i
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***,
***REMOVED***

export default def
