"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.default = void 0;
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _pluginSyntaxTypescript = require("@babel/plugin-syntax-typescript");
var _helperCreateClassFeaturesPlugin = require("@babel/helper-create-class-features-plugin");
var _constEnum = require("./const-enum.js");
var _enum = require("./enum.js");
var _globalTypes = require("./global-types.js");
var _namespace = require("./namespace.js");
function isInType(path) {
  switch (path.parent.type) {
    case "TSTypeReference":
    case "TSExpressionWithTypeArguments":
    case "TSExpressionWithTypeArguments":
    case "TSTypeQuery":
      return true;
    case "TSQualifiedName":
      return (path.parentPath.findParent(path => path.type !== "TSQualifiedName").type !== "TSImportEqualsDeclaration"
      );
    case "ExportSpecifier":
      return (path.parent.exportKind === "type" || path.parentPath.parent.exportKind === "type"
      );
    default:
      return false;
  ***REMOVED***
***REMOVED***
const NEEDS_EXPLICIT_ESM = new WeakMap();
const PARSED_PARAMS = new WeakSet();
function safeRemove(path) {
  const ids = path.getBindingIdentifiers();
  for (const name of Object.keys(ids)) {
    const binding = path.scope.getBinding(name);
    if (binding && binding.identifier === ids[name]) {
      binding.scope.removeBinding(name);
    ***REMOVED***
  ***REMOVED***
  path.opts.noScope = true;
  path.remove();
  path.opts.noScope = false;
***REMOVED***
function assertCjsTransformEnabled(path, pass, wrong, suggestion, extra = "") {
  if (pass.file.get("@babel/plugin-transform-modules-*") !== "commonjs") {
    throw path.buildCodeFrameError(`\`${wrong***REMOVED***\` is only supported when compiling modules to CommonJS.\n` + `Please consider using \`${suggestion***REMOVED***\`${extra***REMOVED***, or add ` + `@babel/plugin-transform-modules-commonjs to your Babel config.`);
  ***REMOVED***
***REMOVED***
var _default = exports.default = (0, _helperPluginUtils.declare)((api, opts) => {
  const {
    types: t,
    template
  ***REMOVED*** = api;
  api.assertVersion(7);
  const JSX_PRAGMA_REGEX = /\*?\s*@jsx((?:Frag)?)\s+(\S+)/;
  const {
    allowNamespaces = true,
    jsxPragma = "React.createElement",
    jsxPragmaFrag = "React.Fragment",
    onlyRemoveTypeImports = false,
    optimizeConstEnums = false
  ***REMOVED*** = opts;
  {
    var {
      allowDeclareFields = false
    ***REMOVED*** = opts;
  ***REMOVED***
  const classMemberVisitors = {
    field(path) {
      const {
        node
      ***REMOVED*** = path;
      {
        if (!allowDeclareFields && node.declare) {
          throw path.buildCodeFrameError(`The 'declare' modifier is only allowed when the 'allowDeclareFields' option of ` + `@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.`);
        ***REMOVED***
      ***REMOVED***
      if (node.declare) {
        if (node.value) {
          throw path.buildCodeFrameError(`Fields with the 'declare' modifier cannot be initialized here, but only in the constructor`);
        ***REMOVED***
        if (!node.decorators) {
          path.remove();
        ***REMOVED***
      ***REMOVED*** else if (node.definite) {
        if (node.value) {
          throw path.buildCodeFrameError(`Definitely assigned fields cannot be initialized here, but only in the constructor`);
        ***REMOVED***
        {
          if (!allowDeclareFields && !node.decorators && !t.isClassPrivateProperty(node)) {
            path.remove();
          ***REMOVED***
        ***REMOVED***
      ***REMOVED*** else if (node.abstract) {
        path.remove();
      ***REMOVED*** else {
        if (!allowDeclareFields && !node.value && !node.decorators && !t.isClassPrivateProperty(node)) {
          path.remove();
        ***REMOVED***
      ***REMOVED***
      if (node.accessibility) node.accessibility = null;
      if (node.abstract) node.abstract = null;
      if (node.readonly) node.readonly = null;
      if (node.optional) node.optional = null;
      if (node.typeAnnotation) node.typeAnnotation = null;
      if (node.definite) node.definite = null;
      if (node.declare) node.declare = null;
      if (node.override) node.override = null;
    ***REMOVED***,
    method({
      node
    ***REMOVED***) {
      if (node.accessibility) node.accessibility = null;
      if (node.abstract) node.abstract = null;
      if (node.optional) node.optional = null;
      if (node.override) node.override = null;
    ***REMOVED***,
    constructor(path, classPath) {
      if (path.node.accessibility) path.node.accessibility = null;
      const assigns = [];
      const {
        scope
      ***REMOVED*** = path;
      for (const paramPath of path.get("params")) {
        const param = paramPath.node;
        if (param.type === "TSParameterProperty") {
          const parameter = param.parameter;
          if (PARSED_PARAMS.has(parameter)) continue;
          PARSED_PARAMS.add(parameter);
          let id;
          if (t.isIdentifier(parameter)) {
            id = parameter;
          ***REMOVED*** else if (t.isAssignmentPattern(parameter) && t.isIdentifier(parameter.left)) {
            id = parameter.left;
          ***REMOVED*** else {
            throw paramPath.buildCodeFrameError("Parameter properties can not be destructuring patterns.");
          ***REMOVED***
          assigns.push(template.statement.ast`
              this.${t.cloneNode(id)***REMOVED*** = ${t.cloneNode(id)***REMOVED***
            `);
          paramPath.replaceWith(paramPath.get("parameter"));
          scope.registerBinding("param", paramPath);
        ***REMOVED***
      ***REMOVED***
      (0, _helperCreateClassFeaturesPlugin.injectInitialization)(classPath, path, assigns);
    ***REMOVED***
  ***REMOVED***;
  return {
    name: "transform-typescript",
    inherits: _pluginSyntaxTypescript.default,
    visitor: {
      Pattern: visitPattern,
      Identifier: visitPattern,
      RestElement: visitPattern,
      Program: {
        enter(path, state) {
          const {
            file
          ***REMOVED*** = state;
          let fileJsxPragma = null;
          let fileJsxPragmaFrag = null;
          const programScope = path.scope;
          if (!_globalTypes.GLOBAL_TYPES.has(programScope)) {
            _globalTypes.GLOBAL_TYPES.set(programScope, new Set());
          ***REMOVED***
          if (file.ast.comments) {
            for (const comment of file.ast.comments) {
              const jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);
              if (jsxMatches) {
                if (jsxMatches[1]) {
                  fileJsxPragmaFrag = jsxMatches[2];
                ***REMOVED*** else {
                  fileJsxPragma = jsxMatches[2];
                ***REMOVED***
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***
          let pragmaImportName = fileJsxPragma || jsxPragma;
          if (pragmaImportName) {
            [pragmaImportName] = pragmaImportName.split(".");
          ***REMOVED***
          let pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;
          if (pragmaFragImportName) {
            [pragmaFragImportName] = pragmaFragImportName.split(".");
          ***REMOVED***
          for (let stmt of path.get("body")) {
            if (stmt.isImportDeclaration()) {
              if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
                NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
              ***REMOVED***
              if (stmt.node.importKind === "type") {
                for (const specifier of stmt.node.specifiers) {
                  (0, _globalTypes.registerGlobalType)(programScope, specifier.local.name);
                ***REMOVED***
                stmt.remove();
                continue;
              ***REMOVED***
              const importsToRemove = new Set();
              const specifiersLength = stmt.node.specifiers.length;
              const isAllSpecifiersElided = () => specifiersLength > 0 && specifiersLength === importsToRemove.size;
              for (const specifier of stmt.node.specifiers) {
                if (specifier.type === "ImportSpecifier" && specifier.importKind === "type") {
                  (0, _globalTypes.registerGlobalType)(programScope, specifier.local.name);
                  const binding = stmt.scope.getBinding(specifier.local.name);
                  if (binding) {
                    importsToRemove.add(binding.path);
                  ***REMOVED***
                ***REMOVED***
              ***REMOVED***
              if (onlyRemoveTypeImports) {
                NEEDS_EXPLICIT_ESM.set(path.node, false);
              ***REMOVED*** else {
                if (stmt.node.specifiers.length === 0) {
                  NEEDS_EXPLICIT_ESM.set(path.node, false);
                  continue;
                ***REMOVED***
                for (const specifier of stmt.node.specifiers) {
                  const binding = stmt.scope.getBinding(specifier.local.name);
                  if (binding && !importsToRemove.has(binding.path)) {
                    if (isImportTypeOnly({
                      binding,
                      programPath: path,
                      pragmaImportName,
                      pragmaFragImportName
                    ***REMOVED***)) {
                      importsToRemove.add(binding.path);
                    ***REMOVED*** else {
                      NEEDS_EXPLICIT_ESM.set(path.node, false);
                    ***REMOVED***
                  ***REMOVED***
                ***REMOVED***
              ***REMOVED***
              if (isAllSpecifiersElided() && !onlyRemoveTypeImports) {
                stmt.remove();
              ***REMOVED*** else {
                for (const importPath of importsToRemove) {
                  importPath.remove();
                ***REMOVED***
              ***REMOVED***
              continue;
            ***REMOVED***
            if (!onlyRemoveTypeImports && stmt.isTSImportEqualsDeclaration()) {
              const {
                id
              ***REMOVED*** = stmt.node;
              const binding = stmt.scope.getBinding(id.name);
              if (binding && !stmt.node.isExport && isImportTypeOnly({
                binding,
                programPath: path,
                pragmaImportName,
                pragmaFragImportName
              ***REMOVED***)) {
                stmt.remove();
                continue;
              ***REMOVED***
            ***REMOVED***
            if (stmt.isExportDeclaration()) {
              stmt = stmt.get("declaration");
            ***REMOVED***
            if (stmt.isVariableDeclaration({
              declare: true
            ***REMOVED***)) {
              for (const name of Object.keys(stmt.getBindingIdentifiers())) {
                (0, _globalTypes.registerGlobalType)(programScope, name);
              ***REMOVED***
            ***REMOVED*** else if (stmt.isTSTypeAliasDeclaration() || stmt.isTSDeclareFunction() && stmt.get("id").isIdentifier() || stmt.isTSInterfaceDeclaration() || stmt.isClassDeclaration({
              declare: true
            ***REMOVED***) || stmt.isTSEnumDeclaration({
              declare: true
            ***REMOVED***) || stmt.isTSModuleDeclaration({
              declare: true
            ***REMOVED***) && stmt.get("id").isIdentifier()) {
              (0, _globalTypes.registerGlobalType)(programScope, stmt.node.id.name);
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***,
        exit(path) {
          if (path.node.sourceType === "module" && NEEDS_EXPLICIT_ESM.get(path.node)) {
            path.pushContainer("body", t.exportNamedDeclaration());
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***,
      ExportNamedDeclaration(path, state) {
        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
        ***REMOVED***
        if (path.node.exportKind === "type") {
          path.remove();
          return;
        ***REMOVED***
        ;
        if (path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every(specifier => specifier.type === "ExportSpecifier" && specifier.exportKind === "type")) {
          path.remove();
          return;
        ***REMOVED***
        if (!path.node.source && path.node.specifiers.length > 0 && path.node.specifiers.every(specifier => t.isExportSpecifier(specifier) && (0, _globalTypes.isGlobalType)(path, specifier.local.name))) {
          path.remove();
          return;
        ***REMOVED***
        if (t.isTSModuleDeclaration(path.node.declaration)) {
          const namespace = path.node.declaration;
          if (!t.isStringLiteral(namespace.id)) {
            const id = (0, _namespace.getFirstIdentifier)(namespace.id);
            if (path.scope.hasOwnBinding(id.name)) {
              path.replaceWith(namespace);
            ***REMOVED*** else {
              const [newExport] = path.replaceWithMultiple([t.exportNamedDeclaration(t.variableDeclaration("let", [t.variableDeclarator(t.cloneNode(id))])), namespace]);
              path.scope.registerDeclaration(newExport);
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
      ***REMOVED***,
      ExportAllDeclaration(path) {
        if (path.node.exportKind === "type") path.remove();
      ***REMOVED***,
      ExportSpecifier(path) {
        const parent = path.parent;
        if (!parent.source && (0, _globalTypes.isGlobalType)(path, path.node.local.name) || path.node.exportKind === "type") {
          path.remove();
        ***REMOVED***
      ***REMOVED***,
      ExportDefaultDeclaration(path, state) {
        if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {
          NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);
        ***REMOVED***
        if (t.isIdentifier(path.node.declaration) && (0, _globalTypes.isGlobalType)(path, path.node.declaration.name)) {
          path.remove();
          return;
        ***REMOVED***
        NEEDS_EXPLICIT_ESM.set(state.file.ast.program, false);
      ***REMOVED***,
      TSDeclareFunction(path) {
        safeRemove(path);
      ***REMOVED***,
      TSDeclareMethod(path) {
        safeRemove(path);
      ***REMOVED***,
      VariableDeclaration(path) {
        if (path.node.declare) {
          safeRemove(path);
        ***REMOVED***
      ***REMOVED***,
      VariableDeclarator({
        node
      ***REMOVED***) {
        if (node.definite) node.definite = null;
      ***REMOVED***,
      TSIndexSignature(path) {
        path.remove();
      ***REMOVED***,
      ClassDeclaration(path) {
        const {
          node
        ***REMOVED*** = path;
        if (node.declare) {
          safeRemove(path);
        ***REMOVED***
      ***REMOVED***,
      Class(path) {
        const {
          node
        ***REMOVED*** = path;
        if (node.typeParameters) node.typeParameters = null;
        {
          if (node.superTypeParameters) node.superTypeParameters = null;
        ***REMOVED***
        if (node.implements) node.implements = null;
        if (node.abstract) node.abstract = null;
        path.get("body.body").forEach(child => {
          if (child.isClassMethod() || child.isClassPrivateMethod()) {
            if (child.node.kind === "constructor") {
              classMemberVisitors.constructor(child, path);
            ***REMOVED*** else {
              classMemberVisitors.method(child);
            ***REMOVED***
          ***REMOVED*** else if (child.isClassProperty() || child.isClassPrivateProperty() || child.isClassAccessorProperty()) {
            classMemberVisitors.field(child);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***,
      Function(path) {
        const {
          node
        ***REMOVED*** = path;
        if (node.typeParameters) node.typeParameters = null;
        if (node.returnType) node.returnType = null;
        const params = node.params;
        if (params.length > 0 && t.isIdentifier(params[0], {
          name: "this"
        ***REMOVED***)) {
          params.shift();
        ***REMOVED***
      ***REMOVED***,
      TSModuleDeclaration(path) {
        (0, _namespace.default)(path, allowNamespaces);
      ***REMOVED***,
      TSInterfaceDeclaration(path) {
        path.remove();
      ***REMOVED***,
      TSTypeAliasDeclaration(path) {
        path.remove();
      ***REMOVED***,
      TSEnumDeclaration(path) {
        if (optimizeConstEnums && path.node.const) {
          (0, _constEnum.default)(path, t);
        ***REMOVED*** else {
          (0, _enum.default)(path, t);
        ***REMOVED***
      ***REMOVED***,
      TSImportEqualsDeclaration(path, pass) {
        const {
          id,
          moduleReference
        ***REMOVED*** = path.node;
        let init;
        let varKind;
        if (t.isTSExternalModuleReference(moduleReference)) {
          assertCjsTransformEnabled(path, pass, `import ${id.name***REMOVED*** = require(...);`, `import ${id.name***REMOVED*** from '...';`, " alongside Typescript's --allowSyntheticDefaultImports option");
          init = t.callExpression(t.identifier("require"), [moduleReference.expression]);
          varKind = "const";
        ***REMOVED*** else {
          init = entityNameToExpr(moduleReference);
          varKind = "var";
        ***REMOVED***
        const newNode = t.variableDeclaration(varKind, [t.variableDeclarator(id, init)]);
        {
          path.replaceWith(path.node.isExport ? t.exportNamedDeclaration(newNode) : newNode);
        ***REMOVED***
        path.scope.registerDeclaration(path);
      ***REMOVED***,
      TSExportAssignment(path, pass) {
        assertCjsTransformEnabled(path, pass, `export = <value>;`, `export default <value>;`);
        path.replaceWith(template.statement.ast`module.exports = ${path.node.expression***REMOVED***`);
      ***REMOVED***,
      TSTypeAssertion(path) {
        path.replaceWith(path.node.expression);
      ***REMOVED***,
      [`TSAsExpression${t.tsSatisfiesExpression ? "|TSSatisfiesExpression" : ""***REMOVED***`](path) {
        let {
          node
        ***REMOVED*** = path;
        do {
          node = node.expression;
        ***REMOVED*** while (t.isTSAsExpression(node) || t.isTSSatisfiesExpression != null && t.isTSSatisfiesExpression(node));
        path.replaceWith(node);
      ***REMOVED***,
      [api.types.tsInstantiationExpression ? "TSNonNullExpression|TSInstantiationExpression" : "TSNonNullExpression"](path) {
        path.replaceWith(path.node.expression);
      ***REMOVED***,
      CallExpression(path) {
        {
          path.node.typeParameters = null;
        ***REMOVED***
      ***REMOVED***,
      OptionalCallExpression(path) {
        {
          path.node.typeParameters = null;
        ***REMOVED***
      ***REMOVED***,
      NewExpression(path) {
        {
          path.node.typeParameters = null;
        ***REMOVED***
      ***REMOVED***,
      JSXOpeningElement(path) {
        {
          path.node.typeParameters = null;
        ***REMOVED***
      ***REMOVED***,
      TaggedTemplateExpression(path) {
        {
          path.node.typeParameters = null;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;
  function entityNameToExpr(node) {
    if (t.isTSQualifiedName(node)) {
      return t.memberExpression(entityNameToExpr(node.left), node.right);
    ***REMOVED***
    return node;
  ***REMOVED***
  function visitPattern({
    node
  ***REMOVED***) {
    if (node.typeAnnotation) node.typeAnnotation = null;
    if (t.isIdentifier(node) && node.optional) node.optional = null;
  ***REMOVED***
  function isImportTypeOnly({
    binding,
    programPath,
    pragmaImportName,
    pragmaFragImportName
  ***REMOVED***) {
    for (const path of binding.referencePaths) {
      if (!isInType(path)) {
        return false;
      ***REMOVED***
    ***REMOVED***
    if (binding.identifier.name !== pragmaImportName && binding.identifier.name !== pragmaFragImportName) {
      return true;
    ***REMOVED***
    let sourceFileHasJsx = false;
    programPath.traverse({
      "JSXElement|JSXFragment"(path) {
        sourceFileHasJsx = true;
        path.stop();
      ***REMOVED***
    ***REMOVED***);
    return !sourceFileHasJsx;
  ***REMOVED***
***REMOVED***);

//# sourceMappingURL=index.js.map
