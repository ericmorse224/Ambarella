"use strict";

/** @typedef {import("@jridgewell/trace-mapping").SourceMapInput***REMOVED*** SourceMapInput */
/** @typedef {import("./index.js").ExtractCommentsOptions***REMOVED*** ExtractCommentsOptions */
/** @typedef {import("./index.js").ExtractCommentsFunction***REMOVED*** ExtractCommentsFunction */
/** @typedef {import("./index.js").ExtractCommentsCondition***REMOVED*** ExtractCommentsCondition */
/** @typedef {import("./index.js").Input***REMOVED*** Input */
/** @typedef {import("./index.js").MinimizedResult***REMOVED*** MinimizedResult */
/** @typedef {import("./index.js").CustomOptions***REMOVED*** CustomOptions */

/**
 * @template T
 * @typedef {import("./index.js").PredefinedOptions<T>***REMOVED*** PredefinedOptions
 */

/**
 * @typedef {Array<string>***REMOVED*** ExtractedComments
 */

const notSettled = Symbol(`not-settled`);

/**
 * @template T
 * @typedef {() => Promise<T>***REMOVED*** Task
 */

/**
 * Run tasks with limited concurrency.
 * @template T
 * @param {number***REMOVED*** limit - Limit of tasks that run at once.
 * @param {Task<T>[]***REMOVED*** tasks - List of tasks to run.
 * @returns {Promise<T[]>***REMOVED*** A promise that fulfills to an array of the results
 */
function throttleAll(limit, tasks) {
  if (!Number.isInteger(limit) || limit < 1) {
    throw new TypeError(`Expected \`limit\` to be a finite number > 0, got \`${limit***REMOVED***\` (${typeof limit***REMOVED***)`);
  ***REMOVED***
  if (!Array.isArray(tasks) || !tasks.every(task => typeof task === `function`)) {
    throw new TypeError(`Expected \`tasks\` to be a list of functions returning a promise`);
  ***REMOVED***
  return new Promise((resolve, reject) => {
    const result = Array(tasks.length).fill(notSettled);
    const entries = tasks.entries();
    const next = () => {
      const {
        done,
        value
      ***REMOVED*** = entries.next();
      if (done) {
        const isLast = !result.includes(notSettled);
        if (isLast) resolve( /** @type{T[]***REMOVED*** **/result);
        return;
      ***REMOVED***
      const [index, task] = value;

      /**
       * @param {T***REMOVED*** x
       */
      const onFulfilled = x => {
        result[index] = x;
        next();
      ***REMOVED***;
      task().then(onFulfilled, reject);
    ***REMOVED***;
    Array(limit).fill(0).forEach(next);
  ***REMOVED***);
***REMOVED***

/* istanbul ignore next */
/**
 * @param {Input***REMOVED*** input
 * @param {SourceMapInput | undefined***REMOVED*** sourceMap
 * @param {CustomOptions***REMOVED*** minimizerOptions
 * @param {ExtractCommentsOptions | undefined***REMOVED*** extractComments
 * @return {Promise<MinimizedResult>***REMOVED***
 */
async function terserMinify(input, sourceMap, minimizerOptions, extractComments) {
  /**
   * @param {any***REMOVED*** value
   * @returns {boolean***REMOVED***
   */
  const isObject = value => {
    const type = typeof value;
    return value != null && (type === "object" || type === "function");
  ***REMOVED***;

  /**
   * @param {import("terser").MinifyOptions & { sourceMap: undefined ***REMOVED*** & ({ output: import("terser").FormatOptions & { beautify: boolean ***REMOVED*** ***REMOVED*** | { format: import("terser").FormatOptions & { beautify: boolean ***REMOVED*** ***REMOVED***)***REMOVED*** terserOptions
   * @param {ExtractedComments***REMOVED*** extractedComments
   * @returns {ExtractCommentsFunction***REMOVED***
   */
  const buildComments = (terserOptions, extractedComments) => {
    /** @type {{ [index: string]: ExtractCommentsCondition ***REMOVED******REMOVED*** */
    const condition = {***REMOVED***;
    let comments;
    if (terserOptions.format) {
      ({
        comments
      ***REMOVED*** = terserOptions.format);
    ***REMOVED*** else if (terserOptions.output) {
      ({
        comments
      ***REMOVED*** = terserOptions.output);
    ***REMOVED***
    condition.preserve = typeof comments !== "undefined" ? comments : false;
    if (typeof extractComments === "boolean" && extractComments) {
      condition.extract = "some";
    ***REMOVED*** else if (typeof extractComments === "string" || extractComments instanceof RegExp) {
      condition.extract = extractComments;
    ***REMOVED*** else if (typeof extractComments === "function") {
      condition.extract = extractComments;
    ***REMOVED*** else if (extractComments && isObject(extractComments)) {
      condition.extract = typeof extractComments.condition === "boolean" && extractComments.condition ? "some" : typeof extractComments.condition !== "undefined" ? extractComments.condition : "some";
    ***REMOVED*** else {
      // No extract
      // Preserve using "commentsOpts" or "some"
      condition.preserve = typeof comments !== "undefined" ? comments : "some";
      condition.extract = false;
    ***REMOVED***

    // Ensure that both conditions are functions
    ["preserve", "extract"].forEach(key => {
      /** @type {undefined | string***REMOVED*** */
      let regexStr;
      /** @type {undefined | RegExp***REMOVED*** */
      let regex;
      switch (typeof condition[key]) {
        case "boolean":
          condition[key] = condition[key] ? () => true : () => false;
          break;
        case "function":
          break;
        case "string":
          if (condition[key] === "all") {
            condition[key] = () => true;
            break;
          ***REMOVED***
          if (condition[key] === "some") {
            condition[key] = /** @type {ExtractCommentsFunction***REMOVED*** */
            (astNode, comment) => (comment.type === "comment2" || comment.type === "comment1") && /@preserve|@lic|@cc_on|^\**!/i.test(comment.value);
            break;
          ***REMOVED***
          regexStr = /** @type {string***REMOVED*** */condition[key];
          condition[key] = /** @type {ExtractCommentsFunction***REMOVED*** */
          (astNode, comment) => new RegExp( /** @type {string***REMOVED*** */regexStr).test(comment.value);
          break;
        default:
          regex = /** @type {RegExp***REMOVED*** */condition[key];
          condition[key] = /** @type {ExtractCommentsFunction***REMOVED*** */
          (astNode, comment) => /** @type {RegExp***REMOVED*** */regex.test(comment.value);
      ***REMOVED***
    ***REMOVED***);

    // Redefine the comments function to extract and preserve
    // comments according to the two conditions
    return (astNode, comment) => {
      if ( /** @type {{ extract: ExtractCommentsFunction ***REMOVED******REMOVED*** */
      condition.extract(astNode, comment)) {
        const commentText = comment.type === "comment2" ? `/*${comment.value***REMOVED****/` : `//${comment.value***REMOVED***`;

        // Don't include duplicate comments
        if (!extractedComments.includes(commentText)) {
          extractedComments.push(commentText);
        ***REMOVED***
      ***REMOVED***
      return /** @type {{ preserve: ExtractCommentsFunction ***REMOVED******REMOVED*** */condition.preserve(astNode, comment);
    ***REMOVED***;
  ***REMOVED***;

  /**
   * @param {PredefinedOptions<import("terser").MinifyOptions> & import("terser").MinifyOptions***REMOVED*** [terserOptions={***REMOVED***]
   * @returns {import("terser").MinifyOptions & { sourceMap: undefined ***REMOVED*** & { compress: import("terser").CompressOptions ***REMOVED*** & ({ output: import("terser").FormatOptions & { beautify: boolean ***REMOVED*** ***REMOVED*** | { format: import("terser").FormatOptions & { beautify: boolean ***REMOVED*** ***REMOVED***)***REMOVED***
   */
  const buildTerserOptions = (terserOptions = {***REMOVED***) => {
    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366
    return {
      ...terserOptions,
      compress: typeof terserOptions.compress === "boolean" ? terserOptions.compress ? {***REMOVED*** : false : {
        ...terserOptions.compress
      ***REMOVED***,
      // ecma: terserOptions.ecma,
      // ie8: terserOptions.ie8,
      // keep_classnames: terserOptions.keep_classnames,
      // keep_fnames: terserOptions.keep_fnames,
      mangle: terserOptions.mangle == null ? true : typeof terserOptions.mangle === "boolean" ? terserOptions.mangle : {
        ...terserOptions.mangle
      ***REMOVED***,
      // module: terserOptions.module,
      // nameCache: { ...terserOptions.toplevel ***REMOVED***,
      // the `output` option is deprecated
      ...(terserOptions.format ? {
        format: {
          beautify: false,
          ...terserOptions.format
        ***REMOVED***
      ***REMOVED*** : {
        output: {
          beautify: false,
          ...terserOptions.output
        ***REMOVED***
      ***REMOVED***),
      parse: {
        ...terserOptions.parse
      ***REMOVED***,
      // safari10: terserOptions.safari10,
      // Ignoring sourceMap from options
      // eslint-disable-next-line no-undefined
      sourceMap: undefined
      // toplevel: terserOptions.toplevel
    ***REMOVED***;
  ***REMOVED***;

  // eslint-disable-next-line global-require
  const {
    minify
  ***REMOVED*** = require("terser");
  // Copy `terser` options
  const terserOptions = buildTerserOptions(minimizerOptions);

  // Let terser generate a SourceMap
  if (sourceMap) {
    // @ts-ignore
    terserOptions.sourceMap = {
      asObject: true
    ***REMOVED***;
  ***REMOVED***

  /** @type {ExtractedComments***REMOVED*** */
  const extractedComments = [];
  if (terserOptions.output) {
    terserOptions.output.comments = buildComments(terserOptions, extractedComments);
  ***REMOVED*** else if (terserOptions.format) {
    terserOptions.format.comments = buildComments(terserOptions, extractedComments);
  ***REMOVED***
  if (terserOptions.compress) {
    // More optimizations
    if (typeof terserOptions.compress.ecma === "undefined") {
      terserOptions.compress.ecma = terserOptions.ecma;
    ***REMOVED***

    // https://github.com/webpack/webpack/issues/16135
    if (terserOptions.ecma === 5 && typeof terserOptions.compress.arrows === "undefined") {
      terserOptions.compress.arrows = false;
    ***REMOVED***
  ***REMOVED***
  const [[filename, code]] = Object.entries(input);
  const result = await minify({
    [filename]: code
  ***REMOVED***, terserOptions);
  return {
    code: ( /** @type {string***REMOVED*** **/result.code),
    // @ts-ignore
    // eslint-disable-next-line no-undefined
    map: result.map ? ( /** @type {SourceMapInput***REMOVED*** **/result.map) : undefined,
    extractedComments
  ***REMOVED***;
***REMOVED***

/**
 * @returns {string | undefined***REMOVED***
 */
terserMinify.getMinimizerVersion = () => {
  let packageJson;
  try {
    // eslint-disable-next-line global-require
    packageJson = require("terser/package.json");
  ***REMOVED*** catch (error) {
    // Ignore
  ***REMOVED***
  return packageJson && packageJson.version;
***REMOVED***;

/**
 * @returns {boolean | undefined***REMOVED***
 */
terserMinify.supportsWorkerThreads = () => true;

/* istanbul ignore next */
/**
 * @param {Input***REMOVED*** input
 * @param {SourceMapInput | undefined***REMOVED*** sourceMap
 * @param {CustomOptions***REMOVED*** minimizerOptions
 * @param {ExtractCommentsOptions | undefined***REMOVED*** extractComments
 * @return {Promise<MinimizedResult>***REMOVED***
 */
async function uglifyJsMinify(input, sourceMap, minimizerOptions, extractComments) {
  /**
   * @param {any***REMOVED*** value
   * @returns {boolean***REMOVED***
   */
  const isObject = value => {
    const type = typeof value;
    return value != null && (type === "object" || type === "function");
  ***REMOVED***;

  /**
   * @param {import("uglify-js").MinifyOptions & { sourceMap: undefined ***REMOVED*** & { output: import("uglify-js").OutputOptions & { beautify: boolean ***REMOVED******REMOVED******REMOVED*** uglifyJsOptions
   * @param {ExtractedComments***REMOVED*** extractedComments
   * @returns {ExtractCommentsFunction***REMOVED***
   */
  const buildComments = (uglifyJsOptions, extractedComments) => {
    /** @type {{ [index: string]: ExtractCommentsCondition ***REMOVED******REMOVED*** */
    const condition = {***REMOVED***;
    const {
      comments
    ***REMOVED*** = uglifyJsOptions.output;
    condition.preserve = typeof comments !== "undefined" ? comments : false;
    if (typeof extractComments === "boolean" && extractComments) {
      condition.extract = "some";
    ***REMOVED*** else if (typeof extractComments === "string" || extractComments instanceof RegExp) {
      condition.extract = extractComments;
    ***REMOVED*** else if (typeof extractComments === "function") {
      condition.extract = extractComments;
    ***REMOVED*** else if (extractComments && isObject(extractComments)) {
      condition.extract = typeof extractComments.condition === "boolean" && extractComments.condition ? "some" : typeof extractComments.condition !== "undefined" ? extractComments.condition : "some";
    ***REMOVED*** else {
      // No extract
      // Preserve using "commentsOpts" or "some"
      condition.preserve = typeof comments !== "undefined" ? comments : "some";
      condition.extract = false;
    ***REMOVED***

    // Ensure that both conditions are functions
    ["preserve", "extract"].forEach(key => {
      /** @type {undefined | string***REMOVED*** */
      let regexStr;
      /** @type {undefined | RegExp***REMOVED*** */
      let regex;
      switch (typeof condition[key]) {
        case "boolean":
          condition[key] = condition[key] ? () => true : () => false;
          break;
        case "function":
          break;
        case "string":
          if (condition[key] === "all") {
            condition[key] = () => true;
            break;
          ***REMOVED***
          if (condition[key] === "some") {
            condition[key] = /** @type {ExtractCommentsFunction***REMOVED*** */
            (astNode, comment) => (comment.type === "comment2" || comment.type === "comment1") && /@preserve|@lic|@cc_on|^\**!/i.test(comment.value);
            break;
          ***REMOVED***
          regexStr = /** @type {string***REMOVED*** */condition[key];
          condition[key] = /** @type {ExtractCommentsFunction***REMOVED*** */
          (astNode, comment) => new RegExp( /** @type {string***REMOVED*** */regexStr).test(comment.value);
          break;
        default:
          regex = /** @type {RegExp***REMOVED*** */condition[key];
          condition[key] = /** @type {ExtractCommentsFunction***REMOVED*** */
          (astNode, comment) => /** @type {RegExp***REMOVED*** */regex.test(comment.value);
      ***REMOVED***
    ***REMOVED***);

    // Redefine the comments function to extract and preserve
    // comments according to the two conditions
    return (astNode, comment) => {
      if ( /** @type {{ extract: ExtractCommentsFunction ***REMOVED******REMOVED*** */
      condition.extract(astNode, comment)) {
        const commentText = comment.type === "comment2" ? `/*${comment.value***REMOVED****/` : `//${comment.value***REMOVED***`;

        // Don't include duplicate comments
        if (!extractedComments.includes(commentText)) {
          extractedComments.push(commentText);
        ***REMOVED***
      ***REMOVED***
      return /** @type {{ preserve: ExtractCommentsFunction ***REMOVED******REMOVED*** */condition.preserve(astNode, comment);
    ***REMOVED***;
  ***REMOVED***;

  /**
   * @param {PredefinedOptions<import("uglify-js").MinifyOptions> & import("uglify-js").MinifyOptions***REMOVED*** [uglifyJsOptions={***REMOVED***]
   * @returns {import("uglify-js").MinifyOptions & { sourceMap: undefined ***REMOVED*** & { output: import("uglify-js").OutputOptions & { beautify: boolean ***REMOVED******REMOVED******REMOVED***
   */
  const buildUglifyJsOptions = (uglifyJsOptions = {***REMOVED***) => {
    // eslint-disable-next-line no-param-reassign
    delete minimizerOptions.ecma;
    // eslint-disable-next-line no-param-reassign
    delete minimizerOptions.module;

    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366
    return {
      ...uglifyJsOptions,
      // warnings: uglifyJsOptions.warnings,
      parse: {
        ...uglifyJsOptions.parse
      ***REMOVED***,
      compress: typeof uglifyJsOptions.compress === "boolean" ? uglifyJsOptions.compress : {
        ...uglifyJsOptions.compress
      ***REMOVED***,
      mangle: uglifyJsOptions.mangle == null ? true : typeof uglifyJsOptions.mangle === "boolean" ? uglifyJsOptions.mangle : {
        ...uglifyJsOptions.mangle
      ***REMOVED***,
      output: {
        beautify: false,
        ...uglifyJsOptions.output
      ***REMOVED***,
      // Ignoring sourceMap from options
      // eslint-disable-next-line no-undefined
      sourceMap: undefined
      // toplevel: uglifyJsOptions.toplevel
      // nameCache: { ...uglifyJsOptions.toplevel ***REMOVED***,
      // ie8: uglifyJsOptions.ie8,
      // keep_fnames: uglifyJsOptions.keep_fnames,
    ***REMOVED***;
  ***REMOVED***;

  // eslint-disable-next-line global-require, import/no-extraneous-dependencies
  const {
    minify
  ***REMOVED*** = require("uglify-js");

  // Copy `uglify-js` options
  const uglifyJsOptions = buildUglifyJsOptions(minimizerOptions);

  // Let terser generate a SourceMap
  if (sourceMap) {
    // @ts-ignore
    uglifyJsOptions.sourceMap = true;
  ***REMOVED***

  /** @type {ExtractedComments***REMOVED*** */
  const extractedComments = [];

  // @ts-ignore
  uglifyJsOptions.output.comments = buildComments(uglifyJsOptions, extractedComments);
  const [[filename, code]] = Object.entries(input);
  const result = await minify({
    [filename]: code
  ***REMOVED***, uglifyJsOptions);
  return {
    code: result.code,
    // eslint-disable-next-line no-undefined
    map: result.map ? JSON.parse(result.map) : undefined,
    errors: result.error ? [result.error] : [],
    warnings: result.warnings || [],
    extractedComments
  ***REMOVED***;
***REMOVED***

/**
 * @returns {string | undefined***REMOVED***
 */
uglifyJsMinify.getMinimizerVersion = () => {
  let packageJson;
  try {
    // eslint-disable-next-line global-require, import/no-extraneous-dependencies
    packageJson = require("uglify-js/package.json");
  ***REMOVED*** catch (error) {
    // Ignore
  ***REMOVED***
  return packageJson && packageJson.version;
***REMOVED***;

/**
 * @returns {boolean | undefined***REMOVED***
 */
uglifyJsMinify.supportsWorkerThreads = () => true;

/* istanbul ignore next */
/**
 * @param {Input***REMOVED*** input
 * @param {SourceMapInput | undefined***REMOVED*** sourceMap
 * @param {CustomOptions***REMOVED*** minimizerOptions
 * @return {Promise<MinimizedResult>***REMOVED***
 */
async function swcMinify(input, sourceMap, minimizerOptions) {
  /**
   * @param {PredefinedOptions<import("@swc/core").JsMinifyOptions> & import("@swc/core").JsMinifyOptions***REMOVED*** [swcOptions={***REMOVED***]
   * @returns {import("@swc/core").JsMinifyOptions & { sourceMap: undefined ***REMOVED*** & { compress: import("@swc/core").TerserCompressOptions ***REMOVED******REMOVED***
   */
  const buildSwcOptions = (swcOptions = {***REMOVED***) => {
    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366
    return {
      ...swcOptions,
      compress: typeof swcOptions.compress === "boolean" ? swcOptions.compress ? {***REMOVED*** : false : {
        ...swcOptions.compress
      ***REMOVED***,
      mangle: swcOptions.mangle == null ? true : typeof swcOptions.mangle === "boolean" ? swcOptions.mangle : {
        ...swcOptions.mangle
      ***REMOVED***,
      // ecma: swcOptions.ecma,
      // keep_classnames: swcOptions.keep_classnames,
      // keep_fnames: swcOptions.keep_fnames,
      // module: swcOptions.module,
      // safari10: swcOptions.safari10,
      // toplevel: swcOptions.toplevel
      // eslint-disable-next-line no-undefined
      sourceMap: undefined
    ***REMOVED***;
  ***REMOVED***;

  // eslint-disable-next-line import/no-extraneous-dependencies, global-require
  const swc = require("@swc/core");
  // Copy `swc` options
  const swcOptions = buildSwcOptions(minimizerOptions);

  // Let `swc` generate a SourceMap
  if (sourceMap) {
    // @ts-ignore
    swcOptions.sourceMap = true;
  ***REMOVED***
  if (swcOptions.compress) {
    // More optimizations
    if (typeof swcOptions.compress.ecma === "undefined") {
      swcOptions.compress.ecma = swcOptions.ecma;
    ***REMOVED***

    // https://github.com/webpack/webpack/issues/16135
    if (swcOptions.ecma === 5 && typeof swcOptions.compress.arrows === "undefined") {
      swcOptions.compress.arrows = false;
    ***REMOVED***
  ***REMOVED***
  const [[filename, code]] = Object.entries(input);
  const result = await swc.minify(code, swcOptions);
  let map;
  if (result.map) {
    map = JSON.parse(result.map);

    // TODO workaround for swc because `filename` is not preset as in `swc` signature as for `terser`
    map.sources = [filename];
    delete map.sourcesContent;
  ***REMOVED***
  return {
    code: result.code,
    map
  ***REMOVED***;
***REMOVED***

/**
 * @returns {string | undefined***REMOVED***
 */
swcMinify.getMinimizerVersion = () => {
  let packageJson;
  try {
    // eslint-disable-next-line global-require, import/no-extraneous-dependencies
    packageJson = require("@swc/core/package.json");
  ***REMOVED*** catch (error) {
    // Ignore
  ***REMOVED***
  return packageJson && packageJson.version;
***REMOVED***;

/**
 * @returns {boolean | undefined***REMOVED***
 */
swcMinify.supportsWorkerThreads = () => false;

/* istanbul ignore next */
/**
 * @param {Input***REMOVED*** input
 * @param {SourceMapInput | undefined***REMOVED*** sourceMap
 * @param {CustomOptions***REMOVED*** minimizerOptions
 * @return {Promise<MinimizedResult>***REMOVED***
 */
async function esbuildMinify(input, sourceMap, minimizerOptions) {
  /**
   * @param {PredefinedOptions<import("esbuild").TransformOptions> & import("esbuild").TransformOptions***REMOVED*** [esbuildOptions={***REMOVED***]
   * @returns {import("esbuild").TransformOptions***REMOVED***
   */
  const buildEsbuildOptions = (esbuildOptions = {***REMOVED***) => {
    // eslint-disable-next-line no-param-reassign
    delete esbuildOptions.ecma;
    if (esbuildOptions.module) {
      // eslint-disable-next-line no-param-reassign
      esbuildOptions.format = "esm";
    ***REMOVED***

    // eslint-disable-next-line no-param-reassign
    delete esbuildOptions.module;

    // Need deep copy objects to avoid https://github.com/terser/terser/issues/366
    return {
      minify: true,
      legalComments: "inline",
      ...esbuildOptions,
      sourcemap: false
    ***REMOVED***;
  ***REMOVED***;

  // eslint-disable-next-line import/no-extraneous-dependencies, global-require
  const esbuild = require("esbuild");

  // Copy `esbuild` options
  const esbuildOptions = buildEsbuildOptions(minimizerOptions);

  // Let `esbuild` generate a SourceMap
  if (sourceMap) {
    esbuildOptions.sourcemap = true;
    esbuildOptions.sourcesContent = false;
  ***REMOVED***
  const [[filename, code]] = Object.entries(input);
  esbuildOptions.sourcefile = filename;
  const result = await esbuild.transform(code, esbuildOptions);
  return {
    code: result.code,
    // eslint-disable-next-line no-undefined
    map: result.map ? JSON.parse(result.map) : undefined,
    warnings: result.warnings.length > 0 ? result.warnings.map(item => {
      const plugin = item.pluginName ? `\nPlugin Name: ${item.pluginName***REMOVED***` : "";
      const location = item.location ? `\n\n${item.location.file***REMOVED***:${item.location.line***REMOVED***:${item.location.column***REMOVED***:\n  ${item.location.line***REMOVED*** | ${item.location.lineText***REMOVED***\n\nSuggestion: ${item.location.suggestion***REMOVED***` : "";
      const notes = item.notes.length > 0 ? `\n\nNotes:\n${item.notes.map(note => `${note.location ? `[${note.location.file***REMOVED***:${note.location.line***REMOVED***:${note.location.column***REMOVED***] ` : ""***REMOVED***${note.text***REMOVED***${note.location ? `\nSuggestion: ${note.location.suggestion***REMOVED***` : ""***REMOVED***${note.location ? `\nLine text:\n${note.location.lineText***REMOVED***\n` : ""***REMOVED***`).join("\n")***REMOVED***` : "";
      return `${item.text***REMOVED*** [${item.id***REMOVED***]${plugin***REMOVED***${location***REMOVED***${item.detail ? `\nDetails:\n${item.detail***REMOVED***` : ""***REMOVED***${notes***REMOVED***`;
    ***REMOVED***) : []
  ***REMOVED***;
***REMOVED***

/**
 * @returns {string | undefined***REMOVED***
 */
esbuildMinify.getMinimizerVersion = () => {
  let packageJson;
  try {
    // eslint-disable-next-line global-require, import/no-extraneous-dependencies
    packageJson = require("esbuild/package.json");
  ***REMOVED*** catch (error) {
    // Ignore
  ***REMOVED***
  return packageJson && packageJson.version;
***REMOVED***;

/**
 * @returns {boolean | undefined***REMOVED***
 */
esbuildMinify.supportsWorkerThreads = () => false;

/**
 * @template T
 * @param fn {(function(): any) | undefined***REMOVED***
 * @returns {function(): T***REMOVED***
 */
function memoize(fn) {
  let cache = false;
  /** @type {T***REMOVED*** */
  let result;
  return () => {
    if (cache) {
      return result;
    ***REMOVED***
    result = /** @type {function(): any***REMOVED*** */fn();
    cache = true;
    // Allow to clean up memory for fn
    // and all dependent resources
    // eslint-disable-next-line no-undefined, no-param-reassign
    fn = undefined;
    return result;
  ***REMOVED***;
***REMOVED***
module.exports = {
  throttleAll,
  memoize,
  terserMinify,
  uglifyJsMinify,
  swcMinify,
  esbuildMinify
***REMOVED***;