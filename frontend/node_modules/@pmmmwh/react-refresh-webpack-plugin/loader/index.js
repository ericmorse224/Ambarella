// This is a patch for mozilla/source-map#349 -
// internally, it uses the existence of the `fetch` global to toggle browser behaviours.
// That check, however, will break when `fetch` polyfills are used for SSR setups.
// We "reset" the polyfill here to ensure it won't interfere with source-map generation.
const originalFetch = global.fetch;
delete global.fetch;

const { getOptions ***REMOVED*** = require('loader-utils');
const { validate: validateOptions ***REMOVED*** = require('schema-utils');
const { SourceMapConsumer, SourceNode ***REMOVED*** = require('source-map');
const {
  getIdentitySourceMap,
  getModuleSystem,
  getRefreshModuleRuntime,
  normalizeOptions,
***REMOVED*** = require('./utils');
const schema = require('./options.json');

const RefreshRuntimePath = require
  .resolve('react-refresh')
  .replace(/\\/g, '/')
  .replace(/'/g, "\\'");

/**
 * A simple Webpack loader to inject react-refresh HMR code into modules.
 *
 * [Reference for Loader API](https://webpack.js.org/api/loaders/)
 * @this {import('webpack').LoaderContext<import('./types').ReactRefreshLoaderOptions>***REMOVED***
 * @param {string***REMOVED*** source The original module source code.
 * @param {import('source-map').RawSourceMap***REMOVED*** [inputSourceMap] The source map of the module.
 * @param {****REMOVED*** [meta] The loader metadata passed in.
 * @returns {void***REMOVED***
 */
function ReactRefreshLoader(source, inputSourceMap, meta) {
  let options = getOptions(this);
  validateOptions(schema, options, {
    baseDataPath: 'options',
    name: 'React Refresh Loader',
  ***REMOVED***);

  options = normalizeOptions(options);

  const callback = this.async();

  const { ModuleFilenameHelpers, Template ***REMOVED*** = this._compiler.webpack || require('webpack');

  const RefreshSetupRuntimes = {
    cjs: Template.asString(
      `__webpack_require__.$Refresh$.runtime = require('${RefreshRuntimePath***REMOVED***');`
    ),
    esm: Template.asString([
      `import * as __react_refresh_runtime__ from '${RefreshRuntimePath***REMOVED***';`,
      `__webpack_require__.$Refresh$.runtime = __react_refresh_runtime__;`,
    ]),
  ***REMOVED***;

  /**
   * @this {import('webpack').LoaderContext<import('./types').ReactRefreshLoaderOptions>***REMOVED***
   * @param {string***REMOVED*** source
   * @param {import('source-map').RawSourceMap***REMOVED*** [inputSourceMap]
   * @returns {Promise<[string, import('source-map').RawSourceMap]>***REMOVED***
   */
  async function _loader(source, inputSourceMap) {
    /** @type {'esm' | 'cjs'***REMOVED*** */
    const moduleSystem = await getModuleSystem.call(this, ModuleFilenameHelpers, options);

    const RefreshSetupRuntime = RefreshSetupRuntimes[moduleSystem];
    const RefreshModuleRuntime = getRefreshModuleRuntime(Template, {
      const: options.const,
      moduleSystem,
    ***REMOVED***);

    if (this.sourceMap) {
      let originalSourceMap = inputSourceMap;
      if (!originalSourceMap) {
        originalSourceMap = getIdentitySourceMap(source, this.resourcePath);
      ***REMOVED***

      return SourceMapConsumer.with(originalSourceMap, undefined, (consumer) => {
        const node = SourceNode.fromStringWithSourceMap(source, consumer);

        node.prepend([RefreshSetupRuntime, '\n\n']);
        node.add(['\n\n', RefreshModuleRuntime]);

        const { code, map ***REMOVED*** = node.toStringWithSourceMap();
        return [code, map.toJSON()];
      ***REMOVED***);
    ***REMOVED*** else {
      return [[RefreshSetupRuntime, source, RefreshModuleRuntime].join('\n\n'), inputSourceMap];
    ***REMOVED***
  ***REMOVED***

  _loader.call(this, source, inputSourceMap).then(
    ([code, map]) => {
      callback(null, code, map, meta);
    ***REMOVED***,
    (error) => {
      callback(error);
    ***REMOVED***
  );
***REMOVED***

module.exports = ReactRefreshLoader;

// Restore the original value of the `fetch` global, if it exists
if (originalFetch) {
  global.fetch = originalFetch;
***REMOVED***
