const ANY = Symbol('SemVer ANY')
// hoisted class for cyclic dependency
class Comparator {
  static get ANY () {
    return ANY
  ***REMOVED***

  constructor (comp, options) {
    options = parseOptions(options)

    if (comp instanceof Comparator) {
      if (comp.loose === !!options.loose) {
        return comp
      ***REMOVED*** else {
        comp = comp.value
      ***REMOVED***
    ***REMOVED***

    comp = comp.trim().split(/\s+/).join(' ')
    debug('comparator', comp, options)
    this.options = options
    this.loose = !!options.loose
    this.parse(comp)

    if (this.semver === ANY) {
      this.value = ''
    ***REMOVED*** else {
      this.value = this.operator + this.semver.version
    ***REMOVED***

    debug('comp', this)
  ***REMOVED***

  parse (comp) {
    const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
    const m = comp.match(r)

    if (!m) {
      throw new TypeError(`Invalid comparator: ${comp***REMOVED***`)
    ***REMOVED***

    this.operator = m[1] !== undefined ? m[1] : ''
    if (this.operator === '=') {
      this.operator = ''
    ***REMOVED***

    // if it literally is just '>' or '' then allow anything.
    if (!m[2]) {
      this.semver = ANY
    ***REMOVED*** else {
      this.semver = new SemVer(m[2], this.options.loose)
    ***REMOVED***
  ***REMOVED***

  toString () {
    return this.value
  ***REMOVED***

  test (version) {
    debug('Comparator.test', version, this.options.loose)

    if (this.semver === ANY || version === ANY) {
      return true
    ***REMOVED***

    if (typeof version === 'string') {
      try {
        version = new SemVer(version, this.options)
      ***REMOVED*** catch (er) {
        return false
      ***REMOVED***
    ***REMOVED***

    return cmp(version, this.operator, this.semver, this.options)
  ***REMOVED***

  intersects (comp, options) {
    if (!(comp instanceof Comparator)) {
      throw new TypeError('a Comparator is required')
    ***REMOVED***

    if (this.operator === '') {
      if (this.value === '') {
        return true
      ***REMOVED***
      return new Range(comp.value, options).test(this.value)
    ***REMOVED*** else if (comp.operator === '') {
      if (comp.value === '') {
        return true
      ***REMOVED***
      return new Range(this.value, options).test(comp.semver)
    ***REMOVED***

    options = parseOptions(options)

    // Special cases where nothing can possibly be lower
    if (options.includePrerelease &&
      (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
      return false
    ***REMOVED***
    if (!options.includePrerelease &&
      (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
      return false
    ***REMOVED***

    // Same direction increasing (> or >=)
    if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
      return true
    ***REMOVED***
    // Same direction decreasing (< or <=)
    if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
      return true
    ***REMOVED***
    // same SemVer and both sides are inclusive (<= or >=)
    if (
      (this.semver.version === comp.semver.version) &&
      this.operator.includes('=') && comp.operator.includes('=')) {
      return true
    ***REMOVED***
    // opposite directions less than
    if (cmp(this.semver, '<', comp.semver, options) &&
      this.operator.startsWith('>') && comp.operator.startsWith('<')) {
      return true
    ***REMOVED***
    // opposite directions greater than
    if (cmp(this.semver, '>', comp.semver, options) &&
      this.operator.startsWith('<') && comp.operator.startsWith('>')) {
      return true
    ***REMOVED***
    return false
  ***REMOVED***
***REMOVED***

module.exports = Comparator

const parseOptions = require('../internal/parse-options')
const { safeRe: re, t ***REMOVED*** = require('../internal/re')
const cmp = require('../functions/cmp')
const debug = require('../internal/debug')
const SemVer = require('./semver')
const Range = require('./range')
