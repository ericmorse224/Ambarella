/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const RequireEnsureDependenciesBlock = require("./RequireEnsureDependenciesBlock");
const RequireEnsureDependency = require("./RequireEnsureDependency");
const RequireEnsureItemDependency = require("./RequireEnsureItemDependency");
const getFunctionExpression = require("./getFunctionExpression");

/** @typedef {import("../AsyncDependenciesBlock").GroupOptions***REMOVED*** GroupOptions */
/** @typedef {import("../ChunkGroup").ChunkGroupOptions***REMOVED*** ChunkGroupOptions */
/** @typedef {import("../Dependency").DependencyLocation***REMOVED*** DependencyLocation */
/** @typedef {import("../javascript/BasicEvaluatedExpression")***REMOVED*** BasicEvaluatedExpression */
/** @typedef {import("../javascript/JavascriptParser")***REMOVED*** JavascriptParser */
/** @typedef {import("../javascript/JavascriptParser").Range***REMOVED*** Range */

const PLUGIN_NAME = "RequireEnsureDependenciesBlockParserPlugin";

module.exports = class RequireEnsureDependenciesBlockParserPlugin {
	/**
	 * @param {JavascriptParser***REMOVED*** parser the parser
	 * @returns {void***REMOVED***
	 */
	apply(parser) {
		parser.hooks.call.for("require.ensure").tap(PLUGIN_NAME, expr => {
			/** @type {string | GroupOptions | null***REMOVED*** */
			let chunkName = null;
			let errorExpressionArg = null;
			let errorExpression = null;
			switch (expr.arguments.length) {
				case 4: {
					const chunkNameExpr = parser.evaluateExpression(expr.arguments[3]);
					if (!chunkNameExpr.isString()) return;
					chunkName =
						/** @type {string***REMOVED*** */
						(chunkNameExpr.string);
				***REMOVED***
				// falls through
				case 3: {
					errorExpressionArg = expr.arguments[2];
					errorExpression = getFunctionExpression(errorExpressionArg);

					if (!errorExpression && !chunkName) {
						const chunkNameExpr = parser.evaluateExpression(expr.arguments[2]);
						if (!chunkNameExpr.isString()) return;
						chunkName =
							/** @type {string***REMOVED*** */
							(chunkNameExpr.string);
					***REMOVED***
				***REMOVED***
				// falls through
				case 2: {
					const dependenciesExpr = parser.evaluateExpression(expr.arguments[0]);
					const dependenciesItems = /** @type {BasicEvaluatedExpression[]***REMOVED*** */ (
						dependenciesExpr.isArray()
							? dependenciesExpr.items
							: [dependenciesExpr]
					);
					const successExpressionArg = expr.arguments[1];
					const successExpression = getFunctionExpression(successExpressionArg);

					if (successExpression) {
						parser.walkExpressions(successExpression.expressions);
					***REMOVED***
					if (errorExpression) {
						parser.walkExpressions(errorExpression.expressions);
					***REMOVED***

					const depBlock = new RequireEnsureDependenciesBlock(
						chunkName,
						/** @type {DependencyLocation***REMOVED*** */
						(expr.loc)
					);
					const errorCallbackExists =
						expr.arguments.length === 4 ||
						(!chunkName && expr.arguments.length === 3);
					const dep = new RequireEnsureDependency(
						/** @type {Range***REMOVED*** */ (expr.range),
						/** @type {Range***REMOVED*** */ (expr.arguments[1].range),
						errorCallbackExists &&
							/** @type {Range***REMOVED*** */ (expr.arguments[2].range)
					);
					dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expr.loc);
					depBlock.addDependency(dep);
					const old = parser.state.current;
					parser.state.current = /** @type {TODO***REMOVED*** */ (depBlock);
					try {
						let failed = false;
						parser.inScope([], () => {
							for (const ee of dependenciesItems) {
								if (ee.isString()) {
									const ensureDependency = new RequireEnsureItemDependency(
										/** @type {string***REMOVED*** */ (ee.string)
									);
									ensureDependency.loc =
										/** @type {DependencyLocation***REMOVED*** */
										(expr.loc);
									depBlock.addDependency(ensureDependency);
								***REMOVED*** else {
									failed = true;
								***REMOVED***
							***REMOVED***
						***REMOVED***);
						if (failed) {
							return;
						***REMOVED***
						if (successExpression) {
							if (successExpression.fn.body.type === "BlockStatement") {
								parser.walkStatement(successExpression.fn.body);
							***REMOVED*** else {
								parser.walkExpression(successExpression.fn.body);
							***REMOVED***
						***REMOVED***
						old.addBlock(depBlock);
					***REMOVED*** finally {
						parser.state.current = old;
					***REMOVED***
					if (!successExpression) {
						parser.walkExpression(successExpressionArg);
					***REMOVED***
					if (errorExpression) {
						if (errorExpression.fn.body.type === "BlockStatement") {
							parser.walkStatement(errorExpression.fn.body);
						***REMOVED*** else {
							parser.walkExpression(errorExpression.fn.body);
						***REMOVED***
					***REMOVED*** else if (errorExpressionArg) {
						parser.walkExpression(errorExpressionArg);
					***REMOVED***
					return true;
				***REMOVED***
			***REMOVED***
		***REMOVED***);
	***REMOVED***
***REMOVED***;
