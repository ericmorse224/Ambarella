/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const Hash = require("./Hash");

/** @typedef {import("../../declarations/WebpackOptions").HashFunction***REMOVED*** HashFunction */

const BULK_SIZE = 2000;

// We are using an object instead of a Map as this will stay static during the runtime
// so access to it can be optimized by v8
/** @type {{[key: string]: Map<string, string>***REMOVED******REMOVED*** */
const digestCaches = {***REMOVED***;

/** @typedef {() => Hash***REMOVED*** HashFactory */

class BulkUpdateDecorator extends Hash {
	/**
	 * @param {Hash | HashFactory***REMOVED*** hashOrFactory function to create a hash
	 * @param {string=***REMOVED*** hashKey key for caching
	 */
	constructor(hashOrFactory, hashKey) {
		super();
		this.hashKey = hashKey;
		if (typeof hashOrFactory === "function") {
			this.hashFactory = hashOrFactory;
			this.hash = undefined;
		***REMOVED*** else {
			this.hashFactory = undefined;
			this.hash = hashOrFactory;
		***REMOVED***
		this.buffer = "";
	***REMOVED***

	/**
	 * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding***REMOVED***
	 * @param {string|Buffer***REMOVED*** data data
	 * @param {string=***REMOVED*** inputEncoding data encoding
	 * @returns {this***REMOVED*** updated hash
	 */
	update(data, inputEncoding) {
		if (
			inputEncoding !== undefined ||
			typeof data !== "string" ||
			data.length > BULK_SIZE
		) {
			if (this.hash === undefined)
				this.hash = /** @type {HashFactory***REMOVED*** */ (this.hashFactory)();
			if (this.buffer.length > 0) {
				this.hash.update(this.buffer);
				this.buffer = "";
			***REMOVED***
			this.hash.update(data, inputEncoding);
		***REMOVED*** else {
			this.buffer += data;
			if (this.buffer.length > BULK_SIZE) {
				if (this.hash === undefined)
					this.hash = /** @type {HashFactory***REMOVED*** */ (this.hashFactory)();
				this.hash.update(this.buffer);
				this.buffer = "";
			***REMOVED***
		***REMOVED***
		return this;
	***REMOVED***

	/**
	 * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding***REMOVED***
	 * @param {string=***REMOVED*** encoding encoding of the return value
	 * @returns {string|Buffer***REMOVED*** digest
	 */
	digest(encoding) {
		let digestCache;
		const buffer = this.buffer;
		if (this.hash === undefined) {
			// short data for hash, we can use caching
			const cacheKey = `${this.hashKey***REMOVED***-${encoding***REMOVED***`;
			digestCache = digestCaches[cacheKey];
			if (digestCache === undefined) {
				digestCache = digestCaches[cacheKey] = new Map();
			***REMOVED***
			const cacheEntry = digestCache.get(buffer);
			if (cacheEntry !== undefined) return cacheEntry;
			this.hash = /** @type {HashFactory***REMOVED*** */ (this.hashFactory)();
		***REMOVED***
		if (buffer.length > 0) {
			this.hash.update(buffer);
		***REMOVED***
		const digestResult = this.hash.digest(encoding);
		const result =
			typeof digestResult === "string" ? digestResult : digestResult.toString();
		if (digestCache !== undefined) {
			digestCache.set(buffer, result);
		***REMOVED***
		return result;
	***REMOVED***
***REMOVED***

/* istanbul ignore next */
class DebugHash extends Hash {
	constructor() {
		super();
		this.string = "";
	***REMOVED***

	/**
	 * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding***REMOVED***
	 * @param {string|Buffer***REMOVED*** data data
	 * @param {string=***REMOVED*** inputEncoding data encoding
	 * @returns {this***REMOVED*** updated hash
	 */
	update(data, inputEncoding) {
		if (typeof data !== "string") data = data.toString("utf-8");
		const prefix = Buffer.from("@webpack-debug-digest@").toString("hex");
		if (data.startsWith(prefix)) {
			data = Buffer.from(data.slice(prefix.length), "hex").toString();
		***REMOVED***
		this.string += `[${data***REMOVED***](${
			/** @type {string***REMOVED*** */ (new Error().stack).split("\n", 3)[2]
		***REMOVED***)\n`;
		return this;
	***REMOVED***

	/**
	 * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding***REMOVED***
	 * @param {string=***REMOVED*** encoding encoding of the return value
	 * @returns {string|Buffer***REMOVED*** digest
	 */
	digest(encoding) {
		return Buffer.from(`@webpack-debug-digest@${this.string***REMOVED***`).toString("hex");
	***REMOVED***
***REMOVED***

/** @type {typeof import("crypto") | undefined***REMOVED*** */
let crypto;
/** @type {typeof import("./hash/xxhash64") | undefined***REMOVED*** */
let createXXHash64;
/** @type {typeof import("./hash/md4") | undefined***REMOVED*** */
let createMd4;
/** @type {typeof import("./hash/BatchedHash") | undefined***REMOVED*** */
let BatchedHash;

/**
 * Creates a hash by name or function
 * @param {HashFunction***REMOVED*** algorithm the algorithm name or a constructor creating a hash
 * @returns {Hash***REMOVED*** the hash
 */
module.exports = algorithm => {
	if (typeof algorithm === "function") {
		// eslint-disable-next-line new-cap
		return new BulkUpdateDecorator(() => new algorithm());
	***REMOVED***
	switch (algorithm) {
		// TODO add non-cryptographic algorithm here
		case "debug":
			return new DebugHash();
		case "xxhash64":
			if (createXXHash64 === undefined) {
				createXXHash64 = require("./hash/xxhash64");
				if (BatchedHash === undefined) {
					BatchedHash = require("./hash/BatchedHash");
				***REMOVED***
			***REMOVED***
			return new /** @type {typeof import("./hash/BatchedHash")***REMOVED*** */ (
				BatchedHash
			)(createXXHash64());
		case "md4":
			if (createMd4 === undefined) {
				createMd4 = require("./hash/md4");
				if (BatchedHash === undefined) {
					BatchedHash = require("./hash/BatchedHash");
				***REMOVED***
			***REMOVED***
			return new /** @type {typeof import("./hash/BatchedHash")***REMOVED*** */ (
				BatchedHash
			)(createMd4());
		case "native-md4":
			if (crypto === undefined) crypto = require("crypto");
			return new BulkUpdateDecorator(
				() => /** @type {typeof import("crypto")***REMOVED*** */ (crypto).createHash("md4"),
				"md4"
			);
		default:
			if (crypto === undefined) crypto = require("crypto");
			return new BulkUpdateDecorator(
				() =>
					/** @type {typeof import("crypto")***REMOVED*** */ (crypto).createHash(algorithm),
				algorithm
			);
	***REMOVED***
***REMOVED***;
