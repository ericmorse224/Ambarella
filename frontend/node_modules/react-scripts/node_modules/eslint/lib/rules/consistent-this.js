/**
 * @fileoverview Rule to enforce consistent naming of "this" context variables
 * @author Raphael Pigulla
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule***REMOVED*** */
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "Enforce consistent naming when capturing the current execution context",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/consistent-this"
        ***REMOVED***,

        schema: {
            type: "array",
            items: {
                type: "string",
                minLength: 1
            ***REMOVED***,
            uniqueItems: true
        ***REMOVED***,

        messages: {
            aliasNotAssignedToThis: "Designated alias '{{name***REMOVED******REMOVED***' is not assigned to 'this'.",
            unexpectedAlias: "Unexpected alias '{{name***REMOVED******REMOVED***' for 'this'."
        ***REMOVED***
    ***REMOVED***,

    create(context) {
        let aliases = [];
        const sourceCode = context.sourceCode;

        if (context.options.length === 0) {
            aliases.push("that");
        ***REMOVED*** else {
            aliases = context.options;
        ***REMOVED***

        /**
         * Reports that a variable declarator or assignment expression is assigning
         * a non-'this' value to the specified alias.
         * @param {ASTNode***REMOVED*** node The assigning node.
         * @param {string***REMOVED*** name the name of the alias that was incorrectly used.
         * @returns {void***REMOVED***
         */
        function reportBadAssignment(node, name) {
            context.report({ node, messageId: "aliasNotAssignedToThis", data: { name ***REMOVED*** ***REMOVED***);
        ***REMOVED***

        /**
         * Checks that an assignment to an identifier only assigns 'this' to the
         * appropriate alias, and the alias is only assigned to 'this'.
         * @param {ASTNode***REMOVED*** node The assigning node.
         * @param {Identifier***REMOVED*** name The name of the variable assigned to.
         * @param {Expression***REMOVED*** value The value of the assignment.
         * @returns {void***REMOVED***
         */
        function checkAssignment(node, name, value) {
            const isThis = value.type === "ThisExpression";

            if (aliases.includes(name)) {
                if (!isThis || node.operator && node.operator !== "=") {
                    reportBadAssignment(node, name);
                ***REMOVED***
            ***REMOVED*** else if (isThis) {
                context.report({ node, messageId: "unexpectedAlias", data: { name ***REMOVED*** ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Ensures that a variable declaration of the alias in a program or function
         * is assigned to the correct value.
         * @param {string***REMOVED*** alias alias the check the assignment of.
         * @param {Object***REMOVED*** scope scope of the current code we are checking.
         * @private
         * @returns {void***REMOVED***
         */
        function checkWasAssigned(alias, scope) {
            const variable = scope.set.get(alias);

            if (!variable) {
                return;
            ***REMOVED***

            if (variable.defs.some(def => def.node.type === "VariableDeclarator" &&
                def.node.init !== null)) {
                return;
            ***REMOVED***

            /*
             * The alias has been declared and not assigned: check it was
             * assigned later in the same scope.
             */
            if (!variable.references.some(reference => {
                const write = reference.writeExpr;

                return (
                    reference.from === scope &&
                    write && write.type === "ThisExpression" &&
                    write.parent.operator === "="
                );
            ***REMOVED***)) {
                variable.defs.map(def => def.node).forEach(node => {
                    reportBadAssignment(node, alias);
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Check each alias to ensure that is was assigned to the correct value.
         * @param {ASTNode***REMOVED*** node The node that represents the scope to check.
         * @returns {void***REMOVED***
         */
        function ensureWasAssigned(node) {
            const scope = sourceCode.getScope(node);

            aliases.forEach(alias => {
                checkWasAssigned(alias, scope);
            ***REMOVED***);
        ***REMOVED***

        return {
            "Program:exit": ensureWasAssigned,
            "FunctionExpression:exit": ensureWasAssigned,
            "FunctionDeclaration:exit": ensureWasAssigned,

            VariableDeclarator(node) {
                const id = node.id;
                const isDestructuring =
                    id.type === "ArrayPattern" || id.type === "ObjectPattern";

                if (node.init !== null && !isDestructuring) {
                    checkAssignment(node, id.name, node.init);
                ***REMOVED***
            ***REMOVED***,

            AssignmentExpression(node) {
                if (node.left.type === "Identifier") {
                    checkAssignment(node, node.left.name, node.right);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
