/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const asyncLib = require("neo-async");
const { AsyncSeriesWaterfallHook, SyncWaterfallHook ***REMOVED*** = require("tapable");
const ContextModule = require("./ContextModule");
const ModuleFactory = require("./ModuleFactory");
const ContextElementDependency = require("./dependencies/ContextElementDependency");
const LazySet = require("./util/LazySet");
const { cachedSetProperty ***REMOVED*** = require("./util/cleverMerge");
const { createFakeHook ***REMOVED*** = require("./util/deprecation");
const { join ***REMOVED*** = require("./util/fs");

/** @typedef {import("./ContextModule").ContextModuleOptions***REMOVED*** ContextModuleOptions */
/** @typedef {import("./ContextModule").ResolveDependenciesCallback***REMOVED*** ResolveDependenciesCallback */
/** @typedef {import("./Module")***REMOVED*** Module */
/** @typedef {import("./ModuleFactory").ModuleFactoryCreateData***REMOVED*** ModuleFactoryCreateData */
/** @typedef {import("./ModuleFactory").ModuleFactoryCallback***REMOVED*** ModuleFactoryCallback */
/** @typedef {import("./ResolverFactory")***REMOVED*** ResolverFactory */
/** @typedef {import("./dependencies/ContextDependency")***REMOVED*** ContextDependency */
/** @typedef {import("enhanced-resolve").ResolveRequest***REMOVED*** ResolveRequest */
/**
 * @template T
 * @typedef {import("./util/deprecation").FakeHook<T>***REMOVED*** FakeHook<T>
 */
/** @typedef {import("./util/fs").IStats***REMOVED*** IStats */
/** @typedef {import("./util/fs").InputFileSystem***REMOVED*** InputFileSystem */
/** @typedef {{ context: string, request: string ***REMOVED******REMOVED*** ContextAlternativeRequest */

const EMPTY_RESOLVE_OPTIONS = {***REMOVED***;

module.exports = class ContextModuleFactory extends ModuleFactory {
	/**
	 * @param {ResolverFactory***REMOVED*** resolverFactory resolverFactory
	 */
	constructor(resolverFactory) {
		super();
		/** @type {AsyncSeriesWaterfallHook<[ContextAlternativeRequest[], ContextModuleOptions]>***REMOVED*** */
		const alternativeRequests = new AsyncSeriesWaterfallHook([
			"modules",
			"options"
		]);
		this.hooks = Object.freeze({
			/** @type {AsyncSeriesWaterfallHook<[TODO]>***REMOVED*** */
			beforeResolve: new AsyncSeriesWaterfallHook(["data"]),
			/** @type {AsyncSeriesWaterfallHook<[TODO]>***REMOVED*** */
			afterResolve: new AsyncSeriesWaterfallHook(["data"]),
			/** @type {SyncWaterfallHook<[string[]]>***REMOVED*** */
			contextModuleFiles: new SyncWaterfallHook(["files"]),
			/** @type {FakeHook<Pick<AsyncSeriesWaterfallHook<[ContextAlternativeRequest[]]>, "tap" | "tapAsync" | "tapPromise" | "name">>***REMOVED*** */
			alternatives: createFakeHook(
				{
					name: "alternatives",
					/** @type {AsyncSeriesWaterfallHook<[ContextAlternativeRequest[]]>["intercept"]***REMOVED*** */
					intercept: interceptor => {
						throw new Error(
							"Intercepting fake hook ContextModuleFactory.hooks.alternatives is not possible, use ContextModuleFactory.hooks.alternativeRequests instead"
						);
					***REMOVED***,
					/** @type {AsyncSeriesWaterfallHook<[ContextAlternativeRequest[]]>["tap"]***REMOVED*** */
					tap: (options, fn) => {
						alternativeRequests.tap(options, fn);
					***REMOVED***,
					/** @type {AsyncSeriesWaterfallHook<[ContextAlternativeRequest[]]>["tapAsync"]***REMOVED*** */
					tapAsync: (options, fn) => {
						alternativeRequests.tapAsync(options, (items, _options, callback) =>
							fn(items, callback)
						);
					***REMOVED***,
					/** @type {AsyncSeriesWaterfallHook<[ContextAlternativeRequest[]]>["tapPromise"]***REMOVED*** */
					tapPromise: (options, fn) => {
						alternativeRequests.tapPromise(options, fn);
					***REMOVED***
				***REMOVED***,
				"ContextModuleFactory.hooks.alternatives has deprecated in favor of ContextModuleFactory.hooks.alternativeRequests with an additional options argument.",
				"DEP_WEBPACK_CONTEXT_MODULE_FACTORY_ALTERNATIVES"
			),
			alternativeRequests
		***REMOVED***);
		this.resolverFactory = resolverFactory;
	***REMOVED***

	/**
	 * @param {ModuleFactoryCreateData***REMOVED*** data data object
	 * @param {ModuleFactoryCallback***REMOVED*** callback callback
	 * @returns {void***REMOVED***
	 */
	create(data, callback) {
		const context = data.context;
		const dependencies = data.dependencies;
		const resolveOptions = data.resolveOptions;
		const dependency = /** @type {ContextDependency***REMOVED*** */ (dependencies[0]);
		const fileDependencies = new LazySet();
		const missingDependencies = new LazySet();
		const contextDependencies = new LazySet();
		this.hooks.beforeResolve.callAsync(
			{
				context,
				dependencies,
				layer: data.contextInfo.issuerLayer,
				resolveOptions,
				fileDependencies,
				missingDependencies,
				contextDependencies,
				...dependency.options
			***REMOVED***,
			(err, beforeResolveResult) => {
				if (err) {
					return callback(err, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					***REMOVED***);
				***REMOVED***

				// Ignored
				if (!beforeResolveResult) {
					return callback(null, {
						fileDependencies,
						missingDependencies,
						contextDependencies
					***REMOVED***);
				***REMOVED***

				const context = beforeResolveResult.context;
				const request = beforeResolveResult.request;
				const resolveOptions = beforeResolveResult.resolveOptions;

				let loaders;
				let resource;
				let loadersPrefix = "";
				const idx = request.lastIndexOf("!");
				if (idx >= 0) {
					let loadersRequest = request.slice(0, idx + 1);
					let i;
					for (
						i = 0;
						i < loadersRequest.length && loadersRequest[i] === "!";
						i++
					) {
						loadersPrefix += "!";
					***REMOVED***
					loadersRequest = loadersRequest
						.slice(i)
						.replace(/!+$/, "")
						.replace(/!!+/g, "!");
					loaders = loadersRequest === "" ? [] : loadersRequest.split("!");
					resource = request.slice(idx + 1);
				***REMOVED*** else {
					loaders = [];
					resource = request;
				***REMOVED***

				const contextResolver = this.resolverFactory.get(
					"context",
					dependencies.length > 0
						? cachedSetProperty(
								resolveOptions || EMPTY_RESOLVE_OPTIONS,
								"dependencyType",
								dependencies[0].category
							)
						: resolveOptions
				);
				const loaderResolver = this.resolverFactory.get("loader");

				asyncLib.parallel(
					[
						callback => {
							const results = /** @type ResolveRequest[] */ ([]);
							/**
							 * @param {ResolveRequest***REMOVED*** obj obj
							 * @returns {void***REMOVED***
							 */
							const yield_ = obj => {
								results.push(obj);
							***REMOVED***;

							contextResolver.resolve(
								{***REMOVED***,
								context,
								resource,
								{
									fileDependencies,
									missingDependencies,
									contextDependencies,
									yield: yield_
								***REMOVED***,
								err => {
									if (err) return callback(err);
									callback(null, results);
								***REMOVED***
							);
						***REMOVED***,
						callback => {
							asyncLib.map(
								loaders,
								(loader, callback) => {
									loaderResolver.resolve(
										{***REMOVED***,
										context,
										loader,
										{
											fileDependencies,
											missingDependencies,
											contextDependencies
										***REMOVED***,
										(err, result) => {
											if (err) return callback(err);
											callback(null, /** @type {string***REMOVED*** */ (result));
										***REMOVED***
									);
								***REMOVED***,
								callback
							);
						***REMOVED***
					],
					(err, result) => {
						if (err) {
							return callback(err, {
								fileDependencies,
								missingDependencies,
								contextDependencies
							***REMOVED***);
						***REMOVED***
						let [contextResult, loaderResult] =
							/** @type {[ResolveRequest[], string[]]***REMOVED*** */ (result);
						if (contextResult.length > 1) {
							const first = contextResult[0];
							contextResult = contextResult.filter(r => r.path);
							if (contextResult.length === 0) contextResult.push(first);
						***REMOVED***
						this.hooks.afterResolve.callAsync(
							{
								addon:
									loadersPrefix +
									loaderResult.join("!") +
									(loaderResult.length > 0 ? "!" : ""),
								resource:
									contextResult.length > 1
										? contextResult.map(r => r.path)
										: contextResult[0].path,
								resolveDependencies: this.resolveDependencies.bind(this),
								resourceQuery: contextResult[0].query,
								resourceFragment: contextResult[0].fragment,
								...beforeResolveResult
							***REMOVED***,
							(err, result) => {
								if (err) {
									return callback(err, {
										fileDependencies,
										missingDependencies,
										contextDependencies
									***REMOVED***);
								***REMOVED***

								// Ignored
								if (!result) {
									return callback(null, {
										fileDependencies,
										missingDependencies,
										contextDependencies
									***REMOVED***);
								***REMOVED***

								return callback(null, {
									module: new ContextModule(result.resolveDependencies, result),
									fileDependencies,
									missingDependencies,
									contextDependencies
								***REMOVED***);
							***REMOVED***
						);
					***REMOVED***
				);
			***REMOVED***
		);
	***REMOVED***

	/**
	 * @param {InputFileSystem***REMOVED*** fs file system
	 * @param {ContextModuleOptions***REMOVED*** options options
	 * @param {ResolveDependenciesCallback***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	resolveDependencies(fs, options, callback) {
		const cmf = this;
		const {
			resource,
			resourceQuery,
			resourceFragment,
			recursive,
			regExp,
			include,
			exclude,
			referencedExports,
			category,
			typePrefix,
			attributes
		***REMOVED*** = options;
		if (!regExp || !resource) return callback(null, []);

		/**
		 * @param {string***REMOVED*** ctx context
		 * @param {string***REMOVED*** directory directory
		 * @param {Set<string>***REMOVED*** visited visited
		 * @param {ResolveDependenciesCallback***REMOVED*** callback callback
		 */
		const addDirectoryChecked = (ctx, directory, visited, callback) => {
			/** @type {NonNullable<InputFileSystem["realpath"]>***REMOVED*** */
			(fs.realpath)(directory, (err, _realPath) => {
				if (err) return callback(err);
				const realPath = /** @type {string***REMOVED*** */ (_realPath);
				if (visited.has(realPath)) return callback(null, []);
				/** @type {Set<string> | undefined***REMOVED*** */
				let recursionStack;
				addDirectory(
					ctx,
					directory,
					(_, dir, callback) => {
						if (recursionStack === undefined) {
							recursionStack = new Set(visited);
							recursionStack.add(realPath);
						***REMOVED***
						addDirectoryChecked(ctx, dir, recursionStack, callback);
					***REMOVED***,
					callback
				);
			***REMOVED***);
		***REMOVED***;

		/**
		 * @param {string***REMOVED*** ctx context
		 * @param {string***REMOVED*** directory directory
		 * @param {(context: string, subResource: string, callback: () => void) => void***REMOVED*** addSubDirectory addSubDirectoryFn
		 * @param {ResolveDependenciesCallback***REMOVED*** callback callback
		 */
		const addDirectory = (ctx, directory, addSubDirectory, callback) => {
			fs.readdir(directory, (err, files) => {
				if (err) return callback(err);
				const processedFiles = cmf.hooks.contextModuleFiles.call(
					/** @type {string[]***REMOVED*** */ (files).map(file => file.normalize("NFC"))
				);
				if (!processedFiles || processedFiles.length === 0)
					return callback(null, []);
				asyncLib.map(
					processedFiles.filter(p => p.indexOf(".") !== 0),
					(segment, callback) => {
						const subResource = join(fs, directory, segment);

						if (!exclude || !subResource.match(exclude)) {
							fs.stat(subResource, (err, _stat) => {
								if (err) {
									if (err.code === "ENOENT") {
										// ENOENT is ok here because the file may have been deleted between
										// the readdir and stat calls.
										return callback();
									***REMOVED***
									return callback(err);
								***REMOVED***

								const stat = /** @type {IStats***REMOVED*** */ (_stat);

								if (stat.isDirectory()) {
									if (!recursive) return callback();
									addSubDirectory(ctx, subResource, callback);
								***REMOVED*** else if (
									stat.isFile() &&
									(!include || subResource.match(include))
								) {
									/** @type {{ context: string, request: string ***REMOVED******REMOVED*** */
									const obj = {
										context: ctx,
										request: `.${subResource.slice(ctx.length).replace(/\\/g, "/")***REMOVED***`
									***REMOVED***;

									this.hooks.alternativeRequests.callAsync(
										[obj],
										options,
										(err, alternatives) => {
											if (err) return callback(err);
											callback(
												null,
												/** @type {ContextAlternativeRequest[]***REMOVED*** */
												(alternatives)
													.filter(obj =>
														regExp.test(/** @type {string***REMOVED*** */ (obj.request))
													)
													.map(obj => {
														const dep = new ContextElementDependency(
															`${obj.request***REMOVED***${resourceQuery***REMOVED***${resourceFragment***REMOVED***`,
															obj.request,
															typePrefix,
															/** @type {string***REMOVED*** */
															(category),
															referencedExports,
															obj.context,
															attributes
														);
														dep.optional = true;
														return dep;
													***REMOVED***)
											);
										***REMOVED***
									);
								***REMOVED*** else {
									callback();
								***REMOVED***
							***REMOVED***);
						***REMOVED*** else {
							callback();
						***REMOVED***
					***REMOVED***,
					(err, result) => {
						if (err) return callback(err);

						if (!result) return callback(null, []);

						const flattenedResult = [];

						for (const item of result) {
							if (item) flattenedResult.push(...item);
						***REMOVED***

						callback(null, flattenedResult);
					***REMOVED***
				);
			***REMOVED***);
		***REMOVED***;

		/**
		 * @param {string***REMOVED*** ctx context
		 * @param {string***REMOVED*** dir dir
		 * @param {ResolveDependenciesCallback***REMOVED*** callback callback
		 * @returns {void***REMOVED***
		 */
		const addSubDirectory = (ctx, dir, callback) =>
			addDirectory(ctx, dir, addSubDirectory, callback);

		/**
		 * @param {string***REMOVED*** resource resource
		 * @param {ResolveDependenciesCallback***REMOVED*** callback callback
		 */
		const visitResource = (resource, callback) => {
			if (typeof fs.realpath === "function") {
				addDirectoryChecked(resource, resource, new Set(), callback);
			***REMOVED*** else {
				addDirectory(resource, resource, addSubDirectory, callback);
			***REMOVED***
		***REMOVED***;

		if (typeof resource === "string") {
			visitResource(resource, callback);
		***REMOVED*** else {
			asyncLib.map(resource, visitResource, (err, _result) => {
				if (err) return callback(err);
				const result = /** @type {ContextElementDependency[][]***REMOVED*** */ (_result);

				// result dependencies should have unique userRequest
				// ordered by resolve result
				/** @type {Set<string>***REMOVED*** */
				const temp = new Set();
				/** @type {ContextElementDependency[]***REMOVED*** */
				const res = [];
				for (let i = 0; i < result.length; i++) {
					const inner = result[i];
					for (const el of inner) {
						if (temp.has(el.userRequest)) continue;
						res.push(el);
						temp.add(el.userRequest);
					***REMOVED***
				***REMOVED***
				callback(null, res);
			***REMOVED***);
		***REMOVED***
	***REMOVED***
***REMOVED***;
