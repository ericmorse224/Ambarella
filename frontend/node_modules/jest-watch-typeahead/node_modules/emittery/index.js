'use strict';

const anyMap = new WeakMap();
const eventsMap = new WeakMap();
const producersMap = new WeakMap();
const anyProducer = Symbol('anyProducer');
const resolvedPromise = Promise.resolve();

const listenerAdded = Symbol('listenerAdded');
const listenerRemoved = Symbol('listenerRemoved');

let isGlobalDebugEnabled = false;

function assertEventName(eventName) {
	if (typeof eventName !== 'string' && typeof eventName !== 'symbol') {
		throw new TypeError('eventName must be a string or a symbol');
	***REMOVED***
***REMOVED***

function assertListener(listener) {
	if (typeof listener !== 'function') {
		throw new TypeError('listener must be a function');
	***REMOVED***
***REMOVED***

function getListeners(instance, eventName) {
	const events = eventsMap.get(instance);
	if (!events.has(eventName)) {
		events.set(eventName, new Set());
	***REMOVED***

	return events.get(eventName);
***REMOVED***

function getEventProducers(instance, eventName) {
	const key = typeof eventName === 'string' || typeof eventName === 'symbol' ? eventName : anyProducer;
	const producers = producersMap.get(instance);
	if (!producers.has(key)) {
		producers.set(key, new Set());
	***REMOVED***

	return producers.get(key);
***REMOVED***

function enqueueProducers(instance, eventName, eventData) {
	const producers = producersMap.get(instance);
	if (producers.has(eventName)) {
		for (const producer of producers.get(eventName)) {
			producer.enqueue(eventData);
		***REMOVED***
	***REMOVED***

	if (producers.has(anyProducer)) {
		const item = Promise.all([eventName, eventData]);
		for (const producer of producers.get(anyProducer)) {
			producer.enqueue(item);
		***REMOVED***
	***REMOVED***
***REMOVED***

function iterator(instance, eventNames) {
	eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];

	let isFinished = false;
	let flush = () => {***REMOVED***;
	let queue = [];

	const producer = {
		enqueue(item) {
			queue.push(item);
			flush();
		***REMOVED***,
		finish() {
			isFinished = true;
			flush();
		***REMOVED***
	***REMOVED***;

	for (const eventName of eventNames) {
		getEventProducers(instance, eventName).add(producer);
	***REMOVED***

	return {
		async next() {
			if (!queue) {
				return {done: true***REMOVED***;
			***REMOVED***

			if (queue.length === 0) {
				if (isFinished) {
					queue = undefined;
					return this.next();
				***REMOVED***

				await new Promise(resolve => {
					flush = resolve;
				***REMOVED***);

				return this.next();
			***REMOVED***

			return {
				done: false,
				value: await queue.shift()
			***REMOVED***;
		***REMOVED***,

		async return(value) {
			queue = undefined;

			for (const eventName of eventNames) {
				getEventProducers(instance, eventName).delete(producer);
			***REMOVED***

			flush();

			return arguments.length > 0 ?
				{done: true, value: await value***REMOVED*** :
				{done: true***REMOVED***;
		***REMOVED***,

		[Symbol.asyncIterator]() {
			return this;
		***REMOVED***
	***REMOVED***;
***REMOVED***

function defaultMethodNamesOrAssert(methodNames) {
	if (methodNames === undefined) {
		return allEmitteryMethods;
	***REMOVED***

	if (!Array.isArray(methodNames)) {
		throw new TypeError('`methodNames` must be an array of strings');
	***REMOVED***

	for (const methodName of methodNames) {
		if (!allEmitteryMethods.includes(methodName)) {
			if (typeof methodName !== 'string') {
				throw new TypeError('`methodNames` element must be a string');
			***REMOVED***

			throw new Error(`${methodName***REMOVED*** is not Emittery method`);
		***REMOVED***
	***REMOVED***

	return methodNames;
***REMOVED***

const isListenerSymbol = symbol => symbol === listenerAdded || symbol === listenerRemoved;

class Emittery {
	static mixin(emitteryPropertyName, methodNames) {
		methodNames = defaultMethodNamesOrAssert(methodNames);
		return target => {
			if (typeof target !== 'function') {
				throw new TypeError('`target` must be function');
			***REMOVED***

			for (const methodName of methodNames) {
				if (target.prototype[methodName] !== undefined) {
					throw new Error(`The property \`${methodName***REMOVED***\` already exists on \`target\``);
				***REMOVED***
			***REMOVED***

			function getEmitteryProperty() {
				Object.defineProperty(this, emitteryPropertyName, {
					enumerable: false,
					value: new Emittery()
				***REMOVED***);
				return this[emitteryPropertyName];
			***REMOVED***

			Object.defineProperty(target.prototype, emitteryPropertyName, {
				enumerable: false,
				get: getEmitteryProperty
			***REMOVED***);

			const emitteryMethodCaller = methodName => function (...args) {
				return this[emitteryPropertyName][methodName](...args);
			***REMOVED***;

			for (const methodName of methodNames) {
				Object.defineProperty(target.prototype, methodName, {
					enumerable: false,
					value: emitteryMethodCaller(methodName)
				***REMOVED***);
			***REMOVED***

			return target;
		***REMOVED***;
	***REMOVED***

	static get isDebugEnabled() {
		if (typeof process !== 'object') {
			return isGlobalDebugEnabled;
		***REMOVED***

		const {env***REMOVED*** = process || {env: {***REMOVED******REMOVED***;
		return env.DEBUG === 'emittery' || env.DEBUG === '*' || isGlobalDebugEnabled;
	***REMOVED***

	static set isDebugEnabled(newValue) {
		isGlobalDebugEnabled = newValue;
	***REMOVED***

	constructor(options = {***REMOVED***) {
		anyMap.set(this, new Set());
		eventsMap.set(this, new Map());
		producersMap.set(this, new Map());
		this.debug = options.debug || {***REMOVED***;

		if (this.debug.enabled === undefined) {
			this.debug.enabled = false;
		***REMOVED***

		if (!this.debug.logger) {
			this.debug.logger = (type, debugName, eventName, eventData) => {
				try {
					// TODO: Use https://github.com/sindresorhus/safe-stringify when the package is more mature. Just copy-paste the code.
					eventData = JSON.stringify(eventData);
				***REMOVED*** catch {
					eventData = `Object with the following keys failed to stringify: ${Object.keys(eventData).join(',')***REMOVED***`;
				***REMOVED***

				if (typeof eventName === 'symbol') {
					eventName = eventName.toString();
				***REMOVED***

				const currentTime = new Date();
				const logTime = `${currentTime.getHours()***REMOVED***:${currentTime.getMinutes()***REMOVED***:${currentTime.getSeconds()***REMOVED***.${currentTime.getMilliseconds()***REMOVED***`;
				console.log(`[${logTime***REMOVED***][emittery:${type***REMOVED***][${debugName***REMOVED***] Event Name: ${eventName***REMOVED***\n\tdata: ${eventData***REMOVED***`);
			***REMOVED***;
		***REMOVED***
	***REMOVED***

	logIfDebugEnabled(type, eventName, eventData) {
		if (Emittery.isDebugEnabled || this.debug.enabled) {
			this.debug.logger(type, this.debug.name, eventName, eventData);
		***REMOVED***
	***REMOVED***

	on(eventNames, listener) {
		assertListener(listener);

		eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
		for (const eventName of eventNames) {
			assertEventName(eventName);
			getListeners(this, eventName).add(listener);

			this.logIfDebugEnabled('subscribe', eventName, undefined);

			if (!isListenerSymbol(eventName)) {
				this.emit(listenerAdded, {eventName, listener***REMOVED***);
			***REMOVED***
		***REMOVED***

		return this.off.bind(this, eventNames, listener);
	***REMOVED***

	off(eventNames, listener) {
		assertListener(listener);

		eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
		for (const eventName of eventNames) {
			assertEventName(eventName);
			getListeners(this, eventName).delete(listener);

			this.logIfDebugEnabled('unsubscribe', eventName, undefined);

			if (!isListenerSymbol(eventName)) {
				this.emit(listenerRemoved, {eventName, listener***REMOVED***);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	once(eventNames) {
		return new Promise(resolve => {
			const off = this.on(eventNames, data => {
				off();
				resolve(data);
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	events(eventNames) {
		eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
		for (const eventName of eventNames) {
			assertEventName(eventName);
		***REMOVED***

		return iterator(this, eventNames);
	***REMOVED***

	async emit(eventName, eventData) {
		assertEventName(eventName);

		this.logIfDebugEnabled('emit', eventName, eventData);

		enqueueProducers(this, eventName, eventData);

		const listeners = getListeners(this, eventName);
		const anyListeners = anyMap.get(this);
		const staticListeners = [...listeners];
		const staticAnyListeners = isListenerSymbol(eventName) ? [] : [...anyListeners];

		await resolvedPromise;
		await Promise.all([
			...staticListeners.map(async listener => {
				if (listeners.has(listener)) {
					return listener(eventData);
				***REMOVED***
			***REMOVED***),
			...staticAnyListeners.map(async listener => {
				if (anyListeners.has(listener)) {
					return listener(eventName, eventData);
				***REMOVED***
			***REMOVED***)
		]);
	***REMOVED***

	async emitSerial(eventName, eventData) {
		assertEventName(eventName);

		this.logIfDebugEnabled('emitSerial', eventName, eventData);

		const listeners = getListeners(this, eventName);
		const anyListeners = anyMap.get(this);
		const staticListeners = [...listeners];
		const staticAnyListeners = [...anyListeners];

		await resolvedPromise;
		/* eslint-disable no-await-in-loop */
		for (const listener of staticListeners) {
			if (listeners.has(listener)) {
				await listener(eventData);
			***REMOVED***
		***REMOVED***

		for (const listener of staticAnyListeners) {
			if (anyListeners.has(listener)) {
				await listener(eventName, eventData);
			***REMOVED***
		***REMOVED***
		/* eslint-enable no-await-in-loop */
	***REMOVED***

	onAny(listener) {
		assertListener(listener);

		this.logIfDebugEnabled('subscribeAny', undefined, undefined);

		anyMap.get(this).add(listener);
		this.emit(listenerAdded, {listener***REMOVED***);
		return this.offAny.bind(this, listener);
	***REMOVED***

	anyEvent() {
		return iterator(this);
	***REMOVED***

	offAny(listener) {
		assertListener(listener);

		this.logIfDebugEnabled('unsubscribeAny', undefined, undefined);

		this.emit(listenerRemoved, {listener***REMOVED***);
		anyMap.get(this).delete(listener);
	***REMOVED***

	clearListeners(eventNames) {
		eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];

		for (const eventName of eventNames) {
			this.logIfDebugEnabled('clear', eventName, undefined);

			if (typeof eventName === 'string' || typeof eventName === 'symbol') {
				getListeners(this, eventName).clear();

				const producers = getEventProducers(this, eventName);

				for (const producer of producers) {
					producer.finish();
				***REMOVED***

				producers.clear();
			***REMOVED*** else {
				anyMap.get(this).clear();

				for (const listeners of eventsMap.get(this).values()) {
					listeners.clear();
				***REMOVED***

				for (const producers of producersMap.get(this).values()) {
					for (const producer of producers) {
						producer.finish();
					***REMOVED***

					producers.clear();
				***REMOVED***
			***REMOVED***
		***REMOVED***
	***REMOVED***

	listenerCount(eventNames) {
		eventNames = Array.isArray(eventNames) ? eventNames : [eventNames];
		let count = 0;

		for (const eventName of eventNames) {
			if (typeof eventName === 'string') {
				count += anyMap.get(this).size + getListeners(this, eventName).size +
					getEventProducers(this, eventName).size + getEventProducers(this).size;
				continue;
			***REMOVED***

			if (typeof eventName !== 'undefined') {
				assertEventName(eventName);
			***REMOVED***

			count += anyMap.get(this).size;

			for (const value of eventsMap.get(this).values()) {
				count += value.size;
			***REMOVED***

			for (const value of producersMap.get(this).values()) {
				count += value.size;
			***REMOVED***
		***REMOVED***

		return count;
	***REMOVED***

	bindMethods(target, methodNames) {
		if (typeof target !== 'object' || target === null) {
			throw new TypeError('`target` must be an object');
		***REMOVED***

		methodNames = defaultMethodNamesOrAssert(methodNames);

		for (const methodName of methodNames) {
			if (target[methodName] !== undefined) {
				throw new Error(`The property \`${methodName***REMOVED***\` already exists on \`target\``);
			***REMOVED***

			Object.defineProperty(target, methodName, {
				enumerable: false,
				value: this[methodName].bind(this)
			***REMOVED***);
		***REMOVED***
	***REMOVED***
***REMOVED***

const allEmitteryMethods = Object.getOwnPropertyNames(Emittery.prototype).filter(v => v !== 'constructor');

Object.defineProperty(Emittery, 'listenerAdded', {
	value: listenerAdded,
	writable: false,
	enumerable: true,
	configurable: false
***REMOVED***);
Object.defineProperty(Emittery, 'listenerRemoved', {
	value: listenerRemoved,
	writable: false,
	enumerable: true,
	configurable: false
***REMOVED***);

module.exports = Emittery;
