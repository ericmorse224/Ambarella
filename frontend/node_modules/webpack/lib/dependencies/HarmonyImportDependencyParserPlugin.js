/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const HotModuleReplacementPlugin = require("../HotModuleReplacementPlugin");
const { getImportAttributes ***REMOVED*** = require("../javascript/JavascriptParser");
const InnerGraph = require("../optimize/InnerGraph");
const ConstDependency = require("./ConstDependency");
const HarmonyAcceptDependency = require("./HarmonyAcceptDependency");
const HarmonyAcceptImportDependency = require("./HarmonyAcceptImportDependency");
const HarmonyEvaluatedImportSpecifierDependency = require("./HarmonyEvaluatedImportSpecifierDependency");
const HarmonyExports = require("./HarmonyExports");
const { ExportPresenceModes ***REMOVED*** = require("./HarmonyImportDependency");
const HarmonyImportSideEffectDependency = require("./HarmonyImportSideEffectDependency");
const HarmonyImportSpecifierDependency = require("./HarmonyImportSpecifierDependency");

/** @typedef {import("estree").Expression***REMOVED*** Expression */
/** @typedef {import("estree").Identifier***REMOVED*** Identifier */
/** @typedef {import("estree").Literal***REMOVED*** Literal */
/** @typedef {import("estree").MemberExpression***REMOVED*** MemberExpression */
/** @typedef {import("estree").ObjectExpression***REMOVED*** ObjectExpression */
/** @typedef {import("estree").Property***REMOVED*** Property */
/** @typedef {import("../../declarations/WebpackOptions").JavascriptParserOptions***REMOVED*** JavascriptParserOptions */
/** @typedef {import("../Dependency").DependencyLocation***REMOVED*** DependencyLocation */
/** @typedef {import("../javascript/BasicEvaluatedExpression")***REMOVED*** BasicEvaluatedExpression */
/** @typedef {import("../javascript/JavascriptParser")***REMOVED*** JavascriptParser */
/** @typedef {import("../javascript/JavascriptParser").DestructuringAssignmentProperty***REMOVED*** DestructuringAssignmentProperty */
/** @typedef {import("../javascript/JavascriptParser").ExportAllDeclaration***REMOVED*** ExportAllDeclaration */
/** @typedef {import("../javascript/JavascriptParser").ExportNamedDeclaration***REMOVED*** ExportNamedDeclaration */
/** @typedef {import("../javascript/JavascriptParser").ImportAttributes***REMOVED*** ImportAttributes */
/** @typedef {import("../javascript/JavascriptParser").ImportDeclaration***REMOVED*** ImportDeclaration */
/** @typedef {import("../javascript/JavascriptParser").ImportExpression***REMOVED*** ImportExpression */
/** @typedef {import("../javascript/JavascriptParser").Range***REMOVED*** Range */
/** @typedef {import("../javascript/JavascriptParser").TagData***REMOVED*** TagData */
/** @typedef {import("../optimize/InnerGraph").InnerGraph***REMOVED*** InnerGraph */
/** @typedef {import("../optimize/InnerGraph").TopLevelSymbol***REMOVED*** TopLevelSymbol */
/** @typedef {import("./HarmonyImportDependency")***REMOVED*** HarmonyImportDependency */

const harmonySpecifierTag = Symbol("harmony import");

/**
 * @typedef {object***REMOVED*** HarmonySettings
 * @property {string[]***REMOVED*** ids
 * @property {string***REMOVED*** source
 * @property {number***REMOVED*** sourceOrder
 * @property {string***REMOVED*** name
 * @property {boolean***REMOVED*** await
 * @property {ImportAttributes=***REMOVED*** attributes
 */

module.exports = class HarmonyImportDependencyParserPlugin {
	/**
	 * @param {JavascriptParserOptions***REMOVED*** options options
	 */
	constructor(options) {
		this.exportPresenceMode =
			options.importExportsPresence !== undefined
				? ExportPresenceModes.fromUserOption(options.importExportsPresence)
				: options.exportsPresence !== undefined
					? ExportPresenceModes.fromUserOption(options.exportsPresence)
					: options.strictExportPresence
						? ExportPresenceModes.ERROR
						: ExportPresenceModes.AUTO;
		this.strictThisContextOnImports = options.strictThisContextOnImports;
	***REMOVED***

	/**
	 * @param {JavascriptParser***REMOVED*** parser the parser
	 * @returns {void***REMOVED***
	 */
	apply(parser) {
		const { exportPresenceMode ***REMOVED*** = this;

		/**
		 * @param {string[]***REMOVED*** members members
		 * @param {boolean[]***REMOVED*** membersOptionals members Optionals
		 * @returns {string[]***REMOVED*** a non optional part
		 */
		function getNonOptionalPart(members, membersOptionals) {
			let i = 0;
			while (i < members.length && membersOptionals[i] === false) i++;
			return i !== members.length ? members.slice(0, i) : members;
		***REMOVED***

		/**
		 * @param {TODO***REMOVED*** node member expression
		 * @param {number***REMOVED*** count count
		 * @returns {Expression***REMOVED*** member expression
		 */
		function getNonOptionalMemberChain(node, count) {
			while (count--) node = node.object;
			return node;
		***REMOVED***

		parser.hooks.isPure
			.for("Identifier")
			.tap("HarmonyImportDependencyParserPlugin", expression => {
				const expr = /** @type {Identifier***REMOVED*** */ (expression);
				if (
					parser.isVariableDefined(expr.name) ||
					parser.getTagData(expr.name, harmonySpecifierTag)
				) {
					return true;
				***REMOVED***
			***REMOVED***);
		parser.hooks.import.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source) => {
				parser.state.lastHarmonyImportOrder =
					(parser.state.lastHarmonyImportOrder || 0) + 1;
				const clearDep = new ConstDependency(
					parser.isAsiPosition(/** @type {Range***REMOVED*** */ (statement.range)[0])
						? ";"
						: "",
					/** @type {Range***REMOVED*** */ (statement.range)
				);
				clearDep.loc = /** @type {DependencyLocation***REMOVED*** */ (statement.loc);
				parser.state.module.addPresentationalDependency(clearDep);
				parser.unsetAsiPosition(/** @type {Range***REMOVED*** */ (statement.range)[1]);
				const attributes = getImportAttributes(statement);
				const sideEffectDep = new HarmonyImportSideEffectDependency(
					/** @type {string***REMOVED*** */ (source),
					parser.state.lastHarmonyImportOrder,
					attributes
				);
				sideEffectDep.loc = /** @type {DependencyLocation***REMOVED*** */ (statement.loc);
				parser.state.module.addDependency(sideEffectDep);
				return true;
			***REMOVED***
		);
		parser.hooks.importSpecifier.tap(
			"HarmonyImportDependencyParserPlugin",
			(statement, source, id, name) => {
				const ids = id === null ? [] : [id];
				parser.tagVariable(name, harmonySpecifierTag, {
					name,
					source,
					ids,
					sourceOrder: parser.state.lastHarmonyImportOrder,
					attributes: getImportAttributes(statement)
				***REMOVED***);
				return true;
			***REMOVED***
		);
		parser.hooks.binaryExpression.tap(
			"HarmonyImportDependencyParserPlugin",
			expression => {
				if (expression.operator !== "in") return;

				const leftPartEvaluated = parser.evaluateExpression(expression.left);
				if (leftPartEvaluated.couldHaveSideEffects()) return;
				const leftPart = leftPartEvaluated.asString();
				if (!leftPart) return;

				const rightPart = parser.evaluateExpression(expression.right);
				if (!rightPart.isIdentifier()) return;

				const rootInfo = rightPart.rootInfo;
				if (
					typeof rootInfo === "string" ||
					!rootInfo ||
					!rootInfo.tagInfo ||
					rootInfo.tagInfo.tag !== harmonySpecifierTag
				)
					return;
				const settings = /** @type {TagData***REMOVED*** */ (rootInfo.tagInfo.data);
				const members =
					/** @type {(() => string[])***REMOVED*** */
					(rightPart.getMembers)();
				const dep = new HarmonyEvaluatedImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids.concat(members).concat([leftPart]),
					settings.name,
					/** @type {Range***REMOVED*** */ (expression.range),
					settings.attributes,
					"in"
				);
				dep.directImport = members.length === 0;
				dep.asiSafe = !parser.isAsiPosition(
					/** @type {Range***REMOVED*** */ (expression.range)[0]
				);
				dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expression.loc);
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			***REMOVED***
		);
		parser.hooks.expression
			.for(harmonySpecifierTag)
			.tap("HarmonyImportDependencyParserPlugin", expr => {
				const settings = /** @type {HarmonySettings***REMOVED*** */ (parser.currentTagData);
				const dep = new HarmonyImportSpecifierDependency(
					settings.source,
					settings.sourceOrder,
					settings.ids,
					settings.name,
					/** @type {Range***REMOVED*** */
					(expr.range),
					exportPresenceMode,
					settings.attributes,
					[]
				);
				dep.referencedPropertiesInDestructuring =
					parser.destructuringAssignmentPropertiesFor(expr);
				dep.shorthand = parser.scope.inShorthand;
				dep.directImport = true;
				dep.asiSafe = !parser.isAsiPosition(
					/** @type {Range***REMOVED*** */ (expr.range)[0]
				);
				dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expr.loc);
				dep.call = parser.scope.inTaggedTemplateTag;
				parser.state.module.addDependency(dep);
				InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
				return true;
			***REMOVED***);
		parser.hooks.expressionMemberChain
			.for(harmonySpecifierTag)
			.tap(
				"HarmonyImportDependencyParserPlugin",
				(expression, members, membersOptionals, memberRanges) => {
					const settings =
						/** @type {HarmonySettings***REMOVED*** */
						(parser.currentTagData);
					const nonOptionalMembers = getNonOptionalPart(
						members,
						membersOptionals
					);
					/** @type {Range[]***REMOVED*** */
					const ranges = memberRanges.slice(
						0,
						memberRanges.length - (members.length - nonOptionalMembers.length)
					);
					const expr =
						nonOptionalMembers !== members
							? getNonOptionalMemberChain(
									expression,
									members.length - nonOptionalMembers.length
								)
							: expression;
					const ids = settings.ids.concat(nonOptionalMembers);
					const dep = new HarmonyImportSpecifierDependency(
						settings.source,
						settings.sourceOrder,
						ids,
						settings.name,
						/** @type {Range***REMOVED*** */
						(expr.range),
						exportPresenceMode,
						settings.attributes,
						ranges
					);
					dep.referencedPropertiesInDestructuring =
						parser.destructuringAssignmentPropertiesFor(expr);
					dep.asiSafe = !parser.isAsiPosition(
						/** @type {Range***REMOVED*** */
						(expr.range)[0]
					);
					dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expr.loc);
					parser.state.module.addDependency(dep);
					InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
					return true;
				***REMOVED***
			);
		parser.hooks.callMemberChain
			.for(harmonySpecifierTag)
			.tap(
				"HarmonyImportDependencyParserPlugin",
				(expression, members, membersOptionals, memberRanges) => {
					const { arguments: args, callee ***REMOVED*** = expression;
					const settings = /** @type {HarmonySettings***REMOVED*** */ (
						parser.currentTagData
					);
					const nonOptionalMembers = getNonOptionalPart(
						members,
						membersOptionals
					);
					/** @type {Range[]***REMOVED*** */
					const ranges = memberRanges.slice(
						0,
						memberRanges.length - (members.length - nonOptionalMembers.length)
					);
					const expr =
						nonOptionalMembers !== members
							? getNonOptionalMemberChain(
									callee,
									members.length - nonOptionalMembers.length
								)
							: callee;
					const ids = settings.ids.concat(nonOptionalMembers);
					const dep = new HarmonyImportSpecifierDependency(
						settings.source,
						settings.sourceOrder,
						ids,
						settings.name,
						/** @type {Range***REMOVED*** */ (expr.range),
						exportPresenceMode,
						settings.attributes,
						ranges
					);
					dep.directImport = members.length === 0;
					dep.call = true;
					dep.asiSafe = !parser.isAsiPosition(
						/** @type {Range***REMOVED*** */ (expr.range)[0]
					);
					// only in case when we strictly follow the spec we need a special case here
					dep.namespaceObjectAsContext =
						members.length > 0 &&
						/** @type {boolean***REMOVED*** */ (this.strictThisContextOnImports);
					dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expr.loc);
					parser.state.module.addDependency(dep);
					if (args) parser.walkExpressions(args);
					InnerGraph.onUsage(parser.state, e => (dep.usedByExports = e));
					return true;
				***REMOVED***
			);
		const { hotAcceptCallback, hotAcceptWithoutCallback ***REMOVED*** =
			HotModuleReplacementPlugin.getParserHooks(parser);
		hotAcceptCallback.tap(
			"HarmonyImportDependencyParserPlugin",
			(expr, requests) => {
				if (!HarmonyExports.isEnabled(parser.state)) {
					// This is not a harmony module, skip it
					return;
				***REMOVED***
				const dependencies = requests.map(request => {
					const dep = new HarmonyAcceptImportDependency(request);
					dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expr.loc);
					parser.state.module.addDependency(dep);
					return dep;
				***REMOVED***);
				if (dependencies.length > 0) {
					const dep = new HarmonyAcceptDependency(
						/** @type {Range***REMOVED*** */
						(expr.range),
						dependencies,
						true
					);
					dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expr.loc);
					parser.state.module.addDependency(dep);
				***REMOVED***
			***REMOVED***
		);
		hotAcceptWithoutCallback.tap(
			"HarmonyImportDependencyParserPlugin",
			(expr, requests) => {
				if (!HarmonyExports.isEnabled(parser.state)) {
					// This is not a harmony module, skip it
					return;
				***REMOVED***
				const dependencies = requests.map(request => {
					const dep = new HarmonyAcceptImportDependency(request);
					dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expr.loc);
					parser.state.module.addDependency(dep);
					return dep;
				***REMOVED***);
				if (dependencies.length > 0) {
					const dep = new HarmonyAcceptDependency(
						/** @type {Range***REMOVED*** */
						(expr.range),
						dependencies,
						false
					);
					dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expr.loc);
					parser.state.module.addDependency(dep);
				***REMOVED***
			***REMOVED***
		);
	***REMOVED***
***REMOVED***;

module.exports.harmonySpecifierTag = harmonySpecifierTag;
