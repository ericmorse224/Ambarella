/**
 * @fileoverview This option sets a specific tab width for your code
 *
 * This rule has been ported and modified from nodeca.
 * @author Vitaly Puzrin
 * @author Gyandeep Singh
 * @deprecated in ESLint v4.0.0
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------
// this rule has known coverage issues, but it's deprecated and shouldn't be updated in the future anyway.
/* c8 ignore next */
/** @type {import('../shared/types').Rule***REMOVED*** */
module.exports = {
    meta: {
        type: "layout",

        docs: {
            description: "Enforce consistent indentation",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/indent-legacy"
        ***REMOVED***,

        deprecated: true,

        replacedBy: ["indent"],

        fixable: "whitespace",

        schema: [
            {
                oneOf: [
                    {
                        enum: ["tab"]
                    ***REMOVED***,
                    {
                        type: "integer",
                        minimum: 0
                    ***REMOVED***
                ]
            ***REMOVED***,
            {
                type: "object",
                properties: {
                    SwitchCase: {
                        type: "integer",
                        minimum: 0
                    ***REMOVED***,
                    VariableDeclarator: {
                        oneOf: [
                            {
                                type: "integer",
                                minimum: 0
                            ***REMOVED***,
                            {
                                type: "object",
                                properties: {
                                    var: {
                                        type: "integer",
                                        minimum: 0
                                    ***REMOVED***,
                                    let: {
                                        type: "integer",
                                        minimum: 0
                                    ***REMOVED***,
                                    const: {
                                        type: "integer",
                                        minimum: 0
                                    ***REMOVED***
                                ***REMOVED***
                            ***REMOVED***
                        ]
                    ***REMOVED***,
                    outerIIFEBody: {
                        type: "integer",
                        minimum: 0
                    ***REMOVED***,
                    MemberExpression: {
                        type: "integer",
                        minimum: 0
                    ***REMOVED***,
                    FunctionDeclaration: {
                        type: "object",
                        properties: {
                            parameters: {
                                oneOf: [
                                    {
                                        type: "integer",
                                        minimum: 0
                                    ***REMOVED***,
                                    {
                                        enum: ["first"]
                                    ***REMOVED***
                                ]
                            ***REMOVED***,
                            body: {
                                type: "integer",
                                minimum: 0
                            ***REMOVED***
                        ***REMOVED***
                    ***REMOVED***,
                    FunctionExpression: {
                        type: "object",
                        properties: {
                            parameters: {
                                oneOf: [
                                    {
                                        type: "integer",
                                        minimum: 0
                                    ***REMOVED***,
                                    {
                                        enum: ["first"]
                                    ***REMOVED***
                                ]
                            ***REMOVED***,
                            body: {
                                type: "integer",
                                minimum: 0
                            ***REMOVED***
                        ***REMOVED***
                    ***REMOVED***,
                    CallExpression: {
                        type: "object",
                        properties: {
                            parameters: {
                                oneOf: [
                                    {
                                        type: "integer",
                                        minimum: 0
                                    ***REMOVED***,
                                    {
                                        enum: ["first"]
                                    ***REMOVED***
                                ]
                            ***REMOVED***
                        ***REMOVED***
                    ***REMOVED***,
                    ArrayExpression: {
                        oneOf: [
                            {
                                type: "integer",
                                minimum: 0
                            ***REMOVED***,
                            {
                                enum: ["first"]
                            ***REMOVED***
                        ]
                    ***REMOVED***,
                    ObjectExpression: {
                        oneOf: [
                            {
                                type: "integer",
                                minimum: 0
                            ***REMOVED***,
                            {
                                enum: ["first"]
                            ***REMOVED***
                        ]
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],
        messages: {
            expected: "Expected indentation of {{expected***REMOVED******REMOVED*** but found {{actual***REMOVED******REMOVED***."
        ***REMOVED***
    ***REMOVED***,

    create(context) {
        const DEFAULT_VARIABLE_INDENT = 1;
        const DEFAULT_PARAMETER_INDENT = null; // For backwards compatibility, don't check parameter indentation unless specified in the config
        const DEFAULT_FUNCTION_BODY_INDENT = 1;

        let indentType = "space";
        let indentSize = 4;
        const options = {
            SwitchCase: 0,
            VariableDeclarator: {
                var: DEFAULT_VARIABLE_INDENT,
                let: DEFAULT_VARIABLE_INDENT,
                const: DEFAULT_VARIABLE_INDENT
            ***REMOVED***,
            outerIIFEBody: null,
            FunctionDeclaration: {
                parameters: DEFAULT_PARAMETER_INDENT,
                body: DEFAULT_FUNCTION_BODY_INDENT
            ***REMOVED***,
            FunctionExpression: {
                parameters: DEFAULT_PARAMETER_INDENT,
                body: DEFAULT_FUNCTION_BODY_INDENT
            ***REMOVED***,
            CallExpression: {
                arguments: DEFAULT_PARAMETER_INDENT
            ***REMOVED***,
            ArrayExpression: 1,
            ObjectExpression: 1
        ***REMOVED***;

        const sourceCode = context.sourceCode;

        if (context.options.length) {
            if (context.options[0] === "tab") {
                indentSize = 1;
                indentType = "tab";
            ***REMOVED*** else /* c8 ignore start */ if (typeof context.options[0] === "number") {
                indentSize = context.options[0];
                indentType = "space";
            ***REMOVED***/* c8 ignore stop */

            if (context.options[1]) {
                const opts = context.options[1];

                options.SwitchCase = opts.SwitchCase || 0;
                const variableDeclaratorRules = opts.VariableDeclarator;

                if (typeof variableDeclaratorRules === "number") {
                    options.VariableDeclarator = {
                        var: variableDeclaratorRules,
                        let: variableDeclaratorRules,
                        const: variableDeclaratorRules
                    ***REMOVED***;
                ***REMOVED*** else if (typeof variableDeclaratorRules === "object") {
                    Object.assign(options.VariableDeclarator, variableDeclaratorRules);
                ***REMOVED***

                if (typeof opts.outerIIFEBody === "number") {
                    options.outerIIFEBody = opts.outerIIFEBody;
                ***REMOVED***

                if (typeof opts.MemberExpression === "number") {
                    options.MemberExpression = opts.MemberExpression;
                ***REMOVED***

                if (typeof opts.FunctionDeclaration === "object") {
                    Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);
                ***REMOVED***

                if (typeof opts.FunctionExpression === "object") {
                    Object.assign(options.FunctionExpression, opts.FunctionExpression);
                ***REMOVED***

                if (typeof opts.CallExpression === "object") {
                    Object.assign(options.CallExpression, opts.CallExpression);
                ***REMOVED***

                if (typeof opts.ArrayExpression === "number" || typeof opts.ArrayExpression === "string") {
                    options.ArrayExpression = opts.ArrayExpression;
                ***REMOVED***

                if (typeof opts.ObjectExpression === "number" || typeof opts.ObjectExpression === "string") {
                    options.ObjectExpression = opts.ObjectExpression;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        const caseIndentStore = {***REMOVED***;

        /**
         * Creates an error message for a line, given the expected/actual indentation.
         * @param {int***REMOVED*** expectedAmount The expected amount of indentation characters for this line
         * @param {int***REMOVED*** actualSpaces The actual number of indentation spaces that were found on this line
         * @param {int***REMOVED*** actualTabs The actual number of indentation tabs that were found on this line
         * @returns {string***REMOVED*** An error message for this line
         */
        function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {
            const expectedStatement = `${expectedAmount***REMOVED*** ${indentType***REMOVED***${expectedAmount === 1 ? "" : "s"***REMOVED***`; // e.g. "2 tabs"
            const foundSpacesWord = `space${actualSpaces === 1 ? "" : "s"***REMOVED***`; // e.g. "space"
            const foundTabsWord = `tab${actualTabs === 1 ? "" : "s"***REMOVED***`; // e.g. "tabs"
            let foundStatement;

            if (actualSpaces > 0 && actualTabs > 0) {
                foundStatement = `${actualSpaces***REMOVED*** ${foundSpacesWord***REMOVED*** and ${actualTabs***REMOVED*** ${foundTabsWord***REMOVED***`; // e.g. "1 space and 2 tabs"
            ***REMOVED*** else if (actualSpaces > 0) {

                /*
                 * Abbreviate the message if the expected indentation is also spaces.
                 * e.g. 'Expected 4 spaces but found 2' rather than 'Expected 4 spaces but found 2 spaces'
                 */
                foundStatement = indentType === "space" ? actualSpaces : `${actualSpaces***REMOVED*** ${foundSpacesWord***REMOVED***`;
            ***REMOVED*** else if (actualTabs > 0) {
                foundStatement = indentType === "tab" ? actualTabs : `${actualTabs***REMOVED*** ${foundTabsWord***REMOVED***`;
            ***REMOVED*** else {
                foundStatement = "0";
            ***REMOVED***
            return {
                expected: expectedStatement,
                actual: foundStatement
            ***REMOVED***;
        ***REMOVED***

        /**
         * Reports a given indent violation
         * @param {ASTNode***REMOVED*** node Node violating the indent rule
         * @param {int***REMOVED*** needed Expected indentation character count
         * @param {int***REMOVED*** gottenSpaces Indentation space count in the actual node/code
         * @param {int***REMOVED*** gottenTabs Indentation tab count in the actual node/code
         * @param {Object***REMOVED*** [loc] Error line and column location
         * @param {boolean***REMOVED*** isLastNodeCheck Is the error for last node check
         * @returns {void***REMOVED***
         */
        function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {
            if (gottenSpaces && gottenTabs) {

                // To avoid conflicts with `no-mixed-spaces-and-tabs`, don't report lines that have both spaces and tabs.
                return;
            ***REMOVED***

            const desiredIndent = (indentType === "space" ? " " : "\t").repeat(needed);

            const textRange = isLastNodeCheck
                ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs]
                : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];

            context.report({
                node,
                loc,
                messageId: "expected",
                data: createErrorMessageData(needed, gottenSpaces, gottenTabs),
                fix: fixer => fixer.replaceTextRange(textRange, desiredIndent)
            ***REMOVED***);
        ***REMOVED***

        /**
         * Get the actual indent of node
         * @param {ASTNode|Token***REMOVED*** node Node to examine
         * @param {boolean***REMOVED*** [byLastLine=false] get indent of node's last line
         * @returns {Object***REMOVED*** The node's indent. Contains keys `space` and `tab`, representing the indent of each character. Also
         * contains keys `goodChar` and `badChar`, where `goodChar` is the amount of the user's desired indentation character, and
         * `badChar` is the amount of the other indentation character.
         */
        function getNodeIndent(node, byLastLine) {
            const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);
            const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split("");
            const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex(char => char !== " " && char !== "\t"));
            const spaces = indentChars.filter(char => char === " ").length;
            const tabs = indentChars.filter(char => char === "\t").length;

            return {
                space: spaces,
                tab: tabs,
                goodChar: indentType === "space" ? spaces : tabs,
                badChar: indentType === "space" ? tabs : spaces
            ***REMOVED***;
        ***REMOVED***

        /**
         * Checks node is the first in its own start line. By default it looks by start line.
         * @param {ASTNode***REMOVED*** node The node to check
         * @param {boolean***REMOVED*** [byEndLocation=false] Lookup based on start position or end
         * @returns {boolean***REMOVED*** true if its the first in the its start line
         */
        function isNodeFirstInLine(node, byEndLocation) {
            const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),
                startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,
                endLine = firstToken ? firstToken.loc.end.line : -1;

            return startLine !== endLine;
        ***REMOVED***

        /**
         * Check indent for node
         * @param {ASTNode***REMOVED*** node Node to check
         * @param {int***REMOVED*** neededIndent needed indent
         * @returns {void***REMOVED***
         */
        function checkNodeIndent(node, neededIndent) {
            const actualIndent = getNodeIndent(node, false);

            if (
                node.type !== "ArrayExpression" &&
                node.type !== "ObjectExpression" &&
                (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) &&
                isNodeFirstInLine(node)
            ) {
                report(node, neededIndent, actualIndent.space, actualIndent.tab);
            ***REMOVED***

            if (node.type === "IfStatement" && node.alternate) {
                const elseToken = sourceCode.getTokenBefore(node.alternate);

                checkNodeIndent(elseToken, neededIndent);

                if (!isNodeFirstInLine(node.alternate)) {
                    checkNodeIndent(node.alternate, neededIndent);
                ***REMOVED***
            ***REMOVED***

            if (node.type === "TryStatement" && node.handler) {
                const catchToken = sourceCode.getFirstToken(node.handler);

                checkNodeIndent(catchToken, neededIndent);
            ***REMOVED***

            if (node.type === "TryStatement" && node.finalizer) {
                const finallyToken = sourceCode.getTokenBefore(node.finalizer);

                checkNodeIndent(finallyToken, neededIndent);
            ***REMOVED***

            if (node.type === "DoWhileStatement") {
                const whileToken = sourceCode.getTokenAfter(node.body);

                checkNodeIndent(whileToken, neededIndent);
            ***REMOVED***
        ***REMOVED***

        /**
         * Check indent for nodes list
         * @param {ASTNode[]***REMOVED*** nodes list of node objects
         * @param {int***REMOVED*** indent needed indent
         * @returns {void***REMOVED***
         */
        function checkNodesIndent(nodes, indent) {
            nodes.forEach(node => checkNodeIndent(node, indent));
        ***REMOVED***

        /**
         * Check last node line indent this detects, that block closed correctly
         * @param {ASTNode***REMOVED*** node Node to examine
         * @param {int***REMOVED*** lastLineIndent needed indent
         * @returns {void***REMOVED***
         */
        function checkLastNodeLineIndent(node, lastLineIndent) {
            const lastToken = sourceCode.getLastToken(node);
            const endIndent = getNodeIndent(lastToken, true);

            if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {
                report(
                    node,
                    lastLineIndent,
                    endIndent.space,
                    endIndent.tab,
                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column ***REMOVED***,
                    true
                );
            ***REMOVED***
        ***REMOVED***

        /**
         * Check last node line indent this detects, that block closed correctly
         * This function for more complicated return statement case, where closing parenthesis may be followed by ';'
         * @param {ASTNode***REMOVED*** node Node to examine
         * @param {int***REMOVED*** firstLineIndent first line needed indent
         * @returns {void***REMOVED***
         */
        function checkLastReturnStatementLineIndent(node, firstLineIndent) {

            /*
             * in case if return statement ends with ');' we have traverse back to ')'
             * otherwise we'll measure indent for ';' and replace ')'
             */
            const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);
            const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);

            if (textBeforeClosingParenthesis.trim()) {

                // There are tokens before the closing paren, don't report this case
                return;
            ***REMOVED***

            const endIndent = getNodeIndent(lastToken, true);

            if (endIndent.goodChar !== firstLineIndent) {
                report(
                    node,
                    firstLineIndent,
                    endIndent.space,
                    endIndent.tab,
                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column ***REMOVED***,
                    true
                );
            ***REMOVED***
        ***REMOVED***

        /**
         * Check first node line indent is correct
         * @param {ASTNode***REMOVED*** node Node to examine
         * @param {int***REMOVED*** firstLineIndent needed indent
         * @returns {void***REMOVED***
         */
        function checkFirstNodeLineIndent(node, firstLineIndent) {
            const startIndent = getNodeIndent(node, false);

            if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {
                report(
                    node,
                    firstLineIndent,
                    startIndent.space,
                    startIndent.tab,
                    { line: node.loc.start.line, column: node.loc.start.column ***REMOVED***
                );
            ***REMOVED***
        ***REMOVED***

        /**
         * Returns a parent node of given node based on a specified type
         * if not present then return null
         * @param {ASTNode***REMOVED*** node node to examine
         * @param {string***REMOVED*** type type that is being looked for
         * @param {string***REMOVED*** stopAtList end points for the evaluating code
         * @returns {ASTNode|void***REMOVED*** if found then node otherwise null
         */
        function getParentNodeByType(node, type, stopAtList) {
            let parent = node.parent;
            const stopAtSet = new Set(stopAtList || ["Program"]);

            while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== "Program") {
                parent = parent.parent;
            ***REMOVED***

            return parent.type === type ? parent : null;
        ***REMOVED***

        /**
         * Returns the VariableDeclarator based on the current node
         * if not present then return null
         * @param {ASTNode***REMOVED*** node node to examine
         * @returns {ASTNode|void***REMOVED*** if found then node otherwise null
         */
        function getVariableDeclaratorNode(node) {
            return getParentNodeByType(node, "VariableDeclarator");
        ***REMOVED***

        /**
         * Check to see if the node is part of the multi-line variable declaration.
         * Also if its on the same line as the varNode
         * @param {ASTNode***REMOVED*** node node to check
         * @param {ASTNode***REMOVED*** varNode variable declaration node to check against
         * @returns {boolean***REMOVED*** True if all the above condition satisfy
         */
        function isNodeInVarOnTop(node, varNode) {
            return varNode &&
                varNode.parent.loc.start.line === node.loc.start.line &&
                varNode.parent.declarations.length > 1;
        ***REMOVED***

        /**
         * Check to see if the argument before the callee node is multi-line and
         * there should only be 1 argument before the callee node
         * @param {ASTNode***REMOVED*** node node to check
         * @returns {boolean***REMOVED*** True if arguments are multi-line
         */
        function isArgBeforeCalleeNodeMultiline(node) {
            const parent = node.parent;

            if (parent.arguments.length >= 2 && parent.arguments[1] === node) {
                return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;
            ***REMOVED***

            return false;
        ***REMOVED***

        /**
         * Check to see if the node is a file level IIFE
         * @param {ASTNode***REMOVED*** node The function node to check.
         * @returns {boolean***REMOVED*** True if the node is the outer IIFE
         */
        function isOuterIIFE(node) {
            const parent = node.parent;
            let stmt = parent.parent;

            /*
             * Verify that the node is an IIEF
             */
            if (
                parent.type !== "CallExpression" ||
                parent.callee !== node) {

                return false;
            ***REMOVED***

            /*
             * Navigate legal ancestors to determine whether this IIEF is outer
             */
            while (
                stmt.type === "UnaryExpression" && (
                    stmt.operator === "!" ||
                    stmt.operator === "~" ||
                    stmt.operator === "+" ||
                    stmt.operator === "-") ||
                stmt.type === "AssignmentExpression" ||
                stmt.type === "LogicalExpression" ||
                stmt.type === "SequenceExpression" ||
                stmt.type === "VariableDeclarator") {

                stmt = stmt.parent;
            ***REMOVED***

            return ((
                stmt.type === "ExpressionStatement" ||
                stmt.type === "VariableDeclaration") &&
                stmt.parent && stmt.parent.type === "Program"
            );
        ***REMOVED***

        /**
         * Check indent for function block content
         * @param {ASTNode***REMOVED*** node A BlockStatement node that is inside of a function.
         * @returns {void***REMOVED***
         */
        function checkIndentInFunctionBlock(node) {

            /*
             * Search first caller in chain.
             * Ex.:
             *
             * Models <- Identifier
             *   .User
             *   .find()
             *   .exec(function() {
             *   // function body
             * ***REMOVED***);
             *
             * Looks for 'Models'
             */
            const calleeNode = node.parent; // FunctionExpression
            let indent;

            if (calleeNode.parent &&
                (calleeNode.parent.type === "Property" ||
                calleeNode.parent.type === "ArrayExpression")) {

                // If function is part of array or object, comma can be put at left
                indent = getNodeIndent(calleeNode, false).goodChar;
            ***REMOVED*** else {

                // If function is standalone, simple calculate indent
                indent = getNodeIndent(calleeNode).goodChar;
            ***REMOVED***

            if (calleeNode.parent.type === "CallExpression") {
                const calleeParent = calleeNode.parent;

                if (calleeNode.type !== "FunctionExpression" && calleeNode.type !== "ArrowFunctionExpression") {
                    if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {
                        indent = getNodeIndent(calleeParent).goodChar;
                    ***REMOVED***
                ***REMOVED*** else {
                    if (isArgBeforeCalleeNodeMultiline(calleeNode) &&
                        calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line &&
                        !isNodeFirstInLine(calleeNode)) {
                        indent = getNodeIndent(calleeParent).goodChar;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***

            /*
             * function body indent should be indent + indent size, unless this
             * is a FunctionDeclaration, FunctionExpression, or outer IIFE and the corresponding options are enabled.
             */
            let functionOffset = indentSize;

            if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {
                functionOffset = options.outerIIFEBody * indentSize;
            ***REMOVED*** else if (calleeNode.type === "FunctionExpression") {
                functionOffset = options.FunctionExpression.body * indentSize;
            ***REMOVED*** else if (calleeNode.type === "FunctionDeclaration") {
                functionOffset = options.FunctionDeclaration.body * indentSize;
            ***REMOVED***
            indent += functionOffset;

            // check if the node is inside a variable
            const parentVarNode = getVariableDeclaratorNode(node);

            if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {
                indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
            ***REMOVED***

            if (node.body.length > 0) {
                checkNodesIndent(node.body, indent);
            ***REMOVED***

            checkLastNodeLineIndent(node, indent - functionOffset);
        ***REMOVED***


        /**
         * Checks if the given node starts and ends on the same line
         * @param {ASTNode***REMOVED*** node The node to check
         * @returns {boolean***REMOVED*** Whether or not the block starts and ends on the same line.
         */
        function isSingleLineNode(node) {
            const lastToken = sourceCode.getLastToken(node),
                startLine = node.loc.start.line,
                endLine = lastToken.loc.end.line;

            return startLine === endLine;
        ***REMOVED***

        /**
         * Check indent for array block content or object block content
         * @param {ASTNode***REMOVED*** node node to examine
         * @returns {void***REMOVED***
         */
        function checkIndentInArrayOrObjectBlock(node) {

            // Skip inline
            if (isSingleLineNode(node)) {
                return;
            ***REMOVED***

            let elements = (node.type === "ArrayExpression") ? node.elements : node.properties;

            // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null
            elements = elements.filter(elem => elem !== null);

            let nodeIndent;
            let elementsIndent;
            const parentVarNode = getVariableDeclaratorNode(node);

            // TODO - come up with a better strategy in future
            if (isNodeFirstInLine(node)) {
                const parent = node.parent;

                nodeIndent = getNodeIndent(parent).goodChar;
                if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {
                    if (parent.type !== "VariableDeclarator" || parentVarNode === parentVarNode.parent.declarations[0]) {
                        if (parent.type === "VariableDeclarator" && parentVarNode.loc.start.line === parent.loc.start.line) {
                            nodeIndent += (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);
                        ***REMOVED*** else if (parent.type === "ObjectExpression" || parent.type === "ArrayExpression") {
                            const parentElements = node.parent.type === "ObjectExpression" ? node.parent.properties : node.parent.elements;

                            if (parentElements[0] &&
                                    parentElements[0].loc.start.line === parent.loc.start.line &&
                                    parentElements[0].loc.end.line !== parent.loc.start.line) {

                                /*
                                 * If the first element of the array spans multiple lines, don't increase the expected indentation of the rest.
                                 * e.g. [{
                                 *        foo: 1
                                 *      ***REMOVED***,
                                 *      {
                                 *        bar: 1
                                 *      ***REMOVED***]
                                 * the second object is not indented.
                                 */
                            ***REMOVED*** else if (typeof options[parent.type] === "number") {
                                nodeIndent += options[parent.type] * indentSize;
                            ***REMOVED*** else {
                                nodeIndent = parentElements[0].loc.start.column;
                            ***REMOVED***
                        ***REMOVED*** else if (parent.type === "CallExpression" || parent.type === "NewExpression") {
                            if (typeof options.CallExpression.arguments === "number") {
                                nodeIndent += options.CallExpression.arguments * indentSize;
                            ***REMOVED*** else if (options.CallExpression.arguments === "first") {
                                if (parent.arguments.includes(node)) {
                                    nodeIndent = parent.arguments[0].loc.start.column;
                                ***REMOVED***
                            ***REMOVED*** else {
                                nodeIndent += indentSize;
                            ***REMOVED***
                        ***REMOVED*** else if (parent.type === "LogicalExpression" || parent.type === "ArrowFunctionExpression") {
                            nodeIndent += indentSize;
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***

                checkFirstNodeLineIndent(node, nodeIndent);
            ***REMOVED*** else {
                nodeIndent = getNodeIndent(node).goodChar;
            ***REMOVED***

            if (options[node.type] === "first") {
                elementsIndent = elements.length ? elements[0].loc.start.column : 0; // If there are no elements, elementsIndent doesn't matter.
            ***REMOVED*** else {
                elementsIndent = nodeIndent + indentSize * options[node.type];
            ***REMOVED***

            /*
             * Check if the node is a multiple variable declaration; if so, then
             * make sure indentation takes that into account.
             */
            if (isNodeInVarOnTop(node, parentVarNode)) {
                elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
            ***REMOVED***

            checkNodesIndent(elements, elementsIndent);

            if (elements.length > 0) {

                // Skip last block line check if last item in same line
                if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {
                    return;
                ***REMOVED***
            ***REMOVED***

            checkLastNodeLineIndent(node, nodeIndent +
                (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));
        ***REMOVED***

        /**
         * Check if the node or node body is a BlockStatement or not
         * @param {ASTNode***REMOVED*** node node to test
         * @returns {boolean***REMOVED*** True if it or its body is a block statement
         */
        function isNodeBodyBlock(node) {
            return node.type === "BlockStatement" || node.type === "ClassBody" || (node.body && node.body.type === "BlockStatement") ||
                (node.consequent && node.consequent.type === "BlockStatement");
        ***REMOVED***

        /**
         * Check indentation for blocks
         * @param {ASTNode***REMOVED*** node node to check
         * @returns {void***REMOVED***
         */
        function blockIndentationCheck(node) {

            // Skip inline blocks
            if (isSingleLineNode(node)) {
                return;
            ***REMOVED***

            if (node.parent && (
                node.parent.type === "FunctionExpression" ||
                node.parent.type === "FunctionDeclaration" ||
                node.parent.type === "ArrowFunctionExpression")
            ) {
                checkIndentInFunctionBlock(node);
                return;
            ***REMOVED***

            let indent;
            let nodesToCheck = [];

            /*
             * For this statements we should check indent from statement beginning,
             * not from the beginning of the block.
             */
            const statementsWithProperties = [
                "IfStatement", "WhileStatement", "ForStatement", "ForInStatement", "ForOfStatement", "DoWhileStatement", "ClassDeclaration", "TryStatement"
            ];

            if (node.parent && statementsWithProperties.includes(node.parent.type) && isNodeBodyBlock(node)) {
                indent = getNodeIndent(node.parent).goodChar;
            ***REMOVED*** else if (node.parent && node.parent.type === "CatchClause") {
                indent = getNodeIndent(node.parent.parent).goodChar;
            ***REMOVED*** else {
                indent = getNodeIndent(node).goodChar;
            ***REMOVED***

            if (node.type === "IfStatement" && node.consequent.type !== "BlockStatement") {
                nodesToCheck = [node.consequent];
            ***REMOVED*** else if (Array.isArray(node.body)) {
                nodesToCheck = node.body;
            ***REMOVED*** else {
                nodesToCheck = [node.body];
            ***REMOVED***

            if (nodesToCheck.length > 0) {
                checkNodesIndent(nodesToCheck, indent + indentSize);
            ***REMOVED***

            if (node.type === "BlockStatement") {
                checkLastNodeLineIndent(node, indent);
            ***REMOVED***
        ***REMOVED***

        /**
         * Filter out the elements which are on the same line of each other or the node.
         * basically have only 1 elements from each line except the variable declaration line.
         * @param {ASTNode***REMOVED*** node Variable declaration node
         * @returns {ASTNode[]***REMOVED*** Filtered elements
         */
        function filterOutSameLineVars(node) {
            return node.declarations.reduce((finalCollection, elem) => {
                const lastElem = finalCollection[finalCollection.length - 1];

                if ((elem.loc.start.line !== node.loc.start.line && !lastElem) ||
                    (lastElem && lastElem.loc.start.line !== elem.loc.start.line)) {
                    finalCollection.push(elem);
                ***REMOVED***

                return finalCollection;
            ***REMOVED***, []);
        ***REMOVED***

        /**
         * Check indentation for variable declarations
         * @param {ASTNode***REMOVED*** node node to examine
         * @returns {void***REMOVED***
         */
        function checkIndentInVariableDeclarations(node) {
            const elements = filterOutSameLineVars(node);
            const nodeIndent = getNodeIndent(node).goodChar;
            const lastElement = elements[elements.length - 1];

            const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];

            checkNodesIndent(elements, elementsIndent);

            // Only check the last line if there is any token after the last item
            if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {
                return;
            ***REMOVED***

            const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);

            if (tokenBeforeLastElement.value === ",") {

                // Special case for comma-first syntax where the semicolon is indented
                checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);
            ***REMOVED*** else {
                checkLastNodeLineIndent(node, elementsIndent - indentSize);
            ***REMOVED***
        ***REMOVED***

        /**
         * Check and decide whether to check for indentation for blockless nodes
         * Scenarios are for or while statements without braces around them
         * @param {ASTNode***REMOVED*** node node to examine
         * @returns {void***REMOVED***
         */
        function blockLessNodes(node) {
            if (node.body.type !== "BlockStatement") {
                blockIndentationCheck(node);
            ***REMOVED***
        ***REMOVED***

        /**
         * Returns the expected indentation for the case statement
         * @param {ASTNode***REMOVED*** node node to examine
         * @param {int***REMOVED*** [providedSwitchIndent] indent for switch statement
         * @returns {int***REMOVED*** indent size
         */
        function expectedCaseIndent(node, providedSwitchIndent) {
            const switchNode = (node.type === "SwitchStatement") ? node : node.parent;
            const switchIndent = typeof providedSwitchIndent === "undefined"
                ? getNodeIndent(switchNode).goodChar
                : providedSwitchIndent;
            let caseIndent;

            if (caseIndentStore[switchNode.loc.start.line]) {
                return caseIndentStore[switchNode.loc.start.line];
            ***REMOVED***

            if (switchNode.cases.length > 0 && options.SwitchCase === 0) {
                caseIndent = switchIndent;
            ***REMOVED*** else {
                caseIndent = switchIndent + (indentSize * options.SwitchCase);
            ***REMOVED***

            caseIndentStore[switchNode.loc.start.line] = caseIndent;
            return caseIndent;

        ***REMOVED***

        /**
         * Checks whether a return statement is wrapped in ()
         * @param {ASTNode***REMOVED*** node node to examine
         * @returns {boolean***REMOVED*** the result
         */
        function isWrappedInParenthesis(node) {
            const regex = /^return\s*?\(\s*?\);*?/u;

            const statementWithoutArgument = sourceCode.getText(node).replace(
                sourceCode.getText(node.argument), ""
            );

            return regex.test(statementWithoutArgument);
        ***REMOVED***

        return {
            Program(node) {
                if (node.body.length > 0) {

                    // Root nodes should have no indent
                    checkNodesIndent(node.body, getNodeIndent(node).goodChar);
                ***REMOVED***
            ***REMOVED***,

            ClassBody: blockIndentationCheck,

            BlockStatement: blockIndentationCheck,

            WhileStatement: blockLessNodes,

            ForStatement: blockLessNodes,

            ForInStatement: blockLessNodes,

            ForOfStatement: blockLessNodes,

            DoWhileStatement: blockLessNodes,

            IfStatement(node) {
                if (node.consequent.type !== "BlockStatement" && node.consequent.loc.start.line > node.loc.start.line) {
                    blockIndentationCheck(node);
                ***REMOVED***
            ***REMOVED***,

            VariableDeclaration(node) {
                if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {
                    checkIndentInVariableDeclarations(node);
                ***REMOVED***
            ***REMOVED***,

            ObjectExpression(node) {
                checkIndentInArrayOrObjectBlock(node);
            ***REMOVED***,

            ArrayExpression(node) {
                checkIndentInArrayOrObjectBlock(node);
            ***REMOVED***,

            MemberExpression(node) {

                if (typeof options.MemberExpression === "undefined") {
                    return;
                ***REMOVED***

                if (isSingleLineNode(node)) {
                    return;
                ***REMOVED***

                /*
                 * The typical layout of variable declarations and assignments
                 * alter the expectation of correct indentation. Skip them.
                 * TODO: Add appropriate configuration options for variable
                 * declarations and assignments.
                 */
                if (getParentNodeByType(node, "VariableDeclarator", ["FunctionExpression", "ArrowFunctionExpression"])) {
                    return;
                ***REMOVED***

                if (getParentNodeByType(node, "AssignmentExpression", ["FunctionExpression"])) {
                    return;
                ***REMOVED***

                const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;

                const checkNodes = [node.property];

                const dot = sourceCode.getTokenBefore(node.property);

                if (dot.type === "Punctuator" && dot.value === ".") {
                    checkNodes.push(dot);
                ***REMOVED***

                checkNodesIndent(checkNodes, propertyIndent);
            ***REMOVED***,

            SwitchStatement(node) {

                // Switch is not a 'BlockStatement'
                const switchIndent = getNodeIndent(node).goodChar;
                const caseIndent = expectedCaseIndent(node, switchIndent);

                checkNodesIndent(node.cases, caseIndent);


                checkLastNodeLineIndent(node, switchIndent);
            ***REMOVED***,

            SwitchCase(node) {

                // Skip inline cases
                if (isSingleLineNode(node)) {
                    return;
                ***REMOVED***
                const caseIndent = expectedCaseIndent(node);

                checkNodesIndent(node.consequent, caseIndent + indentSize);
            ***REMOVED***,

            FunctionDeclaration(node) {
                if (isSingleLineNode(node)) {
                    return;
                ***REMOVED***
                if (options.FunctionDeclaration.parameters === "first" && node.params.length) {
                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
                ***REMOVED*** else if (options.FunctionDeclaration.parameters !== null) {
                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);
                ***REMOVED***
            ***REMOVED***,

            FunctionExpression(node) {
                if (isSingleLineNode(node)) {
                    return;
                ***REMOVED***
                if (options.FunctionExpression.parameters === "first" && node.params.length) {
                    checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
                ***REMOVED*** else if (options.FunctionExpression.parameters !== null) {
                    checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);
                ***REMOVED***
            ***REMOVED***,

            ReturnStatement(node) {
                if (isSingleLineNode(node)) {
                    return;
                ***REMOVED***

                const firstLineIndent = getNodeIndent(node).goodChar;

                // in case if return statement is wrapped in parenthesis
                if (isWrappedInParenthesis(node)) {
                    checkLastReturnStatementLineIndent(node, firstLineIndent);
                ***REMOVED*** else {
                    checkNodeIndent(node, firstLineIndent);
                ***REMOVED***
            ***REMOVED***,

            CallExpression(node) {
                if (isSingleLineNode(node)) {
                    return;
                ***REMOVED***
                if (options.CallExpression.arguments === "first" && node.arguments.length) {
                    checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);
                ***REMOVED*** else if (options.CallExpression.arguments !== null) {
                    checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);
                ***REMOVED***
            ***REMOVED***

        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
