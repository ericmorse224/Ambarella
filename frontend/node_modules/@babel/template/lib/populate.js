"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.default = populatePlaceholders;
var _t = require("@babel/types");
const {
  blockStatement,
  cloneNode,
  emptyStatement,
  expressionStatement,
  identifier,
  isStatement,
  isStringLiteral,
  stringLiteral,
  validate
***REMOVED*** = _t;
function populatePlaceholders(metadata, replacements) {
  const ast = cloneNode(metadata.ast);
  if (replacements) {
    metadata.placeholders.forEach(placeholder => {
      if (!hasOwnProperty.call(replacements, placeholder.name)) {
        const placeholderName = placeholder.name;
        throw new Error(`Error: No substitution given for "${placeholderName***REMOVED***". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName***REMOVED***'])***REMOVED***
            - { placeholderPattern: /^${placeholderName***REMOVED***$/ ***REMOVED***`);
      ***REMOVED***
    ***REMOVED***);
    Object.keys(replacements).forEach(key => {
      if (!metadata.placeholderNames.has(key)) {
        throw new Error(`Unknown substitution "${key***REMOVED***" given`);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***
  metadata.placeholders.slice().reverse().forEach(placeholder => {
    try {
      var _ref;
      applyReplacement(placeholder, ast, (_ref = replacements && replacements[placeholder.name]) != null ? _ref : null);
    ***REMOVED*** catch (e) {
      e.message = `@babel/template placeholder "${placeholder.name***REMOVED***": ${e.message***REMOVED***`;
      throw e;
    ***REMOVED***
  ***REMOVED***);
  return ast;
***REMOVED***
function applyReplacement(placeholder, ast, replacement) {
  if (placeholder.isDuplicate) {
    if (Array.isArray(replacement)) {
      replacement = replacement.map(node => cloneNode(node));
    ***REMOVED*** else if (typeof replacement === "object") {
      replacement = cloneNode(replacement);
    ***REMOVED***
  ***REMOVED***
  const {
    parent,
    key,
    index
  ***REMOVED*** = placeholder.resolve(ast);
  if (placeholder.type === "string") {
    if (typeof replacement === "string") {
      replacement = stringLiteral(replacement);
    ***REMOVED***
    if (!replacement || !isStringLiteral(replacement)) {
      throw new Error("Expected string substitution");
    ***REMOVED***
  ***REMOVED*** else if (placeholder.type === "statement") {
    if (index === undefined) {
      if (!replacement) {
        replacement = emptyStatement();
      ***REMOVED*** else if (Array.isArray(replacement)) {
        replacement = blockStatement(replacement);
      ***REMOVED*** else if (typeof replacement === "string") {
        replacement = expressionStatement(identifier(replacement));
      ***REMOVED*** else if (!isStatement(replacement)) {
        replacement = expressionStatement(replacement);
      ***REMOVED***
    ***REMOVED*** else {
      if (replacement && !Array.isArray(replacement)) {
        if (typeof replacement === "string") {
          replacement = identifier(replacement);
        ***REMOVED***
        if (!isStatement(replacement)) {
          replacement = expressionStatement(replacement);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else if (placeholder.type === "param") {
    if (typeof replacement === "string") {
      replacement = identifier(replacement);
    ***REMOVED***
    if (index === undefined) throw new Error("Assertion failure.");
  ***REMOVED*** else {
    if (typeof replacement === "string") {
      replacement = identifier(replacement);
    ***REMOVED***
    if (Array.isArray(replacement)) {
      throw new Error("Cannot replace single expression with an array.");
    ***REMOVED***
  ***REMOVED***
  function set(parent, key, value) {
    const node = parent[key];
    parent[key] = value;
    if (node.type === "Identifier" || node.type === "Placeholder") {
      if (node.typeAnnotation) {
        value.typeAnnotation = node.typeAnnotation;
      ***REMOVED***
      if (node.optional) {
        value.optional = node.optional;
      ***REMOVED***
      if (node.decorators) {
        value.decorators = node.decorators;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  if (index === undefined) {
    validate(parent, key, replacement);
    set(parent, key, replacement);
  ***REMOVED*** else {
    const items = parent[key].slice();
    if (placeholder.type === "statement" || placeholder.type === "param") {
      if (replacement == null) {
        items.splice(index, 1);
      ***REMOVED*** else if (Array.isArray(replacement)) {
        items.splice(index, 1, ...replacement);
      ***REMOVED*** else {
        set(items, index, replacement);
      ***REMOVED***
    ***REMOVED*** else {
      set(items, index, replacement);
    ***REMOVED***
    validate(parent, key, items);
    parent[key] = items;
  ***REMOVED***
***REMOVED***

//# sourceMappingURL=populate.js.map
