/**
 * @fileoverview `ConfigArray` class.
 *
 * `ConfigArray` class expresses the full of a configuration. It has the entry
 * config file, base config files that were extended, loaded parsers, and loaded
 * plugins.
 *
 * `ConfigArray` class provides three properties and two methods.
 *
 * - `pluginEnvironments`
 * - `pluginProcessors`
 * - `pluginRules`
 *      The `Map` objects that contain the members of all plugins that this
 *      config array contains. Those map objects don't have mutation methods.
 *      Those keys are the member ID such as `pluginId/memberName`.
 * - `isRoot()`
 *      If `true` then this configuration has `root:true` property.
 * - `extractConfig(filePath)`
 *      Extract the final configuration for a given file. This means merging
 *      every config array element which that `criteria` property matched. The
 *      `filePath` argument must be an absolute path.
 *
 * `ConfigArrayFactory` provides the loading logic of config files.
 *
 * @author Toru Nagashima <https://github.com/mysticatea>
 */

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

import { ExtractedConfig ***REMOVED*** from "./extracted-config.js";
import { IgnorePattern ***REMOVED*** from "./ignore-pattern.js";

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

// Define types for VSCode IntelliSense.
/** @typedef {import("../../shared/types").Environment***REMOVED*** Environment */
/** @typedef {import("../../shared/types").GlobalConf***REMOVED*** GlobalConf */
/** @typedef {import("../../shared/types").RuleConf***REMOVED*** RuleConf */
/** @typedef {import("../../shared/types").Rule***REMOVED*** Rule */
/** @typedef {import("../../shared/types").Plugin***REMOVED*** Plugin */
/** @typedef {import("../../shared/types").Processor***REMOVED*** Processor */
/** @typedef {import("./config-dependency").DependentParser***REMOVED*** DependentParser */
/** @typedef {import("./config-dependency").DependentPlugin***REMOVED*** DependentPlugin */
/** @typedef {import("./override-tester")["OverrideTester"]***REMOVED*** OverrideTester */

/**
 * @typedef {Object***REMOVED*** ConfigArrayElement
 * @property {string***REMOVED*** name The name of this config element.
 * @property {string***REMOVED*** filePath The path to the source file of this config element.
 * @property {InstanceType<OverrideTester>|null***REMOVED*** criteria The tester for the `files` and `excludedFiles` of this config element.
 * @property {Record<string, boolean>|undefined***REMOVED*** env The environment settings.
 * @property {Record<string, GlobalConf>|undefined***REMOVED*** globals The global variable settings.
 * @property {IgnorePattern|undefined***REMOVED*** ignorePattern The ignore patterns.
 * @property {boolean|undefined***REMOVED*** noInlineConfig The flag that disables directive comments.
 * @property {DependentParser|undefined***REMOVED*** parser The parser loader.
 * @property {Object|undefined***REMOVED*** parserOptions The parser options.
 * @property {Record<string, DependentPlugin>|undefined***REMOVED*** plugins The plugin loaders.
 * @property {string|undefined***REMOVED*** processor The processor name to refer plugin's processor.
 * @property {boolean|undefined***REMOVED*** reportUnusedDisableDirectives The flag to report unused `eslint-disable` comments.
 * @property {boolean|undefined***REMOVED*** root The flag to express root.
 * @property {Record<string, RuleConf>|undefined***REMOVED*** rules The rule settings
 * @property {Object|undefined***REMOVED*** settings The shared settings.
 * @property {"config" | "ignore" | "implicit-processor"***REMOVED*** type The element type.
 */

/**
 * @typedef {Object***REMOVED*** ConfigArrayInternalSlots
 * @property {Map<string, ExtractedConfig>***REMOVED*** cache The cache to extract configs.
 * @property {ReadonlyMap<string, Environment>|null***REMOVED*** envMap The map from environment ID to environment definition.
 * @property {ReadonlyMap<string, Processor>|null***REMOVED*** processorMap The map from processor ID to environment definition.
 * @property {ReadonlyMap<string, Rule>|null***REMOVED*** ruleMap The map from rule ID to rule definition.
 */

/** @type {WeakMap<ConfigArray, ConfigArrayInternalSlots>***REMOVED*** */
const internalSlotsMap = new class extends WeakMap {
    get(key) {
        let value = super.get(key);

        if (!value) {
            value = {
                cache: new Map(),
                envMap: null,
                processorMap: null,
                ruleMap: null
            ***REMOVED***;
            super.set(key, value);
        ***REMOVED***

        return value;
    ***REMOVED***
***REMOVED***();

/**
 * Get the indices which are matched to a given file.
 * @param {ConfigArrayElement[]***REMOVED*** elements The elements.
 * @param {string***REMOVED*** filePath The path to a target file.
 * @returns {number[]***REMOVED*** The indices.
 */
function getMatchedIndices(elements, filePath) {
    const indices = [];

    for (let i = elements.length - 1; i >= 0; --i) {
        const element = elements[i];

        if (!element.criteria || (filePath && element.criteria.test(filePath))) {
            indices.push(i);
        ***REMOVED***
    ***REMOVED***

    return indices;
***REMOVED***

/**
 * Check if a value is a non-null object.
 * @param {any***REMOVED*** x The value to check.
 * @returns {boolean***REMOVED*** `true` if the value is a non-null object.
 */
function isNonNullObject(x) {
    return typeof x === "object" && x !== null;
***REMOVED***

/**
 * Merge two objects.
 *
 * Assign every property values of `y` to `x` if `x` doesn't have the property.
 * If `x`'s property value is an object, it does recursive.
 * @param {Object***REMOVED*** target The destination to merge
 * @param {Object|undefined***REMOVED*** source The source to merge.
 * @returns {void***REMOVED***
 */
function mergeWithoutOverwrite(target, source) {
    if (!isNonNullObject(source)) {
        return;
    ***REMOVED***

    for (const key of Object.keys(source)) {
        if (key === "__proto__") {
            continue;
        ***REMOVED***

        if (isNonNullObject(target[key])) {
            mergeWithoutOverwrite(target[key], source[key]);
        ***REMOVED*** else if (target[key] === void 0) {
            if (isNonNullObject(source[key])) {
                target[key] = Array.isArray(source[key]) ? [] : {***REMOVED***;
                mergeWithoutOverwrite(target[key], source[key]);
            ***REMOVED*** else if (source[key] !== void 0) {
                target[key] = source[key];
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
***REMOVED***

/**
 * The error for plugin conflicts.
 */
class PluginConflictError extends Error {

    /**
     * Initialize this error object.
     * @param {string***REMOVED*** pluginId The plugin ID.
     * @param {{filePath:string, importerName:string***REMOVED***[]***REMOVED*** plugins The resolved plugins.
     */
    constructor(pluginId, plugins) {
        super(`Plugin "${pluginId***REMOVED***" was conflicted between ${plugins.map(p => `"${p.importerName***REMOVED***"`).join(" and ")***REMOVED***.`);
        this.messageTemplate = "plugin-conflict";
        this.messageData = { pluginId, plugins ***REMOVED***;
    ***REMOVED***
***REMOVED***

/**
 * Merge plugins.
 * `target`'s definition is prior to `source`'s.
 * @param {Record<string, DependentPlugin>***REMOVED*** target The destination to merge
 * @param {Record<string, DependentPlugin>|undefined***REMOVED*** source The source to merge.
 * @returns {void***REMOVED***
 * @throws {PluginConflictError***REMOVED*** When a plugin was conflicted.
 */
function mergePlugins(target, source) {
    if (!isNonNullObject(source)) {
        return;
    ***REMOVED***

    for (const key of Object.keys(source)) {
        if (key === "__proto__") {
            continue;
        ***REMOVED***
        const targetValue = target[key];
        const sourceValue = source[key];

        // Adopt the plugin which was found at first.
        if (targetValue === void 0) {
            if (sourceValue.error) {
                throw sourceValue.error;
            ***REMOVED***
            target[key] = sourceValue;
        ***REMOVED*** else if (sourceValue.filePath !== targetValue.filePath) {
            throw new PluginConflictError(key, [
                {
                    filePath: targetValue.filePath,
                    importerName: targetValue.importerName
                ***REMOVED***,
                {
                    filePath: sourceValue.filePath,
                    importerName: sourceValue.importerName
                ***REMOVED***
            ]);
        ***REMOVED***
    ***REMOVED***
***REMOVED***

/**
 * Merge rule configs.
 * `target`'s definition is prior to `source`'s.
 * @param {Record<string, Array>***REMOVED*** target The destination to merge
 * @param {Record<string, RuleConf>|undefined***REMOVED*** source The source to merge.
 * @returns {void***REMOVED***
 */
function mergeRuleConfigs(target, source) {
    if (!isNonNullObject(source)) {
        return;
    ***REMOVED***

    for (const key of Object.keys(source)) {
        if (key === "__proto__") {
            continue;
        ***REMOVED***
        const targetDef = target[key];
        const sourceDef = source[key];

        // Adopt the rule config which was found at first.
        if (targetDef === void 0) {
            if (Array.isArray(sourceDef)) {
                target[key] = [...sourceDef];
            ***REMOVED*** else {
                target[key] = [sourceDef];
            ***REMOVED***

        /*
         * If the first found rule config is severity only and the current rule
         * config has options, merge the severity and the options.
         */
        ***REMOVED*** else if (
            targetDef.length === 1 &&
            Array.isArray(sourceDef) &&
            sourceDef.length >= 2
        ) {
            targetDef.push(...sourceDef.slice(1));
        ***REMOVED***
    ***REMOVED***
***REMOVED***

/**
 * Create the extracted config.
 * @param {ConfigArray***REMOVED*** instance The config elements.
 * @param {number[]***REMOVED*** indices The indices to use.
 * @returns {ExtractedConfig***REMOVED*** The extracted config.
 * @throws {Error***REMOVED*** When a plugin is conflicted.
 */
function createConfig(instance, indices) {
    const config = new ExtractedConfig();
    const ignorePatterns = [];

    // Merge elements.
    for (const index of indices) {
        const element = instance[index];

        // Adopt the parser which was found at first.
        if (!config.parser && element.parser) {
            if (element.parser.error) {
                throw element.parser.error;
            ***REMOVED***
            config.parser = element.parser;
        ***REMOVED***

        // Adopt the processor which was found at first.
        if (!config.processor && element.processor) {
            config.processor = element.processor;
        ***REMOVED***

        // Adopt the noInlineConfig which was found at first.
        if (config.noInlineConfig === void 0 && element.noInlineConfig !== void 0) {
            config.noInlineConfig = element.noInlineConfig;
            config.configNameOfNoInlineConfig = element.name;
        ***REMOVED***

        // Adopt the reportUnusedDisableDirectives which was found at first.
        if (config.reportUnusedDisableDirectives === void 0 && element.reportUnusedDisableDirectives !== void 0) {
            config.reportUnusedDisableDirectives = element.reportUnusedDisableDirectives;
        ***REMOVED***

        // Collect ignorePatterns
        if (element.ignorePattern) {
            ignorePatterns.push(element.ignorePattern);
        ***REMOVED***

        // Merge others.
        mergeWithoutOverwrite(config.env, element.env);
        mergeWithoutOverwrite(config.globals, element.globals);
        mergeWithoutOverwrite(config.parserOptions, element.parserOptions);
        mergeWithoutOverwrite(config.settings, element.settings);
        mergePlugins(config.plugins, element.plugins);
        mergeRuleConfigs(config.rules, element.rules);
    ***REMOVED***

    // Create the predicate function for ignore patterns.
    if (ignorePatterns.length > 0) {
        config.ignores = IgnorePattern.createIgnore(ignorePatterns.reverse());
    ***REMOVED***

    return config;
***REMOVED***

/**
 * Collect definitions.
 * @template T, U
 * @param {string***REMOVED*** pluginId The plugin ID for prefix.
 * @param {Record<string,T>***REMOVED*** defs The definitions to collect.
 * @param {Map<string, U>***REMOVED*** map The map to output.
 * @returns {void***REMOVED***
 */
function collect(pluginId, defs, map) {
    if (defs) {
        const prefix = pluginId && `${pluginId***REMOVED***/`;

        for (const [key, value] of Object.entries(defs)) {
            map.set(`${prefix***REMOVED***${key***REMOVED***`, value);
        ***REMOVED***
    ***REMOVED***
***REMOVED***

/**
 * Delete the mutation methods from a given map.
 * @param {Map<any, any>***REMOVED*** map The map object to delete.
 * @returns {void***REMOVED***
 */
function deleteMutationMethods(map) {
    Object.defineProperties(map, {
        clear: { configurable: true, value: void 0 ***REMOVED***,
        delete: { configurable: true, value: void 0 ***REMOVED***,
        set: { configurable: true, value: void 0 ***REMOVED***
    ***REMOVED***);
***REMOVED***

/**
 * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.
 * @param {ConfigArrayElement[]***REMOVED*** elements The config elements.
 * @param {ConfigArrayInternalSlots***REMOVED*** slots The internal slots.
 * @returns {void***REMOVED***
 */
function initPluginMemberMaps(elements, slots) {
    const processed = new Set();

    slots.envMap = new Map();
    slots.processorMap = new Map();
    slots.ruleMap = new Map();

    for (const element of elements) {
        if (!element.plugins) {
            continue;
        ***REMOVED***

        for (const [pluginId, value] of Object.entries(element.plugins)) {
            const plugin = value.definition;

            if (!plugin || processed.has(pluginId)) {
                continue;
            ***REMOVED***
            processed.add(pluginId);

            collect(pluginId, plugin.environments, slots.envMap);
            collect(pluginId, plugin.processors, slots.processorMap);
            collect(pluginId, plugin.rules, slots.ruleMap);
        ***REMOVED***
    ***REMOVED***

    deleteMutationMethods(slots.envMap);
    deleteMutationMethods(slots.processorMap);
    deleteMutationMethods(slots.ruleMap);
***REMOVED***

/**
 * Create `envMap`, `processorMap`, `ruleMap` with the plugins in the config array.
 * @param {ConfigArray***REMOVED*** instance The config elements.
 * @returns {ConfigArrayInternalSlots***REMOVED*** The extracted config.
 */
function ensurePluginMemberMaps(instance) {
    const slots = internalSlotsMap.get(instance);

    if (!slots.ruleMap) {
        initPluginMemberMaps(instance, slots);
    ***REMOVED***

    return slots;
***REMOVED***

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * The Config Array.
 *
 * `ConfigArray` instance contains all settings, parsers, and plugins.
 * You need to call `ConfigArray#extractConfig(filePath)` method in order to
 * extract, merge and get only the config data which is related to an arbitrary
 * file.
 * @extends {Array<ConfigArrayElement>***REMOVED***
 */
class ConfigArray extends Array {

    /**
     * Get the plugin environments.
     * The returned map cannot be mutated.
     * @type {ReadonlyMap<string, Environment>***REMOVED*** The plugin environments.
     */
    get pluginEnvironments() {
        return ensurePluginMemberMaps(this).envMap;
    ***REMOVED***

    /**
     * Get the plugin processors.
     * The returned map cannot be mutated.
     * @type {ReadonlyMap<string, Processor>***REMOVED*** The plugin processors.
     */
    get pluginProcessors() {
        return ensurePluginMemberMaps(this).processorMap;
    ***REMOVED***

    /**
     * Get the plugin rules.
     * The returned map cannot be mutated.
     * @returns {ReadonlyMap<string, Rule>***REMOVED*** The plugin rules.
     */
    get pluginRules() {
        return ensurePluginMemberMaps(this).ruleMap;
    ***REMOVED***

    /**
     * Check if this config has `root` flag.
     * @returns {boolean***REMOVED*** `true` if this config array is root.
     */
    isRoot() {
        for (let i = this.length - 1; i >= 0; --i) {
            const root = this[i].root;

            if (typeof root === "boolean") {
                return root;
            ***REMOVED***
        ***REMOVED***
        return false;
    ***REMOVED***

    /**
     * Extract the config data which is related to a given file.
     * @param {string***REMOVED*** filePath The absolute path to the target file.
     * @returns {ExtractedConfig***REMOVED*** The extracted config data.
     */
    extractConfig(filePath) {
        const { cache ***REMOVED*** = internalSlotsMap.get(this);
        const indices = getMatchedIndices(this, filePath);
        const cacheKey = indices.join(",");

        if (!cache.has(cacheKey)) {
            cache.set(cacheKey, createConfig(this, indices));
        ***REMOVED***

        return cache.get(cacheKey);
    ***REMOVED***

    /**
     * Check if a given path is an additional lint target.
     * @param {string***REMOVED*** filePath The absolute path to the target file.
     * @returns {boolean***REMOVED*** `true` if the file is an additional lint target.
     */
    isAdditionalTargetPath(filePath) {
        for (const { criteria, type ***REMOVED*** of this) {
            if (
                type === "config" &&
                criteria &&
                !criteria.endsWithWildcard &&
                criteria.test(filePath)
            ) {
                return true;
            ***REMOVED***
        ***REMOVED***
        return false;
    ***REMOVED***
***REMOVED***

/**
 * Get the used extracted configs.
 * CLIEngine will use this method to collect used deprecated rules.
 * @param {ConfigArray***REMOVED*** instance The config array object to get.
 * @returns {ExtractedConfig[]***REMOVED*** The used extracted configs.
 * @private
 */
function getUsedExtractedConfigs(instance) {
    const { cache ***REMOVED*** = internalSlotsMap.get(instance);

    return Array.from(cache.values());
***REMOVED***


export {
    ConfigArray,
    getUsedExtractedConfigs
***REMOVED***;
