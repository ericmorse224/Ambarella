this.workbox=this.workbox||{***REMOVED***,this.workbox.backgroundSync=function(t,e,s,n){"use strict";function r(){return r=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var s=arguments[e];for(var n in s)Object.prototype.hasOwnProperty.call(s,n)&&(t[n]=s[n])***REMOVED***return t***REMOVED***,r.apply(this,arguments)***REMOVED***const a=(t,e)=>e.some((e=>t instanceof e));let i,c;const o=new WeakMap,u=new WeakMap,h=new WeakMap,y=new WeakMap,w=new WeakMap;let f={get(t,e,s){if(t instanceof IDBTransaction){if("done"===e)return u.get(t);if("objectStoreNames"===e)return t.objectStoreNames||h.get(t);if("store"===e)return s.objectStoreNames[1]?void 0:s.objectStore(s.objectStoreNames[0])***REMOVED***return m(t[e])***REMOVED***,set:(t,e,s)=>(t[e]=s,!0),has:(t,e)=>t instanceof IDBTransaction&&("done"===e||"store"===e)||e in t***REMOVED***;function l(t){return t!==IDBDatabase.prototype.transaction||"objectStoreNames"in IDBTransaction.prototype?(c||(c=[IDBCursor.prototype.advance,IDBCursor.prototype.continue,IDBCursor.prototype.continuePrimaryKey])).includes(t)?function(...e){return t.apply(p(this),e),m(o.get(this))***REMOVED***:function(...e){return m(t.apply(p(this),e))***REMOVED***:function(e,...s){const n=t.call(p(this),e,...s);return h.set(n,e.sort?e.sort():[e]),m(n)***REMOVED******REMOVED***function d(t){return"function"==typeof t?l(t):(t instanceof IDBTransaction&&function(t){if(u.has(t))return;const e=new Promise(((e,s)=>{const n=()=>{t.removeEventListener("complete",r),t.removeEventListener("error",a),t.removeEventListener("abort",a)***REMOVED***,r=()=>{e(),n()***REMOVED***,a=()=>{s(t.error||new DOMException("AbortError","AbortError")),n()***REMOVED***;t.addEventListener("complete",r),t.addEventListener("error",a),t.addEventListener("abort",a)***REMOVED***));u.set(t,e)***REMOVED***(t),a(t,i||(i=[IDBDatabase,IDBObjectStore,IDBIndex,IDBCursor,IDBTransaction]))?new Proxy(t,f):t)***REMOVED***function m(t){if(t instanceof IDBRequest)return function(t){const e=new Promise(((e,s)=>{const n=()=>{t.removeEventListener("success",r),t.removeEventListener("error",a)***REMOVED***,r=()=>{e(m(t.result)),n()***REMOVED***,a=()=>{s(t.error),n()***REMOVED***;t.addEventListener("success",r),t.addEventListener("error",a)***REMOVED***));return e.then((e=>{e instanceof IDBCursor&&o.set(e,t)***REMOVED***)).catch((()=>{***REMOVED***)),w.set(e,t),e***REMOVED***(t);if(y.has(t))return y.get(t);const e=d(t);return e!==t&&(y.set(t,e),w.set(e,t)),e***REMOVED***const p=t=>w.get(t);const g=["get","getKey","getAll","getAllKeys","count"],D=["put","add","delete","clear"],b=new Map;function B(t,e){if(!(t instanceof IDBDatabase)||e in t||"string"!=typeof e)return;if(b.get(e))return b.get(e);const s=e.replace(/FromIndex$/,""),n=e!==s,r=D.includes(s);if(!(s in(n?IDBIndex:IDBObjectStore).prototype)||!r&&!g.includes(s))return;const a=async function(t,...e){const a=this.transaction(t,r?"readwrite":"readonly");let i=a.store;return n&&(i=i.index(e.shift())),(await Promise.all([i[s](...e),r&&a.done]))[0]***REMOVED***;return b.set(e,a),a***REMOVED***f=(t=>r({***REMOVED***,t,{get:(e,s,n)=>B(e,s)||t.get(e,s,n),has:(e,s)=>!!B(e,s)||t.has(e,s)***REMOVED***))(f);try{self["workbox:background-sync:6.5.4"]&&_()***REMOVED***catch(t){***REMOVED***const I="requests",q="queueName";class k{constructor(){this.t=null***REMOVED***async addEntry(t){const e=(await this.getDb()).transaction(I,"readwrite",{durability:"relaxed"***REMOVED***);await e.store.add(t),await e.done***REMOVED***async getFirstEntryId(){const t=await this.getDb(),e=await t.transaction(I).store.openCursor();return null==e?void 0:e.value.id***REMOVED***async getAllEntriesByQueueName(t){const e=await this.getDb(),s=await e.getAllFromIndex(I,q,IDBKeyRange.only(t));return s||new Array***REMOVED***async getEntryCountByQueueName(t){return(await this.getDb()).countFromIndex(I,q,IDBKeyRange.only(t))***REMOVED***async deleteEntry(t){const e=await this.getDb();await e.delete(I,t)***REMOVED***async getFirstEntryByQueueName(t){return await this.getEndEntryFromIndex(IDBKeyRange.only(t),"next")***REMOVED***async getLastEntryByQueueName(t){return await this.getEndEntryFromIndex(IDBKeyRange.only(t),"prev")***REMOVED***async getEndEntryFromIndex(t,e){const s=await this.getDb(),n=await s.transaction(I).store.index(q).openCursor(t,e);return null==n?void 0:n.value***REMOVED***async getDb(){return this.t||(this.t=await function(t,e,{blocked:s,upgrade:n,blocking:r,terminated:a***REMOVED***={***REMOVED***){const i=indexedDB.open(t,e),c=m(i);return n&&i.addEventListener("upgradeneeded",(t=>{n(m(i.result),t.oldVersion,t.newVersion,m(i.transaction))***REMOVED***)),s&&i.addEventListener("blocked",(()=>s())),c.then((t=>{a&&t.addEventListener("close",(()=>a())),r&&t.addEventListener("versionchange",(()=>r()))***REMOVED***)).catch((()=>{***REMOVED***)),c***REMOVED***("workbox-background-sync",3,{upgrade:this.i***REMOVED***)),this.t***REMOVED***i(t,e){e>0&&e<3&&t.objectStoreNames.contains(I)&&t.deleteObjectStore(I);t.createObjectStore(I,{autoIncrement:!0,keyPath:"id"***REMOVED***).createIndex(q,q,{unique:!1***REMOVED***)***REMOVED******REMOVED***class E{constructor(t){this.o=t,this.u=new k***REMOVED***async pushEntry(t){delete t.id,t.queueName=this.o,await this.u.addEntry(t)***REMOVED***async unshiftEntry(t){const e=await this.u.getFirstEntryId();e?t.id=e-1:delete t.id,t.queueName=this.o,await this.u.addEntry(t)***REMOVED***async popEntry(){return this.h(await this.u.getLastEntryByQueueName(this.o))***REMOVED***async shiftEntry(){return this.h(await this.u.getFirstEntryByQueueName(this.o))***REMOVED***async getAll(){return await this.u.getAllEntriesByQueueName(this.o)***REMOVED***async size(){return await this.u.getEntryCountByQueueName(this.o)***REMOVED***async deleteEntry(t){await this.u.deleteEntry(t)***REMOVED***async h(t){return t&&await this.deleteEntry(t.id),t***REMOVED******REMOVED***const R=["method","referrer","referrerPolicy","mode","credentials","cache","redirect","integrity","keepalive"];class x{static async fromRequest(t){const e={url:t.url,headers:{***REMOVED******REMOVED***;"GET"!==t.method&&(e.body=await t.clone().arrayBuffer());for(const[s,n]of t.headers.entries())e.headers[s]=n;for(const s of R)void 0!==t[s]&&(e[s]=t[s]);return new x(e)***REMOVED***constructor(t){"navigate"===t.mode&&(t.mode="same-origin"),this.l=t***REMOVED***toObject(){const t=Object.assign({***REMOVED***,this.l);return t.headers=Object.assign({***REMOVED***,this.l.headers),t.body&&(t.body=t.body.slice(0)),t***REMOVED***toRequest(){return new Request(this.l.url,this.l)***REMOVED***clone(){return new x(this.toObject())***REMOVED******REMOVED***const v="workbox-background-sync",j=new Set,S=t=>{const e={request:new x(t.requestData).toRequest(),timestamp:t.timestamp***REMOVED***;return t.metadata&&(e.metadata=t.metadata),e***REMOVED***;class A{constructor(t,{forceSyncFallback:s,onSync:n,maxRetentionTime:r***REMOVED***={***REMOVED***){if(this.m=!1,this.p=!1,j.has(t))throw new e.WorkboxError("duplicate-queue-name",{name:t***REMOVED***);j.add(t),this.g=t,this.D=n||this.replayRequests,this.B=r||10080,this.I=Boolean(s),this.q=new E(this.g),this.k()***REMOVED***get name(){return this.g***REMOVED***async pushRequest(t){await this.R(t,"push")***REMOVED***async unshiftRequest(t){await this.R(t,"unshift")***REMOVED***async popRequest(){return this.v("pop")***REMOVED***async shiftRequest(){return this.v("shift")***REMOVED***async getAll(){const t=await this.q.getAll(),e=Date.now(),s=[];for(const n of t){const t=60*this.B*1e3;e-n.timestamp>t?await this.q.deleteEntry(n.id):s.push(S(n))***REMOVED***return s***REMOVED***async size(){return await this.q.size()***REMOVED***async R({request:t,metadata:e,timestamp:s=Date.now()***REMOVED***,n){const r={requestData:(await x.fromRequest(t.clone())).toObject(),timestamp:s***REMOVED***;switch(e&&(r.metadata=e),n){case"push":await this.q.pushEntry(r);break;case"unshift":await this.q.unshiftEntry(r)***REMOVED***this.m?this.p=!0:await this.registerSync()***REMOVED***async v(t){const e=Date.now();let s;switch(t){case"pop":s=await this.q.popEntry();break;case"shift":s=await this.q.shiftEntry()***REMOVED***if(s){const n=60*this.B*1e3;return e-s.timestamp>n?this.v(t):S(s)***REMOVED******REMOVED***async replayRequests(){let t;for(;t=await this.shiftRequest();)try{await fetch(t.request.clone())***REMOVED***catch(s){throw await this.unshiftRequest(t),new e.WorkboxError("queue-replay-failed",{name:this.g***REMOVED***)***REMOVED******REMOVED***async registerSync(){if("sync"in self.registration&&!this.I)try{await self.registration.sync.register(`${v***REMOVED***:${this.g***REMOVED***`)***REMOVED***catch(t){***REMOVED******REMOVED***k(){"sync"in self.registration&&!this.I?self.addEventListener("sync",(t=>{if(t.tag===`${v***REMOVED***:${this.g***REMOVED***`){const e=async()=>{let e;this.m=!0;try{await this.D({queue:this***REMOVED***)***REMOVED***catch(t){if(t instanceof Error)throw e=t,e***REMOVED***finally{!this.p||e&&!t.lastChance||await this.registerSync(),this.m=!1,this.p=!1***REMOVED******REMOVED***;t.waitUntil(e())***REMOVED******REMOVED***)):this.D({queue:this***REMOVED***)***REMOVED***static get j(){return j***REMOVED******REMOVED***return t.BackgroundSyncPlugin=class{constructor(t,e){this.fetchDidFail=async({request:t***REMOVED***)=>{await this.S.pushRequest({request:t***REMOVED***)***REMOVED***,this.S=new A(t,e)***REMOVED******REMOVED***,t.Queue=A,t.QueueStore=E,t.StorableRequest=x,t***REMOVED***({***REMOVED***,workbox.core._private,workbox.core._private,workbox.core._private);
//# sourceMappingURL=workbox-background-sync.prod.js.map
