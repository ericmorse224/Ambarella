/**
 * @fileoverview Rule to disallow certain object properties
 * @author Will Klein & Eli White
 */

"use strict";

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "suggestion",

		docs: {
			description: "Disallow certain properties on certain objects",
			recommended: false,
			url: "https://eslint.org/docs/latest/rules/no-restricted-properties",
		***REMOVED***,

		schema: {
			type: "array",
			items: {
				type: "object",
				properties: {
					object: {
						type: "string",
					***REMOVED***,
					property: {
						type: "string",
					***REMOVED***,
					allowObjects: {
						type: "array",
						items: {
							type: "string",
						***REMOVED***,
						uniqueItems: true,
					***REMOVED***,
					message: {
						type: "string",
					***REMOVED***,
				***REMOVED***,
				anyOf: [
					{
						required: ["object"],
					***REMOVED***,
					{
						required: ["property"],
					***REMOVED***,
				],
				not: {
					required: ["allowObjects", "object"],
				***REMOVED***,
				additionalProperties: false,
			***REMOVED***,
			uniqueItems: true,
		***REMOVED***,

		messages: {
			restrictedObjectProperty:
				// eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
				"'{{objectName***REMOVED******REMOVED***.{{propertyName***REMOVED******REMOVED***' is restricted from being used.{{message***REMOVED******REMOVED***",
			restrictedProperty:
				// eslint-disable-next-line eslint-plugin/report-message-format -- Custom message might not end in a period
				"'{{propertyName***REMOVED******REMOVED***' is restricted from being used.{{message***REMOVED******REMOVED***",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const restrictedCalls = context.options;

		if (restrictedCalls.length === 0) {
			return {***REMOVED***;
		***REMOVED***

		const restrictedProperties = new Map();
		const globallyRestrictedObjects = new Map();
		const globallyRestrictedProperties = new Map();

		restrictedCalls.forEach(option => {
			const objectName = option.object;
			const propertyName = option.property;

			if (typeof objectName === "undefined") {
				globallyRestrictedProperties.set(propertyName, {
					allowObjects: option.allowObjects,
					message: option.message,
				***REMOVED***);
			***REMOVED*** else if (typeof propertyName === "undefined") {
				globallyRestrictedObjects.set(objectName, {
					message: option.message,
				***REMOVED***);
			***REMOVED*** else {
				if (!restrictedProperties.has(objectName)) {
					restrictedProperties.set(objectName, new Map());
				***REMOVED***

				restrictedProperties.get(objectName).set(propertyName, {
					message: option.message,
				***REMOVED***);
			***REMOVED***
		***REMOVED***);

		/**
		 * Checks if an object name is in the allowed objects list.
		 * @param {string***REMOVED*** objectName The name of the object to check
		 * @param {string[]***REMOVED*** [allowObjects] The list of objects to allow
		 * @returns {boolean***REMOVED*** True if the object is allowed, false otherwise
		 */
		function isAllowedObject(objectName, allowObjects) {
			if (!allowObjects) {
				return false;
			***REMOVED***

			return allowObjects.includes(objectName);
		***REMOVED***

		/**
		 * Checks to see whether a property access is restricted, and reports it if so.
		 * @param {ASTNode***REMOVED*** node The node to report
		 * @param {string***REMOVED*** objectName The name of the object
		 * @param {string***REMOVED*** propertyName The name of the property
		 * @returns {undefined***REMOVED***
		 */
		function checkPropertyAccess(node, objectName, propertyName) {
			if (propertyName === null) {
				return;
			***REMOVED***
			const matchedObject = restrictedProperties.get(objectName);
			const matchedObjectProperty = matchedObject
				? matchedObject.get(propertyName)
				: globallyRestrictedObjects.get(objectName);
			const globalMatchedProperty =
				globallyRestrictedProperties.get(propertyName);

			if (matchedObjectProperty) {
				const message = matchedObjectProperty.message
					? ` ${matchedObjectProperty.message***REMOVED***`
					: "";

				context.report({
					node,
					messageId: "restrictedObjectProperty",
					data: {
						objectName,
						propertyName,
						message,
					***REMOVED***,
				***REMOVED***);
			***REMOVED*** else if (
				globalMatchedProperty &&
				!isAllowedObject(objectName, globalMatchedProperty.allowObjects)
			) {
				const message = globalMatchedProperty.message
					? ` ${globalMatchedProperty.message***REMOVED***`
					: "";

				context.report({
					node,
					messageId: "restrictedProperty",
					data: {
						propertyName,
						message,
					***REMOVED***,
				***REMOVED***);
			***REMOVED***
		***REMOVED***

		return {
			MemberExpression(node) {
				checkPropertyAccess(
					node,
					node.object && node.object.name,
					astUtils.getStaticPropertyName(node),
				);
			***REMOVED***,
			ObjectPattern(node) {
				let objectName = null;

				if (node.parent.type === "VariableDeclarator") {
					if (
						node.parent.init &&
						node.parent.init.type === "Identifier"
					) {
						objectName = node.parent.init.name;
					***REMOVED***
				***REMOVED*** else if (
					node.parent.type === "AssignmentExpression" ||
					node.parent.type === "AssignmentPattern"
				) {
					if (node.parent.right.type === "Identifier") {
						objectName = node.parent.right.name;
					***REMOVED***
				***REMOVED***

				node.properties.forEach(property => {
					checkPropertyAccess(
						node,
						objectName,
						astUtils.getStaticPropertyName(property),
					);
				***REMOVED***);
			***REMOVED***,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
