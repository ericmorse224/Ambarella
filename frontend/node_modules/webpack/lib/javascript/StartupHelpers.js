/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const RuntimeGlobals = require("../RuntimeGlobals");
const Template = require("../Template");
const { isSubset ***REMOVED*** = require("../util/SetHelpers");
const { getAllChunks ***REMOVED*** = require("./ChunkHelpers");

/** @typedef {import("../util/Hash")***REMOVED*** Hash */
/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../Chunk").ChunkId***REMOVED*** ChunkId */
/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../ChunkGraph").ModuleId***REMOVED*** ModuleId */
/** @typedef {import("../Entrypoint")***REMOVED*** Entrypoint */
/** @typedef {import("../ChunkGraph").EntryModuleWithChunkGroup***REMOVED*** EntryModuleWithChunkGroup */
/** @typedef {import("../ChunkGroup")***REMOVED*** ChunkGroup */
/** @typedef {import("../RuntimeTemplate")***REMOVED*** RuntimeTemplate */
/** @typedef {(string|number)[]***REMOVED*** EntryItem */

const EXPORT_PREFIX = `var ${RuntimeGlobals.exports***REMOVED*** = `;

/** @typedef {Set<Chunk>***REMOVED*** Chunks */
/** @typedef {ModuleId[]***REMOVED*** ModuleIds */

/**
 * @param {ChunkGraph***REMOVED*** chunkGraph chunkGraph
 * @param {RuntimeTemplate***REMOVED*** runtimeTemplate runtimeTemplate
 * @param {EntryModuleWithChunkGroup[]***REMOVED*** entries entries
 * @param {Chunk***REMOVED*** chunk chunk
 * @param {boolean***REMOVED*** passive true: passive startup with on chunks loaded
 * @returns {string***REMOVED*** runtime code
 */
module.exports.generateEntryStartup = (
	chunkGraph,
	runtimeTemplate,
	entries,
	chunk,
	passive
) => {
	/** @type {string[]***REMOVED*** */
	const runtime = [
		`var __webpack_exec__ = ${runtimeTemplate.returningFunction(
			`${RuntimeGlobals.require***REMOVED***(${RuntimeGlobals.entryModuleId***REMOVED*** = moduleId)`,
			"moduleId"
		)***REMOVED***`
	];

	/**
	 * @param {ModuleId***REMOVED*** id id
	 * @returns {string***REMOVED*** fn to execute
	 */
	const runModule = id => `__webpack_exec__(${JSON.stringify(id)***REMOVED***)`;
	/**
	 * @param {Chunks***REMOVED*** chunks chunks
	 * @param {ModuleIds***REMOVED*** moduleIds module ids
	 * @param {boolean=***REMOVED*** final true when final, otherwise false
	 */
	const outputCombination = (chunks, moduleIds, final) => {
		if (chunks.size === 0) {
			runtime.push(
				`${final ? EXPORT_PREFIX : ""***REMOVED***(${moduleIds.map(runModule).join(", ")***REMOVED***);`
			);
		***REMOVED*** else {
			const fn = runtimeTemplate.returningFunction(
				moduleIds.map(runModule).join(", ")
			);
			runtime.push(
				`${final && !passive ? EXPORT_PREFIX : ""***REMOVED***${
					passive
						? RuntimeGlobals.onChunksLoaded
						: RuntimeGlobals.startupEntrypoint
				***REMOVED***(0, ${JSON.stringify(Array.from(chunks, c => c.id))***REMOVED***, ${fn***REMOVED***);`
			);
			if (final && passive) {
				runtime.push(`${EXPORT_PREFIX***REMOVED***${RuntimeGlobals.onChunksLoaded***REMOVED***();`);
			***REMOVED***
		***REMOVED***
	***REMOVED***;

	/** @type {Chunks | undefined***REMOVED*** */
	let currentChunks;
	/** @type {ModuleIds | undefined***REMOVED*** */
	let currentModuleIds;

	for (const [module, entrypoint] of entries) {
		if (!chunkGraph.getModuleSourceTypes(module).has("javascript")) {
			continue;
		***REMOVED***
		const runtimeChunk =
			/** @type {Entrypoint***REMOVED*** */
			(entrypoint).getRuntimeChunk();
		const moduleId = /** @type {ModuleId***REMOVED*** */ (chunkGraph.getModuleId(module));
		const chunks = getAllChunks(
			/** @type {Entrypoint***REMOVED*** */
			(entrypoint),
			chunk,
			runtimeChunk
		);
		if (
			currentChunks &&
			currentChunks.size === chunks.size &&
			isSubset(currentChunks, chunks)
		) {
			/** @type {ModuleIds***REMOVED*** */
			(currentModuleIds).push(moduleId);
		***REMOVED*** else {
			if (currentChunks) {
				outputCombination(
					currentChunks,
					/** @type {ModuleIds***REMOVED*** */ (currentModuleIds)
				);
			***REMOVED***
			currentChunks = chunks;
			currentModuleIds = [moduleId];
		***REMOVED***
	***REMOVED***

	// output current modules with export prefix
	if (currentChunks) {
		outputCombination(
			currentChunks,
			/** @type {ModuleIds***REMOVED*** */
			(currentModuleIds),
			true
		);
	***REMOVED***
	runtime.push("");
	return Template.asString(runtime);
***REMOVED***;

/**
 * @param {Hash***REMOVED*** hash the hash to update
 * @param {ChunkGraph***REMOVED*** chunkGraph chunkGraph
 * @param {EntryModuleWithChunkGroup[]***REMOVED*** entries entries
 * @param {Chunk***REMOVED*** chunk chunk
 * @returns {void***REMOVED***
 */
module.exports.updateHashForEntryStartup = (
	hash,
	chunkGraph,
	entries,
	chunk
) => {
	for (const [module, entrypoint] of entries) {
		const runtimeChunk =
			/** @type {Entrypoint***REMOVED*** */
			(entrypoint).getRuntimeChunk();
		const moduleId = chunkGraph.getModuleId(module);
		hash.update(`${moduleId***REMOVED***`);
		for (const c of getAllChunks(
			/** @type {Entrypoint***REMOVED*** */ (entrypoint),
			chunk,
			/** @type {Chunk***REMOVED*** */ (runtimeChunk)
		)) {
			hash.update(`${c.id***REMOVED***`);
		***REMOVED***
	***REMOVED***
***REMOVED***;

/**
 * @param {Chunk***REMOVED*** chunk the chunk
 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @param {(chunk: Chunk, chunkGraph: ChunkGraph) => boolean***REMOVED*** filterFn filter function
 * @returns {Set<number | string>***REMOVED*** initially fulfilled chunk ids
 */
module.exports.getInitialChunkIds = (chunk, chunkGraph, filterFn) => {
	const initialChunkIds = new Set(chunk.ids);
	for (const c of chunk.getAllInitialChunks()) {
		if (c === chunk || filterFn(c, chunkGraph)) continue;
		for (const id of /** @type {ChunkId[]***REMOVED*** */ (c.ids)) {
			initialChunkIds.add(id);
		***REMOVED***
	***REMOVED***
	return initialChunkIds;
***REMOVED***;
