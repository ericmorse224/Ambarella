/**
 * @fileoverview Rule to enforce consistent naming of "this" context variables
 * @author Raphael Pigulla
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "suggestion",

		docs: {
			description:
				"Enforce consistent naming when capturing the current execution context",
			recommended: false,
			frozen: true,
			url: "https://eslint.org/docs/latest/rules/consistent-this",
		***REMOVED***,

		schema: {
			type: "array",
			items: {
				type: "string",
				minLength: 1,
			***REMOVED***,
			uniqueItems: true,
		***REMOVED***,

		defaultOptions: ["that"],

		messages: {
			aliasNotAssignedToThis:
				"Designated alias '{{name***REMOVED******REMOVED***' is not assigned to 'this'.",
			unexpectedAlias: "Unexpected alias '{{name***REMOVED******REMOVED***' for 'this'.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const aliases = context.options;
		const sourceCode = context.sourceCode;

		/**
		 * Reports that a variable declarator or assignment expression is assigning
		 * a non-'this' value to the specified alias.
		 * @param {ASTNode***REMOVED*** node The assigning node.
		 * @param {string***REMOVED*** name the name of the alias that was incorrectly used.
		 * @returns {void***REMOVED***
		 */
		function reportBadAssignment(node, name) {
			context.report({
				node,
				messageId: "aliasNotAssignedToThis",
				data: { name ***REMOVED***,
			***REMOVED***);
		***REMOVED***

		/**
		 * Checks that an assignment to an identifier only assigns 'this' to the
		 * appropriate alias, and the alias is only assigned to 'this'.
		 * @param {ASTNode***REMOVED*** node The assigning node.
		 * @param {Identifier***REMOVED*** name The name of the variable assigned to.
		 * @param {Expression***REMOVED*** value The value of the assignment.
		 * @returns {void***REMOVED***
		 */
		function checkAssignment(node, name, value) {
			const isThis = value.type === "ThisExpression";

			if (aliases.includes(name)) {
				if (!isThis || (node.operator && node.operator !== "=")) {
					reportBadAssignment(node, name);
				***REMOVED***
			***REMOVED*** else if (isThis) {
				context.report({
					node,
					messageId: "unexpectedAlias",
					data: { name ***REMOVED***,
				***REMOVED***);
			***REMOVED***
		***REMOVED***

		/**
		 * Ensures that a variable declaration of the alias in a program or function
		 * is assigned to the correct value.
		 * @param {string***REMOVED*** alias alias the check the assignment of.
		 * @param {Object***REMOVED*** scope scope of the current code we are checking.
		 * @private
		 * @returns {void***REMOVED***
		 */
		function checkWasAssigned(alias, scope) {
			const variable = scope.set.get(alias);

			if (!variable) {
				return;
			***REMOVED***

			if (
				variable.defs.some(
					def =>
						def.node.type === "VariableDeclarator" &&
						def.node.init !== null,
				)
			) {
				return;
			***REMOVED***

			/*
			 * The alias has been declared and not assigned: check it was
			 * assigned later in the same scope.
			 */
			if (
				!variable.references.some(reference => {
					const write = reference.writeExpr;

					return (
						reference.from === scope &&
						write &&
						write.type === "ThisExpression" &&
						write.parent.operator === "="
					);
				***REMOVED***)
			) {
				variable.defs
					.map(def => def.node)
					.forEach(node => {
						reportBadAssignment(node, alias);
					***REMOVED***);
			***REMOVED***
		***REMOVED***

		/**
		 * Check each alias to ensure that is was assigned to the correct value.
		 * @param {ASTNode***REMOVED*** node The node that represents the scope to check.
		 * @returns {void***REMOVED***
		 */
		function ensureWasAssigned(node) {
			const scope = sourceCode.getScope(node);

			// if this is program scope we also need to check module scope
			const extraScope =
				node.type === "Program" && node.sourceType === "module"
					? scope.childScopes[0]
					: null;

			aliases.forEach(alias => {
				checkWasAssigned(alias, scope);

				if (extraScope) {
					checkWasAssigned(alias, extraScope);
				***REMOVED***
			***REMOVED***);
		***REMOVED***

		return {
			"Program:exit": ensureWasAssigned,
			"FunctionExpression:exit": ensureWasAssigned,
			"FunctionDeclaration:exit": ensureWasAssigned,

			VariableDeclarator(node) {
				const id = node.id;
				const isDestructuring =
					id.type === "ArrayPattern" || id.type === "ObjectPattern";

				if (node.init !== null && !isDestructuring) {
					checkAssignment(node, id.name, node.init);
				***REMOVED***
			***REMOVED***,

			AssignmentExpression(node) {
				if (node.left.type === "Identifier") {
					checkAssignment(node, node.left.name, node.right);
				***REMOVED***
			***REMOVED***,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
