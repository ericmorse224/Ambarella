/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const InitFragment = require("./InitFragment");
const RuntimeGlobals = require("./RuntimeGlobals");
const Template = require("./Template");
const { equals ***REMOVED*** = require("./util/ArrayHelpers");
const compileBooleanMatcher = require("./util/compileBooleanMatcher");
const propertyAccess = require("./util/propertyAccess");
const { forEachRuntime, subtractRuntime ***REMOVED*** = require("./util/runtime");

/** @typedef {import("../declarations/WebpackOptions").Environment***REMOVED*** Environment */
/** @typedef {import("../declarations/WebpackOptions").OutputNormalized***REMOVED*** OutputOptions */
/** @typedef {import("./AsyncDependenciesBlock")***REMOVED*** AsyncDependenciesBlock */
/** @typedef {import("./Chunk")***REMOVED*** Chunk */
/** @typedef {import("./ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("./CodeGenerationResults")***REMOVED*** CodeGenerationResults */
/** @typedef {import("./CodeGenerationResults").CodeGenerationResult***REMOVED*** CodeGenerationResult */
/** @typedef {import("./Compilation")***REMOVED*** Compilation */
/** @typedef {import("./Dependency")***REMOVED*** Dependency */
/** @typedef {import("./Module")***REMOVED*** Module */
/** @typedef {import("./Module").BuildMeta***REMOVED*** BuildMeta */
/** @typedef {import("./Module").RuntimeRequirements***REMOVED*** RuntimeRequirements */
/** @typedef {import("./ModuleGraph")***REMOVED*** ModuleGraph */
/** @typedef {import("./RequestShortener")***REMOVED*** RequestShortener */
/** @typedef {import("./util/runtime").RuntimeSpec***REMOVED*** RuntimeSpec */

/**
 * @param {Module***REMOVED*** module the module
 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @returns {string***REMOVED*** error message
 */
const noModuleIdErrorMessage = (
	module,
	chunkGraph
) => `Module ${module.identifier()***REMOVED*** has no id assigned.
This should not happen.
It's in these chunks: ${
	Array.from(
		chunkGraph.getModuleChunksIterable(module),
		c => c.name || c.id || c.debugId
	).join(", ") || "none"
***REMOVED*** (If module is in no chunk this indicates a bug in some chunk/module optimization logic)
Module has these incoming connections: ${Array.from(
	chunkGraph.moduleGraph.getIncomingConnections(module),
	connection =>
		`\n - ${
			connection.originModule && connection.originModule.identifier()
		***REMOVED*** ${connection.dependency && connection.dependency.type***REMOVED*** ${
			(connection.explanations &&
				Array.from(connection.explanations).join(", ")) ||
			""
		***REMOVED***`
).join("")***REMOVED***`;

/**
 * @param {string | undefined***REMOVED*** definition global object definition
 * @returns {string | undefined***REMOVED*** save to use global object
 */
function getGlobalObject(definition) {
	if (!definition) return definition;
	const trimmed = definition.trim();

	if (
		// identifier, we do not need real identifier regarding ECMAScript/Unicode
		/^[_\p{L***REMOVED***][_0-9\p{L***REMOVED***]*$/iu.test(trimmed) ||
		// iife
		// call expression
		// expression in parentheses
		/^([_\p{L***REMOVED***][_0-9\p{L***REMOVED***]*)?\(.*\)$/iu.test(trimmed)
	)
		return trimmed;

	return `Object(${trimmed***REMOVED***)`;
***REMOVED***

class RuntimeTemplate {
	/**
	 * @param {Compilation***REMOVED*** compilation the compilation
	 * @param {OutputOptions***REMOVED*** outputOptions the compilation output options
	 * @param {RequestShortener***REMOVED*** requestShortener the request shortener
	 */
	constructor(compilation, outputOptions, requestShortener) {
		this.compilation = compilation;
		this.outputOptions = /** @type {OutputOptions***REMOVED*** */ (outputOptions || {***REMOVED***);
		this.requestShortener = requestShortener;
		this.globalObject =
			/** @type {string***REMOVED*** */
			(getGlobalObject(outputOptions.globalObject));
		this.contentHashReplacement = "X".repeat(
			/** @type {NonNullable<OutputOptions["hashDigestLength"]>***REMOVED*** */
			(outputOptions.hashDigestLength)
		);
	***REMOVED***

	isIIFE() {
		return this.outputOptions.iife;
	***REMOVED***

	isModule() {
		return this.outputOptions.module;
	***REMOVED***

	isNeutralPlatform() {
		return (
			!this.outputOptions.environment.document &&
			!this.compilation.compiler.platform.node
		);
	***REMOVED***

	supportsConst() {
		return this.outputOptions.environment.const;
	***REMOVED***

	supportsArrowFunction() {
		return this.outputOptions.environment.arrowFunction;
	***REMOVED***

	supportsAsyncFunction() {
		return this.outputOptions.environment.asyncFunction;
	***REMOVED***

	supportsOptionalChaining() {
		return this.outputOptions.environment.optionalChaining;
	***REMOVED***

	supportsForOf() {
		return this.outputOptions.environment.forOf;
	***REMOVED***

	supportsDestructuring() {
		return this.outputOptions.environment.destructuring;
	***REMOVED***

	supportsBigIntLiteral() {
		return this.outputOptions.environment.bigIntLiteral;
	***REMOVED***

	supportsDynamicImport() {
		return this.outputOptions.environment.dynamicImport;
	***REMOVED***

	supportsEcmaScriptModuleSyntax() {
		return this.outputOptions.environment.module;
	***REMOVED***

	supportTemplateLiteral() {
		return this.outputOptions.environment.templateLiteral;
	***REMOVED***

	supportNodePrefixForCoreModules() {
		return this.outputOptions.environment.nodePrefixForCoreModules;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** returnValue return value
	 * @param {string***REMOVED*** args arguments
	 * @returns {string***REMOVED*** returning function
	 */
	returningFunction(returnValue, args = "") {
		return this.supportsArrowFunction()
			? `(${args***REMOVED***) => (${returnValue***REMOVED***)`
			: `function(${args***REMOVED***) { return ${returnValue***REMOVED***; ***REMOVED***`;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** args arguments
	 * @param {string | string[]***REMOVED*** body body
	 * @returns {string***REMOVED*** basic function
	 */
	basicFunction(args, body) {
		return this.supportsArrowFunction()
			? `(${args***REMOVED***) => {\n${Template.indent(body)***REMOVED***\n***REMOVED***`
			: `function(${args***REMOVED***) {\n${Template.indent(body)***REMOVED***\n***REMOVED***`;
	***REMOVED***

	/**
	 * @param {Array<string|{expr: string***REMOVED***>***REMOVED*** args args
	 * @returns {string***REMOVED*** result expression
	 */
	concatenation(...args) {
		const len = args.length;

		if (len === 2) return this._es5Concatenation(args);
		if (len === 0) return '""';
		if (len === 1) {
			return typeof args[0] === "string"
				? JSON.stringify(args[0])
				: `"" + ${args[0].expr***REMOVED***`;
		***REMOVED***
		if (!this.supportTemplateLiteral()) return this._es5Concatenation(args);

		// cost comparison between template literal and concatenation:
		// both need equal surroundings: `xxx` vs "xxx"
		// template literal has constant cost of 3 chars for each expression
		// es5 concatenation has cost of 3 + n chars for n expressions in row
		// when a es5 concatenation ends with an expression it reduces cost by 3
		// when a es5 concatenation starts with an single expression it reduces cost by 3
		// e. g. `${a***REMOVED***${b***REMOVED***${c***REMOVED***` (3*3 = 9) is longer than ""+a+b+c ((3+3)-3 = 3)
		// e. g. `x${a***REMOVED***x${b***REMOVED***x${c***REMOVED***x` (3*3 = 9) is shorter than "x"+a+"x"+b+"x"+c+"x" (4+4+4 = 12)

		let templateCost = 0;
		let concatenationCost = 0;

		let lastWasExpr = false;
		for (const arg of args) {
			const isExpr = typeof arg !== "string";
			if (isExpr) {
				templateCost += 3;
				concatenationCost += lastWasExpr ? 1 : 4;
			***REMOVED***
			lastWasExpr = isExpr;
		***REMOVED***
		if (lastWasExpr) concatenationCost -= 3;
		if (typeof args[0] !== "string" && typeof args[1] === "string")
			concatenationCost -= 3;

		if (concatenationCost <= templateCost) return this._es5Concatenation(args);

		return `\`${args
			.map(arg => (typeof arg === "string" ? arg : `\${${arg.expr***REMOVED******REMOVED***`))
			.join("")***REMOVED***\``;
	***REMOVED***

	/**
	 * @param {Array<string|{expr: string***REMOVED***>***REMOVED*** args args (len >= 2)
	 * @returns {string***REMOVED*** result expression
	 * @private
	 */
	_es5Concatenation(args) {
		const str = args
			.map(arg => (typeof arg === "string" ? JSON.stringify(arg) : arg.expr))
			.join(" + ");

		// when the first two args are expression, we need to prepend "" + to force string
		// concatenation instead of number addition.
		return typeof args[0] !== "string" && typeof args[1] !== "string"
			? `"" + ${str***REMOVED***`
			: str;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** expression expression
	 * @param {string***REMOVED*** args arguments
	 * @returns {string***REMOVED*** expression function code
	 */
	expressionFunction(expression, args = "") {
		return this.supportsArrowFunction()
			? `(${args***REMOVED***) => (${expression***REMOVED***)`
			: `function(${args***REMOVED***) { ${expression***REMOVED***; ***REMOVED***`;
	***REMOVED***

	/**
	 * @returns {string***REMOVED*** empty function code
	 */
	emptyFunction() {
		return this.supportsArrowFunction() ? "x => {***REMOVED***" : "function() {***REMOVED***";
	***REMOVED***

	/**
	 * @param {string[]***REMOVED*** items items
	 * @param {string***REMOVED*** value value
	 * @returns {string***REMOVED*** destructure array code
	 */
	destructureArray(items, value) {
		return this.supportsDestructuring()
			? `var [${items.join(", ")***REMOVED***] = ${value***REMOVED***;`
			: Template.asString(
					items.map((item, i) => `var ${item***REMOVED*** = ${value***REMOVED***[${i***REMOVED***];`)
				);
	***REMOVED***

	/**
	 * @param {string[]***REMOVED*** items items
	 * @param {string***REMOVED*** value value
	 * @returns {string***REMOVED*** destructure object code
	 */
	destructureObject(items, value) {
		return this.supportsDestructuring()
			? `var {${items.join(", ")***REMOVED******REMOVED*** = ${value***REMOVED***;`
			: Template.asString(
					items.map(item => `var ${item***REMOVED*** = ${value***REMOVED***${propertyAccess([item])***REMOVED***;`)
				);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** args arguments
	 * @param {string***REMOVED*** body body
	 * @returns {string***REMOVED*** IIFE code
	 */
	iife(args, body) {
		return `(${this.basicFunction(args, body)***REMOVED***)()`;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** variable variable
	 * @param {string***REMOVED*** array array
	 * @param {string | string[]***REMOVED*** body body
	 * @returns {string***REMOVED*** for each code
	 */
	forEach(variable, array, body) {
		return this.supportsForOf()
			? `for(const ${variable***REMOVED*** of ${array***REMOVED***) {\n${Template.indent(body)***REMOVED***\n***REMOVED***`
			: `${array***REMOVED***.forEach(function(${variable***REMOVED***) {\n${Template.indent(
					body
				)***REMOVED***\n***REMOVED***);`;
	***REMOVED***

	/**
	 * Add a comment
	 * @param {object***REMOVED*** options Information content of the comment
	 * @param {string=***REMOVED*** options.request request string used originally
	 * @param {(string | null)=***REMOVED*** options.chunkName name of the chunk referenced
	 * @param {string=***REMOVED*** options.chunkReason reason information of the chunk
	 * @param {string=***REMOVED*** options.message additional message
	 * @param {string=***REMOVED*** options.exportName name of the export
	 * @returns {string***REMOVED*** comment
	 */
	comment({ request, chunkName, chunkReason, message, exportName ***REMOVED***) {
		let content;
		if (this.outputOptions.pathinfo) {
			content = [message, request, chunkName, chunkReason]
				.filter(Boolean)
				.map(item => this.requestShortener.shorten(item))
				.join(" | ");
		***REMOVED*** else {
			content = [message, chunkName, chunkReason]
				.filter(Boolean)
				.map(item => this.requestShortener.shorten(item))
				.join(" | ");
		***REMOVED***
		if (!content) return "";
		if (this.outputOptions.pathinfo) {
			return `${Template.toComment(content)***REMOVED*** `;
		***REMOVED***
		return `${Template.toNormalComment(content)***REMOVED*** `;
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options generation options
	 * @param {string=***REMOVED*** options.request request string used originally
	 * @returns {string***REMOVED*** generated error block
	 */
	throwMissingModuleErrorBlock({ request ***REMOVED***) {
		const err = `Cannot find module '${request***REMOVED***'`;
		return `var e = new Error(${JSON.stringify(
			err
		)***REMOVED***); e.code = 'MODULE_NOT_FOUND'; throw e;`;
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options generation options
	 * @param {string=***REMOVED*** options.request request string used originally
	 * @returns {string***REMOVED*** generated error function
	 */
	throwMissingModuleErrorFunction({ request ***REMOVED***) {
		return `function webpackMissingModule() { ${this.throwMissingModuleErrorBlock(
			{ request ***REMOVED***
		)***REMOVED*** ***REMOVED***`;
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options generation options
	 * @param {string=***REMOVED*** options.request request string used originally
	 * @returns {string***REMOVED*** generated error IIFE
	 */
	missingModule({ request ***REMOVED***) {
		return `Object(${this.throwMissingModuleErrorFunction({ request ***REMOVED***)***REMOVED***())`;
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options generation options
	 * @param {string=***REMOVED*** options.request request string used originally
	 * @returns {string***REMOVED*** generated error statement
	 */
	missingModuleStatement({ request ***REMOVED***) {
		return `${this.missingModule({ request ***REMOVED***)***REMOVED***;\n`;
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options generation options
	 * @param {string=***REMOVED*** options.request request string used originally
	 * @returns {string***REMOVED*** generated error code
	 */
	missingModulePromise({ request ***REMOVED***) {
		return `Promise.resolve().then(${this.throwMissingModuleErrorFunction({
			request
		***REMOVED***)***REMOVED***)`;
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options options object
	 * @param {ChunkGraph***REMOVED*** options.chunkGraph the chunk graph
	 * @param {Module***REMOVED*** options.module the module
	 * @param {string=***REMOVED*** options.request the request that should be printed as comment
	 * @param {string=***REMOVED*** options.idExpr expression to use as id expression
	 * @param {"expression" | "promise" | "statements"***REMOVED*** options.type which kind of code should be returned
	 * @returns {string***REMOVED*** the code
	 */
	weakError({ module, chunkGraph, request, idExpr, type ***REMOVED***) {
		const moduleId = chunkGraph.getModuleId(module);
		const errorMessage =
			moduleId === null
				? JSON.stringify("Module is not available (weak dependency)")
				: idExpr
					? `"Module '" + ${idExpr***REMOVED*** + "' is not available (weak dependency)"`
					: JSON.stringify(
							`Module '${moduleId***REMOVED***' is not available (weak dependency)`
						);
		const comment = request ? `${Template.toNormalComment(request)***REMOVED*** ` : "";
		const errorStatements = `var e = new Error(${errorMessage***REMOVED***); ${
			comment
		***REMOVED***e.code = 'MODULE_NOT_FOUND'; throw e;`;
		switch (type) {
			case "statements":
				return errorStatements;
			case "promise":
				return `Promise.resolve().then(${this.basicFunction(
					"",
					errorStatements
				)***REMOVED***)`;
			case "expression":
				return this.iife("", errorStatements);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options options object
	 * @param {Module***REMOVED*** options.module the module
	 * @param {ChunkGraph***REMOVED*** options.chunkGraph the chunk graph
	 * @param {string=***REMOVED*** options.request the request that should be printed as comment
	 * @param {boolean=***REMOVED*** options.weak if the dependency is weak (will create a nice error message)
	 * @returns {string***REMOVED*** the expression
	 */
	moduleId({ module, chunkGraph, request, weak ***REMOVED***) {
		if (!module) {
			return this.missingModule({
				request
			***REMOVED***);
		***REMOVED***
		const moduleId = chunkGraph.getModuleId(module);
		if (moduleId === null) {
			if (weak) {
				return "null /* weak dependency, without id */";
			***REMOVED***
			throw new Error(
				`RuntimeTemplate.moduleId(): ${noModuleIdErrorMessage(
					module,
					chunkGraph
				)***REMOVED***`
			);
		***REMOVED***
		return `${this.comment({ request ***REMOVED***)***REMOVED***${JSON.stringify(moduleId)***REMOVED***`;
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options options object
	 * @param {Module | null***REMOVED*** options.module the module
	 * @param {ChunkGraph***REMOVED*** options.chunkGraph the chunk graph
	 * @param {string=***REMOVED*** options.request the request that should be printed as comment
	 * @param {boolean=***REMOVED*** options.weak if the dependency is weak (will create a nice error message)
	 * @param {RuntimeRequirements***REMOVED*** options.runtimeRequirements if set, will be filled with runtime requirements
	 * @returns {string***REMOVED*** the expression
	 */
	moduleRaw({ module, chunkGraph, request, weak, runtimeRequirements ***REMOVED***) {
		if (!module) {
			return this.missingModule({
				request
			***REMOVED***);
		***REMOVED***
		const moduleId = chunkGraph.getModuleId(module);
		if (moduleId === null) {
			if (weak) {
				// only weak referenced modules don't get an id
				// we can always emit an error emitting code here
				return this.weakError({
					module,
					chunkGraph,
					request,
					type: "expression"
				***REMOVED***);
			***REMOVED***
			throw new Error(
				`RuntimeTemplate.moduleId(): ${noModuleIdErrorMessage(
					module,
					chunkGraph
				)***REMOVED***`
			);
		***REMOVED***
		runtimeRequirements.add(RuntimeGlobals.require);
		return `${RuntimeGlobals.require***REMOVED***(${this.moduleId({
			module,
			chunkGraph,
			request,
			weak
		***REMOVED***)***REMOVED***)`;
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options options object
	 * @param {Module | null***REMOVED*** options.module the module
	 * @param {ChunkGraph***REMOVED*** options.chunkGraph the chunk graph
	 * @param {string***REMOVED*** options.request the request that should be printed as comment
	 * @param {boolean=***REMOVED*** options.weak if the dependency is weak (will create a nice error message)
	 * @param {RuntimeRequirements***REMOVED*** options.runtimeRequirements if set, will be filled with runtime requirements
	 * @returns {string***REMOVED*** the expression
	 */
	moduleExports({ module, chunkGraph, request, weak, runtimeRequirements ***REMOVED***) {
		return this.moduleRaw({
			module,
			chunkGraph,
			request,
			weak,
			runtimeRequirements
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options options object
	 * @param {Module***REMOVED*** options.module the module
	 * @param {ChunkGraph***REMOVED*** options.chunkGraph the chunk graph
	 * @param {string***REMOVED*** options.request the request that should be printed as comment
	 * @param {boolean=***REMOVED*** options.strict if the current module is in strict esm mode
	 * @param {boolean=***REMOVED*** options.weak if the dependency is weak (will create a nice error message)
	 * @param {RuntimeRequirements***REMOVED*** options.runtimeRequirements if set, will be filled with runtime requirements
	 * @returns {string***REMOVED*** the expression
	 */
	moduleNamespace({
		module,
		chunkGraph,
		request,
		strict,
		weak,
		runtimeRequirements
	***REMOVED***) {
		if (!module) {
			return this.missingModule({
				request
			***REMOVED***);
		***REMOVED***
		if (chunkGraph.getModuleId(module) === null) {
			if (weak) {
				// only weak referenced modules don't get an id
				// we can always emit an error emitting code here
				return this.weakError({
					module,
					chunkGraph,
					request,
					type: "expression"
				***REMOVED***);
			***REMOVED***
			throw new Error(
				`RuntimeTemplate.moduleNamespace(): ${noModuleIdErrorMessage(
					module,
					chunkGraph
				)***REMOVED***`
			);
		***REMOVED***
		const moduleId = this.moduleId({
			module,
			chunkGraph,
			request,
			weak
		***REMOVED***);
		const exportsType = module.getExportsType(chunkGraph.moduleGraph, strict);
		switch (exportsType) {
			case "namespace":
				return this.moduleRaw({
					module,
					chunkGraph,
					request,
					weak,
					runtimeRequirements
				***REMOVED***);
			case "default-with-named":
				runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);
				return `${RuntimeGlobals.createFakeNamespaceObject***REMOVED***(${moduleId***REMOVED***, 3)`;
			case "default-only":
				runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);
				return `${RuntimeGlobals.createFakeNamespaceObject***REMOVED***(${moduleId***REMOVED***, 1)`;
			case "dynamic":
				runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);
				return `${RuntimeGlobals.createFakeNamespaceObject***REMOVED***(${moduleId***REMOVED***, 7)`;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options options object
	 * @param {ChunkGraph***REMOVED*** options.chunkGraph the chunk graph
	 * @param {AsyncDependenciesBlock=***REMOVED*** options.block the current dependencies block
	 * @param {Module***REMOVED*** options.module the module
	 * @param {string***REMOVED*** options.request the request that should be printed as comment
	 * @param {string***REMOVED*** options.message a message for the comment
	 * @param {boolean=***REMOVED*** options.strict if the current module is in strict esm mode
	 * @param {boolean=***REMOVED*** options.weak if the dependency is weak (will create a nice error message)
	 * @param {RuntimeRequirements***REMOVED*** options.runtimeRequirements if set, will be filled with runtime requirements
	 * @returns {string***REMOVED*** the promise expression
	 */
	moduleNamespacePromise({
		chunkGraph,
		block,
		module,
		request,
		message,
		strict,
		weak,
		runtimeRequirements
	***REMOVED***) {
		if (!module) {
			return this.missingModulePromise({
				request
			***REMOVED***);
		***REMOVED***
		const moduleId = chunkGraph.getModuleId(module);
		if (moduleId === null) {
			if (weak) {
				// only weak referenced modules don't get an id
				// we can always emit an error emitting code here
				return this.weakError({
					module,
					chunkGraph,
					request,
					type: "promise"
				***REMOVED***);
			***REMOVED***
			throw new Error(
				`RuntimeTemplate.moduleNamespacePromise(): ${noModuleIdErrorMessage(
					module,
					chunkGraph
				)***REMOVED***`
			);
		***REMOVED***
		const promise = this.blockPromise({
			chunkGraph,
			block,
			message,
			runtimeRequirements
		***REMOVED***);

		let appending;
		let idExpr = JSON.stringify(chunkGraph.getModuleId(module));
		const comment = this.comment({
			request
		***REMOVED***);
		let header = "";
		if (weak) {
			if (idExpr.length > 8) {
				// 'var x="nnnnnn";x,"+x+",x' vs '"nnnnnn",nnnnnn,"nnnnnn"'
				header += `var id = ${idExpr***REMOVED***; `;
				idExpr = "id";
			***REMOVED***
			runtimeRequirements.add(RuntimeGlobals.moduleFactories);
			header += `if(!${
				RuntimeGlobals.moduleFactories
			***REMOVED***[${idExpr***REMOVED***]) { ${this.weakError({
				module,
				chunkGraph,
				request,
				idExpr,
				type: "statements"
			***REMOVED***)***REMOVED*** ***REMOVED*** `;
		***REMOVED***
		const moduleIdExpr = this.moduleId({
			module,
			chunkGraph,
			request,
			weak
		***REMOVED***);
		const exportsType = module.getExportsType(chunkGraph.moduleGraph, strict);
		let fakeType = 16;
		switch (exportsType) {
			case "namespace":
				if (header) {
					const rawModule = this.moduleRaw({
						module,
						chunkGraph,
						request,
						weak,
						runtimeRequirements
					***REMOVED***);
					appending = `.then(${this.basicFunction(
						"",
						`${header***REMOVED***return ${rawModule***REMOVED***;`
					)***REMOVED***)`;
				***REMOVED*** else {
					runtimeRequirements.add(RuntimeGlobals.require);
					appending = `.then(${RuntimeGlobals.require***REMOVED***.bind(${RuntimeGlobals.require***REMOVED***, ${comment***REMOVED***${idExpr***REMOVED***))`;
				***REMOVED***
				break;
			case "dynamic":
				fakeType |= 4;
			/* fall through */
			case "default-with-named":
				fakeType |= 2;
			/* fall through */
			case "default-only":
				runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);
				if (chunkGraph.moduleGraph.isAsync(module)) {
					if (header) {
						const rawModule = this.moduleRaw({
							module,
							chunkGraph,
							request,
							weak,
							runtimeRequirements
						***REMOVED***);
						appending = `.then(${this.basicFunction(
							"",
							`${header***REMOVED***return ${rawModule***REMOVED***;`
						)***REMOVED***)`;
					***REMOVED*** else {
						runtimeRequirements.add(RuntimeGlobals.require);
						appending = `.then(${RuntimeGlobals.require***REMOVED***.bind(${RuntimeGlobals.require***REMOVED***, ${comment***REMOVED***${idExpr***REMOVED***))`;
					***REMOVED***
					appending += `.then(${this.returningFunction(
						`${RuntimeGlobals.createFakeNamespaceObject***REMOVED***(m, ${fakeType***REMOVED***)`,
						"m"
					)***REMOVED***)`;
				***REMOVED*** else {
					fakeType |= 1;
					if (header) {
						const returnExpression = `${RuntimeGlobals.createFakeNamespaceObject***REMOVED***(${moduleIdExpr***REMOVED***, ${fakeType***REMOVED***)`;
						appending = `.then(${this.basicFunction(
							"",
							`${header***REMOVED***return ${returnExpression***REMOVED***;`
						)***REMOVED***)`;
					***REMOVED*** else {
						appending = `.then(${RuntimeGlobals.createFakeNamespaceObject***REMOVED***.bind(${RuntimeGlobals.require***REMOVED***, ${comment***REMOVED***${idExpr***REMOVED***, ${fakeType***REMOVED***))`;
					***REMOVED***
				***REMOVED***
				break;
		***REMOVED***

		return `${promise || "Promise.resolve()"***REMOVED***${appending***REMOVED***`;
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options options object
	 * @param {ChunkGraph***REMOVED*** options.chunkGraph the chunk graph
	 * @param {RuntimeSpec=***REMOVED*** options.runtime runtime for which this code will be generated
	 * @param {RuntimeSpec | boolean=***REMOVED*** options.runtimeCondition only execute the statement in some runtimes
	 * @param {RuntimeRequirements***REMOVED*** options.runtimeRequirements if set, will be filled with runtime requirements
	 * @returns {string***REMOVED*** expression
	 */
	runtimeConditionExpression({
		chunkGraph,
		runtimeCondition,
		runtime,
		runtimeRequirements
	***REMOVED***) {
		if (runtimeCondition === undefined) return "true";
		if (typeof runtimeCondition === "boolean") return `${runtimeCondition***REMOVED***`;
		/** @type {Set<string>***REMOVED*** */
		const positiveRuntimeIds = new Set();
		forEachRuntime(runtimeCondition, runtime =>
			positiveRuntimeIds.add(
				`${chunkGraph.getRuntimeId(/** @type {string***REMOVED*** */ (runtime))***REMOVED***`
			)
		);
		/** @type {Set<string>***REMOVED*** */
		const negativeRuntimeIds = new Set();
		forEachRuntime(subtractRuntime(runtime, runtimeCondition), runtime =>
			negativeRuntimeIds.add(
				`${chunkGraph.getRuntimeId(/** @type {string***REMOVED*** */ (runtime))***REMOVED***`
			)
		);
		runtimeRequirements.add(RuntimeGlobals.runtimeId);
		return compileBooleanMatcher.fromLists(
			Array.from(positiveRuntimeIds),
			Array.from(negativeRuntimeIds)
		)(RuntimeGlobals.runtimeId);
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options options object
	 * @param {boolean=***REMOVED*** options.update whether a new variable should be created or the existing one updated
	 * @param {Module***REMOVED*** options.module the module
	 * @param {ChunkGraph***REMOVED*** options.chunkGraph the chunk graph
	 * @param {string***REMOVED*** options.request the request that should be printed as comment
	 * @param {string***REMOVED*** options.importVar name of the import variable
	 * @param {Module***REMOVED*** options.originModule module in which the statement is emitted
	 * @param {boolean=***REMOVED*** options.weak true, if this is a weak dependency
	 * @param {RuntimeRequirements***REMOVED*** options.runtimeRequirements if set, will be filled with runtime requirements
	 * @returns {[string, string]***REMOVED*** the import statement and the compat statement
	 */
	importStatement({
		update,
		module,
		chunkGraph,
		request,
		importVar,
		originModule,
		weak,
		runtimeRequirements
	***REMOVED***) {
		if (!module) {
			return [
				this.missingModuleStatement({
					request
				***REMOVED***),
				""
			];
		***REMOVED***
		if (chunkGraph.getModuleId(module) === null) {
			if (weak) {
				// only weak referenced modules don't get an id
				// we can always emit an error emitting code here
				return [
					this.weakError({
						module,
						chunkGraph,
						request,
						type: "statements"
					***REMOVED***),
					""
				];
			***REMOVED***
			throw new Error(
				`RuntimeTemplate.importStatement(): ${noModuleIdErrorMessage(
					module,
					chunkGraph
				)***REMOVED***`
			);
		***REMOVED***
		const moduleId = this.moduleId({
			module,
			chunkGraph,
			request,
			weak
		***REMOVED***);
		const optDeclaration = update ? "" : "var ";

		const exportsType = module.getExportsType(
			chunkGraph.moduleGraph,
			/** @type {BuildMeta***REMOVED*** */
			(originModule.buildMeta).strictHarmonyModule
		);
		runtimeRequirements.add(RuntimeGlobals.require);
		const importContent = `/* harmony import */ ${optDeclaration***REMOVED***${importVar***REMOVED*** = ${RuntimeGlobals.require***REMOVED***(${moduleId***REMOVED***);\n`;

		if (exportsType === "dynamic") {
			runtimeRequirements.add(RuntimeGlobals.compatGetDefaultExport);
			return [
				importContent,
				`/* harmony import */ ${optDeclaration***REMOVED***${importVar***REMOVED***_default = /*#__PURE__*/${RuntimeGlobals.compatGetDefaultExport***REMOVED***(${importVar***REMOVED***);\n`
			];
		***REMOVED***
		return [importContent, ""];
	***REMOVED***

	/**
	 * @template GenerateContext
	 * @param {object***REMOVED*** options options
	 * @param {ModuleGraph***REMOVED*** options.moduleGraph the module graph
	 * @param {Module***REMOVED*** options.module the module
	 * @param {string***REMOVED*** options.request the request
	 * @param {string | string[]***REMOVED*** options.exportName the export name
	 * @param {Module***REMOVED*** options.originModule the origin module
	 * @param {boolean|undefined***REMOVED*** options.asiSafe true, if location is safe for ASI, a bracket can be emitted
	 * @param {boolean***REMOVED*** options.isCall true, if expression will be called
	 * @param {boolean | null***REMOVED*** options.callContext when false, call context will not be preserved
	 * @param {boolean***REMOVED*** options.defaultInterop when true and accessing the default exports, interop code will be generated
	 * @param {string***REMOVED*** options.importVar the identifier name of the import variable
	 * @param {InitFragment<GenerateContext>[]***REMOVED*** options.initFragments init fragments will be added here
	 * @param {RuntimeSpec***REMOVED*** options.runtime runtime for which this code will be generated
	 * @param {RuntimeRequirements***REMOVED*** options.runtimeRequirements if set, will be filled with runtime requirements
	 * @returns {string***REMOVED*** expression
	 */
	exportFromImport({
		moduleGraph,
		module,
		request,
		exportName,
		originModule,
		asiSafe,
		isCall,
		callContext,
		defaultInterop,
		importVar,
		initFragments,
		runtime,
		runtimeRequirements
	***REMOVED***) {
		if (!module) {
			return this.missingModule({
				request
			***REMOVED***);
		***REMOVED***
		if (!Array.isArray(exportName)) {
			exportName = exportName ? [exportName] : [];
		***REMOVED***
		const exportsType = module.getExportsType(
			moduleGraph,
			/** @type {BuildMeta***REMOVED*** */
			(originModule.buildMeta).strictHarmonyModule
		);

		if (defaultInterop) {
			if (exportName.length > 0 && exportName[0] === "default") {
				switch (exportsType) {
					case "dynamic":
						if (isCall) {
							return `${importVar***REMOVED***_default()${propertyAccess(exportName, 1)***REMOVED***`;
						***REMOVED***
						return asiSafe
							? `(${importVar***REMOVED***_default()${propertyAccess(exportName, 1)***REMOVED***)`
							: asiSafe === false
								? `;(${importVar***REMOVED***_default()${propertyAccess(exportName, 1)***REMOVED***)`
								: `${importVar***REMOVED***_default.a${propertyAccess(exportName, 1)***REMOVED***`;

					case "default-only":
					case "default-with-named":
						exportName = exportName.slice(1);
						break;
				***REMOVED***
			***REMOVED*** else if (exportName.length > 0) {
				if (exportsType === "default-only") {
					return `/* non-default import from non-esm module */undefined${propertyAccess(
						exportName,
						1
					)***REMOVED***`;
				***REMOVED*** else if (
					exportsType !== "namespace" &&
					exportName[0] === "__esModule"
				) {
					return "/* __esModule */true";
				***REMOVED***
			***REMOVED*** else if (
				exportsType === "default-only" ||
				exportsType === "default-with-named"
			) {
				runtimeRequirements.add(RuntimeGlobals.createFakeNamespaceObject);
				initFragments.push(
					new InitFragment(
						`var ${importVar***REMOVED***_namespace_cache;\n`,
						InitFragment.STAGE_CONSTANTS,
						-1,
						`${importVar***REMOVED***_namespace_cache`
					)
				);
				return `/*#__PURE__*/ ${
					asiSafe ? "" : asiSafe === false ? ";" : "Object"
				***REMOVED***(${importVar***REMOVED***_namespace_cache || (${importVar***REMOVED***_namespace_cache = ${
					RuntimeGlobals.createFakeNamespaceObject
				***REMOVED***(${importVar***REMOVED***${exportsType === "default-only" ? "" : ", 2"***REMOVED***)))`;
			***REMOVED***
		***REMOVED***

		if (exportName.length > 0) {
			const exportsInfo = moduleGraph.getExportsInfo(module);
			const used = exportsInfo.getUsedName(exportName, runtime);
			if (!used) {
				const comment = Template.toNormalComment(
					`unused export ${propertyAccess(exportName)***REMOVED***`
				);
				return `${comment***REMOVED*** undefined`;
			***REMOVED***
			const comment = equals(used, exportName)
				? ""
				: `${Template.toNormalComment(propertyAccess(exportName))***REMOVED*** `;
			const access = `${importVar***REMOVED***${comment***REMOVED***${propertyAccess(used)***REMOVED***`;
			if (isCall && callContext === false) {
				return asiSafe
					? `(0,${access***REMOVED***)`
					: asiSafe === false
						? `;(0,${access***REMOVED***)`
						: `/*#__PURE__*/Object(${access***REMOVED***)`;
			***REMOVED***
			return access;
		***REMOVED***
		return importVar;
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options options
	 * @param {AsyncDependenciesBlock | undefined***REMOVED*** options.block the async block
	 * @param {string***REMOVED*** options.message the message
	 * @param {ChunkGraph***REMOVED*** options.chunkGraph the chunk graph
	 * @param {RuntimeRequirements***REMOVED*** options.runtimeRequirements if set, will be filled with runtime requirements
	 * @returns {string***REMOVED*** expression
	 */
	blockPromise({ block, message, chunkGraph, runtimeRequirements ***REMOVED***) {
		if (!block) {
			const comment = this.comment({
				message
			***REMOVED***);
			return `Promise.resolve(${comment.trim()***REMOVED***)`;
		***REMOVED***
		const chunkGroup = chunkGraph.getBlockChunkGroup(block);
		if (!chunkGroup || chunkGroup.chunks.length === 0) {
			const comment = this.comment({
				message
			***REMOVED***);
			return `Promise.resolve(${comment.trim()***REMOVED***)`;
		***REMOVED***
		const chunks = chunkGroup.chunks.filter(
			chunk => !chunk.hasRuntime() && chunk.id !== null
		);
		const comment = this.comment({
			message,
			chunkName: block.chunkName
		***REMOVED***);
		if (chunks.length === 1) {
			const chunkId = JSON.stringify(chunks[0].id);
			runtimeRequirements.add(RuntimeGlobals.ensureChunk);

			const fetchPriority = chunkGroup.options.fetchPriority;

			if (fetchPriority) {
				runtimeRequirements.add(RuntimeGlobals.hasFetchPriority);
			***REMOVED***

			return `${RuntimeGlobals.ensureChunk***REMOVED***(${comment***REMOVED***${chunkId***REMOVED***${
				fetchPriority ? `, ${JSON.stringify(fetchPriority)***REMOVED***` : ""
			***REMOVED***)`;
		***REMOVED*** else if (chunks.length > 0) {
			runtimeRequirements.add(RuntimeGlobals.ensureChunk);

			const fetchPriority = chunkGroup.options.fetchPriority;

			if (fetchPriority) {
				runtimeRequirements.add(RuntimeGlobals.hasFetchPriority);
			***REMOVED***

			/**
			 * @param {Chunk***REMOVED*** chunk chunk
			 * @returns {string***REMOVED*** require chunk id code
			 */
			const requireChunkId = chunk =>
				`${RuntimeGlobals.ensureChunk***REMOVED***(${JSON.stringify(chunk.id)***REMOVED***${
					fetchPriority ? `, ${JSON.stringify(fetchPriority)***REMOVED***` : ""
				***REMOVED***)`;
			return `Promise.all(${comment.trim()***REMOVED***[${chunks
				.map(requireChunkId)
				.join(", ")***REMOVED***])`;
		***REMOVED***
		return `Promise.resolve(${comment.trim()***REMOVED***)`;
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options options
	 * @param {AsyncDependenciesBlock***REMOVED*** options.block the async block
	 * @param {ChunkGraph***REMOVED*** options.chunkGraph the chunk graph
	 * @param {RuntimeRequirements***REMOVED*** options.runtimeRequirements if set, will be filled with runtime requirements
	 * @param {string=***REMOVED*** options.request request string used originally
	 * @returns {string***REMOVED*** expression
	 */
	asyncModuleFactory({ block, chunkGraph, runtimeRequirements, request ***REMOVED***) {
		const dep = block.dependencies[0];
		const module = chunkGraph.moduleGraph.getModule(dep);
		const ensureChunk = this.blockPromise({
			block,
			message: "",
			chunkGraph,
			runtimeRequirements
		***REMOVED***);
		const factory = this.returningFunction(
			this.moduleRaw({
				module,
				chunkGraph,
				request,
				runtimeRequirements
			***REMOVED***)
		);
		return this.returningFunction(
			ensureChunk.startsWith("Promise.resolve(")
				? `${factory***REMOVED***`
				: `${ensureChunk***REMOVED***.then(${this.returningFunction(factory)***REMOVED***)`
		);
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options options
	 * @param {Dependency***REMOVED*** options.dependency the dependency
	 * @param {ChunkGraph***REMOVED*** options.chunkGraph the chunk graph
	 * @param {RuntimeRequirements***REMOVED*** options.runtimeRequirements if set, will be filled with runtime requirements
	 * @param {string=***REMOVED*** options.request request string used originally
	 * @returns {string***REMOVED*** expression
	 */
	syncModuleFactory({ dependency, chunkGraph, runtimeRequirements, request ***REMOVED***) {
		const module = chunkGraph.moduleGraph.getModule(dependency);
		const factory = this.returningFunction(
			this.moduleRaw({
				module,
				chunkGraph,
				request,
				runtimeRequirements
			***REMOVED***)
		);
		return this.returningFunction(factory);
	***REMOVED***

	/**
	 * @param {object***REMOVED*** options options
	 * @param {string***REMOVED*** options.exportsArgument the name of the exports object
	 * @param {RuntimeRequirements***REMOVED*** options.runtimeRequirements if set, will be filled with runtime requirements
	 * @returns {string***REMOVED*** statement
	 */
	defineEsModuleFlagStatement({ exportsArgument, runtimeRequirements ***REMOVED***) {
		runtimeRequirements.add(RuntimeGlobals.makeNamespaceObject);
		runtimeRequirements.add(RuntimeGlobals.exports);
		return `${RuntimeGlobals.makeNamespaceObject***REMOVED***(${exportsArgument***REMOVED***);\n`;
	***REMOVED***
***REMOVED***

module.exports = RuntimeTemplate;
