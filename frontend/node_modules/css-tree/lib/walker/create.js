var hasOwnProperty = Object.prototype.hasOwnProperty;
var noop = function() {***REMOVED***;

function ensureFunction(value) {
    return typeof value === 'function' ? value : noop;
***REMOVED***

function invokeForType(fn, type) {
    return function(node, item, list) {
        if (node.type === type) {
            fn.call(this, node, item, list);
        ***REMOVED***
    ***REMOVED***;
***REMOVED***

function getWalkersFromStructure(name, nodeType) {
    var structure = nodeType.structure;
    var walkers = [];

    for (var key in structure) {
        if (hasOwnProperty.call(structure, key) === false) {
            continue;
        ***REMOVED***

        var fieldTypes = structure[key];
        var walker = {
            name: key,
            type: false,
            nullable: false
        ***REMOVED***;

        if (!Array.isArray(structure[key])) {
            fieldTypes = [structure[key]];
        ***REMOVED***

        for (var i = 0; i < fieldTypes.length; i++) {
            var fieldType = fieldTypes[i];
            if (fieldType === null) {
                walker.nullable = true;
            ***REMOVED*** else if (typeof fieldType === 'string') {
                walker.type = 'node';
            ***REMOVED*** else if (Array.isArray(fieldType)) {
                walker.type = 'list';
            ***REMOVED***
        ***REMOVED***

        if (walker.type) {
            walkers.push(walker);
        ***REMOVED***
    ***REMOVED***

    if (walkers.length) {
        return {
            context: nodeType.walkContext,
            fields: walkers
        ***REMOVED***;
    ***REMOVED***

    return null;
***REMOVED***

function getTypesFromConfig(config) {
    var types = {***REMOVED***;

    for (var name in config.node) {
        if (hasOwnProperty.call(config.node, name)) {
            var nodeType = config.node[name];

            if (!nodeType.structure) {
                throw new Error('Missed `structure` field in `' + name + '` node type definition');
            ***REMOVED***

            types[name] = getWalkersFromStructure(name, nodeType);
        ***REMOVED***
    ***REMOVED***

    return types;
***REMOVED***

function createTypeIterator(config, reverse) {
    var fields = config.fields.slice();
    var contextName = config.context;
    var useContext = typeof contextName === 'string';

    if (reverse) {
        fields.reverse();
    ***REMOVED***

    return function(node, context, walk) {
        var prevContextValue;

        if (useContext) {
            prevContextValue = context[contextName];
            context[contextName] = node;
        ***REMOVED***

        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            var ref = node[field.name];

            if (!field.nullable || ref) {
                if (field.type === 'list') {
                    if (reverse) {
                        ref.forEachRight(walk);
                    ***REMOVED*** else {
                        ref.forEach(walk);
                    ***REMOVED***
                ***REMOVED*** else {
                    walk(ref);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        if (useContext) {
            context[contextName] = prevContextValue;
        ***REMOVED***
    ***REMOVED***;
***REMOVED***

function createFastTraveralMap(iterators) {
    return {
        Atrule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        ***REMOVED***,
        Rule: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        ***REMOVED***,
        Declaration: {
            StyleSheet: iterators.StyleSheet,
            Atrule: iterators.Atrule,
            Rule: iterators.Rule,
            Block: iterators.Block
        ***REMOVED***
    ***REMOVED***;
***REMOVED***

module.exports = function createWalker(config) {
    var types = getTypesFromConfig(config);
    var iteratorsNatural = {***REMOVED***;
    var iteratorsReverse = {***REMOVED***;

    for (var name in types) {
        if (hasOwnProperty.call(types, name) && types[name] !== null) {
            iteratorsNatural[name] = createTypeIterator(types[name], false);
            iteratorsReverse[name] = createTypeIterator(types[name], true);
        ***REMOVED***
    ***REMOVED***

    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

    var walk = function(root, options) {
        function walkNode(node, item, list) {
            enter.call(context, node, item, list);

            if (iterators.hasOwnProperty(node.type)) {
                iterators[node.type](node, context, walkNode);
            ***REMOVED***

            leave.call(context, node, item, list);
        ***REMOVED***

        var enter = noop;
        var leave = noop;
        var iterators = iteratorsNatural;
        var context = {
            root: root,
            stylesheet: null,
            atrule: null,
            atrulePrelude: null,
            rule: null,
            selector: null,
            block: null,
            declaration: null,
            function: null
        ***REMOVED***;

        if (typeof options === 'function') {
            enter = options;
        ***REMOVED*** else if (options) {
            enter = ensureFunction(options.enter);
            leave = ensureFunction(options.leave);

            if (options.reverse) {
                iterators = iteratorsReverse;
            ***REMOVED***

            if (options.visit) {
                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
                    iterators = options.reverse
                        ? fastTraversalIteratorsReverse[options.visit]
                        : fastTraversalIteratorsNatural[options.visit];
                ***REMOVED*** else if (!types.hasOwnProperty(options.visit)) {
                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
                ***REMOVED***

                enter = invokeForType(enter, options.visit);
                leave = invokeForType(leave, options.visit);
            ***REMOVED***
        ***REMOVED***

        if (enter === noop && leave === noop) {
            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
        ***REMOVED***

        // swap handlers in reverse mode to invert visit order
        if (options.reverse) {
            var tmp = enter;
            enter = leave;
            leave = tmp;
        ***REMOVED***

        walkNode(root);
    ***REMOVED***;

    walk.find = function(ast, fn) {
        var found = null;

        walk(ast, function(node, item, list) {
            if (found === null && fn.call(this, node, item, list)) {
                found = node;
            ***REMOVED***
        ***REMOVED***);

        return found;
    ***REMOVED***;

    walk.findLast = function(ast, fn) {
        var found = null;

        walk(ast, {
            reverse: true,
            enter: function(node, item, list) {
                if (found === null && fn.call(this, node, item, list)) {
                    found = node;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***);

        return found;
    ***REMOVED***;

    walk.findAll = function(ast, fn) {
        var found = [];

        walk(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
                found.push(node);
            ***REMOVED***
        ***REMOVED***);

        return found;
    ***REMOVED***;

    return walk;
***REMOVED***;
