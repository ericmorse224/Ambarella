"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.find = find;
exports.findParent = findParent;
exports.getAncestry = getAncestry;
exports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
exports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
exports.getFunctionParent = getFunctionParent;
exports.getStatementParent = getStatementParent;
exports.inType = inType;
exports.isAncestor = isAncestor;
exports.isDescendant = isDescendant;
var _t = require("@babel/types");
const {
  VISITOR_KEYS
***REMOVED*** = _t;
function findParent(callback) {
  let path = this;
  while (path = path.parentPath) {
    if (callback(path)) return path;
  ***REMOVED***
  return null;
***REMOVED***
function find(callback) {
  let path = this;
  do {
    if (callback(path)) return path;
  ***REMOVED*** while (path = path.parentPath);
  return null;
***REMOVED***
function getFunctionParent() {
  return this.findParent(p => p.isFunction());
***REMOVED***
function getStatementParent() {
  let path = this;
  do {
    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {
      break;
    ***REMOVED*** else {
      path = path.parentPath;
    ***REMOVED***
  ***REMOVED*** while (path);
  if (path && (path.isProgram() || path.isFile())) {
    throw new Error("File/Program node, we can't possibly find a statement parent to this");
  ***REMOVED***
  return path;
***REMOVED***
function getEarliestCommonAncestorFrom(paths) {
  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {
    let earliest;
    const keys = VISITOR_KEYS[deepest.type];
    for (const ancestry of ancestries) {
      const path = ancestry[i + 1];
      if (!earliest) {
        earliest = path;
        continue;
      ***REMOVED***
      if (path.listKey && earliest.listKey === path.listKey) {
        if (path.key < earliest.key) {
          earliest = path;
          continue;
        ***REMOVED***
      ***REMOVED***
      const earliestKeyIndex = keys.indexOf(earliest.parentKey);
      const currentKeyIndex = keys.indexOf(path.parentKey);
      if (earliestKeyIndex > currentKeyIndex) {
        earliest = path;
      ***REMOVED***
    ***REMOVED***
    return earliest;
  ***REMOVED***);
***REMOVED***
function getDeepestCommonAncestorFrom(paths, filter) {
  if (!paths.length) {
    return this;
  ***REMOVED***
  if (paths.length === 1) {
    return paths[0];
  ***REMOVED***
  let minDepth = Infinity;
  let lastCommonIndex, lastCommon;
  const ancestries = paths.map(path => {
    const ancestry = [];
    do {
      ancestry.unshift(path);
    ***REMOVED*** while ((path = path.parentPath) && path !== this);
    if (ancestry.length < minDepth) {
      minDepth = ancestry.length;
    ***REMOVED***
    return ancestry;
  ***REMOVED***);
  const first = ancestries[0];
  depthLoop: for (let i = 0; i < minDepth; i++) {
    const shouldMatch = first[i];
    for (const ancestry of ancestries) {
      if (ancestry[i] !== shouldMatch) {
        break depthLoop;
      ***REMOVED***
    ***REMOVED***
    lastCommonIndex = i;
    lastCommon = shouldMatch;
  ***REMOVED***
  if (lastCommon) {
    if (filter) {
      return filter(lastCommon, lastCommonIndex, ancestries);
    ***REMOVED*** else {
      return lastCommon;
    ***REMOVED***
  ***REMOVED*** else {
    throw new Error("Couldn't find intersection");
  ***REMOVED***
***REMOVED***
function getAncestry() {
  let path = this;
  const paths = [];
  do {
    paths.push(path);
  ***REMOVED*** while (path = path.parentPath);
  return paths;
***REMOVED***
function isAncestor(maybeDescendant) {
  return maybeDescendant.isDescendant(this);
***REMOVED***
function isDescendant(maybeAncestor) {
  return !!this.findParent(parent => parent === maybeAncestor);
***REMOVED***
function inType(...candidateTypes) {
  let path = this;
  while (path) {
    if (candidateTypes.includes(path.node.type)) return true;
    path = path.parentPath;
  ***REMOVED***
  return false;
***REMOVED***

//# sourceMappingURL=ancestry.js.map
