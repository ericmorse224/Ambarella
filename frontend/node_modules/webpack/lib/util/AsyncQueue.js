/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { SyncHook, AsyncSeriesHook ***REMOVED*** = require("tapable");
const { makeWebpackError ***REMOVED*** = require("../HookWebpackError");
const WebpackError = require("../WebpackError");
const ArrayQueue = require("./ArrayQueue");

const QUEUED_STATE = 0;
const PROCESSING_STATE = 1;
const DONE_STATE = 2;

let inHandleResult = 0;

/**
 * @template T
 * @callback Callback
 * @param {(WebpackError | null)=***REMOVED*** err
 * @param {(T | null)=***REMOVED*** result
 */

/**
 * @template T
 * @template K
 * @template R
 */
class AsyncQueueEntry {
	/**
	 * @param {T***REMOVED*** item the item
	 * @param {Callback<R>***REMOVED*** callback the callback
	 */
	constructor(item, callback) {
		this.item = item;
		/** @type {typeof QUEUED_STATE | typeof PROCESSING_STATE | typeof DONE_STATE***REMOVED*** */
		this.state = QUEUED_STATE;
		/** @type {Callback<R> | undefined***REMOVED*** */
		this.callback = callback;
		/** @type {Callback<R>[] | undefined***REMOVED*** */
		this.callbacks = undefined;
		/** @type {R | null | undefined***REMOVED*** */
		this.result = undefined;
		/** @type {WebpackError | null | undefined***REMOVED*** */
		this.error = undefined;
	***REMOVED***
***REMOVED***

/**
 * @template T, K
 * @typedef {(item: T) => K***REMOVED*** getKey
 */

/**
 * @template T, R
 * @typedef {(item: T, callback: Callback<R>) => void***REMOVED*** Processor
 */

/**
 * @template T
 * @template K
 * @template R
 */
class AsyncQueue {
	/**
	 * @param {object***REMOVED*** options options object
	 * @param {string=***REMOVED*** options.name name of the queue
	 * @param {number=***REMOVED*** options.parallelism how many items should be processed at once
	 * @param {string=***REMOVED*** options.context context of execution
	 * @param {AsyncQueue<EXPECTED_ANY, EXPECTED_ANY, EXPECTED_ANY>=***REMOVED*** options.parent parent queue, which will have priority over this queue and with shared parallelism
	 * @param {getKey<T, K>=***REMOVED*** options.getKey extract key from item
	 * @param {Processor<T, R>***REMOVED*** options.processor async function to process items
	 */
	constructor({ name, context, parallelism, parent, processor, getKey ***REMOVED***) {
		this._name = name;
		this._context = context || "normal";
		this._parallelism = parallelism || 1;
		this._processor = processor;
		this._getKey =
			getKey ||
			/** @type {getKey<T, K>***REMOVED*** */ (item => /** @type {T & K***REMOVED*** */ (item));
		/** @type {Map<K, AsyncQueueEntry<T, K, R>>***REMOVED*** */
		this._entries = new Map();
		/** @type {ArrayQueue<AsyncQueueEntry<T, K, R>>***REMOVED*** */
		this._queued = new ArrayQueue();
		/** @type {AsyncQueue<T, K, R>[] | undefined***REMOVED*** */
		this._children = undefined;
		this._activeTasks = 0;
		this._willEnsureProcessing = false;
		this._needProcessing = false;
		this._stopped = false;
		/** @type {AsyncQueue<T, K, R>***REMOVED*** */
		this._root = parent ? parent._root : this;
		if (parent) {
			if (this._root._children === undefined) {
				this._root._children = [this];
			***REMOVED*** else {
				this._root._children.push(this);
			***REMOVED***
		***REMOVED***

		this.hooks = {
			/** @type {AsyncSeriesHook<[T]>***REMOVED*** */
			beforeAdd: new AsyncSeriesHook(["item"]),
			/** @type {SyncHook<[T]>***REMOVED*** */
			added: new SyncHook(["item"]),
			/** @type {AsyncSeriesHook<[T]>***REMOVED*** */
			beforeStart: new AsyncSeriesHook(["item"]),
			/** @type {SyncHook<[T]>***REMOVED*** */
			started: new SyncHook(["item"]),
			/** @type {SyncHook<[T, WebpackError | null | undefined, R | null | undefined]>***REMOVED*** */
			result: new SyncHook(["item", "error", "result"])
		***REMOVED***;

		this._ensureProcessing = this._ensureProcessing.bind(this);
	***REMOVED***

	/**
	 * @returns {string***REMOVED*** context of execution
	 */
	getContext() {
		return this._context;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** value context of execution
	 */
	setContext(value) {
		this._context = value;
	***REMOVED***

	/**
	 * @param {T***REMOVED*** item an item
	 * @param {Callback<R>***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	add(item, callback) {
		if (this._stopped) return callback(new WebpackError("Queue was stopped"));
		this.hooks.beforeAdd.callAsync(item, err => {
			if (err) {
				callback(
					makeWebpackError(err, `AsyncQueue(${this._name***REMOVED***).hooks.beforeAdd`)
				);
				return;
			***REMOVED***
			const key = this._getKey(item);
			const entry = this._entries.get(key);
			if (entry !== undefined) {
				if (entry.state === DONE_STATE) {
					if (inHandleResult++ > 3) {
						process.nextTick(() => callback(entry.error, entry.result));
					***REMOVED*** else {
						callback(entry.error, entry.result);
					***REMOVED***
					inHandleResult--;
				***REMOVED*** else if (entry.callbacks === undefined) {
					entry.callbacks = [callback];
				***REMOVED*** else {
					entry.callbacks.push(callback);
				***REMOVED***
				return;
			***REMOVED***
			const newEntry = new AsyncQueueEntry(item, callback);
			if (this._stopped) {
				this.hooks.added.call(item);
				this._root._activeTasks++;
				process.nextTick(() =>
					this._handleResult(newEntry, new WebpackError("Queue was stopped"))
				);
			***REMOVED*** else {
				this._entries.set(key, newEntry);
				this._queued.enqueue(newEntry);
				const root = this._root;
				root._needProcessing = true;
				if (root._willEnsureProcessing === false) {
					root._willEnsureProcessing = true;
					setImmediate(root._ensureProcessing);
				***REMOVED***
				this.hooks.added.call(item);
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {T***REMOVED*** item an item
	 * @returns {void***REMOVED***
	 */
	invalidate(item) {
		const key = this._getKey(item);
		const entry =
			/** @type {AsyncQueueEntry<T, K, R>***REMOVED*** */
			(this._entries.get(key));
		this._entries.delete(key);
		if (entry.state === QUEUED_STATE) {
			this._queued.delete(entry);
		***REMOVED***
	***REMOVED***

	/**
	 * Waits for an already started item
	 * @param {T***REMOVED*** item an item
	 * @param {Callback<R>***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	waitFor(item, callback) {
		const key = this._getKey(item);
		const entry = this._entries.get(key);
		if (entry === undefined) {
			return callback(
				new WebpackError(
					"waitFor can only be called for an already started item"
				)
			);
		***REMOVED***
		if (entry.state === DONE_STATE) {
			process.nextTick(() => callback(entry.error, entry.result));
		***REMOVED*** else if (entry.callbacks === undefined) {
			entry.callbacks = [callback];
		***REMOVED*** else {
			entry.callbacks.push(callback);
		***REMOVED***
	***REMOVED***

	/**
	 * @returns {void***REMOVED***
	 */
	stop() {
		this._stopped = true;
		const queue = this._queued;
		this._queued = new ArrayQueue();
		const root = this._root;
		for (const entry of queue) {
			this._entries.delete(
				this._getKey(/** @type {AsyncQueueEntry<T, K, R>***REMOVED*** */ (entry).item)
			);
			root._activeTasks++;
			this._handleResult(
				/** @type {AsyncQueueEntry<T, K, R>***REMOVED*** */ (entry),
				new WebpackError("Queue was stopped")
			);
		***REMOVED***
	***REMOVED***

	/**
	 * @returns {void***REMOVED***
	 */
	increaseParallelism() {
		const root = this._root;
		root._parallelism++;
		/* istanbul ignore next */
		if (root._willEnsureProcessing === false && root._needProcessing) {
			root._willEnsureProcessing = true;
			setImmediate(root._ensureProcessing);
		***REMOVED***
	***REMOVED***

	/**
	 * @returns {void***REMOVED***
	 */
	decreaseParallelism() {
		const root = this._root;
		root._parallelism--;
	***REMOVED***

	/**
	 * @param {T***REMOVED*** item an item
	 * @returns {boolean***REMOVED*** true, if the item is currently being processed
	 */
	isProcessing(item) {
		const key = this._getKey(item);
		const entry = this._entries.get(key);
		return entry !== undefined && entry.state === PROCESSING_STATE;
	***REMOVED***

	/**
	 * @param {T***REMOVED*** item an item
	 * @returns {boolean***REMOVED*** true, if the item is currently queued
	 */
	isQueued(item) {
		const key = this._getKey(item);
		const entry = this._entries.get(key);
		return entry !== undefined && entry.state === QUEUED_STATE;
	***REMOVED***

	/**
	 * @param {T***REMOVED*** item an item
	 * @returns {boolean***REMOVED*** true, if the item is currently queued
	 */
	isDone(item) {
		const key = this._getKey(item);
		const entry = this._entries.get(key);
		return entry !== undefined && entry.state === DONE_STATE;
	***REMOVED***

	/**
	 * @returns {void***REMOVED***
	 */
	_ensureProcessing() {
		while (this._activeTasks < this._parallelism) {
			const entry = this._queued.dequeue();
			if (entry === undefined) break;
			this._activeTasks++;
			entry.state = PROCESSING_STATE;
			this._startProcessing(entry);
		***REMOVED***
		this._willEnsureProcessing = false;
		if (this._queued.length > 0) return;
		if (this._children !== undefined) {
			for (const child of this._children) {
				while (this._activeTasks < this._parallelism) {
					const entry = child._queued.dequeue();
					if (entry === undefined) break;
					this._activeTasks++;
					entry.state = PROCESSING_STATE;
					child._startProcessing(entry);
				***REMOVED***
				if (child._queued.length > 0) return;
			***REMOVED***
		***REMOVED***
		if (!this._willEnsureProcessing) this._needProcessing = false;
	***REMOVED***

	/**
	 * @param {AsyncQueueEntry<T, K, R>***REMOVED*** entry the entry
	 * @returns {void***REMOVED***
	 */
	_startProcessing(entry) {
		this.hooks.beforeStart.callAsync(entry.item, err => {
			if (err) {
				this._handleResult(
					entry,
					makeWebpackError(err, `AsyncQueue(${this._name***REMOVED***).hooks.beforeStart`)
				);
				return;
			***REMOVED***
			let inCallback = false;
			try {
				this._processor(entry.item, (e, r) => {
					inCallback = true;
					this._handleResult(entry, e, r);
				***REMOVED***);
			***REMOVED*** catch (err) {
				if (inCallback) throw err;
				this._handleResult(entry, /** @type {WebpackError***REMOVED*** */ (err), null);
			***REMOVED***
			this.hooks.started.call(entry.item);
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {AsyncQueueEntry<T, K, R>***REMOVED*** entry the entry
	 * @param {(WebpackError | null)=***REMOVED*** err error, if any
	 * @param {(R | null)=***REMOVED*** result result, if any
	 * @returns {void***REMOVED***
	 */
	_handleResult(entry, err, result) {
		this.hooks.result.callAsync(entry.item, err, result, hookError => {
			const error = hookError
				? makeWebpackError(hookError, `AsyncQueue(${this._name***REMOVED***).hooks.result`)
				: err;

			const callback = /** @type {Callback<R>***REMOVED*** */ (entry.callback);
			const callbacks = entry.callbacks;
			entry.state = DONE_STATE;
			entry.callback = undefined;
			entry.callbacks = undefined;
			entry.result = result;
			entry.error = error;

			const root = this._root;
			root._activeTasks--;
			if (root._willEnsureProcessing === false && root._needProcessing) {
				root._willEnsureProcessing = true;
				setImmediate(root._ensureProcessing);
			***REMOVED***

			if (inHandleResult++ > 3) {
				process.nextTick(() => {
					callback(error, result);
					if (callbacks !== undefined) {
						for (const callback of callbacks) {
							callback(error, result);
						***REMOVED***
					***REMOVED***
				***REMOVED***);
			***REMOVED*** else {
				callback(error, result);
				if (callbacks !== undefined) {
					for (const callback of callbacks) {
						callback(error, result);
					***REMOVED***
				***REMOVED***
			***REMOVED***
			inHandleResult--;
		***REMOVED***);
	***REMOVED***

	clear() {
		this._entries.clear();
		this._queued.clear();
		this._activeTasks = 0;
		this._willEnsureProcessing = false;
		this._needProcessing = false;
		this._stopped = false;
	***REMOVED***
***REMOVED***

module.exports = AsyncQueue;
