"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.default = void 0;

var _experimentalUtils = require("@typescript-eslint/experimental-utils");

var _utils = require("./utils");

const isBooleanLiteral = node => node.type === _experimentalUtils.AST_NODE_TYPES.Literal && typeof node.value === 'boolean';

/**
 * Checks if the given `ParsedExpectMatcher` is a call to one of the equality matchers,
 * with a boolean literal as the sole argument.
 *
 * @example javascript
 * toBe(true);
 * toEqual(false);
 *
 * @param {ParsedExpectMatcher***REMOVED*** matcher
 *
 * @return {matcher is ParsedBooleanEqualityMatcher***REMOVED***
 */
const isBooleanEqualityMatcher = matcher => (0, _utils.isParsedEqualityMatcherCall)(matcher) && isBooleanLiteral((0, _utils.followTypeAssertionChain)(matcher.arguments[0]));

const isString = node => {
  return (0, _utils.isStringNode)(node) || node.type === _experimentalUtils.AST_NODE_TYPES.TemplateLiteral;
***REMOVED***;

const isComparingToString = expression => {
  return isString(expression.left) || isString(expression.right);
***REMOVED***;

const invertOperator = operator => {
  switch (operator) {
    case '>':
      return '<=';

    case '<':
      return '>=';

    case '>=':
      return '<';

    case '<=':
      return '>';
  ***REMOVED***

  return null;
***REMOVED***;

const determineMatcher = (operator, negated) => {
  const op = negated ? invertOperator(operator) : operator;

  switch (op) {
    case '>':
      return 'toBeGreaterThan';

    case '<':
      return 'toBeLessThan';

    case '>=':
      return 'toBeGreaterThanOrEqual';

    case '<=':
      return 'toBeLessThanOrEqual';
  ***REMOVED***

  return null;
***REMOVED***;

var _default = (0, _utils.createRule)({
  name: __filename,
  meta: {
    docs: {
      category: 'Best Practices',
      description: 'Suggest using the built-in comparison matchers',
      recommended: false
    ***REMOVED***,
    messages: {
      useToBeComparison: 'Prefer using `{{ preferredMatcher ***REMOVED******REMOVED***` instead'
    ***REMOVED***,
    fixable: 'code',
    type: 'suggestion',
    schema: []
  ***REMOVED***,
  defaultOptions: [],

  create(context) {
    return {
      CallExpression(node) {
        if (!(0, _utils.isExpectCall)(node)) {
          return;
        ***REMOVED***

        const {
          expect: {
            arguments: [comparison],
            range: [, expectCallEnd]
          ***REMOVED***,
          matcher,
          modifier
        ***REMOVED*** = (0, _utils.parseExpectCall)(node);

        if (!matcher || (comparison === null || comparison === void 0 ? void 0 : comparison.type) !== _experimentalUtils.AST_NODE_TYPES.BinaryExpression || isComparingToString(comparison) || !isBooleanEqualityMatcher(matcher)) {
          return;
        ***REMOVED***

        const preferredMatcher = determineMatcher(comparison.operator, (0, _utils.followTypeAssertionChain)(matcher.arguments[0]).value === !!modifier);

        if (!preferredMatcher) {
          return;
        ***REMOVED***

        context.report({
          fix(fixer) {
            const sourceCode = context.getSourceCode();
            return [// replace the comparison argument with the left-hand side of the comparison
            fixer.replaceText(comparison, sourceCode.getText(comparison.left)), // replace the current matcher & modifier with the preferred matcher
            fixer.replaceTextRange([expectCallEnd, matcher.node.range[1]], `.${preferredMatcher***REMOVED***`), // replace the matcher argument with the right-hand side of the comparison
            fixer.replaceText(matcher.arguments[0], sourceCode.getText(comparison.right))];
          ***REMOVED***,

          messageId: 'useToBeComparison',
          data: {
            preferredMatcher
          ***REMOVED***,
          node: (modifier || matcher).node.property
        ***REMOVED***);
      ***REMOVED***

    ***REMOVED***;
  ***REMOVED***

***REMOVED***);

exports.default = _default;