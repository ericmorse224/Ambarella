/**
 * @fileoverview Prevent usage of Array index in keys
 * @author Joe Lencioni
 */

'use strict';

const has = require('hasown');
const astUtil = require('../util/ast');
const docsUrl = require('../util/docsUrl');
const pragma = require('../util/pragma');
const report = require('../util/report');
const variableUtil = require('../util/variable');

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

function isCreateCloneElement(node, context) {
  if (!node) {
    return false;
  ***REMOVED***

  if (node.type === 'MemberExpression' || node.type === 'OptionalMemberExpression') {
    return node.object
      && node.object.name === pragma.getFromContext(context)
      && ['createElement', 'cloneElement'].indexOf(node.property.name) !== -1;
  ***REMOVED***

  if (node.type === 'Identifier') {
    const variable = variableUtil.findVariableByName(context, node, node.name);
    if (variable && variable.type === 'ImportSpecifier') {
      return variable.parent.source.value === 'react';
    ***REMOVED***
  ***REMOVED***

  return false;
***REMOVED***

const messages = {
  noArrayIndex: 'Do not use Array index in keys',
***REMOVED***;

/** @type {import('eslint').Rule.RuleModule***REMOVED*** */
module.exports = {
  meta: {
    docs: {
      description: 'Disallow usage of Array index in keys',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('no-array-index-key'),
    ***REMOVED***,

    messages,

    schema: [],
  ***REMOVED***,

  create(context) {
    // --------------------------------------------------------------------------
    // Public
    // --------------------------------------------------------------------------
    const indexParamNames = [];
    const iteratorFunctionsToIndexParamPosition = {
      every: 1,
      filter: 1,
      find: 1,
      findIndex: 1,
      flatMap: 1,
      forEach: 1,
      map: 1,
      reduce: 2,
      reduceRight: 2,
      some: 1,
    ***REMOVED***;

    function isArrayIndex(node) {
      return node.type === 'Identifier'
        && indexParamNames.indexOf(node.name) !== -1;
    ***REMOVED***

    function isUsingReactChildren(node) {
      const callee = node.callee;
      if (
        !callee
        || !callee.property
        || !callee.object
      ) {
        return null;
      ***REMOVED***

      const isReactChildMethod = ['map', 'forEach'].indexOf(callee.property.name) > -1;
      if (!isReactChildMethod) {
        return null;
      ***REMOVED***

      const obj = callee.object;
      if (obj && obj.name === 'Children') {
        return true;
      ***REMOVED***
      if (obj && obj.object && obj.object.name === pragma.getFromContext(context)) {
        return true;
      ***REMOVED***

      return false;
    ***REMOVED***

    function getMapIndexParamName(node) {
      const callee = node.callee;
      if (callee.type !== 'MemberExpression' && callee.type !== 'OptionalMemberExpression') {
        return null;
      ***REMOVED***
      if (callee.property.type !== 'Identifier') {
        return null;
      ***REMOVED***
      if (!has(iteratorFunctionsToIndexParamPosition, callee.property.name)) {
        return null;
      ***REMOVED***

      const name = /** @type {keyof iteratorFunctionsToIndexParamPosition***REMOVED*** */ (callee.property.name);

      const callbackArg = isUsingReactChildren(node)
        ? node.arguments[1]
        : node.arguments[0];

      if (!callbackArg) {
        return null;
      ***REMOVED***

      if (!astUtil.isFunctionLikeExpression(callbackArg)) {
        return null;
      ***REMOVED***

      const params = callbackArg.params;

      const indexParamPosition = iteratorFunctionsToIndexParamPosition[name];
      if (params.length < indexParamPosition + 1) {
        return null;
      ***REMOVED***

      return params[indexParamPosition].name;
    ***REMOVED***

    function getIdentifiersFromBinaryExpression(side) {
      if (side.type === 'Identifier') {
        return side;
      ***REMOVED***

      if (side.type === 'BinaryExpression') {
        // recurse
        const left = getIdentifiersFromBinaryExpression(side.left);
        const right = getIdentifiersFromBinaryExpression(side.right);
        return [].concat(left, right).filter(Boolean);
      ***REMOVED***

      return null;
    ***REMOVED***

    function checkPropValue(node) {
      if (isArrayIndex(node)) {
        // key={bar***REMOVED***
        report(context, messages.noArrayIndex, 'noArrayIndex', {
          node,
        ***REMOVED***);
        return;
      ***REMOVED***

      if (node.type === 'TemplateLiteral') {
        // key={`foo-${bar***REMOVED***`***REMOVED***
        node.expressions.filter(isArrayIndex).forEach(() => {
          report(context, messages.noArrayIndex, 'noArrayIndex', {
            node,
          ***REMOVED***);
        ***REMOVED***);

        return;
      ***REMOVED***

      if (node.type === 'BinaryExpression') {
        // key={'foo' + bar***REMOVED***
        const identifiers = getIdentifiersFromBinaryExpression(node);

        identifiers.filter(isArrayIndex).forEach(() => {
          report(context, messages.noArrayIndex, 'noArrayIndex', {
            node,
          ***REMOVED***);
        ***REMOVED***);

        return;
      ***REMOVED***

      if (
        astUtil.isCallExpression(node)
        && node.callee
        && node.callee.type === 'MemberExpression'
        && node.callee.object
        && isArrayIndex(node.callee.object)
        && node.callee.property
        && node.callee.property.type === 'Identifier'
        && node.callee.property.name === 'toString'
      ) {
        // key={bar.toString()***REMOVED***
        report(context, messages.noArrayIndex, 'noArrayIndex', {
          node,
        ***REMOVED***);
        return;
      ***REMOVED***

      if (
        astUtil.isCallExpression(node)
        && node.callee
        && node.callee.type === 'Identifier'
        && node.callee.name === 'String'
        && Array.isArray(node.arguments)
        && node.arguments.length > 0
        && isArrayIndex(node.arguments[0])
      ) {
        // key={String(bar)***REMOVED***
        report(context, messages.noArrayIndex, 'noArrayIndex', {
          node: node.arguments[0],
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    function popIndex(node) {
      const mapIndexParamName = getMapIndexParamName(node);
      if (!mapIndexParamName) {
        return;
      ***REMOVED***

      indexParamNames.pop();
    ***REMOVED***

    return {
      'CallExpression, OptionalCallExpression'(node) {
        if (isCreateCloneElement(node.callee, context) && node.arguments.length > 1) {
          // React.createElement
          if (!indexParamNames.length) {
            return;
          ***REMOVED***

          const props = node.arguments[1];

          if (props.type !== 'ObjectExpression') {
            return;
          ***REMOVED***

          props.properties.forEach((prop) => {
            if (!prop.key || prop.key.name !== 'key') {
              // { ...foo ***REMOVED***
              // { foo: bar ***REMOVED***
              return;
            ***REMOVED***

            checkPropValue(prop.value);
          ***REMOVED***);

          return;
        ***REMOVED***

        const mapIndexParamName = getMapIndexParamName(node);
        if (!mapIndexParamName) {
          return;
        ***REMOVED***

        indexParamNames.push(mapIndexParamName);
      ***REMOVED***,

      JSXAttribute(node) {
        if (node.name.name !== 'key') {
          // foo={bar***REMOVED***
          return;
        ***REMOVED***

        if (!indexParamNames.length) {
          // Not inside a call expression that we think has an index param.
          return;
        ***REMOVED***

        const value = node.value;
        if (!value || value.type !== 'JSXExpressionContainer') {
          // key='foo' or just simply 'key'
          return;
        ***REMOVED***

        checkPropValue(value.expression);
      ***REMOVED***,

      'CallExpression:exit': popIndex,
      'OptionalCallExpression:exit': popIndex,
    ***REMOVED***;
  ***REMOVED***,
***REMOVED***;
