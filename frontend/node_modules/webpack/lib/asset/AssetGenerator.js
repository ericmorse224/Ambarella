/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Sergey Melyukov @smelukov
*/

"use strict";

const mimeTypes = require("mime-types");
const path = require("path");
const { RawSource ***REMOVED*** = require("webpack-sources");
const ConcatenationScope = require("../ConcatenationScope");
const Generator = require("../Generator");
const {
	NO_TYPES,
	ASSET_TYPES,
	ASSET_AND_JS_TYPES,
	ASSET_AND_JS_AND_CSS_URL_TYPES,
	ASSET_AND_CSS_URL_TYPES,
	JS_TYPES,
	JS_AND_CSS_URL_TYPES,
	CSS_URL_TYPES
***REMOVED*** = require("../ModuleSourceTypesConstants");
const { ASSET_MODULE_TYPE ***REMOVED*** = require("../ModuleTypeConstants");
const RuntimeGlobals = require("../RuntimeGlobals");
const CssUrlDependency = require("../dependencies/CssUrlDependency");
const createHash = require("../util/createHash");
const { makePathsRelative ***REMOVED*** = require("../util/identifier");
const nonNumericOnlyHash = require("../util/nonNumericOnlyHash");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../../declarations/WebpackOptions").AssetGeneratorDataUrlOptions***REMOVED*** AssetGeneratorDataUrlOptions */
/** @typedef {import("../../declarations/WebpackOptions").AssetGeneratorOptions***REMOVED*** AssetGeneratorOptions */
/** @typedef {import("../../declarations/WebpackOptions").AssetModuleFilename***REMOVED*** AssetModuleFilename */
/** @typedef {import("../../declarations/WebpackOptions").AssetModuleOutputPath***REMOVED*** AssetModuleOutputPath */
/** @typedef {import("../../declarations/WebpackOptions").AssetResourceGeneratorOptions***REMOVED*** AssetResourceGeneratorOptions */
/** @typedef {import("../../declarations/WebpackOptions").HashFunction***REMOVED*** HashFunction */
/** @typedef {import("../../declarations/WebpackOptions").RawPublicPath***REMOVED*** RawPublicPath */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("../Compilation").AssetInfo***REMOVED*** AssetInfo */
/** @typedef {import("../Compilation").InterpolatedPathAndAssetInfo***REMOVED*** InterpolatedPathAndAssetInfo */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../Generator").GenerateContext***REMOVED*** GenerateContext */
/** @typedef {import("../Generator").UpdateHashContext***REMOVED*** UpdateHashContext */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../Module").BuildInfo***REMOVED*** BuildInfo */
/** @typedef {import("../Module").BuildMeta***REMOVED*** BuildMeta */
/** @typedef {import("../Module").ConcatenationBailoutReasonContext***REMOVED*** ConcatenationBailoutReasonContext */
/** @typedef {import("../Module").SourceTypes***REMOVED*** SourceTypes */
/** @typedef {import("../ModuleGraph")***REMOVED*** ModuleGraph */
/** @typedef {import("../NormalModule")***REMOVED*** NormalModule */
/** @typedef {import("../RuntimeTemplate")***REMOVED*** RuntimeTemplate */
/** @typedef {import("../TemplatedPathPlugin").TemplatePath***REMOVED*** TemplatePath */
/** @typedef {import("../util/Hash")***REMOVED*** Hash */
/** @typedef {import("../util/runtime").RuntimeSpec***REMOVED*** RuntimeSpec */

/**
 * @template T
 * @template U
 * @param {string | Array<T> | Set<T> | undefined***REMOVED*** a a
 * @param {string | Array<U> | Set<U> | undefined***REMOVED*** b b
 * @returns {Array<T> & Array<U>***REMOVED*** array
 */
const mergeMaybeArrays = (a, b) => {
	const set = new Set();
	if (Array.isArray(a)) for (const item of a) set.add(item);
	else set.add(a);
	if (Array.isArray(b)) for (const item of b) set.add(item);
	else set.add(b);
	return Array.from(set);
***REMOVED***;

/**
 * @param {AssetInfo***REMOVED*** a a
 * @param {AssetInfo***REMOVED*** b b
 * @returns {AssetInfo***REMOVED*** object
 */
const mergeAssetInfo = (a, b) => {
	/** @type {AssetInfo***REMOVED*** */
	const result = { ...a, ...b ***REMOVED***;
	for (const key of Object.keys(a)) {
		if (key in b) {
			if (a[key] === b[key]) continue;
			switch (key) {
				case "fullhash":
				case "chunkhash":
				case "modulehash":
				case "contenthash":
					result[key] = mergeMaybeArrays(a[key], b[key]);
					break;
				case "immutable":
				case "development":
				case "hotModuleReplacement":
				case "javascriptModule":
					result[key] = a[key] || b[key];
					break;
				case "related":
					result[key] = mergeRelatedInfo(
						/** @type {NonNullable<AssetInfo["related"]>***REMOVED*** */
						(a[key]),
						/** @type {NonNullable<AssetInfo["related"]>***REMOVED*** */
						(b[key])
					);
					break;
				default:
					throw new Error(`Can't handle conflicting asset info for ${key***REMOVED***`);
			***REMOVED***
		***REMOVED***
	***REMOVED***
	return result;
***REMOVED***;

/**
 * @param {NonNullable<AssetInfo["related"]>***REMOVED*** a a
 * @param {NonNullable<AssetInfo["related"]>***REMOVED*** b b
 * @returns {NonNullable<AssetInfo["related"]>***REMOVED*** object
 */
const mergeRelatedInfo = (a, b) => {
	const result = { ...a, ...b ***REMOVED***;
	for (const key of Object.keys(a)) {
		if (key in b) {
			if (a[key] === b[key]) continue;
			result[key] = mergeMaybeArrays(a[key], b[key]);
		***REMOVED***
	***REMOVED***
	return result;
***REMOVED***;

/**
 * @param {"base64" | false***REMOVED*** encoding encoding
 * @param {Source***REMOVED*** source source
 * @returns {string***REMOVED*** encoded data
 */
const encodeDataUri = (encoding, source) => {
	/** @type {string | undefined***REMOVED*** */
	let encodedContent;

	switch (encoding) {
		case "base64": {
			encodedContent = source.buffer().toString("base64");
			break;
		***REMOVED***
		case false: {
			const content = source.source();

			if (typeof content !== "string") {
				encodedContent = content.toString("utf-8");
			***REMOVED***

			encodedContent = encodeURIComponent(
				/** @type {string***REMOVED*** */
				(encodedContent)
			).replace(
				/[!'()*]/g,
				character =>
					`%${/** @type {number***REMOVED*** */ (character.codePointAt(0)).toString(16)***REMOVED***`
			);
			break;
		***REMOVED***
		default:
			throw new Error(`Unsupported encoding '${encoding***REMOVED***'`);
	***REMOVED***

	return encodedContent;
***REMOVED***;

/**
 * @param {string***REMOVED*** encoding encoding
 * @param {string***REMOVED*** content content
 * @returns {Buffer***REMOVED*** decoded content
 */
const decodeDataUriContent = (encoding, content) => {
	const isBase64 = encoding === "base64";

	if (isBase64) {
		return Buffer.from(content, "base64");
	***REMOVED***

	// If we can't decode return the original body
	try {
		return Buffer.from(decodeURIComponent(content), "ascii");
	***REMOVED*** catch (_) {
		return Buffer.from(content, "ascii");
	***REMOVED***
***REMOVED***;

const DEFAULT_ENCODING = "base64";

class AssetGenerator extends Generator {
	/**
	 * @param {ModuleGraph***REMOVED*** moduleGraph the module graph
	 * @param {AssetGeneratorOptions["dataUrl"]=***REMOVED*** dataUrlOptions the options for the data url
	 * @param {AssetModuleFilename=***REMOVED*** filename override for output.assetModuleFilename
	 * @param {RawPublicPath=***REMOVED*** publicPath override for output.assetModulePublicPath
	 * @param {AssetModuleOutputPath=***REMOVED*** outputPath the output path for the emitted file which is not included in the runtime import
	 * @param {boolean=***REMOVED*** emit generate output asset
	 */
	constructor(
		moduleGraph,
		dataUrlOptions,
		filename,
		publicPath,
		outputPath,
		emit
	) {
		super();
		this.dataUrlOptions = dataUrlOptions;
		this.filename = filename;
		this.publicPath = publicPath;
		this.outputPath = outputPath;
		this.emit = emit;
		this._moduleGraph = moduleGraph;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module module
	 * @param {RuntimeTemplate***REMOVED*** runtimeTemplate runtime template
	 * @returns {string***REMOVED*** source file name
	 */
	static getSourceFileName(module, runtimeTemplate) {
		return makePathsRelative(
			runtimeTemplate.compilation.compiler.context,
			module.matchResource || module.resource,
			runtimeTemplate.compilation.compiler.root
		).replace(/^\.\//, "");
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module module
	 * @param {RuntimeTemplate***REMOVED*** runtimeTemplate runtime template
	 * @returns {[string, string]***REMOVED*** return full hash and non-numeric full hash
	 */
	static getFullContentHash(module, runtimeTemplate) {
		const hash = createHash(
			/** @type {HashFunction***REMOVED*** */
			(runtimeTemplate.outputOptions.hashFunction)
		);

		if (runtimeTemplate.outputOptions.hashSalt) {
			hash.update(runtimeTemplate.outputOptions.hashSalt);
		***REMOVED***

		const source = module.originalSource();

		if (source) {
			hash.update(source.buffer());
		***REMOVED***

		if (module.error) {
			hash.update(module.error.toString());
		***REMOVED***

		const fullContentHash = /** @type {string***REMOVED*** */ (
			hash.digest(runtimeTemplate.outputOptions.hashDigest)
		);

		/** @type {string***REMOVED*** */
		const contentHash = nonNumericOnlyHash(
			fullContentHash,
			/** @type {number***REMOVED*** */
			(runtimeTemplate.outputOptions.hashDigestLength)
		);

		return [fullContentHash, contentHash];
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module module for which the code should be generated
	 * @param {Pick<AssetResourceGeneratorOptions, "filename" | "outputPath">***REMOVED*** generatorOptions generator options
	 * @param {{ runtime: RuntimeSpec, runtimeTemplate: RuntimeTemplate, chunkGraph: ChunkGraph ***REMOVED******REMOVED*** generateContext context for generate
	 * @param {string***REMOVED*** contentHash the content hash
	 * @returns {{ filename: string, originalFilename: string, assetInfo: AssetInfo ***REMOVED******REMOVED*** info
	 */
	static getFilenameWithInfo(
		module,
		generatorOptions,
		{ runtime, runtimeTemplate, chunkGraph ***REMOVED***,
		contentHash
	) {
		const assetModuleFilename =
			generatorOptions.filename ||
			/** @type {AssetModuleFilename***REMOVED*** */
			(runtimeTemplate.outputOptions.assetModuleFilename);

		const sourceFilename = AssetGenerator.getSourceFileName(
			module,
			runtimeTemplate
		);
		let { path: filename, info: assetInfo ***REMOVED*** =
			runtimeTemplate.compilation.getAssetPathWithInfo(assetModuleFilename, {
				module,
				runtime,
				filename: sourceFilename,
				chunkGraph,
				contentHash
			***REMOVED***);

		const originalFilename = filename;

		if (generatorOptions.outputPath) {
			const { path: outputPath, info ***REMOVED*** =
				runtimeTemplate.compilation.getAssetPathWithInfo(
					generatorOptions.outputPath,
					{
						module,
						runtime,
						filename: sourceFilename,
						chunkGraph,
						contentHash
					***REMOVED***
				);
			filename = path.posix.join(outputPath, filename);
			assetInfo = mergeAssetInfo(assetInfo, info);
		***REMOVED***

		return { originalFilename, filename, assetInfo ***REMOVED***;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module module for which the code should be generated
	 * @param {Pick<AssetResourceGeneratorOptions, "publicPath">***REMOVED*** generatorOptions generator options
	 * @param {GenerateContext***REMOVED*** generateContext context for generate
	 * @param {string***REMOVED*** filename the filename
	 * @param {AssetInfo***REMOVED*** assetInfo the asset info
	 * @param {string***REMOVED*** contentHash the content hash
	 * @returns {{ assetPath: string, assetInfo: AssetInfo ***REMOVED******REMOVED*** asset path and info
	 */
	static getAssetPathWithInfo(
		module,
		generatorOptions,
		{ runtime, runtimeTemplate, type, chunkGraph, runtimeRequirements ***REMOVED***,
		filename,
		assetInfo,
		contentHash
	) {
		const sourceFilename = AssetGenerator.getSourceFileName(
			module,
			runtimeTemplate
		);

		let assetPath;

		if (generatorOptions.publicPath !== undefined && type === "javascript") {
			const { path, info ***REMOVED*** = runtimeTemplate.compilation.getAssetPathWithInfo(
				generatorOptions.publicPath,
				{
					module,
					runtime,
					filename: sourceFilename,
					chunkGraph,
					contentHash
				***REMOVED***
			);
			assetInfo = mergeAssetInfo(assetInfo, info);
			assetPath = JSON.stringify(path + filename);
		***REMOVED*** else if (
			generatorOptions.publicPath !== undefined &&
			type === "css-url"
		) {
			const { path, info ***REMOVED*** = runtimeTemplate.compilation.getAssetPathWithInfo(
				generatorOptions.publicPath,
				{
					module,
					runtime,
					filename: sourceFilename,
					chunkGraph,
					contentHash
				***REMOVED***
			);
			assetInfo = mergeAssetInfo(assetInfo, info);
			assetPath = path + filename;
		***REMOVED*** else if (type === "javascript") {
			// add __webpack_require__.p
			runtimeRequirements.add(RuntimeGlobals.publicPath);
			assetPath = runtimeTemplate.concatenation(
				{ expr: RuntimeGlobals.publicPath ***REMOVED***,
				filename
			);
		***REMOVED*** else if (type === "css-url") {
			const compilation = runtimeTemplate.compilation;
			const path =
				compilation.outputOptions.publicPath === "auto"
					? CssUrlDependency.PUBLIC_PATH_AUTO
					: compilation.getAssetPath(
							/** @type {TemplatePath***REMOVED*** */
							(compilation.outputOptions.publicPath),
							{
								hash: compilation.hash
							***REMOVED***
						);

			assetPath = path + filename;
		***REMOVED***

		return {
			// eslint-disable-next-line object-shorthand
			assetPath: /** @type {string***REMOVED*** */ (assetPath),
			assetInfo: { sourceFilename, ...assetInfo ***REMOVED***
		***REMOVED***;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module module for which the bailout reason should be determined
	 * @param {ConcatenationBailoutReasonContext***REMOVED*** context context
	 * @returns {string | undefined***REMOVED*** reason why this module can't be concatenated, undefined when it can be concatenated
	 */
	getConcatenationBailoutReason(module, context) {
		return undefined;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module module
	 * @returns {string***REMOVED*** mime type
	 */
	getMimeType(module) {
		if (typeof this.dataUrlOptions === "function") {
			throw new Error(
				"This method must not be called when dataUrlOptions is a function"
			);
		***REMOVED***

		/** @type {string | boolean | undefined***REMOVED*** */
		let mimeType =
			/** @type {AssetGeneratorDataUrlOptions***REMOVED*** */
			(this.dataUrlOptions).mimetype;
		if (mimeType === undefined) {
			const ext = path.extname(
				/** @type {string***REMOVED*** */
				(module.nameForCondition())
			);
			if (
				module.resourceResolveData &&
				module.resourceResolveData.mimetype !== undefined
			) {
				mimeType =
					module.resourceResolveData.mimetype +
					module.resourceResolveData.parameters;
			***REMOVED*** else if (ext) {
				mimeType = mimeTypes.lookup(ext);

				if (typeof mimeType !== "string") {
					throw new Error(
						"DataUrl can't be generated automatically, " +
							`because there is no mimetype for "${ext***REMOVED***" in mimetype database. ` +
							'Either pass a mimetype via "generator.mimetype" or ' +
							'use type: "asset/resource" to create a resource file instead of a DataUrl'
					);
				***REMOVED***
			***REMOVED***
		***REMOVED***

		if (typeof mimeType !== "string") {
			throw new Error(
				"DataUrl can't be generated automatically. " +
					'Either pass a mimetype via "generator.mimetype" or ' +
					'use type: "asset/resource" to create a resource file instead of a DataUrl'
			);
		***REMOVED***

		return /** @type {string***REMOVED*** */ (mimeType);
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module module for which the code should be generated
	 * @returns {string***REMOVED*** DataURI
	 */
	generateDataUri(module) {
		const source = /** @type {Source***REMOVED*** */ (module.originalSource());

		let encodedSource;

		if (typeof this.dataUrlOptions === "function") {
			encodedSource = this.dataUrlOptions.call(null, source.source(), {
				filename: module.matchResource || module.resource,
				module
			***REMOVED***);
		***REMOVED*** else {
			/** @type {"base64" | false | undefined***REMOVED*** */
			let encoding =
				/** @type {AssetGeneratorDataUrlOptions***REMOVED*** */
				(this.dataUrlOptions).encoding;
			if (
				encoding === undefined &&
				module.resourceResolveData &&
				module.resourceResolveData.encoding !== undefined
			) {
				encoding = module.resourceResolveData.encoding;
			***REMOVED***
			if (encoding === undefined) {
				encoding = DEFAULT_ENCODING;
			***REMOVED***
			const mimeType = this.getMimeType(module);

			let encodedContent;

			if (
				module.resourceResolveData &&
				module.resourceResolveData.encoding === encoding &&
				decodeDataUriContent(
					module.resourceResolveData.encoding,
					module.resourceResolveData.encodedContent
				).equals(source.buffer())
			) {
				encodedContent = module.resourceResolveData.encodedContent;
			***REMOVED*** else {
				encodedContent = encodeDataUri(encoding, source);
			***REMOVED***

			encodedSource = `data:${mimeType***REMOVED***${
				encoding ? `;${encoding***REMOVED***` : ""
			***REMOVED***,${encodedContent***REMOVED***`;
		***REMOVED***

		return encodedSource;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module module for which the code should be generated
	 * @param {GenerateContext***REMOVED*** generateContext context for generate
	 * @returns {Source | null***REMOVED*** generated code
	 */
	generate(module, generateContext) {
		const {
			type,
			getData,
			runtimeTemplate,
			runtimeRequirements,
			concatenationScope
		***REMOVED*** = generateContext;

		let content;

		const needContent = type === "javascript" || type === "css-url";

		const data = getData ? getData() : undefined;

		if (
			/** @type {BuildInfo***REMOVED*** */
			(module.buildInfo).dataUrl &&
			needContent
		) {
			const encodedSource = this.generateDataUri(module);
			content =
				type === "javascript" ? JSON.stringify(encodedSource) : encodedSource;

			if (data) {
				data.set("url", { [type]: content, ...data.get("url") ***REMOVED***);
			***REMOVED***
		***REMOVED*** else {
			const [fullContentHash, contentHash] = AssetGenerator.getFullContentHash(
				module,
				runtimeTemplate
			);

			if (data) {
				data.set("fullContentHash", fullContentHash);
				data.set("contentHash", contentHash);
			***REMOVED***

			/** @type {BuildInfo***REMOVED*** */
			(module.buildInfo).fullContentHash = fullContentHash;

			const { originalFilename, filename, assetInfo ***REMOVED*** =
				AssetGenerator.getFilenameWithInfo(
					module,
					{ filename: this.filename, outputPath: this.outputPath ***REMOVED***,
					generateContext,
					contentHash
				);

			if (data) {
				data.set("filename", filename);
			***REMOVED***

			let { assetPath, assetInfo: newAssetInfo ***REMOVED*** =
				AssetGenerator.getAssetPathWithInfo(
					module,
					{ publicPath: this.publicPath ***REMOVED***,
					generateContext,
					originalFilename,
					assetInfo,
					contentHash
				);

			if (data && (type === "javascript" || type === "css-url")) {
				data.set("url", { [type]: assetPath, ...data.get("url") ***REMOVED***);
			***REMOVED***

			if (data && data.get("assetInfo")) {
				newAssetInfo = mergeAssetInfo(data.get("assetInfo"), newAssetInfo);
			***REMOVED***

			if (data) {
				data.set("assetInfo", newAssetInfo);
			***REMOVED***

			// Due to code generation caching module.buildInfo.XXX can't used to store such information
			// It need to be stored in the code generation results instead, where it's cached too
			// TODO webpack 6 For back-compat reasons we also store in on module.buildInfo
			/** @type {BuildInfo***REMOVED*** */
			(module.buildInfo).filename = filename;

			/** @type {BuildInfo***REMOVED*** */
			(module.buildInfo).assetInfo = newAssetInfo;

			content = assetPath;
		***REMOVED***

		if (type === "javascript") {
			if (concatenationScope) {
				concatenationScope.registerNamespaceExport(
					ConcatenationScope.NAMESPACE_OBJECT_EXPORT
				);

				return new RawSource(
					`${runtimeTemplate.supportsConst() ? "const" : "var"***REMOVED*** ${
						ConcatenationScope.NAMESPACE_OBJECT_EXPORT
					***REMOVED*** = ${content***REMOVED***;`
				);
			***REMOVED***

			runtimeRequirements.add(RuntimeGlobals.module);

			return new RawSource(`${RuntimeGlobals.module***REMOVED***.exports = ${content***REMOVED***;`);
		***REMOVED*** else if (type === "css-url") {
			return null;
		***REMOVED***

		return /** @type {Source***REMOVED*** */ (module.originalSource());
	***REMOVED***

	/**
	 * @param {Error***REMOVED*** error the error
	 * @param {NormalModule***REMOVED*** module module for which the code should be generated
	 * @param {GenerateContext***REMOVED*** generateContext context for generate
	 * @returns {Source | null***REMOVED*** generated code
	 */
	generateError(error, module, generateContext) {
		switch (generateContext.type) {
			case "asset": {
				return new RawSource(error.message);
			***REMOVED***
			case "javascript": {
				return new RawSource(
					`throw new Error(${JSON.stringify(error.message)***REMOVED***);`
				);
			***REMOVED***
			default:
				return null;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module fresh module
	 * @returns {SourceTypes***REMOVED*** available types (do not mutate)
	 */
	getTypes(module) {
		const sourceTypes = new Set();
		const connections = this._moduleGraph.getIncomingConnections(module);

		for (const connection of connections) {
			if (!connection.originModule) {
				continue;
			***REMOVED***

			sourceTypes.add(connection.originModule.type.split("/")[0]);
		***REMOVED***

		if ((module.buildInfo && module.buildInfo.dataUrl) || this.emit === false) {
			if (sourceTypes) {
				if (sourceTypes.has("javascript") && sourceTypes.has("css")) {
					return JS_AND_CSS_URL_TYPES;
				***REMOVED*** else if (sourceTypes.has("javascript")) {
					return JS_TYPES;
				***REMOVED*** else if (sourceTypes.has("css")) {
					return CSS_URL_TYPES;
				***REMOVED***
			***REMOVED***

			return NO_TYPES;
		***REMOVED***

		if (sourceTypes) {
			if (sourceTypes.has("javascript") && sourceTypes.has("css")) {
				return ASSET_AND_JS_AND_CSS_URL_TYPES;
			***REMOVED*** else if (sourceTypes.has("javascript")) {
				return ASSET_AND_JS_TYPES;
			***REMOVED*** else if (sourceTypes.has("css")) {
				return ASSET_AND_CSS_URL_TYPES;
			***REMOVED***
		***REMOVED***

		return ASSET_TYPES;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module the module
	 * @param {string=***REMOVED*** type source type
	 * @returns {number***REMOVED*** estimate size of the module
	 */
	getSize(module, type) {
		switch (type) {
			case ASSET_MODULE_TYPE: {
				const originalSource = module.originalSource();

				if (!originalSource) {
					return 0;
				***REMOVED***

				return originalSource.size();
			***REMOVED***
			default:
				if (module.buildInfo && module.buildInfo.dataUrl) {
					const originalSource = module.originalSource();

					if (!originalSource) {
						return 0;
					***REMOVED***

					// roughly for data url
					// Example: m.exports="data:image/png;base64,ag82/f+2=="
					// 4/3 = base64 encoding
					// 34 = ~ data url header + footer + rounding
					return originalSource.size() * 1.34 + 36;
				***REMOVED***
				// it's only estimated so this number is probably fine
				// Example: m.exports=r.p+"0123456789012345678901.ext"
				return 42;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Hash***REMOVED*** hash hash that will be modified
	 * @param {UpdateHashContext***REMOVED*** updateHashContext context for updating hash
	 */
	updateHash(hash, updateHashContext) {
		const { module ***REMOVED*** = updateHashContext;

		if (
			/** @type {BuildInfo***REMOVED*** */
			(module.buildInfo).dataUrl
		) {
			hash.update("data-url");
			// this.dataUrlOptions as function should be pure and only depend on input source and filename
			// therefore it doesn't need to be hashed
			if (typeof this.dataUrlOptions === "function") {
				const ident = /** @type {{ ident?: string ***REMOVED******REMOVED*** */ (this.dataUrlOptions)
					.ident;
				if (ident) hash.update(ident);
			***REMOVED*** else {
				const dataUrlOptions =
					/** @type {AssetGeneratorDataUrlOptions***REMOVED*** */
					(this.dataUrlOptions);
				if (
					dataUrlOptions.encoding &&
					dataUrlOptions.encoding !== DEFAULT_ENCODING
				) {
					hash.update(dataUrlOptions.encoding);
				***REMOVED***
				if (dataUrlOptions.mimetype) hash.update(dataUrlOptions.mimetype);
				// computed mimetype depends only on module filename which is already part of the hash
			***REMOVED***
		***REMOVED*** else {
			hash.update("resource");

			const { module, chunkGraph, runtime ***REMOVED*** = updateHashContext;
			const runtimeTemplate =
				/** @type {NonNullable<UpdateHashContext["runtimeTemplate"]>***REMOVED*** */
				(updateHashContext.runtimeTemplate);

			const pathData = {
				module,
				runtime,
				filename: AssetGenerator.getSourceFileName(module, runtimeTemplate),
				chunkGraph,
				contentHash: runtimeTemplate.contentHashReplacement
			***REMOVED***;

			if (typeof this.publicPath === "function") {
				hash.update("path");
				const assetInfo = {***REMOVED***;
				hash.update(this.publicPath(pathData, assetInfo));
				hash.update(JSON.stringify(assetInfo));
			***REMOVED*** else if (this.publicPath) {
				hash.update("path");
				hash.update(this.publicPath);
			***REMOVED*** else {
				hash.update("no-path");
			***REMOVED***

			const assetModuleFilename =
				this.filename ||
				/** @type {AssetModuleFilename***REMOVED*** */
				(runtimeTemplate.outputOptions.assetModuleFilename);
			const { path: filename, info ***REMOVED*** =
				runtimeTemplate.compilation.getAssetPathWithInfo(
					assetModuleFilename,
					pathData
				);
			hash.update(filename);
			hash.update(JSON.stringify(info));
		***REMOVED***
	***REMOVED***
***REMOVED***

module.exports = AssetGenerator;
