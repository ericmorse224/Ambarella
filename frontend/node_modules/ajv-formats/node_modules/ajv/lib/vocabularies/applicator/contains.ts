import type {
  CodeKeywordDefinition,
  KeywordErrorDefinition,
  ErrorObject,
  AnySchema,
***REMOVED*** from "../../types"
import type {KeywordCxt***REMOVED*** from "../../compile/validate"
import {_, str, Name***REMOVED*** from "../../compile/codegen"
import {alwaysValidSchema, checkStrictMode, Type***REMOVED*** from "../../compile/util"

export type ContainsError = ErrorObject<
  "contains",
  {minContains: number; maxContains?: number***REMOVED***,
  AnySchema
>

const error: KeywordErrorDefinition = {
  message: ({params: {min, max***REMOVED******REMOVED***) =>
    max === undefined
      ? str`must contain at least ${min***REMOVED*** valid item(s)`
      : str`must contain at least ${min***REMOVED*** and no more than ${max***REMOVED*** valid item(s)`,
  params: ({params: {min, max***REMOVED******REMOVED***) =>
    max === undefined ? _`{minContains: ${min***REMOVED******REMOVED***` : _`{minContains: ${min***REMOVED***, maxContains: ${max***REMOVED******REMOVED***`,
***REMOVED***

const def: CodeKeywordDefinition = {
  keyword: "contains",
  type: "array",
  schemaType: ["object", "boolean"],
  before: "uniqueItems",
  trackErrors: true,
  error,
  code(cxt: KeywordCxt) {
    const {gen, schema, parentSchema, data, it***REMOVED*** = cxt
    let min: number
    let max: number | undefined
    const {minContains, maxContains***REMOVED*** = parentSchema
    if (it.opts.next) {
      min = minContains === undefined ? 1 : minContains
      max = maxContains
    ***REMOVED*** else {
      min = 1
    ***REMOVED***
    const len = gen.const("len", _`${data***REMOVED***.length`)
    cxt.setParams({min, max***REMOVED***)
    if (max === undefined && min === 0) {
      checkStrictMode(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`)
      return
    ***REMOVED***
    if (max !== undefined && min > max) {
      checkStrictMode(it, `"minContains" > "maxContains" is always invalid`)
      cxt.fail()
      return
    ***REMOVED***
    if (alwaysValidSchema(it, schema)) {
      let cond = _`${len***REMOVED*** >= ${min***REMOVED***`
      if (max !== undefined) cond = _`${cond***REMOVED*** && ${len***REMOVED*** <= ${max***REMOVED***`
      cxt.pass(cond)
      return
    ***REMOVED***

    it.items = true
    const valid = gen.name("valid")
    if (max === undefined && min === 1) {
      validateItems(valid, () => gen.if(valid, () => gen.break()))
    ***REMOVED*** else if (min === 0) {
      gen.let(valid, true)
      if (max !== undefined) gen.if(_`${data***REMOVED***.length > 0`, validateItemsWithCount)
    ***REMOVED*** else {
      gen.let(valid, false)
      validateItemsWithCount()
    ***REMOVED***
    cxt.result(valid, () => cxt.reset())

    function validateItemsWithCount(): void {
      const schValid = gen.name("_valid")
      const count = gen.let("count", 0)
      validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)))
    ***REMOVED***

    function validateItems(_valid: Name, block: () => void): void {
      gen.forRange("i", 0, len, (i) => {
        cxt.subschema(
          {
            keyword: "contains",
            dataProp: i,
            dataPropType: Type.Num,
            compositeRule: true,
          ***REMOVED***,
          _valid
        )
        block()
      ***REMOVED***)
    ***REMOVED***

    function checkLimits(count: Name): void {
      gen.code(_`${count***REMOVED***++`)
      if (max === undefined) {
        gen.if(_`${count***REMOVED*** >= ${min***REMOVED***`, () => gen.assign(valid, true).break())
      ***REMOVED*** else {
        gen.if(_`${count***REMOVED*** > ${max***REMOVED***`, () => gen.assign(valid, false).break())
        if (min === 1) gen.assign(valid, true)
        else gen.if(_`${count***REMOVED*** >= ${min***REMOVED***`, () => gen.assign(valid, true))
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***,
***REMOVED***

export default def
