'use strict';

const { tokenChars ***REMOVED*** = require('./validation');

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object***REMOVED*** dest The map of extension offers or parameters
 * @param {String***REMOVED*** name The extension or parameter name
 * @param {(Object|Boolean|String)***REMOVED*** elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
***REMOVED***

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String***REMOVED*** header The field value of the header
 * @return {Object***REMOVED*** The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      ***REMOVED*** else if (
        i !== 0 &&
        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      ***REMOVED*** else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i***REMOVED***`);
        ***REMOVED***

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        ***REMOVED*** else {
          extensionName = name;
        ***REMOVED***

        start = end = -1;
      ***REMOVED*** else {
        throw new SyntaxError(`Unexpected character at index ${i***REMOVED***`);
      ***REMOVED***
    ***REMOVED*** else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      ***REMOVED*** else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      ***REMOVED*** else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i***REMOVED***`);
        ***REMOVED***

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        ***REMOVED***

        start = end = -1;
      ***REMOVED*** else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      ***REMOVED*** else {
        throw new SyntaxError(`Unexpected character at index ${i***REMOVED***`);
      ***REMOVED***
    ***REMOVED*** else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i***REMOVED***`);
        ***REMOVED***
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      ***REMOVED*** else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        ***REMOVED*** else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        ***REMOVED*** else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        ***REMOVED*** else {
          throw new SyntaxError(`Unexpected character at index ${i***REMOVED***`);
        ***REMOVED***
      ***REMOVED*** else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      ***REMOVED*** else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      ***REMOVED*** else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      ***REMOVED*** else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i***REMOVED***`);
        ***REMOVED***

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        ***REMOVED***
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        ***REMOVED***

        paramName = undefined;
        start = end = -1;
      ***REMOVED*** else {
        throw new SyntaxError(`Unexpected character at index ${i***REMOVED***`);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  ***REMOVED***

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  ***REMOVED*** else {
    if (paramName === undefined) {
      push(params, token, true);
    ***REMOVED*** else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    ***REMOVED*** else {
      push(params, paramName, token);
    ***REMOVED***
    push(offers, extensionName, params);
  ***REMOVED***

  return offers;
***REMOVED***

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object***REMOVED*** extensions The map of extensions and parameters to format
 * @return {String***REMOVED*** A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k***REMOVED***=${v***REMOVED***`))
                  .join('; ');
              ***REMOVED***)
            )
            .join('; ');
        ***REMOVED***)
        .join(', ');
    ***REMOVED***)
    .join(', ');
***REMOVED***

module.exports = { format, parse ***REMOVED***;
