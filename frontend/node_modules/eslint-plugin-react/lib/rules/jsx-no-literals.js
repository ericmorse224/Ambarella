/**
 * @fileoverview Prevent using string literals in React component definition
 * @author Caleb Morris
 * @author David Buchan-Swanson
 */

'use strict';

const iterFrom = require('es-iterator-helpers/Iterator.from');
const map = require('es-iterator-helpers/Iterator.prototype.map');
const some = require('es-iterator-helpers/Iterator.prototype.some');
const flatMap = require('es-iterator-helpers/Iterator.prototype.flatMap');
const fromEntries = require('object.fromentries');
const entries = require('object.entries');

const docsUrl = require('../util/docsUrl');
const report = require('../util/report');
const getText = require('../util/eslint').getText;

/** @typedef {import('eslint').Rule.RuleModule***REMOVED*** RuleModule */

/** @typedef {import('../../types/rules/jsx-no-literals').Config***REMOVED*** Config */
/** @typedef {import('../../types/rules/jsx-no-literals').RawConfig***REMOVED*** RawConfig */
/** @typedef {import('../../types/rules/jsx-no-literals').ResolvedConfig***REMOVED*** ResolvedConfig */
/** @typedef {import('../../types/rules/jsx-no-literals').OverrideConfig***REMOVED*** OverrideConfig */
/** @typedef {import('../../types/rules/jsx-no-literals').ElementConfig***REMOVED*** ElementConfig */

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

/**
 * @param {unknown***REMOVED*** value
 * @returns {string | unknown***REMOVED***
 */
function trimIfString(value) {
  return typeof value === 'string' ? value.trim() : value;
***REMOVED***

const reOverridableElement = /^[A-Z][\w.]*$/;
const reIsWhiteSpace = /^[\s]+$/;
const jsxElementTypes = new Set(['JSXElement', 'JSXFragment']);
const standardJSXNodeParentTypes = new Set(['JSXAttribute', 'JSXElement', 'JSXExpressionContainer', 'JSXFragment']);

const messages = {
  invalidPropValue: 'Invalid prop value: "{{text***REMOVED******REMOVED***"',
  invalidPropValueInElement: 'Invalid prop value: "{{text***REMOVED******REMOVED***" in {{element***REMOVED******REMOVED***',
  noStringsInAttributes: 'Strings not allowed in attributes: "{{text***REMOVED******REMOVED***"',
  noStringsInAttributesInElement: 'Strings not allowed in attributes: "{{text***REMOVED******REMOVED***" in {{element***REMOVED******REMOVED***',
  noStringsInJSX: 'Strings not allowed in JSX files: "{{text***REMOVED******REMOVED***"',
  noStringsInJSXInElement: 'Strings not allowed in JSX files: "{{text***REMOVED******REMOVED***" in {{element***REMOVED******REMOVED***',
  literalNotInJSXExpression: 'Missing JSX expression container around literal string: "{{text***REMOVED******REMOVED***"',
  literalNotInJSXExpressionInElement: 'Missing JSX expression container around literal string: "{{text***REMOVED******REMOVED***" in {{element***REMOVED******REMOVED***',
***REMOVED***;

/** @type {Exclude<RuleModule['meta']['schema'], unknown[] | false>['properties']***REMOVED*** */
const commonPropertiesSchema = {
  noStrings: {
    type: 'boolean',
  ***REMOVED***,
  allowedStrings: {
    type: 'array',
    uniqueItems: true,
    items: {
      type: 'string',
    ***REMOVED***,
  ***REMOVED***,
  ignoreProps: {
    type: 'boolean',
  ***REMOVED***,
  noAttributeStrings: {
    type: 'boolean',
  ***REMOVED***,
***REMOVED***;

// eslint-disable-next-line valid-jsdoc
/**
 * Normalizes the element portion of the config
 * @param {RawConfig***REMOVED*** config
 * @returns {ElementConfig***REMOVED***
 */
function normalizeElementConfig(config) {
  return {
    type: 'element',
    noStrings: !!config.noStrings,
    allowedStrings: config.allowedStrings
      ? new Set(map(iterFrom(config.allowedStrings), trimIfString))
      : new Set(),
    ignoreProps: !!config.ignoreProps,
    noAttributeStrings: !!config.noAttributeStrings,
  ***REMOVED***;
***REMOVED***

// eslint-disable-next-line valid-jsdoc
/**
 * Normalizes the config and applies default values to all config options
 * @param {RawConfig***REMOVED*** config
 * @returns {Config***REMOVED***
 */
function normalizeConfig(config) {
  /** @type {Config***REMOVED*** */
  const normalizedConfig = Object.assign(normalizeElementConfig(config), {
    elementOverrides: {***REMOVED***,
  ***REMOVED***);

  if (config.elementOverrides) {
    normalizedConfig.elementOverrides = fromEntries(
      flatMap(
        iterFrom(entries(config.elementOverrides)),
        (entry) => {
          const elementName = entry[0];
          const rawElementConfig = entry[1];

          if (!reOverridableElement.test(elementName)) {
            return [];
          ***REMOVED***

          return [[
            elementName,
            Object.assign(normalizeElementConfig(rawElementConfig), {
              type: 'override',
              name: elementName,
              allowElement: !!rawElementConfig.allowElement,
              applyToNestedElements: typeof rawElementConfig.applyToNestedElements === 'undefined' || !!rawElementConfig.applyToNestedElements,
            ***REMOVED***),
          ]];
        ***REMOVED***
      )
    );
  ***REMOVED***

  return normalizedConfig;
***REMOVED***

const elementOverrides = {
  type: 'object',
  patternProperties: {
    [reOverridableElement.source]: {
      type: 'object',
      properties: Object.assign(
        { applyToNestedElements: { type: 'boolean' ***REMOVED*** ***REMOVED***,
        commonPropertiesSchema
      ),

    ***REMOVED***,
  ***REMOVED***,
***REMOVED***;

/** @type {RuleModule***REMOVED*** */
module.exports = {
  meta: /** @type {RuleModule['meta']***REMOVED*** */ ({
    docs: {
      description: 'Disallow usage of string literals in JSX',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-no-literals'),
    ***REMOVED***,

    messages,

    schema: [{
      type: 'object',
      properties: Object.assign(
        { elementOverrides ***REMOVED***,
        commonPropertiesSchema
      ),
      additionalProperties: false,
    ***REMOVED***],
  ***REMOVED***),

  create(context) {
    /** @type {RawConfig***REMOVED*** */
    const rawConfig = (context.options.length && context.options[0]) || {***REMOVED***;
    const config = normalizeConfig(rawConfig);

    const hasElementOverrides = Object.keys(config.elementOverrides).length > 0;

    /** @type {Map<string, string>***REMOVED*** */
    const renamedImportMap = new Map();

    /**
     * Determines if the given expression is a require statement. Supports
     * nested MemberExpresions. ie `require('foo').nested.property`
     * @param {ASTNode***REMOVED*** node
     * @returns {boolean***REMOVED***
     */
    function isRequireStatement(node) {
      if (node.type === 'CallExpression') {
        if (node.callee.type === 'Identifier') {
          return node.callee.name === 'require';
        ***REMOVED***
      ***REMOVED***
      if (node.type === 'MemberExpression') {
        return isRequireStatement(node.object);
      ***REMOVED***

      return false;
    ***REMOVED***

    /** @typedef {{ name: string, compoundName?: string ***REMOVED******REMOVED*** ElementNameFragment */

    /**
     * Gets the name of the given JSX element. Supports nested
     * JSXMemeberExpressions. ie `<Namesapce.Component.SubComponent />`
     * @param {ASTNode***REMOVED*** node
     * @returns {ElementNameFragment | undefined***REMOVED***
     */
    function getJSXElementName(node) {
      if (node.openingElement.name.type === 'JSXIdentifier') {
        const name = node.openingElement.name.name;
        return {
          name: renamedImportMap.get(name) || name,
          compoundName: undefined,
        ***REMOVED***;
      ***REMOVED***

      /** @type {string[]***REMOVED*** */
      const nameFragments = [];

      if (node.openingElement.name.type === 'JSXMemberExpression') {
        /** @type {ASTNode***REMOVED*** */
        let current = node.openingElement.name;
        while (current.type === 'JSXMemberExpression') {
          if (current.property.type === 'JSXIdentifier') {
            nameFragments.unshift(current.property.name);
          ***REMOVED***

          current = current.object;
        ***REMOVED***

        if (current.type === 'JSXIdentifier') {
          nameFragments.unshift(current.name);

          const rootFragment = nameFragments[0];
          if (rootFragment) {
            const rootFragmentRenamed = renamedImportMap.get(rootFragment);
            if (rootFragmentRenamed) {
              nameFragments[0] = rootFragmentRenamed;
            ***REMOVED***
          ***REMOVED***

          const nameFragment = nameFragments[nameFragments.length - 1];
          if (nameFragment) {
            return {
              name: nameFragment,
              compoundName: nameFragments.join('.'),
            ***REMOVED***;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    /**
     * Gets all JSXElement ancestor nodes for the given node
     * @param {ASTNode***REMOVED*** node
     * @returns {ASTNode[]***REMOVED***
     */
    function getJSXElementAncestors(node) {
      /** @type {ASTNode[]***REMOVED*** */
      const ancestors = [];

      let current = node;
      while (current) {
        if (current.type === 'JSXElement') {
          ancestors.push(current);
        ***REMOVED***

        current = current.parent;
      ***REMOVED***

      return ancestors;
    ***REMOVED***

    /**
     * @param {ASTNode***REMOVED*** node
     * @returns {ASTNode***REMOVED***
     */
    function getParentIgnoringBinaryExpressions(node) {
      let current = node;
      while (current.parent.type === 'BinaryExpression') {
        current = current.parent;
      ***REMOVED***
      return current.parent;
    ***REMOVED***

    /**
     * @param {ASTNode***REMOVED*** node
     * @returns {{ parent: ASTNode, grandParent: ASTNode ***REMOVED******REMOVED***
     */
    function getParentAndGrandParent(node) {
      const parent = getParentIgnoringBinaryExpressions(node);
      return {
        parent,
        grandParent: parent.parent,
      ***REMOVED***;
    ***REMOVED***

    /**
     * @param {ASTNode***REMOVED*** node
     * @returns {boolean***REMOVED***
     */
    function hasJSXElementParentOrGrandParent(node) {
      const ancestors = getParentAndGrandParent(node);
      return some(iterFrom([ancestors.parent, ancestors.grandParent]), (parent) => jsxElementTypes.has(parent.type));
    ***REMOVED***

    // eslint-disable-next-line valid-jsdoc
    /**
     * Determines whether a given node's value and its immediate parent are
     * viable text nodes that can/should be reported on
     * @param {ASTNode***REMOVED*** node
     * @param {ResolvedConfig***REMOVED*** resolvedConfig
     * @returns {boolean***REMOVED***
     */
    function isViableTextNode(node, resolvedConfig) {
      const textValues = iterFrom([trimIfString(node.raw), trimIfString(node.value)]);
      if (some(textValues, (value) => resolvedConfig.allowedStrings.has(value))) {
        return false;
      ***REMOVED***

      const parent = getParentIgnoringBinaryExpressions(node);

      let isStandardJSXNode = false;
      if (typeof node.value === 'string' && !reIsWhiteSpace.test(node.value) && standardJSXNodeParentTypes.has(parent.type)) {
        if (resolvedConfig.noAttributeStrings) {
          isStandardJSXNode = parent.type === 'JSXAttribute' || parent.type === 'JSXElement';
        ***REMOVED*** else {
          isStandardJSXNode = parent.type !== 'JSXAttribute';
        ***REMOVED***
      ***REMOVED***

      if (resolvedConfig.noStrings) {
        return isStandardJSXNode;
      ***REMOVED***

      return isStandardJSXNode && parent.type !== 'JSXExpressionContainer';
    ***REMOVED***

    // eslint-disable-next-line valid-jsdoc
    /**
     * Gets an override config for a given node. For any given node, we also
     * need to traverse the ancestor tree to determine if an ancestor's config
     * will also apply to the current node.
     * @param {ASTNode***REMOVED*** node
     * @returns {OverrideConfig | undefined***REMOVED***
     */
    function getOverrideConfig(node) {
      if (!hasElementOverrides) {
        return;
      ***REMOVED***

      const allAncestorElements = getJSXElementAncestors(node);
      if (!allAncestorElements.length) {
        return;
      ***REMOVED***

      for (const ancestorElement of allAncestorElements) {
        const isClosestJSXAncestor = ancestorElement === allAncestorElements[0];

        const ancestor = getJSXElementName(ancestorElement);
        if (ancestor) {
          if (ancestor.name) {
            const ancestorElements = config.elementOverrides[ancestor.name];
            const ancestorConfig = ancestor.compoundName
              ? config.elementOverrides[ancestor.compoundName] || ancestorElements
              : ancestorElements;

            if (ancestorConfig) {
              if (isClosestJSXAncestor || ancestorConfig.applyToNestedElements) {
                return ancestorConfig;
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***

    // eslint-disable-next-line valid-jsdoc
    /**
     * @param {ResolvedConfig***REMOVED*** resolvedConfig
     * @returns {boolean***REMOVED***
     */
    function shouldAllowElement(resolvedConfig) {
      return resolvedConfig.type === 'override' && 'allowElement' in resolvedConfig && !!resolvedConfig.allowElement;
    ***REMOVED***

    // eslint-disable-next-line valid-jsdoc
    /**
     * @param {boolean***REMOVED*** ancestorIsJSXElement
     * @param {ResolvedConfig***REMOVED*** resolvedConfig
     * @returns {string***REMOVED***
     */
    function defaultMessageId(ancestorIsJSXElement, resolvedConfig) {
      if (resolvedConfig.noAttributeStrings && !ancestorIsJSXElement) {
        return resolvedConfig.type === 'override' ? 'noStringsInAttributesInElement' : 'noStringsInAttributes';
      ***REMOVED***

      if (resolvedConfig.noStrings) {
        return resolvedConfig.type === 'override' ? 'noStringsInJSXInElement' : 'noStringsInJSX';
      ***REMOVED***

      return resolvedConfig.type === 'override' ? 'literalNotInJSXExpressionInElement' : 'literalNotInJSXExpression';
    ***REMOVED***

    // eslint-disable-next-line valid-jsdoc
    /**
     * @param {ASTNode***REMOVED*** node
     * @param {string***REMOVED*** messageId
     * @param {ResolvedConfig***REMOVED*** resolvedConfig
     */
    function reportLiteralNode(node, messageId, resolvedConfig) {
      report(context, messages[messageId], messageId, {
        node,
        data: {
          text: getText(context, node).trim(),
          element: resolvedConfig.type === 'override' && 'name' in resolvedConfig ? resolvedConfig.name : undefined,
        ***REMOVED***,
      ***REMOVED***);
    ***REMOVED***

    // --------------------------------------------------------------------------
    // Public
    // --------------------------------------------------------------------------

    return Object.assign(hasElementOverrides ? {
      // Get renamed import local names mapped to their imported name
      ImportDeclaration(node) {
        node.specifiers
          .filter((s) => s.type === 'ImportSpecifier')
          .forEach((specifier) => {
            renamedImportMap.set(
              (specifier.local || specifier.imported).name,
              specifier.imported.name
            );
          ***REMOVED***);
      ***REMOVED***,

      // Get renamed destructured local names mapped to their imported name
      VariableDeclaration(node) {
        node.declarations
          .filter((d) => (
            d.type === 'VariableDeclarator'
            && isRequireStatement(d.init)
            && d.id.type === 'ObjectPattern'
          ))
          .forEach((declaration) => {
            declaration.id.properties
              .filter((property) => (
                property.type === 'Property'
                && property.key.type === 'Identifier'
                && property.value.type === 'Identifier'
              ))
              .forEach((property) => {
                renamedImportMap.set(property.value.name, property.key.name);
              ***REMOVED***);
          ***REMOVED***);
      ***REMOVED***,
    ***REMOVED*** : false, {
      Literal(node) {
        const resolvedConfig = getOverrideConfig(node) || config;

        const hasJSXParentOrGrandParent = hasJSXElementParentOrGrandParent(node);
        if (hasJSXParentOrGrandParent && shouldAllowElement(resolvedConfig)) {
          return;
        ***REMOVED***

        if (isViableTextNode(node, resolvedConfig)) {
          if (hasJSXParentOrGrandParent || !config.ignoreProps) {
            reportLiteralNode(node, defaultMessageId(hasJSXParentOrGrandParent, resolvedConfig), resolvedConfig);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***,

      JSXAttribute(node) {
        const isLiteralString = node.value && node.value.type === 'Literal'
          && typeof node.value.value === 'string';
        const isStringLiteral = node.value && node.value.type === 'StringLiteral';

        if (isLiteralString || isStringLiteral) {
          const resolvedConfig = getOverrideConfig(node) || config;

          if (
            resolvedConfig.noStrings
            && !resolvedConfig.ignoreProps
            && !resolvedConfig.allowedStrings.has(node.value.value)
          ) {
            const messageId = resolvedConfig.type === 'override' ? 'invalidPropValueInElement' : 'invalidPropValue';
            reportLiteralNode(node, messageId, resolvedConfig);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***,

      JSXText(node) {
        const resolvedConfig = getOverrideConfig(node) || config;

        if (shouldAllowElement(resolvedConfig)) {
          return;
        ***REMOVED***

        if (isViableTextNode(node, resolvedConfig)) {
          const hasJSXParendOrGrantParent = hasJSXElementParentOrGrandParent(node);
          reportLiteralNode(node, defaultMessageId(hasJSXParendOrGrantParent, resolvedConfig), resolvedConfig);
        ***REMOVED***
      ***REMOVED***,

      TemplateLiteral(node) {
        const ancestors = getParentAndGrandParent(node);
        const isParentJSXExpressionCont = ancestors.parent.type === 'JSXExpressionContainer';
        const isParentJSXElement = ancestors.grandParent.type === 'JSXElement';

        if (isParentJSXExpressionCont) {
          const resolvedConfig = getOverrideConfig(node) || config;

          if (
            resolvedConfig.noStrings
            && (isParentJSXElement || !resolvedConfig.ignoreProps)
          ) {
            reportLiteralNode(node, defaultMessageId(isParentJSXElement, resolvedConfig), resolvedConfig);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***,
    ***REMOVED***);
  ***REMOVED***,
***REMOVED***;
