function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; ***REMOVED***)), keys.push.apply(keys, symbols); ***REMOVED*** return keys; ***REMOVED***
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {***REMOVED***; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); ***REMOVED***) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); ***REMOVED***); ***REMOVED*** return target; ***REMOVED***
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true ***REMOVED***); ***REMOVED*** else { obj[key] = value; ***REMOVED*** return obj; ***REMOVED***
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); ***REMOVED***
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); ***REMOVED*** return (hint === "string" ? String : Number)(input); ***REMOVED***
/* global __resourceQuery, __webpack_hash__ */
/// <reference types="webpack/module" />
import webpackHotLog from "webpack/hot/log.js";
import stripAnsi from "./utils/stripAnsi.js";
import parseURL from "./utils/parseURL.js";
import socket from "./socket.js";
import { formatProblem, createOverlay ***REMOVED*** from "./overlay.js";
import { log, logEnabledFeatures, setLogLevel ***REMOVED*** from "./utils/log.js";
import sendMessage from "./utils/sendMessage.js";
import reloadApp from "./utils/reloadApp.js";
import createSocketURL from "./utils/createSocketURL.js";

/**
 * @typedef {Object***REMOVED*** OverlayOptions
 * @property {boolean | (error: Error) => boolean***REMOVED*** [warnings]
 * @property {boolean | (error: Error) => boolean***REMOVED*** [errors]
 * @property {boolean | (error: Error) => boolean***REMOVED*** [runtimeErrors]
 * @property {string***REMOVED*** [trustedTypesPolicyName]
 */

/**
 * @typedef {Object***REMOVED*** Options
 * @property {boolean***REMOVED*** hot
 * @property {boolean***REMOVED*** liveReload
 * @property {boolean***REMOVED*** progress
 * @property {boolean | OverlayOptions***REMOVED*** overlay
 * @property {string***REMOVED*** [logging]
 * @property {number***REMOVED*** [reconnect]
 */

/**
 * @typedef {Object***REMOVED*** Status
 * @property {boolean***REMOVED*** isUnloading
 * @property {string***REMOVED*** currentHash
 * @property {string***REMOVED*** [previousHash]
 */

/**
 * @param {boolean | { warnings?: boolean | string; errors?: boolean | string; runtimeErrors?: boolean | string; ***REMOVED******REMOVED*** overlayOptions
 */
var decodeOverlayOptions = function decodeOverlayOptions(overlayOptions) {
  if (typeof overlayOptions === "object") {
    ["warnings", "errors", "runtimeErrors"].forEach(function (property) {
      if (typeof overlayOptions[property] === "string") {
        var overlayFilterFunctionString = decodeURIComponent(overlayOptions[property]);

        // eslint-disable-next-line no-new-func
        var overlayFilterFunction = new Function("message", "var callback = ".concat(overlayFilterFunctionString, "\n        return callback(message)"));
        overlayOptions[property] = overlayFilterFunction;
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***
***REMOVED***;

/**
 * @type {Status***REMOVED***
 */
var status = {
  isUnloading: false,
  // TODO Workaround for webpack v4, `__webpack_hash__` is not replaced without HotModuleReplacement
  // eslint-disable-next-line camelcase
  currentHash: typeof __webpack_hash__ !== "undefined" ? __webpack_hash__ : ""
***REMOVED***;

/** @type {Options***REMOVED*** */
var options = {
  hot: false,
  liveReload: false,
  progress: false,
  overlay: false
***REMOVED***;
var parsedResourceQuery = parseURL(__resourceQuery);
var enabledFeatures = {
  "Hot Module Replacement": false,
  "Live Reloading": false,
  Progress: false,
  Overlay: false
***REMOVED***;
if (parsedResourceQuery.hot === "true") {
  options.hot = true;
  enabledFeatures["Hot Module Replacement"] = true;
***REMOVED***
if (parsedResourceQuery["live-reload"] === "true") {
  options.liveReload = true;
  enabledFeatures["Live Reloading"] = true;
***REMOVED***
if (parsedResourceQuery.progress === "true") {
  options.progress = true;
  enabledFeatures.Progress = true;
***REMOVED***
if (parsedResourceQuery.overlay) {
  try {
    options.overlay = JSON.parse(parsedResourceQuery.overlay);
  ***REMOVED*** catch (e) {
    log.error("Error parsing overlay options from resource query:", e);
  ***REMOVED***

  // Fill in default "true" params for partially-specified objects.
  if (typeof options.overlay === "object") {
    options.overlay = _objectSpread({
      errors: true,
      warnings: true,
      runtimeErrors: true
    ***REMOVED***, options.overlay);
    decodeOverlayOptions(options.overlay);
  ***REMOVED***
  enabledFeatures.Overlay = true;
***REMOVED***
if (parsedResourceQuery.logging) {
  options.logging = parsedResourceQuery.logging;
***REMOVED***
if (typeof parsedResourceQuery.reconnect !== "undefined") {
  options.reconnect = Number(parsedResourceQuery.reconnect);
***REMOVED***

/**
 * @param {string***REMOVED*** level
 */
function setAllLogLevel(level) {
  // This is needed because the HMR logger operate separately from dev server logger
  webpackHotLog.setLogLevel(level === "verbose" || level === "log" ? "info" : level);
  setLogLevel(level);
***REMOVED***
if (options.logging) {
  setAllLogLevel(options.logging);
***REMOVED***
logEnabledFeatures(enabledFeatures);
self.addEventListener("beforeunload", function () {
  status.isUnloading = true;
***REMOVED***);
var overlay = typeof window !== "undefined" ? createOverlay(typeof options.overlay === "object" ? {
  trustedTypesPolicyName: options.overlay.trustedTypesPolicyName,
  catchRuntimeError: options.overlay.runtimeErrors
***REMOVED*** : {
  trustedTypesPolicyName: false,
  catchRuntimeError: options.overlay
***REMOVED***) : {
  send: function send() {***REMOVED***
***REMOVED***;
var onSocketMessage = {
  hot: function hot() {
    if (parsedResourceQuery.hot === "false") {
      return;
    ***REMOVED***
    options.hot = true;
  ***REMOVED***,
  liveReload: function liveReload() {
    if (parsedResourceQuery["live-reload"] === "false") {
      return;
    ***REMOVED***
    options.liveReload = true;
  ***REMOVED***,
  invalid: function invalid() {
    log.info("App updated. Recompiling...");

    // Fixes #1042. overlay doesn't clear if errors are fixed but warnings remain.
    if (options.overlay) {
      overlay.send({
        type: "DISMISS"
      ***REMOVED***);
    ***REMOVED***
    sendMessage("Invalid");
  ***REMOVED***,
  /**
   * @param {string***REMOVED*** hash
   */
  hash: function hash(_hash) {
    status.previousHash = status.currentHash;
    status.currentHash = _hash;
  ***REMOVED***,
  logging: setAllLogLevel,
  /**
   * @param {boolean***REMOVED*** value
   */
  overlay: function overlay(value) {
    if (typeof document === "undefined") {
      return;
    ***REMOVED***
    options.overlay = value;
    decodeOverlayOptions(options.overlay);
  ***REMOVED***,
  /**
   * @param {number***REMOVED*** value
   */
  reconnect: function reconnect(value) {
    if (parsedResourceQuery.reconnect === "false") {
      return;
    ***REMOVED***
    options.reconnect = value;
  ***REMOVED***,
  /**
   * @param {boolean***REMOVED*** value
   */
  progress: function progress(value) {
    options.progress = value;
  ***REMOVED***,
  /**
   * @param {{ pluginName?: string, percent: number, msg: string ***REMOVED******REMOVED*** data
   */
  "progress-update": function progressUpdate(data) {
    if (options.progress) {
      log.info("".concat(data.pluginName ? "[".concat(data.pluginName, "] ") : "").concat(data.percent, "% - ").concat(data.msg, "."));
    ***REMOVED***
    sendMessage("Progress", data);
  ***REMOVED***,
  "still-ok": function stillOk() {
    log.info("Nothing changed.");
    if (options.overlay) {
      overlay.send({
        type: "DISMISS"
      ***REMOVED***);
    ***REMOVED***
    sendMessage("StillOk");
  ***REMOVED***,
  ok: function ok() {
    sendMessage("Ok");
    if (options.overlay) {
      overlay.send({
        type: "DISMISS"
      ***REMOVED***);
    ***REMOVED***
    reloadApp(options, status);
  ***REMOVED***,
  // TODO: remove in v5 in favor of 'static-changed'
  /**
   * @param {string***REMOVED*** file
   */
  "content-changed": function contentChanged(file) {
    log.info("".concat(file ? "\"".concat(file, "\"") : "Content", " from static directory was changed. Reloading..."));
    self.location.reload();
  ***REMOVED***,
  /**
   * @param {string***REMOVED*** file
   */
  "static-changed": function staticChanged(file) {
    log.info("".concat(file ? "\"".concat(file, "\"") : "Content", " from static directory was changed. Reloading..."));
    self.location.reload();
  ***REMOVED***,
  /**
   * @param {Error[]***REMOVED*** warnings
   * @param {any***REMOVED*** params
   */
  warnings: function warnings(_warnings, params) {
    log.warn("Warnings while compiling.");
    var printableWarnings = _warnings.map(function (error) {
      var _formatProblem = formatProblem("warning", error),
        header = _formatProblem.header,
        body = _formatProblem.body;
      return "".concat(header, "\n").concat(stripAnsi(body));
    ***REMOVED***);
    sendMessage("Warnings", printableWarnings);
    for (var i = 0; i < printableWarnings.length; i++) {
      log.warn(printableWarnings[i]);
    ***REMOVED***
    var overlayWarningsSetting = typeof options.overlay === "boolean" ? options.overlay : options.overlay && options.overlay.warnings;
    if (overlayWarningsSetting) {
      var warningsToDisplay = typeof overlayWarningsSetting === "function" ? _warnings.filter(overlayWarningsSetting) : _warnings;
      if (warningsToDisplay.length) {
        overlay.send({
          type: "BUILD_ERROR",
          level: "warning",
          messages: _warnings
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***
    if (params && params.preventReloading) {
      return;
    ***REMOVED***
    reloadApp(options, status);
  ***REMOVED***,
  /**
   * @param {Error[]***REMOVED*** errors
   */
  errors: function errors(_errors) {
    log.error("Errors while compiling. Reload prevented.");
    var printableErrors = _errors.map(function (error) {
      var _formatProblem2 = formatProblem("error", error),
        header = _formatProblem2.header,
        body = _formatProblem2.body;
      return "".concat(header, "\n").concat(stripAnsi(body));
    ***REMOVED***);
    sendMessage("Errors", printableErrors);
    for (var i = 0; i < printableErrors.length; i++) {
      log.error(printableErrors[i]);
    ***REMOVED***
    var overlayErrorsSettings = typeof options.overlay === "boolean" ? options.overlay : options.overlay && options.overlay.errors;
    if (overlayErrorsSettings) {
      var errorsToDisplay = typeof overlayErrorsSettings === "function" ? _errors.filter(overlayErrorsSettings) : _errors;
      if (errorsToDisplay.length) {
        overlay.send({
          type: "BUILD_ERROR",
          level: "error",
          messages: _errors
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***,
  /**
   * @param {Error***REMOVED*** error
   */
  error: function error(_error) {
    log.error(_error);
  ***REMOVED***,
  close: function close() {
    log.info("Disconnected!");
    if (options.overlay) {
      overlay.send({
        type: "DISMISS"
      ***REMOVED***);
    ***REMOVED***
    sendMessage("Close");
  ***REMOVED***
***REMOVED***;
var socketURL = createSocketURL(parsedResourceQuery);
socket(socketURL, onSocketMessage, options.reconnect);