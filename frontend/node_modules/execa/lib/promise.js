'use strict';

const nativePromisePrototype = (async () => {***REMOVED***)().constructor.prototype;
const descriptors = ['then', 'catch', 'finally'].map(property => [
	property,
	Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
]);

// The return value is a mixin of `childProcess` and `Promise`
const mergePromise = (spawned, promise) => {
	for (const [property, descriptor] of descriptors) {
		// Starting the main `promise` is deferred to avoid consuming streams
		const value = typeof promise === 'function' ?
			(...args) => Reflect.apply(descriptor.value, promise(), args) :
			descriptor.value.bind(promise);

		Reflect.defineProperty(spawned, property, {...descriptor, value***REMOVED***);
	***REMOVED***

	return spawned;
***REMOVED***;

// Use promises instead of `child_process` events
const getSpawnedPromise = spawned => {
	return new Promise((resolve, reject) => {
		spawned.on('exit', (exitCode, signal) => {
			resolve({exitCode, signal***REMOVED***);
		***REMOVED***);

		spawned.on('error', error => {
			reject(error);
		***REMOVED***);

		if (spawned.stdin) {
			spawned.stdin.on('error', error => {
				reject(error);
			***REMOVED***);
		***REMOVED***
	***REMOVED***);
***REMOVED***;

module.exports = {
	mergePromise,
	getSpawnedPromise
***REMOVED***;

