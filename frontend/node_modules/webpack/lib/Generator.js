/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("./ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("./CodeGenerationResults")***REMOVED*** CodeGenerationResults */
/** @typedef {import("./Compilation")***REMOVED*** Compilation */
/** @typedef {import("./ConcatenationScope")***REMOVED*** ConcatenationScope */
/** @typedef {import("./DependencyTemplate")***REMOVED*** DependencyTemplate */
/** @typedef {import("./DependencyTemplates")***REMOVED*** DependencyTemplates */
/** @typedef {import("./Module").ConcatenationBailoutReasonContext***REMOVED*** ConcatenationBailoutReasonContext */
/** @typedef {import("./Module").RuntimeRequirements***REMOVED*** RuntimeRequirements */
/** @typedef {import("./Module").SourceTypes***REMOVED*** SourceTypes */
/** @typedef {import("./ModuleGraph")***REMOVED*** ModuleGraph */
/** @typedef {import("./NormalModule")***REMOVED*** NormalModule */
/** @typedef {import("./RuntimeTemplate")***REMOVED*** RuntimeTemplate */
/** @typedef {import("./util/Hash")***REMOVED*** Hash */
/** @typedef {import("./util/runtime").RuntimeSpec***REMOVED*** RuntimeSpec */

/**
 * @typedef {object***REMOVED*** GenerateContext
 * @property {DependencyTemplates***REMOVED*** dependencyTemplates mapping from dependencies to templates
 * @property {RuntimeTemplate***REMOVED*** runtimeTemplate the runtime template
 * @property {ModuleGraph***REMOVED*** moduleGraph the module graph
 * @property {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @property {RuntimeRequirements***REMOVED*** runtimeRequirements the requirements for runtime
 * @property {RuntimeSpec***REMOVED*** runtime the runtime
 * @property {ConcatenationScope=***REMOVED*** concatenationScope when in concatenated module, information about other concatenated modules
 * @property {CodeGenerationResults=***REMOVED*** codeGenerationResults code generation results of other modules (need to have a codeGenerationDependency to use that)
 * @property {string***REMOVED*** type which kind of code should be generated
 * @property {() => Map<string, TODO>=***REMOVED*** getData get access to the code generation data
 */

/**
 * @callback GenerateErrorFn
 * @param {Error***REMOVED*** error the error
 * @param {NormalModule***REMOVED*** module module for which the code should be generated
 * @param {GenerateContext***REMOVED*** generateContext context for generate
 * @returns {Source | null***REMOVED*** generated code
 */

/**
 * @typedef {object***REMOVED*** UpdateHashContext
 * @property {NormalModule***REMOVED*** module the module
 * @property {ChunkGraph***REMOVED*** chunkGraph
 * @property {RuntimeSpec***REMOVED*** runtime
 * @property {RuntimeTemplate=***REMOVED*** runtimeTemplate
 */

class Generator {
	/**
	 * @param {Record<string, Generator>***REMOVED*** map map of types
	 * @returns {ByTypeGenerator***REMOVED*** generator by type
	 */
	static byType(map) {
		return new ByTypeGenerator(map);
	***REMOVED***

	/* istanbul ignore next */
	/**
	 * @abstract
	 * @param {NormalModule***REMOVED*** module fresh module
	 * @returns {SourceTypes***REMOVED*** available types (do not mutate)
	 */
	getTypes(module) {
		const AbstractMethodError = require("./AbstractMethodError");
		throw new AbstractMethodError();
	***REMOVED***

	/* istanbul ignore next */
	/**
	 * @abstract
	 * @param {NormalModule***REMOVED*** module the module
	 * @param {string=***REMOVED*** type source type
	 * @returns {number***REMOVED*** estimate size of the module
	 */
	getSize(module, type) {
		const AbstractMethodError = require("./AbstractMethodError");
		throw new AbstractMethodError();
	***REMOVED***

	/* istanbul ignore next */
	/**
	 * @abstract
	 * @param {NormalModule***REMOVED*** module module for which the code should be generated
	 * @param {GenerateContext***REMOVED*** generateContext context for generate
	 * @returns {Source | null***REMOVED*** generated code
	 */
	generate(
		module,
		{ dependencyTemplates, runtimeTemplate, moduleGraph, type ***REMOVED***
	) {
		const AbstractMethodError = require("./AbstractMethodError");
		throw new AbstractMethodError();
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module module for which the bailout reason should be determined
	 * @param {ConcatenationBailoutReasonContext***REMOVED*** context context
	 * @returns {string | undefined***REMOVED*** reason why this module can't be concatenated, undefined when it can be concatenated
	 */
	getConcatenationBailoutReason(module, context) {
		return `Module Concatenation is not implemented for ${this.constructor.name***REMOVED***`;
	***REMOVED***

	/**
	 * @param {Hash***REMOVED*** hash hash that will be modified
	 * @param {UpdateHashContext***REMOVED*** updateHashContext context for updating hash
	 */
	updateHash(hash, { module, runtime ***REMOVED***) {
		// no nothing
	***REMOVED***
***REMOVED***

/**
 * @this {ByTypeGenerator***REMOVED***
 * @type {GenerateErrorFn***REMOVED***
 */
function generateError(error, module, generateContext) {
	const type = generateContext.type;
	const generator =
		/** @type {Generator & { generateError?: GenerateErrorFn ***REMOVED******REMOVED*** */
		(this.map[type]);
	if (!generator) {
		throw new Error(`Generator.byType: no generator specified for ${type***REMOVED***`);
	***REMOVED***
	if (typeof generator.generateError === "undefined") {
		return null;
	***REMOVED***
	return generator.generateError(error, module, generateContext);
***REMOVED***

class ByTypeGenerator extends Generator {
	/**
	 * @param {Record<string, Generator>***REMOVED*** map map of types
	 */
	constructor(map) {
		super();
		this.map = map;
		this._types = new Set(Object.keys(map));
		/** @type {GenerateErrorFn | undefined***REMOVED*** */
		this.generateError = generateError.bind(this);
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module fresh module
	 * @returns {SourceTypes***REMOVED*** available types (do not mutate)
	 */
	getTypes(module) {
		return this._types;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module the module
	 * @param {string=***REMOVED*** type source type
	 * @returns {number***REMOVED*** estimate size of the module
	 */
	getSize(module, type = "javascript") {
		const t = type;
		const generator = this.map[t];
		return generator ? generator.getSize(module, t) : 0;
	***REMOVED***

	/**
	 * @param {NormalModule***REMOVED*** module module for which the code should be generated
	 * @param {GenerateContext***REMOVED*** generateContext context for generate
	 * @returns {Source | null***REMOVED*** generated code
	 */
	generate(module, generateContext) {
		const type = generateContext.type;
		const generator = this.map[type];
		if (!generator) {
			throw new Error(`Generator.byType: no generator specified for ${type***REMOVED***`);
		***REMOVED***
		return generator.generate(module, generateContext);
	***REMOVED***
***REMOVED***

module.exports = Generator;
