"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const utils = require("../../utils");
class EntryFilter {
    constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = new Map();
    ***REMOVED***
    getFilter(positive, negative) {
        const [absoluteNegative, relativeNegative] = utils.pattern.partitionAbsoluteAndRelative(negative);
        const patterns = {
            positive: {
                all: utils.pattern.convertPatternsToRe(positive, this._micromatchOptions)
            ***REMOVED***,
            negative: {
                absolute: utils.pattern.convertPatternsToRe(absoluteNegative, Object.assign(Object.assign({***REMOVED***, this._micromatchOptions), { dot: true ***REMOVED***)),
                relative: utils.pattern.convertPatternsToRe(relativeNegative, Object.assign(Object.assign({***REMOVED***, this._micromatchOptions), { dot: true ***REMOVED***))
            ***REMOVED***
        ***REMOVED***;
        return (entry) => this._filter(entry, patterns);
    ***REMOVED***
    _filter(entry, patterns) {
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._settings.unique && this._isDuplicateEntry(filepath)) {
            return false;
        ***REMOVED***
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
            return false;
        ***REMOVED***
        const isMatched = this._isMatchToPatternsSet(filepath, patterns, entry.dirent.isDirectory());
        if (this._settings.unique && isMatched) {
            this._createIndexRecord(filepath);
        ***REMOVED***
        return isMatched;
    ***REMOVED***
    _isDuplicateEntry(filepath) {
        return this.index.has(filepath);
    ***REMOVED***
    _createIndexRecord(filepath) {
        this.index.set(filepath, undefined);
    ***REMOVED***
    _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
    ***REMOVED***
    _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
    ***REMOVED***
    _isMatchToPatternsSet(filepath, patterns, isDirectory) {
        const isMatched = this._isMatchToPatterns(filepath, patterns.positive.all, isDirectory);
        if (!isMatched) {
            return false;
        ***REMOVED***
        const isMatchedByRelativeNegative = this._isMatchToPatterns(filepath, patterns.negative.relative, isDirectory);
        if (isMatchedByRelativeNegative) {
            return false;
        ***REMOVED***
        const isMatchedByAbsoluteNegative = this._isMatchToAbsoluteNegative(filepath, patterns.negative.absolute, isDirectory);
        if (isMatchedByAbsoluteNegative) {
            return false;
        ***REMOVED***
        return true;
    ***REMOVED***
    _isMatchToAbsoluteNegative(filepath, patternsRe, isDirectory) {
        if (patternsRe.length === 0) {
            return false;
        ***REMOVED***
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, filepath);
        return this._isMatchToPatterns(fullpath, patternsRe, isDirectory);
    ***REMOVED***
    _isMatchToPatterns(filepath, patternsRe, isDirectory) {
        if (patternsRe.length === 0) {
            return false;
        ***REMOVED***
        // Trying to match files and directories by patterns.
        const isMatched = utils.pattern.matchAny(filepath, patternsRe);
        // A pattern with a trailling slash can be used for directory matching.
        // To apply such pattern, we need to add a tralling slash to the path.
        if (!isMatched && isDirectory) {
            return utils.pattern.matchAny(filepath + '/', patternsRe);
        ***REMOVED***
        return isMatched;
    ***REMOVED***
***REMOVED***
exports.default = EntryFilter;
