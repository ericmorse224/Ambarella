/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { ConcatSource ***REMOVED*** = require("webpack-sources");
const { RuntimeGlobals ***REMOVED*** = require("..");
const HotUpdateChunk = require("../HotUpdateChunk");
const Template = require("../Template");
const { getAllChunks ***REMOVED*** = require("../javascript/ChunkHelpers");
const {
	chunkHasJs,
	getCompilationHooks,
	getChunkFilenameTemplate
***REMOVED*** = require("../javascript/JavascriptModulesPlugin");
const { updateHashForEntryStartup ***REMOVED*** = require("../javascript/StartupHelpers");
const { getUndoPath ***REMOVED*** = require("../util/identifier");

/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../Entrypoint")***REMOVED*** Entrypoint */

class ModuleChunkFormatPlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		compiler.hooks.thisCompilation.tap(
			"ModuleChunkFormatPlugin",
			compilation => {
				compilation.hooks.additionalChunkRuntimeRequirements.tap(
					"ModuleChunkFormatPlugin",
					(chunk, set) => {
						if (chunk.hasRuntime()) return;
						if (compilation.chunkGraph.getNumberOfEntryModules(chunk) > 0) {
							set.add(RuntimeGlobals.require);
							set.add(RuntimeGlobals.startupEntrypoint);
							set.add(RuntimeGlobals.externalInstallChunk);
						***REMOVED***
					***REMOVED***
				);
				const hooks = getCompilationHooks(compilation);
				hooks.renderChunk.tap(
					"ModuleChunkFormatPlugin",
					(modules, renderContext) => {
						const { chunk, chunkGraph, runtimeTemplate ***REMOVED*** = renderContext;
						const hotUpdateChunk =
							chunk instanceof HotUpdateChunk ? chunk : null;
						const source = new ConcatSource();
						if (hotUpdateChunk) {
							throw new Error(
								"HMR is not implemented for module chunk format yet"
							);
						***REMOVED*** else {
							source.add(
								`export const __webpack_id__ = ${JSON.stringify(chunk.id)***REMOVED***;\n`
							);
							source.add(
								`export const __webpack_ids__ = ${JSON.stringify(chunk.ids)***REMOVED***;\n`
							);
							source.add("export const __webpack_modules__ = ");
							source.add(modules);
							source.add(";\n");
							const runtimeModules =
								chunkGraph.getChunkRuntimeModulesInOrder(chunk);
							if (runtimeModules.length > 0) {
								source.add("export const __webpack_runtime__ =\n");
								source.add(
									Template.renderChunkRuntimeModules(
										runtimeModules,
										renderContext
									)
								);
							***REMOVED***
							const entries = Array.from(
								chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk)
							);
							if (entries.length > 0) {
								const runtimeChunk =
									/** @type {Entrypoint[][]***REMOVED*** */
									(entries)[0][1].getRuntimeChunk();
								const currentOutputName = compilation
									.getPath(
										getChunkFilenameTemplate(chunk, compilation.outputOptions),
										{
											chunk,
											contentHashType: "javascript"
										***REMOVED***
									)
									.replace(/^\/+/g, "")
									.split("/");

								/**
								 * @param {Chunk***REMOVED*** chunk the chunk
								 * @returns {string***REMOVED*** the relative path
								 */
								const getRelativePath = chunk => {
									const baseOutputName = currentOutputName.slice();
									const chunkOutputName = compilation
										.getPath(
											getChunkFilenameTemplate(
												chunk,
												compilation.outputOptions
											),
											{
												chunk,
												contentHashType: "javascript"
											***REMOVED***
										)
										.replace(/^\/+/g, "")
										.split("/");

									// remove common parts except filename
									while (
										baseOutputName.length > 1 &&
										chunkOutputName.length > 1 &&
										baseOutputName[0] === chunkOutputName[0]
									) {
										baseOutputName.shift();
										chunkOutputName.shift();
									***REMOVED***
									const last = chunkOutputName.join("/");
									// create final path
									return (
										getUndoPath(baseOutputName.join("/"), last, true) + last
									);
								***REMOVED***;

								const entrySource = new ConcatSource();
								entrySource.add(source);
								entrySource.add(";\n\n// load runtime\n");
								entrySource.add(
									`import ${RuntimeGlobals.require***REMOVED*** from ${JSON.stringify(
										getRelativePath(/** @type {Chunk***REMOVED*** */ (runtimeChunk))
									)***REMOVED***;\n`
								);

								const startupSource = new ConcatSource();
								startupSource.add(
									`var __webpack_exec__ = ${runtimeTemplate.returningFunction(
										`${RuntimeGlobals.require***REMOVED***(${RuntimeGlobals.entryModuleId***REMOVED*** = moduleId)`,
										"moduleId"
									)***REMOVED***\n`
								);

								const loadedChunks = new Set();
								let index = 0;
								for (let i = 0; i < entries.length; i++) {
									const [module, entrypoint] = entries[i];
									if (
										!chunkGraph.getModuleSourceTypes(module).has("javascript")
									) {
										continue;
									***REMOVED***
									const final = i + 1 === entries.length;
									const moduleId = chunkGraph.getModuleId(module);
									const chunks = getAllChunks(
										/** @type {Entrypoint***REMOVED*** */ (entrypoint),
										/** @type {Chunk***REMOVED*** */ (runtimeChunk),
										undefined
									);
									for (const chunk of chunks) {
										if (
											loadedChunks.has(chunk) ||
											!chunkHasJs(chunk, chunkGraph)
										)
											continue;
										loadedChunks.add(chunk);
										startupSource.add(
											`import * as __webpack_chunk_${index***REMOVED***__ from ${JSON.stringify(
												getRelativePath(chunk)
											)***REMOVED***;\n`
										);
										startupSource.add(
											`${RuntimeGlobals.externalInstallChunk***REMOVED***(__webpack_chunk_${index***REMOVED***__);\n`
										);
										index++;
									***REMOVED***
									startupSource.add(
										`${
											final ? `var ${RuntimeGlobals.exports***REMOVED*** = ` : ""
										***REMOVED***__webpack_exec__(${JSON.stringify(moduleId)***REMOVED***);\n`
									);
								***REMOVED***

								entrySource.add(
									hooks.renderStartup.call(
										startupSource,
										entries[entries.length - 1][0],
										{
											...renderContext,
											inlined: false
										***REMOVED***
									)
								);
								return entrySource;
							***REMOVED***
						***REMOVED***
						return source;
					***REMOVED***
				);
				hooks.chunkHash.tap(
					"ModuleChunkFormatPlugin",
					(chunk, hash, { chunkGraph, runtimeTemplate ***REMOVED***) => {
						if (chunk.hasRuntime()) return;
						hash.update("ModuleChunkFormatPlugin");
						hash.update("1");
						const entries = Array.from(
							chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk)
						);
						updateHashForEntryStartup(hash, chunkGraph, entries, chunk);
					***REMOVED***
				);
			***REMOVED***
		);
	***REMOVED***
***REMOVED***

module.exports = ModuleChunkFormatPlugin;
