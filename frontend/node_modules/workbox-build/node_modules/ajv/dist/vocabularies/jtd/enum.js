"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const codegen_1 = require("../../compile/codegen");
const metadata_1 = require("./metadata");
const nullable_1 = require("./nullable");
const error = {
    message: "must be equal to one of the allowed values",
    params: ({ schemaCode ***REMOVED***) => (0, codegen_1._) `{allowedValues: ${schemaCode***REMOVED******REMOVED***`,
***REMOVED***;
const def = {
    keyword: "enum",
    schemaType: "array",
    error,
    code(cxt) {
        (0, metadata_1.checkMetadata)(cxt);
        const { gen, data, schema, schemaValue, parentSchema, it ***REMOVED*** = cxt;
        if (schema.length === 0)
            throw new Error("enum must have non-empty array");
        if (schema.length !== new Set(schema).size)
            throw new Error("enum items must be unique");
        let valid;
        const isString = (0, codegen_1._) `typeof ${data***REMOVED*** == "string"`;
        if (schema.length >= it.opts.loopEnum) {
            let cond;
            [valid, cond] = (0, nullable_1.checkNullable)(cxt, isString);
            gen.if(cond, loopEnum);
        ***REMOVED***
        else {
            /* istanbul ignore if */
            if (!Array.isArray(schema))
                throw new Error("ajv implementation error");
            valid = (0, codegen_1.and)(isString, (0, codegen_1.or)(...schema.map((value) => (0, codegen_1._) `${data***REMOVED*** === ${value***REMOVED***`)));
            if (parentSchema.nullable)
                valid = (0, codegen_1.or)((0, codegen_1._) `${data***REMOVED*** === null`, valid);
        ***REMOVED***
        cxt.pass(valid);
        function loopEnum() {
            gen.forOf("v", schemaValue, (v) => gen.if((0, codegen_1._) `${valid***REMOVED*** = ${data***REMOVED*** === ${v***REMOVED***`, () => gen.break()));
        ***REMOVED***
    ***REMOVED***,
***REMOVED***;
exports.default = def;
//# sourceMappingURL=enum.js.map