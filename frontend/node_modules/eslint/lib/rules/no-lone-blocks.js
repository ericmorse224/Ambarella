/**
 * @fileoverview Rule to flag blocks with no reason to exist
 * @author Brandon Mills
 */

"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "suggestion",

		docs: {
			description: "Disallow unnecessary nested blocks",
			recommended: false,
			url: "https://eslint.org/docs/latest/rules/no-lone-blocks",
		***REMOVED***,

		schema: [],

		messages: {
			redundantBlock: "Block is redundant.",
			redundantNestedBlock: "Nested block is redundant.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		// A stack of lone blocks to be checked for block-level bindings
		const loneBlocks = [];
		let ruleDef;
		const sourceCode = context.sourceCode;

		/**
		 * Reports a node as invalid.
		 * @param {ASTNode***REMOVED*** node The node to be reported.
		 * @returns {void***REMOVED***
		 */
		function report(node) {
			const messageId =
				node.parent.type === "BlockStatement" ||
				node.parent.type === "StaticBlock"
					? "redundantNestedBlock"
					: "redundantBlock";

			context.report({
				node,
				messageId,
			***REMOVED***);
		***REMOVED***

		/**
		 * Checks for any occurrence of a BlockStatement in a place where lists of statements can appear
		 * @param {ASTNode***REMOVED*** node The node to check
		 * @returns {boolean***REMOVED*** True if the node is a lone block.
		 */
		function isLoneBlock(node) {
			return (
				node.parent.type === "BlockStatement" ||
				node.parent.type === "StaticBlock" ||
				node.parent.type === "Program" ||
				// Don't report blocks in switch cases if the block is the only statement of the case.
				(node.parent.type === "SwitchCase" &&
					!(
						node.parent.consequent[0] === node &&
						node.parent.consequent.length === 1
					))
			);
		***REMOVED***

		/**
		 * Checks the enclosing block of the current node for block-level bindings,
		 * and "marks it" as valid if any.
		 * @param {ASTNode***REMOVED*** node The current node to check.
		 * @returns {void***REMOVED***
		 */
		function markLoneBlock(node) {
			if (loneBlocks.length === 0) {
				return;
			***REMOVED***

			const block = node.parent;

			if (loneBlocks.at(-1) === block) {
				loneBlocks.pop();
			***REMOVED***
		***REMOVED***

		// Default rule definition: report all lone blocks
		ruleDef = {
			BlockStatement(node) {
				if (isLoneBlock(node)) {
					report(node);
				***REMOVED***
			***REMOVED***,
		***REMOVED***;

		// ES6: report blocks without block-level bindings, or that's only child of another block
		if (context.languageOptions.ecmaVersion >= 2015) {
			ruleDef = {
				BlockStatement(node) {
					if (isLoneBlock(node)) {
						loneBlocks.push(node);
					***REMOVED***
				***REMOVED***,
				"BlockStatement:exit"(node) {
					if (loneBlocks.length > 0 && loneBlocks.at(-1) === node) {
						loneBlocks.pop();
						report(node);
					***REMOVED*** else if (
						(node.parent.type === "BlockStatement" ||
							node.parent.type === "StaticBlock") &&
						node.parent.body.length === 1
					) {
						report(node);
					***REMOVED***
				***REMOVED***,
			***REMOVED***;

			ruleDef.VariableDeclaration = function (node) {
				if (node.kind !== "var") {
					markLoneBlock(node);
				***REMOVED***
			***REMOVED***;

			ruleDef.FunctionDeclaration = function (node) {
				if (sourceCode.getScope(node).isStrict) {
					markLoneBlock(node);
				***REMOVED***
			***REMOVED***;

			ruleDef.ClassDeclaration = markLoneBlock;
		***REMOVED***

		return ruleDef;
	***REMOVED***,
***REMOVED***;
