import type AjvCore from "../core"
import type {AnyValidateFunction, SourceCode***REMOVED*** from "../types"
import type {SchemaEnv***REMOVED*** from "../compile"
import {UsedScopeValues, UsedValueState, ValueScopeName, varKinds***REMOVED*** from "../compile/codegen/scope"
import {_, nil, _Code, Code, getProperty, getEsmExportName***REMOVED*** from "../compile/codegen/code"

function standaloneCode(
  ajv: AjvCore,
  refsOrFunc?: {[K in string]?: string***REMOVED*** | AnyValidateFunction
): string {
  if (!ajv.opts.code.source) {
    throw new Error("moduleCode: ajv instance must have code.source option")
  ***REMOVED***
  const {_n***REMOVED*** = ajv.scope.opts
  return typeof refsOrFunc == "function"
    ? funcExportCode(refsOrFunc.source)
    : refsOrFunc !== undefined
    ? multiExportsCode<string>(refsOrFunc, getValidate)
    : multiExportsCode<SchemaEnv>(ajv.schemas, (sch) =>
        sch.meta ? undefined : ajv.compile(sch.schema)
      )

  function getValidate(id: string): AnyValidateFunction {
    const v = ajv.getSchema(id)
    if (!v) throw new Error(`moduleCode: no schema with id ${id***REMOVED***`)
    return v
  ***REMOVED***

  function funcExportCode(source?: SourceCode): string {
    const usedValues: UsedScopeValues = {***REMOVED***
    const n = source?.validateName
    const vCode = validateCode(usedValues, source)
    if (ajv.opts.code.esm) {
      // Always do named export as `validate` rather than the variable `n` which is `validateXX` for known export value
      return `"use strict";${_n***REMOVED***export const validate = ${n***REMOVED***;${_n***REMOVED***export default ${n***REMOVED***;${_n***REMOVED***${vCode***REMOVED***`
    ***REMOVED***
    return `"use strict";${_n***REMOVED***module.exports = ${n***REMOVED***;${_n***REMOVED***module.exports.default = ${n***REMOVED***;${_n***REMOVED***${vCode***REMOVED***`
  ***REMOVED***

  function multiExportsCode<T extends SchemaEnv | string>(
    schemas: {[K in string]?: T***REMOVED***,
    getValidateFunc: (schOrId: T) => AnyValidateFunction | undefined
  ): string {
    const usedValues: UsedScopeValues = {***REMOVED***
    let code = _`"use strict";`
    for (const name in schemas) {
      const v = getValidateFunc(schemas[name] as T)
      if (v) {
        const vCode = validateCode(usedValues, v.source)
        const exportSyntax = ajv.opts.code.esm
          ? _`export const ${getEsmExportName(name)***REMOVED***`
          : _`exports${getProperty(name)***REMOVED***`
        code = _`${code***REMOVED***${_n***REMOVED***${exportSyntax***REMOVED*** = ${v.source?.validateName***REMOVED***;${_n***REMOVED***${vCode***REMOVED***`
      ***REMOVED***
    ***REMOVED***
    return `${code***REMOVED***`
  ***REMOVED***

  function validateCode(usedValues: UsedScopeValues, s?: SourceCode): Code {
    if (!s) throw new Error('moduleCode: function does not have "source" property')
    if (usedState(s.validateName) === UsedValueState.Completed) return nil
    setUsedState(s.validateName, UsedValueState.Started)

    const scopeCode = ajv.scope.scopeCode(s.scopeValues, usedValues, refValidateCode)
    const code = new _Code(`${scopeCode***REMOVED***${_n***REMOVED***${s.validateCode***REMOVED***`)
    return s.evaluated ? _`${code***REMOVED***${s.validateName***REMOVED***.evaluated = ${s.evaluated***REMOVED***;${_n***REMOVED***` : code

    function refValidateCode(n: ValueScopeName): Code | undefined {
      const vRef = n.value?.ref
      if (n.prefix === "validate" && typeof vRef == "function") {
        const v = vRef as AnyValidateFunction
        return validateCode(usedValues, v.source)
      ***REMOVED*** else if ((n.prefix === "root" || n.prefix === "wrapper") && typeof vRef == "object") {
        const {validate, validateName***REMOVED*** = vRef as SchemaEnv
        if (!validateName) throw new Error("ajv internal error")
        const def = ajv.opts.code.es5 ? varKinds.var : varKinds.const
        const wrapper = _`${def***REMOVED*** ${n***REMOVED*** = {validate: ${validateName***REMOVED******REMOVED***;`
        if (usedState(validateName) === UsedValueState.Started) return wrapper
        const vCode = validateCode(usedValues, validate?.source)
        return _`${wrapper***REMOVED***${_n***REMOVED***${vCode***REMOVED***`
      ***REMOVED***
      return undefined
    ***REMOVED***

    function usedState(name: ValueScopeName): UsedValueState | undefined {
      return usedValues[name.prefix]?.get(name)
    ***REMOVED***

    function setUsedState(name: ValueScopeName, state: UsedValueState): void {
      const {prefix***REMOVED*** = name
      const names = (usedValues[prefix] = usedValues[prefix] || new Map())
      names.set(name, state)
    ***REMOVED***
  ***REMOVED***
***REMOVED***

module.exports = exports = standaloneCode
Object.defineProperty(exports, "__esModule", {value: true***REMOVED***)

export default standaloneCode
