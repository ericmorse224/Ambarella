/**
 * @fileoverview Rule to count multiple spaces in regular expressions
 * @author Matt DuVall <http://www.mattduvall.com/>
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");
const regexpp = require("@eslint-community/regexpp");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const regExpParser = new regexpp.RegExpParser();
const DOUBLE_SPACE = / {2***REMOVED***/u;

/**
 * Check if node is a string
 * @param {ASTNode***REMOVED*** node node to evaluate
 * @returns {boolean***REMOVED*** True if its a string
 * @private
 */
function isString(node) {
    return node && node.type === "Literal" && typeof node.value === "string";
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule***REMOVED*** */
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "Disallow multiple spaces in regular expressions",
            recommended: true,
            url: "https://eslint.org/docs/latest/rules/no-regex-spaces"
        ***REMOVED***,

        schema: [],
        fixable: "code",

        messages: {
            multipleSpaces: "Spaces are hard to count. Use {{{length***REMOVED******REMOVED******REMOVED***."
        ***REMOVED***
    ***REMOVED***,

    create(context) {

        const sourceCode = context.sourceCode;

        /**
         * Validate regular expression
         * @param {ASTNode***REMOVED*** nodeToReport Node to report.
         * @param {string***REMOVED*** pattern Regular expression pattern to validate.
         * @param {string***REMOVED*** rawPattern Raw representation of the pattern in the source code.
         * @param {number***REMOVED*** rawPatternStartRange Start range of the pattern in the source code.
         * @param {string***REMOVED*** flags Regular expression flags.
         * @returns {void***REMOVED***
         * @private
         */
        function checkRegex(nodeToReport, pattern, rawPattern, rawPatternStartRange, flags) {

            // Skip if there are no consecutive spaces in the source code, to avoid reporting e.g., RegExp(' \ ').
            if (!DOUBLE_SPACE.test(rawPattern)) {
                return;
            ***REMOVED***

            const characterClassNodes = [];
            let regExpAST;

            try {
                regExpAST = regExpParser.parsePattern(pattern, 0, pattern.length, { unicode: flags.includes("u"), unicodeSets: flags.includes("v") ***REMOVED***);
            ***REMOVED*** catch {

                // Ignore regular expressions with syntax errors
                return;
            ***REMOVED***

            regexpp.visitRegExpAST(regExpAST, {
                onCharacterClassEnter(ccNode) {
                    characterClassNodes.push(ccNode);
                ***REMOVED***
            ***REMOVED***);

            const spacesPattern = /( {2,***REMOVED***)(?: [+*{?]|[^+*{?]|$)/gu;
            let match;

            while ((match = spacesPattern.exec(pattern))) {
                const { 1: { length ***REMOVED***, index ***REMOVED*** = match;

                // Report only consecutive spaces that are not in character classes.
                if (
                    characterClassNodes.every(({ start, end ***REMOVED***) => index < start || end <= index)
                ) {
                    context.report({
                        node: nodeToReport,
                        messageId: "multipleSpaces",
                        data: { length ***REMOVED***,
                        fix(fixer) {
                            if (pattern !== rawPattern) {
                                return null;
                            ***REMOVED***
                            return fixer.replaceTextRange(
                                [rawPatternStartRange + index, rawPatternStartRange + index + length],
                                ` {${length***REMOVED******REMOVED***`
                            );
                        ***REMOVED***
                    ***REMOVED***);

                    // Report only the first occurrence of consecutive spaces
                    return;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Validate regular expression literals
         * @param {ASTNode***REMOVED*** node node to validate
         * @returns {void***REMOVED***
         * @private
         */
        function checkLiteral(node) {
            if (node.regex) {
                const pattern = node.regex.pattern;
                const rawPattern = node.raw.slice(1, node.raw.lastIndexOf("/"));
                const rawPatternStartRange = node.range[0] + 1;
                const flags = node.regex.flags;

                checkRegex(
                    node,
                    pattern,
                    rawPattern,
                    rawPatternStartRange,
                    flags
                );
            ***REMOVED***
        ***REMOVED***

        /**
         * Validate strings passed to the RegExp constructor
         * @param {ASTNode***REMOVED*** node node to validate
         * @returns {void***REMOVED***
         * @private
         */
        function checkFunction(node) {
            const scope = sourceCode.getScope(node);
            const regExpVar = astUtils.getVariableByName(scope, "RegExp");
            const shadowed = regExpVar && regExpVar.defs.length > 0;
            const patternNode = node.arguments[0];

            if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(patternNode) && !shadowed) {
                const pattern = patternNode.value;
                const rawPattern = patternNode.raw.slice(1, -1);
                const rawPatternStartRange = patternNode.range[0] + 1;
                let flags;

                if (node.arguments.length < 2) {

                    // It has no flags.
                    flags = "";
                ***REMOVED*** else {
                    const flagsNode = node.arguments[1];

                    if (isString(flagsNode)) {
                        flags = flagsNode.value;
                    ***REMOVED*** else {

                        // The flags cannot be determined.
                        return;
                    ***REMOVED***
                ***REMOVED***

                checkRegex(
                    node,
                    pattern,
                    rawPattern,
                    rawPatternStartRange,
                    flags
                );
            ***REMOVED***
        ***REMOVED***

        return {
            Literal: checkLiteral,
            CallExpression: checkFunction,
            NewExpression: checkFunction
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
