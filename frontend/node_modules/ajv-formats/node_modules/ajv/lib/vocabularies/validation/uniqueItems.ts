import type {CodeKeywordDefinition, ErrorObject, KeywordErrorDefinition***REMOVED*** from "../../types"
import type {KeywordCxt***REMOVED*** from "../../compile/validate"
import {checkDataTypes, getSchemaTypes, DataType***REMOVED*** from "../../compile/validate/dataType"
import {_, str, Name***REMOVED*** from "../../compile/codegen"
import {useFunc***REMOVED*** from "../../compile/util"
import equal from "../../runtime/equal"

export type UniqueItemsError = ErrorObject<
  "uniqueItems",
  {i: number; j: number***REMOVED***,
  boolean | {$data: string***REMOVED***
>

const error: KeywordErrorDefinition = {
  message: ({params: {i, j***REMOVED******REMOVED***) =>
    str`must NOT have duplicate items (items ## ${j***REMOVED*** and ${i***REMOVED*** are identical)`,
  params: ({params: {i, j***REMOVED******REMOVED***) => _`{i: ${i***REMOVED***, j: ${j***REMOVED******REMOVED***`,
***REMOVED***

const def: CodeKeywordDefinition = {
  keyword: "uniqueItems",
  type: "array",
  schemaType: "boolean",
  $data: true,
  error,
  code(cxt: KeywordCxt) {
    const {gen, data, $data, schema, parentSchema, schemaCode, it***REMOVED*** = cxt
    if (!$data && !schema) return
    const valid = gen.let("valid")
    const itemTypes = parentSchema.items ? getSchemaTypes(parentSchema.items) : []
    cxt.block$data(valid, validateUniqueItems, _`${schemaCode***REMOVED*** === false`)
    cxt.ok(valid)

    function validateUniqueItems(): void {
      const i = gen.let("i", _`${data***REMOVED***.length`)
      const j = gen.let("j")
      cxt.setParams({i, j***REMOVED***)
      gen.assign(valid, true)
      gen.if(_`${i***REMOVED*** > 1`, () => (canOptimize() ? loopN : loopN2)(i, j))
    ***REMOVED***

    function canOptimize(): boolean {
      return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array")
    ***REMOVED***

    function loopN(i: Name, j: Name): void {
      const item = gen.name("item")
      const wrongType = checkDataTypes(itemTypes, item, it.opts.strictNumbers, DataType.Wrong)
      const indices = gen.const("indices", _`{***REMOVED***`)
      gen.for(_`;${i***REMOVED***--;`, () => {
        gen.let(item, _`${data***REMOVED***[${i***REMOVED***]`)
        gen.if(wrongType, _`continue`)
        if (itemTypes.length > 1) gen.if(_`typeof ${item***REMOVED*** == "string"`, _`${item***REMOVED*** += "_"`)
        gen
          .if(_`typeof ${indices***REMOVED***[${item***REMOVED***] == "number"`, () => {
            gen.assign(j, _`${indices***REMOVED***[${item***REMOVED***]`)
            cxt.error()
            gen.assign(valid, false).break()
          ***REMOVED***)
          .code(_`${indices***REMOVED***[${item***REMOVED***] = ${i***REMOVED***`)
      ***REMOVED***)
    ***REMOVED***

    function loopN2(i: Name, j: Name): void {
      const eql = useFunc(gen, equal)
      const outer = gen.name("outer")
      gen.label(outer).for(_`;${i***REMOVED***--;`, () =>
        gen.for(_`${j***REMOVED*** = ${i***REMOVED***; ${j***REMOVED***--;`, () =>
          gen.if(_`${eql***REMOVED***(${data***REMOVED***[${i***REMOVED***], ${data***REMOVED***[${j***REMOVED***])`, () => {
            cxt.error()
            gen.assign(valid, false).break(outer)
          ***REMOVED***)
        )
      )
    ***REMOVED***
  ***REMOVED***,
***REMOVED***

export default def
