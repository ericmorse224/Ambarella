/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const versions = require("process").versions;
const Resolver = require("./Resolver");
const { getType, PathType ***REMOVED*** = require("./util/path");

const SyncAsyncFileSystemDecorator = require("./SyncAsyncFileSystemDecorator");

const AliasFieldPlugin = require("./AliasFieldPlugin");
const AliasPlugin = require("./AliasPlugin");
const AppendPlugin = require("./AppendPlugin");
const ConditionalPlugin = require("./ConditionalPlugin");
const DescriptionFilePlugin = require("./DescriptionFilePlugin");
const DirectoryExistsPlugin = require("./DirectoryExistsPlugin");
const ExportsFieldPlugin = require("./ExportsFieldPlugin");
const ExtensionAliasPlugin = require("./ExtensionAliasPlugin");
const FileExistsPlugin = require("./FileExistsPlugin");
const ImportsFieldPlugin = require("./ImportsFieldPlugin");
const JoinRequestPartPlugin = require("./JoinRequestPartPlugin");
const JoinRequestPlugin = require("./JoinRequestPlugin");
const MainFieldPlugin = require("./MainFieldPlugin");
const ModulesInHierarchicalDirectoriesPlugin = require("./ModulesInHierarchicalDirectoriesPlugin");
const ModulesInRootPlugin = require("./ModulesInRootPlugin");
const NextPlugin = require("./NextPlugin");
const ParsePlugin = require("./ParsePlugin");
const PnpPlugin = require("./PnpPlugin");
const RestrictionsPlugin = require("./RestrictionsPlugin");
const ResultPlugin = require("./ResultPlugin");
const RootsPlugin = require("./RootsPlugin");
const SelfReferencePlugin = require("./SelfReferencePlugin");
const SymlinkPlugin = require("./SymlinkPlugin");
const TryNextPlugin = require("./TryNextPlugin");
const UnsafeCachePlugin = require("./UnsafeCachePlugin");
const UseFilePlugin = require("./UseFilePlugin");

/** @typedef {import("./AliasPlugin").AliasOption***REMOVED*** AliasOptionEntry */
/** @typedef {import("./ExtensionAliasPlugin").ExtensionAliasOption***REMOVED*** ExtensionAliasOption */
/** @typedef {import("./PnpPlugin").PnpApiImpl***REMOVED*** PnpApi */
/** @typedef {import("./Resolver").EnsuredHooks***REMOVED*** EnsuredHooks */
/** @typedef {import("./Resolver").FileSystem***REMOVED*** FileSystem */
/** @typedef {import("./Resolver").KnownHooks***REMOVED*** KnownHooks */
/** @typedef {import("./Resolver").ResolveRequest***REMOVED*** ResolveRequest */
/** @typedef {import("./Resolver").SyncFileSystem***REMOVED*** SyncFileSystem */

/** @typedef {string|string[]|false***REMOVED*** AliasOptionNewRequest */
/** @typedef {{[k: string]: AliasOptionNewRequest***REMOVED******REMOVED*** AliasOptions */
/** @typedef {{[k: string]: string|string[] ***REMOVED******REMOVED*** ExtensionAliasOptions */
/** @typedef {false | 0 | "" | null | undefined***REMOVED*** Falsy */
/** @typedef {{apply: function(Resolver): void***REMOVED*** | (function(this: Resolver, Resolver): void) | Falsy***REMOVED*** Plugin */

/**
 * @typedef {Object***REMOVED*** UserResolveOptions
 * @property {(AliasOptions | AliasOptionEntry[])=***REMOVED*** alias A list of module alias configurations or an object which maps key to value
 * @property {(AliasOptions | AliasOptionEntry[])=***REMOVED*** fallback A list of module alias configurations or an object which maps key to value, applied only after modules option
 * @property {ExtensionAliasOptions=***REMOVED*** extensionAlias An object which maps extension to extension aliases
 * @property {(string | string[])[]=***REMOVED*** aliasFields A list of alias fields in description files
 * @property {(function(ResolveRequest): boolean)=***REMOVED*** cachePredicate A function which decides whether a request should be cached or not. An object is passed with at least `path` and `request` properties.
 * @property {boolean=***REMOVED*** cacheWithContext Whether or not the unsafeCache should include request context as part of the cache key.
 * @property {string[]=***REMOVED*** descriptionFiles A list of description files to read from
 * @property {string[]=***REMOVED*** conditionNames A list of exports field condition names.
 * @property {boolean=***REMOVED*** enforceExtension Enforce that a extension from extensions must be used
 * @property {(string | string[])[]=***REMOVED*** exportsFields A list of exports fields in description files
 * @property {(string | string[])[]=***REMOVED*** importsFields A list of imports fields in description files
 * @property {string[]=***REMOVED*** extensions A list of extensions which should be tried for files
 * @property {FileSystem***REMOVED*** fileSystem The file system which should be used
 * @property {(object | boolean)=***REMOVED*** unsafeCache Use this cache object to unsafely cache the successful requests
 * @property {boolean=***REMOVED*** symlinks Resolve symlinks to their symlinked location
 * @property {Resolver=***REMOVED*** resolver A prepared Resolver to which the plugins are attached
 * @property {string[] | string=***REMOVED*** modules A list of directories to resolve modules from, can be absolute path or folder name
 * @property {(string | string[] | {name: string | string[], forceRelative: boolean***REMOVED***)[]=***REMOVED*** mainFields A list of main fields in description files
 * @property {string[]=***REMOVED*** mainFiles  A list of main files in directories
 * @property {Plugin[]=***REMOVED*** plugins A list of additional resolve plugins which should be applied
 * @property {PnpApi | null=***REMOVED*** pnpApi A PnP API that should be used - null is "never", undefined is "auto"
 * @property {string[]=***REMOVED*** roots A list of root paths
 * @property {boolean=***REMOVED*** fullySpecified The request is already fully specified and no extensions or directories are resolved for it
 * @property {boolean=***REMOVED*** resolveToContext Resolve to a context instead of a file
 * @property {(string|RegExp)[]=***REMOVED*** restrictions A list of resolve restrictions
 * @property {boolean=***REMOVED*** useSyncFileSystemCalls Use only the sync constraints of the file system calls
 * @property {boolean=***REMOVED*** preferRelative Prefer to resolve module requests as relative requests before falling back to modules
 * @property {boolean=***REMOVED*** preferAbsolute Prefer to resolve server-relative urls as absolute paths before falling back to resolve in roots
 */

/**
 * @typedef {Object***REMOVED*** ResolveOptions
 * @property {AliasOptionEntry[]***REMOVED*** alias
 * @property {AliasOptionEntry[]***REMOVED*** fallback
 * @property {Set<string | string[]>***REMOVED*** aliasFields
 * @property {ExtensionAliasOption[]***REMOVED*** extensionAlias
 * @property {(function(ResolveRequest): boolean)***REMOVED*** cachePredicate
 * @property {boolean***REMOVED*** cacheWithContext
 * @property {Set<string>***REMOVED*** conditionNames A list of exports field condition names.
 * @property {string[]***REMOVED*** descriptionFiles
 * @property {boolean***REMOVED*** enforceExtension
 * @property {Set<string | string[]>***REMOVED*** exportsFields
 * @property {Set<string | string[]>***REMOVED*** importsFields
 * @property {Set<string>***REMOVED*** extensions
 * @property {FileSystem***REMOVED*** fileSystem
 * @property {object | false***REMOVED*** unsafeCache
 * @property {boolean***REMOVED*** symlinks
 * @property {Resolver=***REMOVED*** resolver
 * @property {Array<string | string[]>***REMOVED*** modules
 * @property {{name: string[], forceRelative: boolean***REMOVED***[]***REMOVED*** mainFields
 * @property {Set<string>***REMOVED*** mainFiles
 * @property {Plugin[]***REMOVED*** plugins
 * @property {PnpApi | null***REMOVED*** pnpApi
 * @property {Set<string>***REMOVED*** roots
 * @property {boolean***REMOVED*** fullySpecified
 * @property {boolean***REMOVED*** resolveToContext
 * @property {Set<string|RegExp>***REMOVED*** restrictions
 * @property {boolean***REMOVED*** preferRelative
 * @property {boolean***REMOVED*** preferAbsolute
 */

/**
 * @param {PnpApi | null=***REMOVED*** option option
 * @returns {PnpApi | null***REMOVED*** processed option
 */
function processPnpApiOption(option) {
	if (
		option === undefined &&
		/** @type {NodeJS.ProcessVersions & {pnp: string***REMOVED******REMOVED*** */ versions.pnp
	) {
		const _findPnpApi =
			/** @type {function(string): PnpApi | null***REMOVED******REMOVED*** */
			(
				// @ts-ignore
				require("module").findPnpApi
			);

		if (_findPnpApi) {
			return {
				resolveToUnqualified(request, issuer, opts) {
					const pnpapi = _findPnpApi(issuer);

					if (!pnpapi) {
						// Issuer isn't managed by PnP
						return null;
					***REMOVED***

					return pnpapi.resolveToUnqualified(request, issuer, opts);
				***REMOVED***
			***REMOVED***;
		***REMOVED***
	***REMOVED***

	return option || null;
***REMOVED***

/**
 * @param {AliasOptions | AliasOptionEntry[] | undefined***REMOVED*** alias alias
 * @returns {AliasOptionEntry[]***REMOVED*** normalized aliases
 */
function normalizeAlias(alias) {
	return typeof alias === "object" && !Array.isArray(alias) && alias !== null
		? Object.keys(alias).map(key => {
				/** @type {AliasOptionEntry***REMOVED*** */
				const obj = { name: key, onlyModule: false, alias: alias[key] ***REMOVED***;

				if (/\$$/.test(key)) {
					obj.onlyModule = true;
					obj.name = key.slice(0, -1);
				***REMOVED***

				return obj;
		  ***REMOVED***)
		: /** @type {Array<AliasOptionEntry>***REMOVED*** */ (alias) || [];
***REMOVED***

/**
 * @param {UserResolveOptions***REMOVED*** options input options
 * @returns {ResolveOptions***REMOVED*** output options
 */
function createOptions(options) {
	const mainFieldsSet = new Set(options.mainFields || ["main"]);
	/** @type {ResolveOptions["mainFields"]***REMOVED*** */
	const mainFields = [];

	for (const item of mainFieldsSet) {
		if (typeof item === "string") {
			mainFields.push({
				name: [item],
				forceRelative: true
			***REMOVED***);
		***REMOVED*** else if (Array.isArray(item)) {
			mainFields.push({
				name: item,
				forceRelative: true
			***REMOVED***);
		***REMOVED*** else {
			mainFields.push({
				name: Array.isArray(item.name) ? item.name : [item.name],
				forceRelative: item.forceRelative
			***REMOVED***);
		***REMOVED***
	***REMOVED***

	return {
		alias: normalizeAlias(options.alias),
		fallback: normalizeAlias(options.fallback),
		aliasFields: new Set(options.aliasFields),
		cachePredicate:
			options.cachePredicate ||
			function () {
				return true;
			***REMOVED***,
		cacheWithContext:
			typeof options.cacheWithContext !== "undefined"
				? options.cacheWithContext
				: true,
		exportsFields: new Set(options.exportsFields || ["exports"]),
		importsFields: new Set(options.importsFields || ["imports"]),
		conditionNames: new Set(options.conditionNames),
		descriptionFiles: Array.from(
			new Set(options.descriptionFiles || ["package.json"])
		),
		enforceExtension:
			options.enforceExtension === undefined
				? options.extensions && options.extensions.includes("")
					? true
					: false
				: options.enforceExtension,
		extensions: new Set(options.extensions || [".js", ".json", ".node"]),
		extensionAlias: options.extensionAlias
			? Object.keys(options.extensionAlias).map(k => ({
					extension: k,
					alias: /** @type {ExtensionAliasOptions***REMOVED*** */ (options.extensionAlias)[
						k
					]
			  ***REMOVED***))
			: [],
		fileSystem: options.useSyncFileSystemCalls
			? new SyncAsyncFileSystemDecorator(
					/** @type {SyncFileSystem***REMOVED*** */ (
						/** @type {unknown***REMOVED*** */ (options.fileSystem)
					)
			  )
			: options.fileSystem,
		unsafeCache:
			options.unsafeCache && typeof options.unsafeCache !== "object"
				? {***REMOVED***
				: options.unsafeCache || false,
		symlinks: typeof options.symlinks !== "undefined" ? options.symlinks : true,
		resolver: options.resolver,
		modules: mergeFilteredToArray(
			Array.isArray(options.modules)
				? options.modules
				: options.modules
				? [options.modules]
				: ["node_modules"],
			item => {
				const type = getType(item);
				return type === PathType.Normal || type === PathType.Relative;
			***REMOVED***
		),
		mainFields,
		mainFiles: new Set(options.mainFiles || ["index"]),
		plugins: options.plugins || [],
		pnpApi: processPnpApiOption(options.pnpApi),
		roots: new Set(options.roots || undefined),
		fullySpecified: options.fullySpecified || false,
		resolveToContext: options.resolveToContext || false,
		preferRelative: options.preferRelative || false,
		preferAbsolute: options.preferAbsolute || false,
		restrictions: new Set(options.restrictions)
	***REMOVED***;
***REMOVED***

/**
 * @param {UserResolveOptions***REMOVED*** options resolve options
 * @returns {Resolver***REMOVED*** created resolver
 */
exports.createResolver = function (options) {
	const normalizedOptions = createOptions(options);

	const {
		alias,
		fallback,
		aliasFields,
		cachePredicate,
		cacheWithContext,
		conditionNames,
		descriptionFiles,
		enforceExtension,
		exportsFields,
		extensionAlias,
		importsFields,
		extensions,
		fileSystem,
		fullySpecified,
		mainFields,
		mainFiles,
		modules,
		plugins: userPlugins,
		pnpApi,
		resolveToContext,
		preferRelative,
		preferAbsolute,
		symlinks,
		unsafeCache,
		resolver: customResolver,
		restrictions,
		roots
	***REMOVED*** = normalizedOptions;

	const plugins = userPlugins.slice();

	const resolver = customResolver
		? customResolver
		: new Resolver(fileSystem, normalizedOptions);

	//// pipeline ////

	resolver.ensureHook("resolve");
	resolver.ensureHook("internalResolve");
	resolver.ensureHook("newInternalResolve");
	resolver.ensureHook("parsedResolve");
	resolver.ensureHook("describedResolve");
	resolver.ensureHook("rawResolve");
	resolver.ensureHook("normalResolve");
	resolver.ensureHook("internal");
	resolver.ensureHook("rawModule");
	resolver.ensureHook("alternateRawModule");
	resolver.ensureHook("module");
	resolver.ensureHook("resolveAsModule");
	resolver.ensureHook("undescribedResolveInPackage");
	resolver.ensureHook("resolveInPackage");
	resolver.ensureHook("resolveInExistingDirectory");
	resolver.ensureHook("relative");
	resolver.ensureHook("describedRelative");
	resolver.ensureHook("directory");
	resolver.ensureHook("undescribedExistingDirectory");
	resolver.ensureHook("existingDirectory");
	resolver.ensureHook("undescribedRawFile");
	resolver.ensureHook("rawFile");
	resolver.ensureHook("file");
	resolver.ensureHook("finalFile");
	resolver.ensureHook("existingFile");
	resolver.ensureHook("resolved");

	// TODO remove in next major
	// cspell:word Interal
	// Backward-compat
	// @ts-ignore
	resolver.hooks.newInteralResolve = resolver.hooks.newInternalResolve;

	// resolve
	for (const { source, resolveOptions ***REMOVED*** of [
		{ source: "resolve", resolveOptions: { fullySpecified ***REMOVED*** ***REMOVED***,
		{ source: "internal-resolve", resolveOptions: { fullySpecified: false ***REMOVED*** ***REMOVED***
	]) {
		if (unsafeCache) {
			plugins.push(
				new UnsafeCachePlugin(
					source,
					cachePredicate,
					/** @type {import("./UnsafeCachePlugin").Cache***REMOVED*** */ (unsafeCache),
					cacheWithContext,
					`new-${source***REMOVED***`
				)
			);
			plugins.push(
				new ParsePlugin(`new-${source***REMOVED***`, resolveOptions, "parsed-resolve")
			);
		***REMOVED*** else {
			plugins.push(new ParsePlugin(source, resolveOptions, "parsed-resolve"));
		***REMOVED***
	***REMOVED***

	// parsed-resolve
	plugins.push(
		new DescriptionFilePlugin(
			"parsed-resolve",
			descriptionFiles,
			false,
			"described-resolve"
		)
	);
	plugins.push(new NextPlugin("after-parsed-resolve", "described-resolve"));

	// described-resolve
	plugins.push(new NextPlugin("described-resolve", "raw-resolve"));
	if (fallback.length > 0) {
		plugins.push(
			new AliasPlugin("described-resolve", fallback, "internal-resolve")
		);
	***REMOVED***

	// raw-resolve
	if (alias.length > 0) {
		plugins.push(new AliasPlugin("raw-resolve", alias, "internal-resolve"));
	***REMOVED***
	aliasFields.forEach(item => {
		plugins.push(new AliasFieldPlugin("raw-resolve", item, "internal-resolve"));
	***REMOVED***);
	extensionAlias.forEach(item =>
		plugins.push(
			new ExtensionAliasPlugin("raw-resolve", item, "normal-resolve")
		)
	);
	plugins.push(new NextPlugin("raw-resolve", "normal-resolve"));

	// normal-resolve
	if (preferRelative) {
		plugins.push(new JoinRequestPlugin("after-normal-resolve", "relative"));
	***REMOVED***
	plugins.push(
		new ConditionalPlugin(
			"after-normal-resolve",
			{ module: true ***REMOVED***,
			"resolve as module",
			false,
			"raw-module"
		)
	);
	plugins.push(
		new ConditionalPlugin(
			"after-normal-resolve",
			{ internal: true ***REMOVED***,
			"resolve as internal import",
			false,
			"internal"
		)
	);
	if (preferAbsolute) {
		plugins.push(new JoinRequestPlugin("after-normal-resolve", "relative"));
	***REMOVED***
	if (roots.size > 0) {
		plugins.push(new RootsPlugin("after-normal-resolve", roots, "relative"));
	***REMOVED***
	if (!preferRelative && !preferAbsolute) {
		plugins.push(new JoinRequestPlugin("after-normal-resolve", "relative"));
	***REMOVED***

	// internal
	importsFields.forEach(importsField => {
		plugins.push(
			new ImportsFieldPlugin(
				"internal",
				conditionNames,
				importsField,
				"relative",
				"internal-resolve"
			)
		);
	***REMOVED***);

	// raw-module
	exportsFields.forEach(exportsField => {
		plugins.push(
			new SelfReferencePlugin("raw-module", exportsField, "resolve-as-module")
		);
	***REMOVED***);
	modules.forEach(item => {
		if (Array.isArray(item)) {
			if (item.includes("node_modules") && pnpApi) {
				plugins.push(
					new ModulesInHierarchicalDirectoriesPlugin(
						"raw-module",
						item.filter(i => i !== "node_modules"),
						"module"
					)
				);
				plugins.push(
					new PnpPlugin(
						"raw-module",
						pnpApi,
						"undescribed-resolve-in-package",
						"alternate-raw-module"
					)
				);

				plugins.push(
					new ModulesInHierarchicalDirectoriesPlugin(
						"alternate-raw-module",
						["node_modules"],
						"module"
					)
				);
			***REMOVED*** else {
				plugins.push(
					new ModulesInHierarchicalDirectoriesPlugin(
						"raw-module",
						item,
						"module"
					)
				);
			***REMOVED***
		***REMOVED*** else {
			plugins.push(new ModulesInRootPlugin("raw-module", item, "module"));
		***REMOVED***
	***REMOVED***);

	// module
	plugins.push(new JoinRequestPartPlugin("module", "resolve-as-module"));

	// resolve-as-module
	if (!resolveToContext) {
		plugins.push(
			new ConditionalPlugin(
				"resolve-as-module",
				{ directory: false, request: "." ***REMOVED***,
				"single file module",
				true,
				"undescribed-raw-file"
			)
		);
	***REMOVED***
	plugins.push(
		new DirectoryExistsPlugin(
			"resolve-as-module",
			"undescribed-resolve-in-package"
		)
	);

	// undescribed-resolve-in-package
	plugins.push(
		new DescriptionFilePlugin(
			"undescribed-resolve-in-package",
			descriptionFiles,
			false,
			"resolve-in-package"
		)
	);
	plugins.push(
		new NextPlugin("after-undescribed-resolve-in-package", "resolve-in-package")
	);

	// resolve-in-package
	exportsFields.forEach(exportsField => {
		plugins.push(
			new ExportsFieldPlugin(
				"resolve-in-package",
				conditionNames,
				exportsField,
				"relative"
			)
		);
	***REMOVED***);
	plugins.push(
		new NextPlugin("resolve-in-package", "resolve-in-existing-directory")
	);

	// resolve-in-existing-directory
	plugins.push(
		new JoinRequestPlugin("resolve-in-existing-directory", "relative")
	);

	// relative
	plugins.push(
		new DescriptionFilePlugin(
			"relative",
			descriptionFiles,
			true,
			"described-relative"
		)
	);
	plugins.push(new NextPlugin("after-relative", "described-relative"));

	// described-relative
	if (resolveToContext) {
		plugins.push(new NextPlugin("described-relative", "directory"));
	***REMOVED*** else {
		plugins.push(
			new ConditionalPlugin(
				"described-relative",
				{ directory: false ***REMOVED***,
				null,
				true,
				"raw-file"
			)
		);
		plugins.push(
			new ConditionalPlugin(
				"described-relative",
				{ fullySpecified: false ***REMOVED***,
				"as directory",
				true,
				"directory"
			)
		);
	***REMOVED***

	// directory
	plugins.push(
		new DirectoryExistsPlugin("directory", "undescribed-existing-directory")
	);

	if (resolveToContext) {
		// undescribed-existing-directory
		plugins.push(new NextPlugin("undescribed-existing-directory", "resolved"));
	***REMOVED*** else {
		// undescribed-existing-directory
		plugins.push(
			new DescriptionFilePlugin(
				"undescribed-existing-directory",
				descriptionFiles,
				false,
				"existing-directory"
			)
		);
		mainFiles.forEach(item => {
			plugins.push(
				new UseFilePlugin(
					"undescribed-existing-directory",
					item,
					"undescribed-raw-file"
				)
			);
		***REMOVED***);

		// described-existing-directory
		mainFields.forEach(item => {
			plugins.push(
				new MainFieldPlugin(
					"existing-directory",
					item,
					"resolve-in-existing-directory"
				)
			);
		***REMOVED***);
		mainFiles.forEach(item => {
			plugins.push(
				new UseFilePlugin("existing-directory", item, "undescribed-raw-file")
			);
		***REMOVED***);

		// undescribed-raw-file
		plugins.push(
			new DescriptionFilePlugin(
				"undescribed-raw-file",
				descriptionFiles,
				true,
				"raw-file"
			)
		);
		plugins.push(new NextPlugin("after-undescribed-raw-file", "raw-file"));

		// raw-file
		plugins.push(
			new ConditionalPlugin(
				"raw-file",
				{ fullySpecified: true ***REMOVED***,
				null,
				false,
				"file"
			)
		);
		if (!enforceExtension) {
			plugins.push(new TryNextPlugin("raw-file", "no extension", "file"));
		***REMOVED***
		extensions.forEach(item => {
			plugins.push(new AppendPlugin("raw-file", item, "file"));
		***REMOVED***);

		// file
		if (alias.length > 0)
			plugins.push(new AliasPlugin("file", alias, "internal-resolve"));
		aliasFields.forEach(item => {
			plugins.push(new AliasFieldPlugin("file", item, "internal-resolve"));
		***REMOVED***);
		plugins.push(new NextPlugin("file", "final-file"));

		// final-file
		plugins.push(new FileExistsPlugin("final-file", "existing-file"));

		// existing-file
		if (symlinks)
			plugins.push(new SymlinkPlugin("existing-file", "existing-file"));
		plugins.push(new NextPlugin("existing-file", "resolved"));
	***REMOVED***

	const resolved =
		/** @type {KnownHooks & EnsuredHooks***REMOVED*** */
		(resolver.hooks).resolved;

	// resolved
	if (restrictions.size > 0) {
		plugins.push(new RestrictionsPlugin(resolved, restrictions));
	***REMOVED***

	plugins.push(new ResultPlugin(resolved));

	//// RESOLVER ////

	for (const plugin of plugins) {
		if (typeof plugin === "function") {
			/** @type {function(this: Resolver, Resolver): void***REMOVED*** */
			(plugin).call(resolver, resolver);
		***REMOVED*** else if (plugin) {
			plugin.apply(resolver);
		***REMOVED***
	***REMOVED***

	return resolver;
***REMOVED***;

/**
 * Merging filtered elements
 * @param {string[]***REMOVED*** array source array
 * @param {function(string): boolean***REMOVED*** filter predicate
 * @returns {Array<string | string[]>***REMOVED*** merge result
 */
function mergeFilteredToArray(array, filter) {
	/** @type {Array<string | string[]>***REMOVED*** */
	const result = [];
	const set = new Set(array);

	for (const item of set) {
		if (filter(item)) {
			const lastElement =
				result.length > 0 ? result[result.length - 1] : undefined;
			if (Array.isArray(lastElement)) {
				lastElement.push(item);
			***REMOVED*** else {
				result.push([item]);
			***REMOVED***
		***REMOVED*** else {
			result.push(item);
		***REMOVED***
	***REMOVED***

	return result;
***REMOVED***
