/**
 * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval
 * @author James Allardice
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");
const { getStaticValue ***REMOVED*** = require("@eslint-community/eslint-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule***REMOVED*** */
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "Disallow the use of `eval()`-like methods",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/no-implied-eval"
        ***REMOVED***,

        schema: [],

        messages: {
            impliedEval: "Implied eval. Consider passing a function instead of a string."
        ***REMOVED***
    ***REMOVED***,

    create(context) {
        const GLOBAL_CANDIDATES = Object.freeze(["global", "window", "globalThis"]);
        const EVAL_LIKE_FUNC_PATTERN = /^(?:set(?:Interval|Timeout)|execScript)$/u;
        const sourceCode = context.sourceCode;

        /**
         * Checks whether a node is evaluated as a string or not.
         * @param {ASTNode***REMOVED*** node A node to check.
         * @returns {boolean***REMOVED*** True if the node is evaluated as a string.
         */
        function isEvaluatedString(node) {
            if (
                (node.type === "Literal" && typeof node.value === "string") ||
                node.type === "TemplateLiteral"
            ) {
                return true;
            ***REMOVED***
            if (node.type === "BinaryExpression" && node.operator === "+") {
                return isEvaluatedString(node.left) || isEvaluatedString(node.right);
            ***REMOVED***
            return false;
        ***REMOVED***

        /**
         * Reports if the `CallExpression` node has evaluated argument.
         * @param {ASTNode***REMOVED*** node A CallExpression to check.
         * @returns {void***REMOVED***
         */
        function reportImpliedEvalCallExpression(node) {
            const [firstArgument] = node.arguments;

            if (firstArgument) {

                const staticValue = getStaticValue(firstArgument, sourceCode.getScope(node));
                const isStaticString = staticValue && typeof staticValue.value === "string";
                const isString = isStaticString || isEvaluatedString(firstArgument);

                if (isString) {
                    context.report({
                        node,
                        messageId: "impliedEval"
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***

        ***REMOVED***

        /**
         * Reports calls of `implied eval` via the global references.
         * @param {Variable***REMOVED*** globalVar A global variable to check.
         * @returns {void***REMOVED***
         */
        function reportImpliedEvalViaGlobal(globalVar) {
            const { references, name ***REMOVED*** = globalVar;

            references.forEach(ref => {
                const identifier = ref.identifier;
                let node = identifier.parent;

                while (astUtils.isSpecificMemberAccess(node, null, name)) {
                    node = node.parent;
                ***REMOVED***

                if (astUtils.isSpecificMemberAccess(node, null, EVAL_LIKE_FUNC_PATTERN)) {
                    const calleeNode = node.parent.type === "ChainExpression" ? node.parent : node;
                    const parent = calleeNode.parent;

                    if (parent.type === "CallExpression" && parent.callee === calleeNode) {
                        reportImpliedEvalCallExpression(parent);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return {
            CallExpression(node) {
                if (astUtils.isSpecificId(node.callee, EVAL_LIKE_FUNC_PATTERN)) {
                    reportImpliedEvalCallExpression(node);
                ***REMOVED***
            ***REMOVED***,
            "Program:exit"(node) {
                const globalScope = sourceCode.getScope(node);

                GLOBAL_CANDIDATES
                    .map(candidate => astUtils.getVariableByName(globalScope, candidate))
                    .filter(globalVar => !!globalVar && globalVar.defs.length === 0)
                    .forEach(reportImpliedEvalViaGlobal);
            ***REMOVED***
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
