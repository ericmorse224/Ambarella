/*
 * EJS Embedded JavaScript templates
 * Copyright 2112 Matthew Eernisse (mde@fleegix.org)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
*/

/**
 * Private utility functions
 * @module utils
 * @private
 */

'use strict';

var regExpChars = /[|\\{***REMOVED***()[\]^$+*?.]/g;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var hasOwn = function (obj, key) { return hasOwnProperty.apply(obj, [key]); ***REMOVED***;

/**
 * Escape characters reserved in regular expressions.
 *
 * If `string` is `undefined` or `null`, the empty string is returned.
 *
 * @param {String***REMOVED*** string Input string
 * @return {String***REMOVED*** Escaped string
 * @static
 * @private
 */
exports.escapeRegExpChars = function (string) {
  // istanbul ignore if
  if (!string) {
    return '';
  ***REMOVED***
  return String(string).replace(regExpChars, '\\$&');
***REMOVED***;

var _ENCODE_HTML_RULES = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&#34;',
  "'": '&#39;'
***REMOVED***;
var _MATCH_HTML = /[&<>'"]/g;

function encode_char(c) {
  return _ENCODE_HTML_RULES[c] || c;
***REMOVED***

/**
 * Stringified version of constants used by {@link module:utils.escapeXML***REMOVED***.
 *
 * It is used in the process of generating {@link ClientFunction***REMOVED***s.
 *
 * @readonly
 * @type {String***REMOVED***
 */

var escapeFuncStr =
  'var _ENCODE_HTML_RULES = {\n'
+ '      "&": "&amp;"\n'
+ '    , "<": "&lt;"\n'
+ '    , ">": "&gt;"\n'
+ '    , \'"\': "&#34;"\n'
+ '    , "\'": "&#39;"\n'
+ '    ***REMOVED***\n'
+ '  , _MATCH_HTML = /[&<>\'"]/g;\n'
+ 'function encode_char(c) {\n'
+ '  return _ENCODE_HTML_RULES[c] || c;\n'
+ '***REMOVED***;\n';

/**
 * Escape characters reserved in XML.
 *
 * If `markup` is `undefined` or `null`, the empty string is returned.
 *
 * @implements {EscapeCallback***REMOVED***
 * @param {String***REMOVED*** markup Input string
 * @return {String***REMOVED*** Escaped string
 * @static
 * @private
 */

exports.escapeXML = function (markup) {
  return markup == undefined
    ? ''
    : String(markup)
      .replace(_MATCH_HTML, encode_char);
***REMOVED***;

function escapeXMLToString() {
  return Function.prototype.toString.call(this) + ';\n' + escapeFuncStr;
***REMOVED***

try {
  if (typeof Object.defineProperty === 'function') {
  // If the Function prototype is frozen, the "toString" property is non-writable. This means that any objects which inherit this property
  // cannot have the property changed using an assignment. If using strict mode, attempting that will cause an error. If not using strict
  // mode, attempting that will be silently ignored.
  // However, we can still explicitly shadow the prototype's "toString" property by defining a new "toString" property on this object.
    Object.defineProperty(exports.escapeXML, 'toString', { value: escapeXMLToString ***REMOVED***);
  ***REMOVED*** else {
    // If Object.defineProperty() doesn't exist, attempt to shadow this property using the assignment operator.
    exports.escapeXML.toString = escapeXMLToString;
  ***REMOVED***
***REMOVED*** catch (err) {
  console.warn('Unable to set escapeXML.toString (is the Function prototype frozen?)');
***REMOVED***

/**
 * Naive copy of properties from one object to another.
 * Does not recurse into non-scalar properties
 * Does not check to see if the property has a value before copying
 *
 * @param  {Object***REMOVED*** to   Destination object
 * @param  {Object***REMOVED*** from Source object
 * @return {Object***REMOVED***      Destination object
 * @static
 * @private
 */
exports.shallowCopy = function (to, from) {
  from = from || {***REMOVED***;
  if ((to !== null) && (to !== undefined)) {
    for (var p in from) {
      if (!hasOwn(from, p)) {
        continue;
      ***REMOVED***
      if (p === '__proto__' || p === 'constructor') {
        continue;
      ***REMOVED***
      to[p] = from[p];
    ***REMOVED***
  ***REMOVED***
  return to;
***REMOVED***;

/**
 * Naive copy of a list of key names, from one object to another.
 * Only copies property if it is actually defined
 * Does not recurse into non-scalar properties
 *
 * @param  {Object***REMOVED*** to   Destination object
 * @param  {Object***REMOVED*** from Source object
 * @param  {Array***REMOVED*** list List of properties to copy
 * @return {Object***REMOVED***      Destination object
 * @static
 * @private
 */
exports.shallowCopyFromList = function (to, from, list) {
  list = list || [];
  from = from || {***REMOVED***;
  if ((to !== null) && (to !== undefined)) {
    for (var i = 0; i < list.length; i++) {
      var p = list[i];
      if (typeof from[p] != 'undefined') {
        if (!hasOwn(from, p)) {
          continue;
        ***REMOVED***
        if (p === '__proto__' || p === 'constructor') {
          continue;
        ***REMOVED***
        to[p] = from[p];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return to;
***REMOVED***;

/**
 * Simple in-process cache implementation. Does not implement limits of any
 * sort.
 *
 * @implements {Cache***REMOVED***
 * @static
 * @private
 */
exports.cache = {
  _data: {***REMOVED***,
  set: function (key, val) {
    this._data[key] = val;
  ***REMOVED***,
  get: function (key) {
    return this._data[key];
  ***REMOVED***,
  remove: function (key) {
    delete this._data[key];
  ***REMOVED***,
  reset: function () {
    this._data = {***REMOVED***;
  ***REMOVED***
***REMOVED***;

/**
 * Transforms hyphen case variable into camel case.
 *
 * @param {String***REMOVED*** string Hyphen case string
 * @return {String***REMOVED*** Camel case string
 * @static
 * @private
 */
exports.hyphenToCamel = function (str) {
  return str.replace(/-[a-z]/g, function (match) { return match[1].toUpperCase(); ***REMOVED***);
***REMOVED***;

/**
 * Returns a null-prototype object in runtimes that support it
 *
 * @return {Object***REMOVED*** Object, prototype will be set to null where possible
 * @static
 * @private
 */
exports.createNullProtoObjWherePossible = (function () {
  if (typeof Object.create == 'function') {
    return function () {
      return Object.create(null);
    ***REMOVED***;
  ***REMOVED***
  if (!({__proto__: null***REMOVED*** instanceof Object)) {
    return function () {
      return {__proto__: null***REMOVED***;
    ***REMOVED***;
  ***REMOVED***
  // Not possible, just pass through
  return function () {
    return {***REMOVED***;
  ***REMOVED***;
***REMOVED***)();

exports.hasOwnOnlyObject = function (obj) {
  var o = exports.createNullProtoObjWherePossible();
  for (var p in obj) {
    if (hasOwn(obj, p)) {
      o[p] = obj[p];
    ***REMOVED***
  ***REMOVED***
  return o;
***REMOVED***;

