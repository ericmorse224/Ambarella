import type {
  KeywordErrorDefinition,
  KeywordErrorCxt,
  ErrorObject,
  AnySchemaObject,
***REMOVED*** from "../../types"
import type {SchemaObjCxt***REMOVED*** from ".."
import {isJSONType, JSONType***REMOVED*** from "../rules"
import {schemaHasRulesForType***REMOVED*** from "./applicability"
import {reportError***REMOVED*** from "../errors"
import {_, nil, and, not, operators, Code, Name***REMOVED*** from "../codegen"
import {toHash, schemaRefOrVal***REMOVED*** from "../util"

export enum DataType {
  Correct,
  Wrong,
***REMOVED***

export function getSchemaTypes(schema: AnySchemaObject): JSONType[] {
  const types = getJSONTypes(schema.type)
  const hasNull = types.includes("null")
  if (hasNull) {
    if (schema.nullable === false) throw new Error("type: null contradicts nullable: false")
  ***REMOVED*** else {
    if (!types.length && schema.nullable !== undefined) {
      throw new Error('"nullable" cannot be used without "type"')
    ***REMOVED***
    if (schema.nullable === true) types.push("null")
  ***REMOVED***
  return types
***REMOVED***

// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents
export function getJSONTypes(ts: unknown | unknown[]): JSONType[] {
  const types: unknown[] = Array.isArray(ts) ? ts : ts ? [ts] : []
  if (types.every(isJSONType)) return types
  throw new Error("type must be JSONType or JSONType[]: " + types.join(","))
***REMOVED***

export function coerceAndCheckDataType(it: SchemaObjCxt, types: JSONType[]): boolean {
  const {gen, data, opts***REMOVED*** = it
  const coerceTo = coerceToTypes(types, opts.coerceTypes)
  const checkTypes =
    types.length > 0 &&
    !(coerceTo.length === 0 && types.length === 1 && schemaHasRulesForType(it, types[0]))
  if (checkTypes) {
    const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong)
    gen.if(wrongType, () => {
      if (coerceTo.length) coerceData(it, types, coerceTo)
      else reportTypeError(it)
    ***REMOVED***)
  ***REMOVED***
  return checkTypes
***REMOVED***

const COERCIBLE: Set<JSONType> = new Set(["string", "number", "integer", "boolean", "null"])
function coerceToTypes(types: JSONType[], coerceTypes?: boolean | "array"): JSONType[] {
  return coerceTypes
    ? types.filter((t) => COERCIBLE.has(t) || (coerceTypes === "array" && t === "array"))
    : []
***REMOVED***

function coerceData(it: SchemaObjCxt, types: JSONType[], coerceTo: JSONType[]): void {
  const {gen, data, opts***REMOVED*** = it
  const dataType = gen.let("dataType", _`typeof ${data***REMOVED***`)
  const coerced = gen.let("coerced", _`undefined`)
  if (opts.coerceTypes === "array") {
    gen.if(_`${dataType***REMOVED*** == 'object' && Array.isArray(${data***REMOVED***) && ${data***REMOVED***.length == 1`, () =>
      gen
        .assign(data, _`${data***REMOVED***[0]`)
        .assign(dataType, _`typeof ${data***REMOVED***`)
        .if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))
    )
  ***REMOVED***
  gen.if(_`${coerced***REMOVED*** !== undefined`)
  for (const t of coerceTo) {
    if (COERCIBLE.has(t) || (t === "array" && opts.coerceTypes === "array")) {
      coerceSpecificType(t)
    ***REMOVED***
  ***REMOVED***
  gen.else()
  reportTypeError(it)
  gen.endIf()

  gen.if(_`${coerced***REMOVED*** !== undefined`, () => {
    gen.assign(data, coerced)
    assignParentData(it, coerced)
  ***REMOVED***)

  function coerceSpecificType(t: string): void {
    switch (t) {
      case "string":
        gen
          .elseIf(_`${dataType***REMOVED*** == "number" || ${dataType***REMOVED*** == "boolean"`)
          .assign(coerced, _`"" + ${data***REMOVED***`)
          .elseIf(_`${data***REMOVED*** === null`)
          .assign(coerced, _`""`)
        return
      case "number":
        gen
          .elseIf(
            _`${dataType***REMOVED*** == "boolean" || ${data***REMOVED*** === null
              || (${dataType***REMOVED*** == "string" && ${data***REMOVED*** && ${data***REMOVED*** == +${data***REMOVED***)`
          )
          .assign(coerced, _`+${data***REMOVED***`)
        return
      case "integer":
        gen
          .elseIf(
            _`${dataType***REMOVED*** === "boolean" || ${data***REMOVED*** === null
              || (${dataType***REMOVED*** === "string" && ${data***REMOVED*** && ${data***REMOVED*** == +${data***REMOVED*** && !(${data***REMOVED*** % 1))`
          )
          .assign(coerced, _`+${data***REMOVED***`)
        return
      case "boolean":
        gen
          .elseIf(_`${data***REMOVED*** === "false" || ${data***REMOVED*** === 0 || ${data***REMOVED*** === null`)
          .assign(coerced, false)
          .elseIf(_`${data***REMOVED*** === "true" || ${data***REMOVED*** === 1`)
          .assign(coerced, true)
        return
      case "null":
        gen.elseIf(_`${data***REMOVED*** === "" || ${data***REMOVED*** === 0 || ${data***REMOVED*** === false`)
        gen.assign(coerced, null)
        return

      case "array":
        gen
          .elseIf(
            _`${dataType***REMOVED*** === "string" || ${dataType***REMOVED*** === "number"
              || ${dataType***REMOVED*** === "boolean" || ${data***REMOVED*** === null`
          )
          .assign(coerced, _`[${data***REMOVED***]`)
    ***REMOVED***
  ***REMOVED***
***REMOVED***

function assignParentData({gen, parentData, parentDataProperty***REMOVED***: SchemaObjCxt, expr: Name): void {
  // TODO use gen.property
  gen.if(_`${parentData***REMOVED*** !== undefined`, () =>
    gen.assign(_`${parentData***REMOVED***[${parentDataProperty***REMOVED***]`, expr)
  )
***REMOVED***

export function checkDataType(
  dataType: JSONType,
  data: Name,
  strictNums?: boolean | "log",
  correct = DataType.Correct
): Code {
  const EQ = correct === DataType.Correct ? operators.EQ : operators.NEQ
  let cond: Code
  switch (dataType) {
    case "null":
      return _`${data***REMOVED*** ${EQ***REMOVED*** null`
    case "array":
      cond = _`Array.isArray(${data***REMOVED***)`
      break
    case "object":
      cond = _`${data***REMOVED*** && typeof ${data***REMOVED*** == "object" && !Array.isArray(${data***REMOVED***)`
      break
    case "integer":
      cond = numCond(_`!(${data***REMOVED*** % 1) && !isNaN(${data***REMOVED***)`)
      break
    case "number":
      cond = numCond()
      break
    default:
      return _`typeof ${data***REMOVED*** ${EQ***REMOVED*** ${dataType***REMOVED***`
  ***REMOVED***
  return correct === DataType.Correct ? cond : not(cond)

  function numCond(_cond: Code = nil): Code {
    return and(_`typeof ${data***REMOVED*** == "number"`, _cond, strictNums ? _`isFinite(${data***REMOVED***)` : nil)
  ***REMOVED***
***REMOVED***

export function checkDataTypes(
  dataTypes: JSONType[],
  data: Name,
  strictNums?: boolean | "log",
  correct?: DataType
): Code {
  if (dataTypes.length === 1) {
    return checkDataType(dataTypes[0], data, strictNums, correct)
  ***REMOVED***
  let cond: Code
  const types = toHash(dataTypes)
  if (types.array && types.object) {
    const notObj = _`typeof ${data***REMOVED*** != "object"`
    cond = types.null ? notObj : _`!${data***REMOVED*** || ${notObj***REMOVED***`
    delete types.null
    delete types.array
    delete types.object
  ***REMOVED*** else {
    cond = nil
  ***REMOVED***
  if (types.number) delete types.integer
  for (const t in types) cond = and(cond, checkDataType(t as JSONType, data, strictNums, correct))
  return cond
***REMOVED***

export type TypeError = ErrorObject<"type", {type: string***REMOVED***>

const typeError: KeywordErrorDefinition = {
  message: ({schema***REMOVED***) => `must be ${schema***REMOVED***`,
  params: ({schema, schemaValue***REMOVED***) =>
    typeof schema == "string" ? _`{type: ${schema***REMOVED******REMOVED***` : _`{type: ${schemaValue***REMOVED******REMOVED***`,
***REMOVED***

export function reportTypeError(it: SchemaObjCxt): void {
  const cxt = getTypeErrorContext(it)
  reportError(cxt, typeError)
***REMOVED***

function getTypeErrorContext(it: SchemaObjCxt): KeywordErrorCxt {
  const {gen, data, schema***REMOVED*** = it
  const schemaCode = schemaRefOrVal(it, schema, "type")
  return {
    gen,
    keyword: "type",
    data,
    schema: schema.type,
    schemaCode,
    schemaValue: schemaCode,
    parentSchema: schema,
    params: {***REMOVED***,
    it,
  ***REMOVED***
***REMOVED***
