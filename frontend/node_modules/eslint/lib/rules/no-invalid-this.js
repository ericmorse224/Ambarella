/**
 * @fileoverview A rule to disallow `this` keywords in contexts where the value of `this` is `undefined`.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Determines if the given code path is a code path with lexical `this` binding.
 * That is, if `this` within the code path refers to `this` of surrounding code path.
 * @param {CodePath***REMOVED*** codePath Code path.
 * @param {ASTNode***REMOVED*** node Node that started the code path.
 * @returns {boolean***REMOVED*** `true` if it is a code path with lexical `this` binding.
 */
function isCodePathWithLexicalThis(codePath, node) {
	return (
		codePath.origin === "function" &&
		node.type === "ArrowFunctionExpression"
	);
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		dialects: ["javascript", "typescript"],
		language: "javascript",
		type: "suggestion",

		defaultOptions: [{ capIsConstructor: true ***REMOVED***],

		docs: {
			description:
				"Disallow use of `this` in contexts where the value of `this` is `undefined`",
			recommended: false,
			url: "https://eslint.org/docs/latest/rules/no-invalid-this",
		***REMOVED***,

		schema: [
			{
				type: "object",
				properties: {
					capIsConstructor: {
						type: "boolean",
					***REMOVED***,
				***REMOVED***,
				additionalProperties: false,
			***REMOVED***,
		],

		messages: {
			unexpectedThis: "Unexpected 'this'.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const [{ capIsConstructor ***REMOVED***] = context.options;
		const stack = [],
			sourceCode = context.sourceCode;

		/**
		 * Gets the current checking context.
		 *
		 * The return value has a flag that whether or not `this` keyword is valid.
		 * The flag is initialized when got at the first time.
		 * @returns {{valid: boolean***REMOVED******REMOVED***
		 *   an object which has a flag that whether or not `this` keyword is valid.
		 */
		stack.getCurrent = function () {
			const current = this.at(-1);

			if (!current.init) {
				current.init = true;
				current.valid = !astUtils.isDefaultThisBinding(
					current.node,
					sourceCode,
					{ capIsConstructor ***REMOVED***,
				);
			***REMOVED***
			return current;
		***REMOVED***;

		return {
			onCodePathStart(codePath, node) {
				if (isCodePathWithLexicalThis(codePath, node)) {
					return;
				***REMOVED***

				if (codePath.origin === "program") {
					const scope = sourceCode.getScope(node);
					const features =
						context.languageOptions.parserOptions.ecmaFeatures ||
						{***REMOVED***;

					// `this` at the top level of scripts always refers to the global object
					stack.push({
						init: true,
						node,
						valid: !(
							node.sourceType === "module" ||
							(features.globalReturn &&
								scope.childScopes[0].isStrict)
						),
					***REMOVED***);

					return;
				***REMOVED***

				/*
				 * `init: false` means that `valid` isn't determined yet.
				 * Most functions don't use `this`, and the calculation for `valid`
				 * is relatively costly, so we'll calculate it lazily when the first
				 * `this` within the function is traversed. A special case are non-strict
				 * functions, because `this` refers to the global object and therefore is
				 * always valid, so we can set `init: true` right away.
				 */
				stack.push({
					init: !sourceCode.getScope(node).isStrict,
					node,
					valid: true,
				***REMOVED***);
			***REMOVED***,

			onCodePathEnd(codePath, node) {
				if (isCodePathWithLexicalThis(codePath, node)) {
					return;
				***REMOVED***

				stack.pop();
			***REMOVED***,

			"AccessorProperty > *.value"(node) {
				stack.push({
					init: true,
					node,
					valid: true,
				***REMOVED***);
			***REMOVED***,

			"AccessorProperty:exit"() {
				stack.pop();
			***REMOVED***,

			// Reports if `this` of the current context is invalid.
			ThisExpression(node) {
				// Special case: skip `this` if it's the value of an AccessorProperty
				if (
					node.parent.type === "AccessorProperty" &&
					node.parent.value === node
				) {
					return;
				***REMOVED***

				const current = stack.getCurrent();

				if (current && !current.valid) {
					context.report({
						node,
						messageId: "unexpectedThis",
					***REMOVED***);
				***REMOVED***
			***REMOVED***,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
