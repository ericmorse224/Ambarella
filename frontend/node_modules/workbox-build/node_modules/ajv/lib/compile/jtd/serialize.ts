import type Ajv from "../../core"
import type {SchemaObject***REMOVED*** from "../../types"
import {jtdForms, JTDForm, SchemaObjectMap***REMOVED*** from "./types"
import {SchemaEnv, getCompilingSchema***REMOVED*** from ".."
import {_, str, and, getProperty, CodeGen, Code, Name***REMOVED*** from "../codegen"
import MissingRefError from "../ref_error"
import N from "../names"
import {isOwnProperty***REMOVED*** from "../../vocabularies/code"
import {hasRef***REMOVED*** from "../../vocabularies/jtd/ref"
import {useFunc***REMOVED*** from "../util"
import quote from "../../runtime/quote"

const genSerialize: {[F in JTDForm]: (cxt: SerializeCxt) => void***REMOVED*** = {
  elements: serializeElements,
  values: serializeValues,
  discriminator: serializeDiscriminator,
  properties: serializeProperties,
  optionalProperties: serializeProperties,
  enum: serializeString,
  type: serializeType,
  ref: serializeRef,
***REMOVED***

interface SerializeCxt {
  readonly gen: CodeGen
  readonly self: Ajv // current Ajv instance
  readonly schemaEnv: SchemaEnv
  readonly definitions: SchemaObjectMap
  schema: SchemaObject
  data: Code
***REMOVED***

export default function compileSerializer(
  this: Ajv,
  sch: SchemaEnv,
  definitions: SchemaObjectMap
): SchemaEnv {
  const _sch = getCompilingSchema.call(this, sch)
  if (_sch) return _sch
  const {es5, lines***REMOVED*** = this.opts.code
  const {ownProperties***REMOVED*** = this.opts
  const gen = new CodeGen(this.scope, {es5, lines, ownProperties***REMOVED***)
  const serializeName = gen.scopeName("serialize")
  const cxt: SerializeCxt = {
    self: this,
    gen,
    schema: sch.schema as SchemaObject,
    schemaEnv: sch,
    definitions,
    data: N.data,
  ***REMOVED***

  let sourceCode: string | undefined
  try {
    this._compilations.add(sch)
    sch.serializeName = serializeName
    gen.func(serializeName, N.data, false, () => {
      gen.let(N.json, str``)
      serializeCode(cxt)
      gen.return(N.json)
    ***REMOVED***)
    gen.optimize(this.opts.code.optimize)
    const serializeFuncCode = gen.toString()
    sourceCode = `${gen.scopeRefs(N.scope)***REMOVED***return ${serializeFuncCode***REMOVED***`
    const makeSerialize = new Function(`${N.scope***REMOVED***`, sourceCode)
    const serialize: (data: unknown) => string = makeSerialize(this.scope.get())
    this.scope.value(serializeName, {ref: serialize***REMOVED***)
    sch.serialize = serialize
  ***REMOVED*** catch (e) {
    if (sourceCode) this.logger.error("Error compiling serializer, function code:", sourceCode)
    delete sch.serialize
    delete sch.serializeName
    throw e
  ***REMOVED*** finally {
    this._compilations.delete(sch)
  ***REMOVED***
  return sch
***REMOVED***

function serializeCode(cxt: SerializeCxt): void {
  let form: JTDForm | undefined
  for (const key of jtdForms) {
    if (key in cxt.schema) {
      form = key
      break
    ***REMOVED***
  ***REMOVED***
  serializeNullable(cxt, form ? genSerialize[form] : serializeEmpty)
***REMOVED***

function serializeNullable(cxt: SerializeCxt, serializeForm: (_cxt: SerializeCxt) => void): void {
  const {gen, schema, data***REMOVED*** = cxt
  if (!schema.nullable) return serializeForm(cxt)
  gen.if(
    _`${data***REMOVED*** === undefined || ${data***REMOVED*** === null`,
    () => gen.add(N.json, _`"null"`),
    () => serializeForm(cxt)
  )
***REMOVED***

function serializeElements(cxt: SerializeCxt): void {
  const {gen, schema, data***REMOVED*** = cxt
  gen.add(N.json, str`[`)
  const first = gen.let("first", true)
  gen.forOf("el", data, (el) => {
    addComma(cxt, first)
    serializeCode({...cxt, schema: schema.elements, data: el***REMOVED***)
  ***REMOVED***)
  gen.add(N.json, str`]`)
***REMOVED***

function serializeValues(cxt: SerializeCxt): void {
  const {gen, schema, data***REMOVED*** = cxt
  gen.add(N.json, str`{`)
  const first = gen.let("first", true)
  gen.forIn("key", data, (key) => serializeKeyValue(cxt, key, schema.values, first))
  gen.add(N.json, str`***REMOVED***`)
***REMOVED***

function serializeKeyValue(cxt: SerializeCxt, key: Name, schema: SchemaObject, first?: Name): void {
  const {gen, data***REMOVED*** = cxt
  addComma(cxt, first)
  serializeString({...cxt, data: key***REMOVED***)
  gen.add(N.json, str`:`)
  const value = gen.const("value", _`${data***REMOVED***${getProperty(key)***REMOVED***`)
  serializeCode({...cxt, schema, data: value***REMOVED***)
***REMOVED***

function serializeDiscriminator(cxt: SerializeCxt): void {
  const {gen, schema, data***REMOVED*** = cxt
  const {discriminator***REMOVED*** = schema
  gen.add(N.json, str`{${JSON.stringify(discriminator)***REMOVED***:`)
  const tag = gen.const("tag", _`${data***REMOVED***${getProperty(discriminator)***REMOVED***`)
  serializeString({...cxt, data: tag***REMOVED***)
  gen.if(false)
  for (const tagValue in schema.mapping) {
    gen.elseIf(_`${tag***REMOVED*** === ${tagValue***REMOVED***`)
    const sch = schema.mapping[tagValue]
    serializeSchemaProperties({...cxt, schema: sch***REMOVED***, discriminator)
  ***REMOVED***
  gen.endIf()
  gen.add(N.json, str`***REMOVED***`)
***REMOVED***

function serializeProperties(cxt: SerializeCxt): void {
  const {gen***REMOVED*** = cxt
  gen.add(N.json, str`{`)
  serializeSchemaProperties(cxt)
  gen.add(N.json, str`***REMOVED***`)
***REMOVED***

function serializeSchemaProperties(cxt: SerializeCxt, discriminator?: string): void {
  const {gen, schema, data***REMOVED*** = cxt
  const {properties, optionalProperties***REMOVED*** = schema
  const props = keys(properties)
  const optProps = keys(optionalProperties)
  const allProps = allProperties(props.concat(optProps))
  let first = !discriminator
  let firstProp: Name | undefined

  for (const key of props) {
    if (first) first = false
    else gen.add(N.json, str`,`)
    serializeProperty(key, properties[key], keyValue(key))
  ***REMOVED***
  if (first) firstProp = gen.let("first", true)
  for (const key of optProps) {
    const value = keyValue(key)
    gen.if(and(_`${value***REMOVED*** !== undefined`, isOwnProperty(gen, data, key)), () => {
      addComma(cxt, firstProp)
      serializeProperty(key, optionalProperties[key], value)
    ***REMOVED***)
  ***REMOVED***
  if (schema.additionalProperties) {
    gen.forIn("key", data, (key) =>
      gen.if(isAdditional(key, allProps), () => serializeKeyValue(cxt, key, {***REMOVED***, firstProp))
    )
  ***REMOVED***

  function keys(ps?: SchemaObjectMap): string[] {
    return ps ? Object.keys(ps) : []
  ***REMOVED***

  function allProperties(ps: string[]): string[] {
    if (discriminator) ps.push(discriminator)
    if (new Set(ps).size !== ps.length) {
      throw new Error("JTD: properties/optionalProperties/disciminator overlap")
    ***REMOVED***
    return ps
  ***REMOVED***

  function keyValue(key: string): Name {
    return gen.const("value", _`${data***REMOVED***${getProperty(key)***REMOVED***`)
  ***REMOVED***

  function serializeProperty(key: string, propSchema: SchemaObject, value: Name): void {
    gen.add(N.json, str`${JSON.stringify(key)***REMOVED***:`)
    serializeCode({...cxt, schema: propSchema, data: value***REMOVED***)
  ***REMOVED***

  function isAdditional(key: Name, ps: string[]): Code | true {
    return ps.length ? and(...ps.map((p) => _`${key***REMOVED*** !== ${p***REMOVED***`)) : true
  ***REMOVED***
***REMOVED***

function serializeType(cxt: SerializeCxt): void {
  const {gen, schema, data***REMOVED*** = cxt
  switch (schema.type) {
    case "boolean":
      gen.add(N.json, _`${data***REMOVED*** ? "true" : "false"`)
      break
    case "string":
      serializeString(cxt)
      break
    case "timestamp":
      gen.if(
        _`${data***REMOVED*** instanceof Date`,
        () => gen.add(N.json, _`'"' + ${data***REMOVED***.toISOString() + '"'`),
        () => serializeString(cxt)
      )
      break
    default:
      serializeNumber(cxt)
  ***REMOVED***
***REMOVED***

function serializeString({gen, data***REMOVED***: SerializeCxt): void {
  gen.add(N.json, _`${useFunc(gen, quote)***REMOVED***(${data***REMOVED***)`)
***REMOVED***

function serializeNumber({gen, data***REMOVED***: SerializeCxt): void {
  gen.add(N.json, _`"" + ${data***REMOVED***`)
***REMOVED***

function serializeRef(cxt: SerializeCxt): void {
  const {gen, self, data, definitions, schema, schemaEnv***REMOVED*** = cxt
  const {ref***REMOVED*** = schema
  const refSchema = definitions[ref]
  if (!refSchema) throw new MissingRefError(self.opts.uriResolver, "", ref, `No definition ${ref***REMOVED***`)
  if (!hasRef(refSchema)) return serializeCode({...cxt, schema: refSchema***REMOVED***)
  const {root***REMOVED*** = schemaEnv
  const sch = compileSerializer.call(self, new SchemaEnv({schema: refSchema, root***REMOVED***), definitions)
  gen.add(N.json, _`${getSerialize(gen, sch)***REMOVED***(${data***REMOVED***)`)
***REMOVED***

function getSerialize(gen: CodeGen, sch: SchemaEnv): Code {
  return sch.serialize
    ? gen.scopeValue("serialize", {ref: sch.serialize***REMOVED***)
    : _`${gen.scopeValue("wrapper", {ref: sch***REMOVED***)***REMOVED***.serialize`
***REMOVED***

function serializeEmpty({gen, data***REMOVED***: SerializeCxt): void {
  gen.add(N.json, _`JSON.stringify(${data***REMOVED***)`)
***REMOVED***

function addComma({gen***REMOVED***: SerializeCxt, first?: Name): void {
  if (first) {
    gen.if(
      first,
      () => gen.assign(first, false),
      () => gen.add(N.json, str`,`)
    )
  ***REMOVED*** else {
    gen.add(N.json, str`,`)
  ***REMOVED***
***REMOVED***
