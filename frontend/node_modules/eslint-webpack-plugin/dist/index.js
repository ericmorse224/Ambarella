"use strict";

const {
  isAbsolute,
  join
***REMOVED*** = require('path');

const {
  isMatch
***REMOVED*** = require('micromatch');

const {
  getOptions
***REMOVED*** = require('./options');

const linter = require('./linter');

const {
  arrify,
  parseFiles,
  parseFoldersToGlobs
***REMOVED*** = require('./utils');
/** @typedef {import('webpack').Compiler***REMOVED*** Compiler */

/** @typedef {import('./options').Options***REMOVED*** Options */


const ESLINT_PLUGIN = 'ESLintWebpackPlugin';
let counter = 0;

class ESLintWebpackPlugin {
  /**
   * @param {Options***REMOVED*** options
   */
  constructor(options = {***REMOVED***) {
    this.key = ESLINT_PLUGIN;
    this.options = getOptions(options);
    this.run = this.run.bind(this);
  ***REMOVED***
  /**
   * @param {Compiler***REMOVED*** compiler
   * @returns {void***REMOVED***
   */


  apply(compiler) {
    // Generate key for each compilation,
    // this differentiates one from the other when being cached.
    this.key = compiler.name || `${this.key***REMOVED***_${counter += 1***REMOVED***`;
    const options = { ...this.options,
      exclude: parseFiles(this.options.exclude || [], this.getContext(compiler)),
      extensions: arrify(this.options.extensions),
      resourceQueryExclude: arrify(this.options.resourceQueryExclude || []).map(item => item instanceof RegExp ? item : new RegExp(item)),
      files: parseFiles(this.options.files || '', this.getContext(compiler))
    ***REMOVED***;
    const wanted = parseFoldersToGlobs(options.files, options.extensions);
    const exclude = parseFoldersToGlobs(this.options.exclude ? options.exclude : '**/node_modules/**', []); // If `lintDirtyModulesOnly` is disabled,
    // execute the linter on the build

    if (!this.options.lintDirtyModulesOnly) {
      compiler.hooks.run.tapPromise(this.key, c => this.run(c, options, wanted, exclude));
    ***REMOVED***

    let isFirstRun = this.options.lintDirtyModulesOnly;
    compiler.hooks.watchRun.tapPromise(this.key, c => {
      if (isFirstRun) {
        isFirstRun = false;
        return Promise.resolve();
      ***REMOVED***

      return this.run(c, options, wanted, exclude);
    ***REMOVED***);
  ***REMOVED***
  /**
   * @param {Compiler***REMOVED*** compiler
   * @param {Omit<Options, 'resourceQueryExclude'> & {resourceQueryExclude: RegExp[]***REMOVED******REMOVED*** options
   * @param {string[]***REMOVED*** wanted
   * @param {string[]***REMOVED*** exclude
   */


  async run(compiler, options, wanted, exclude) {
    // Do not re-hook
    if ( // @ts-ignore
    compiler.hooks.compilation.taps.find(({
      name
    ***REMOVED***) => name === this.key)) {
      return;
    ***REMOVED***

    compiler.hooks.compilation.tap(this.key, compilation => {
      /** @type {import('./linter').Linter***REMOVED*** */
      let lint;
      /** @type {import('./linter').Reporter***REMOVED*** */

      let report;
      /** @type number */

      let threads;

      try {
        ({
          lint,
          report,
          threads
        ***REMOVED*** = linter(this.key, options, compilation));
      ***REMOVED*** catch (e) {
        compilation.errors.push(e);
        return;
      ***REMOVED***
      /** @type {string[]***REMOVED*** */


      const files = []; // @ts-ignore
      // Add the file to be linted

      compilation.hooks.succeedModule.tap(this.key, ({
        resource
      ***REMOVED***) => {
        if (resource) {
          const [file, query] = resource.split('?');

          if (file && !files.includes(file) && isMatch(file, wanted, {
            dot: true
          ***REMOVED***) && !isMatch(file, exclude, {
            dot: true
          ***REMOVED***) && options.resourceQueryExclude.every(reg => !reg.test(query))) {
            files.push(file);

            if (threads > 1) {
              lint(file);
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***); // Lint all files added

      compilation.hooks.finishModules.tap(this.key, () => {
        if (files.length > 0 && threads <= 1) {
          lint(files);
        ***REMOVED***
      ***REMOVED***); // await and interpret results

      compilation.hooks.additionalAssets.tapPromise(this.key, processResults);

      async function processResults() {
        const {
          errors,
          warnings,
          generateReportAsset
        ***REMOVED*** = await report();

        if (warnings && !options.failOnWarning) {
          // @ts-ignore
          compilation.warnings.push(warnings);
        ***REMOVED*** else if (warnings && options.failOnWarning) {
          // @ts-ignore
          compilation.errors.push(warnings);
        ***REMOVED***

        if (errors && options.failOnError) {
          // @ts-ignore
          compilation.errors.push(errors);
        ***REMOVED*** else if (errors && !options.failOnError) {
          // @ts-ignore
          compilation.warnings.push(errors);
        ***REMOVED***

        if (generateReportAsset) {
          await generateReportAsset(compilation);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***
  /**
   *
   * @param {Compiler***REMOVED*** compiler
   * @returns {string***REMOVED***
   */


  getContext(compiler) {
    if (!this.options.context) {
      return String(compiler.options.context);
    ***REMOVED***

    if (!isAbsolute(this.options.context)) {
      return join(String(compiler.options.context), this.options.context);
    ***REMOVED***

    return this.options.context;
  ***REMOVED***

***REMOVED***

module.exports = ESLintWebpackPlugin;