/**
 * @fileoverview Rule to disallow using `Object.assign` with an object literal as the first argument and prefer the use of object spread instead
 * @author Sharmila Jesupaul
 */

"use strict";

const { CALL, ReferenceTracker ***REMOVED*** = require("@eslint-community/eslint-utils");
const {
	isCommaToken,
	isOpeningParenToken,
	isClosingParenToken,
	isParenthesised,
***REMOVED*** = require("./utils/ast-utils");

const ANY_SPACE = /\s/u;

/**
 * Helper that checks if the Object.assign call has array spread
 * @param {ASTNode***REMOVED*** node The node that the rule warns on
 * @returns {boolean***REMOVED*** - Returns true if the Object.assign call has array spread
 */
function hasArraySpread(node) {
	return node.arguments.some(arg => arg.type === "SpreadElement");
***REMOVED***

/**
 * Determines whether the given node is an accessor property (getter/setter).
 * @param {ASTNode***REMOVED*** node Node to check.
 * @returns {boolean***REMOVED*** `true` if the node is a getter or a setter.
 */
function isAccessorProperty(node) {
	return (
		node.type === "Property" && (node.kind === "get" || node.kind === "set")
	);
***REMOVED***

/**
 * Determines whether the given object expression node has accessor properties (getters/setters).
 * @param {ASTNode***REMOVED*** node `ObjectExpression` node to check.
 * @returns {boolean***REMOVED*** `true` if the node has at least one getter/setter.
 */
function hasAccessors(node) {
	return node.properties.some(isAccessorProperty);
***REMOVED***

/**
 * Determines whether the given call expression node has object expression arguments with accessor properties (getters/setters).
 * @param {ASTNode***REMOVED*** node `CallExpression` node to check.
 * @returns {boolean***REMOVED*** `true` if the node has at least one argument that is an object expression with at least one getter/setter.
 */
function hasArgumentsWithAccessors(node) {
	return node.arguments
		.filter(arg => arg.type === "ObjectExpression")
		.some(hasAccessors);
***REMOVED***

/**
 * Helper that checks if the node needs parentheses to be valid JS.
 * The default is to wrap the node in parentheses to avoid parsing errors.
 * @param {ASTNode***REMOVED*** node The node that the rule warns on
 * @param {Object***REMOVED*** sourceCode in context sourcecode object
 * @returns {boolean***REMOVED*** - Returns true if the node needs parentheses
 */
function needsParens(node, sourceCode) {
	const parent = node.parent;

	switch (parent.type) {
		case "VariableDeclarator":
		case "ArrayExpression":
		case "ReturnStatement":
		case "CallExpression":
		case "Property":
			return false;
		case "AssignmentExpression":
			return parent.left === node && !isParenthesised(sourceCode, node);
		default:
			return !isParenthesised(sourceCode, node);
	***REMOVED***
***REMOVED***

/**
 * Determines if an argument needs parentheses. The default is to not add parens.
 * @param {ASTNode***REMOVED*** node The node to be checked.
 * @param {Object***REMOVED*** sourceCode in context sourcecode object
 * @returns {boolean***REMOVED*** True if the node needs parentheses
 */
function argNeedsParens(node, sourceCode) {
	switch (node.type) {
		case "AssignmentExpression":
		case "ArrowFunctionExpression":
		case "ConditionalExpression":
			return !isParenthesised(sourceCode, node);
		default:
			return false;
	***REMOVED***
***REMOVED***

/**
 * Get the parenthesis tokens of a given ObjectExpression node.
 * This includes the braces of the object literal and enclosing parentheses.
 * @param {ASTNode***REMOVED*** node The node to get.
 * @param {Token***REMOVED*** leftArgumentListParen The opening paren token of the argument list.
 * @param {SourceCode***REMOVED*** sourceCode The source code object to get tokens.
 * @returns {Token[]***REMOVED*** The parenthesis tokens of the node. This is sorted by the location.
 */
function getParenTokens(node, leftArgumentListParen, sourceCode) {
	const parens = [
		sourceCode.getFirstToken(node),
		sourceCode.getLastToken(node),
	];
	let leftNext = sourceCode.getTokenBefore(node);
	let rightNext = sourceCode.getTokenAfter(node);

	// Note: don't include the parens of the argument list.
	while (
		leftNext &&
		rightNext &&
		leftNext.range[0] > leftArgumentListParen.range[0] &&
		isOpeningParenToken(leftNext) &&
		isClosingParenToken(rightNext)
	) {
		parens.push(leftNext, rightNext);
		leftNext = sourceCode.getTokenBefore(leftNext);
		rightNext = sourceCode.getTokenAfter(rightNext);
	***REMOVED***

	return parens.sort((a, b) => a.range[0] - b.range[0]);
***REMOVED***

/**
 * Get the range of a given token and around whitespaces.
 * @param {Token***REMOVED*** token The token to get range.
 * @param {SourceCode***REMOVED*** sourceCode The source code object to get tokens.
 * @returns {number***REMOVED*** The end of the range of the token and around whitespaces.
 */
function getStartWithSpaces(token, sourceCode) {
	const text = sourceCode.text;
	let start = token.range[0];

	// If the previous token is a line comment then skip this step to avoid commenting this token out.
	{
		const prevToken = sourceCode.getTokenBefore(token, {
			includeComments: true,
		***REMOVED***);

		if (prevToken && prevToken.type === "Line") {
			return start;
		***REMOVED***
	***REMOVED***

	// Detect spaces before the token.
	while (ANY_SPACE.test(text[start - 1] || "")) {
		start -= 1;
	***REMOVED***

	return start;
***REMOVED***

/**
 * Get the range of a given token and around whitespaces.
 * @param {Token***REMOVED*** token The token to get range.
 * @param {SourceCode***REMOVED*** sourceCode The source code object to get tokens.
 * @returns {number***REMOVED*** The start of the range of the token and around whitespaces.
 */
function getEndWithSpaces(token, sourceCode) {
	const text = sourceCode.text;
	let end = token.range[1];

	// Detect spaces after the token.
	while (ANY_SPACE.test(text[end] || "")) {
		end += 1;
	***REMOVED***

	return end;
***REMOVED***

/**
 * Autofixes the Object.assign call to use an object spread instead.
 * @param {ASTNode|null***REMOVED*** node The node that the rule warns on, i.e. the Object.assign call
 * @param {string***REMOVED*** sourceCode sourceCode of the Object.assign call
 * @returns {Function***REMOVED*** autofixer - replaces the Object.assign with a spread object.
 */
function defineFixer(node, sourceCode) {
	return function* (fixer) {
		const leftParen = sourceCode.getTokenAfter(
			node.callee,
			isOpeningParenToken,
		);
		const rightParen = sourceCode.getLastToken(node);

		// Remove everything before the opening paren: callee `Object.assign`, type arguments, and whitespace between the callee and the paren.
		yield fixer.removeRange([node.range[0], leftParen.range[0]]);

		// Replace the parens of argument list to braces.
		if (needsParens(node, sourceCode)) {
			yield fixer.replaceText(leftParen, "({");
			yield fixer.replaceText(rightParen, "***REMOVED***)");
		***REMOVED*** else {
			yield fixer.replaceText(leftParen, "{");
			yield fixer.replaceText(rightParen, "***REMOVED***");
		***REMOVED***

		// Process arguments.
		for (const argNode of node.arguments) {
			const innerParens = getParenTokens(argNode, leftParen, sourceCode);
			const left = innerParens.shift();
			const right = innerParens.pop();

			if (argNode.type === "ObjectExpression") {
				const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);
				const maybeArgumentComma = sourceCode.getTokenAfter(right);

				/*
				 * Make bare this object literal.
				 * And remove spaces inside of the braces for better formatting.
				 */
				for (const innerParen of innerParens) {
					yield fixer.remove(innerParen);
				***REMOVED***
				const leftRange = [
					left.range[0],
					getEndWithSpaces(left, sourceCode),
				];
				const rightRange = [
					Math.max(
						getStartWithSpaces(right, sourceCode),
						leftRange[1],
					), // Ensure ranges don't overlap
					right.range[1],
				];

				yield fixer.removeRange(leftRange);
				yield fixer.removeRange(rightRange);

				// Remove the comma of this argument if it's duplication.
				if (
					(argNode.properties.length === 0 ||
						isCommaToken(maybeTrailingComma)) &&
					isCommaToken(maybeArgumentComma)
				) {
					yield fixer.remove(maybeArgumentComma);
				***REMOVED***
			***REMOVED*** else {
				// Make spread.
				if (argNeedsParens(argNode, sourceCode)) {
					yield fixer.insertTextBefore(left, "...(");
					yield fixer.insertTextAfter(right, ")");
				***REMOVED*** else {
					yield fixer.insertTextBefore(left, "...");
				***REMOVED***
			***REMOVED***
		***REMOVED***
	***REMOVED***;
***REMOVED***

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "suggestion",

		docs: {
			description:
				"Disallow using `Object.assign` with an object literal as the first argument and prefer the use of object spread instead",
			recommended: false,
			frozen: true,
			url: "https://eslint.org/docs/latest/rules/prefer-object-spread",
		***REMOVED***,

		schema: [],
		fixable: "code",

		messages: {
			useSpreadMessage:
				"Use an object spread instead of `Object.assign` eg: `{ ...foo ***REMOVED***`.",
			useLiteralMessage:
				"Use an object literal instead of `Object.assign`. eg: `{ foo: bar ***REMOVED***`.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const sourceCode = context.sourceCode;

		return {
			Program(node) {
				const scope = sourceCode.getScope(node);
				const tracker = new ReferenceTracker(scope);
				const trackMap = {
					Object: {
						assign: { [CALL]: true ***REMOVED***,
					***REMOVED***,
				***REMOVED***;

				// Iterate all calls of `Object.assign` (only of the global variable `Object`).
				for (const { node: refNode ***REMOVED*** of tracker.iterateGlobalReferences(
					trackMap,
				)) {
					if (
						refNode.arguments.length >= 1 &&
						refNode.arguments[0].type === "ObjectExpression" &&
						!hasArraySpread(refNode) &&
						!(
							refNode.arguments.length > 1 &&
							hasArgumentsWithAccessors(refNode)
						)
					) {
						const messageId =
							refNode.arguments.length === 1
								? "useLiteralMessage"
								: "useSpreadMessage";
						const fix = defineFixer(refNode, sourceCode);

						context.report({ node: refNode, messageId, fix ***REMOVED***);
					***REMOVED***
				***REMOVED***
			***REMOVED***,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
