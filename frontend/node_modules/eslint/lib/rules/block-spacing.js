/**
 * @fileoverview A rule to disallow or enforce spaces inside of single line blocks.
 * @author Toru Nagashima
 * @deprecated in ESLint v8.53.0
 */

"use strict";

const util = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		deprecated: {
			message: "Formatting rules are being moved out of ESLint core.",
			url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
			deprecatedSince: "8.53.0",
			availableUntil: "10.0.0",
			replacedBy: [
				{
					message:
						"ESLint Stylistic now maintains deprecated stylistic core rules.",
					url: "https://eslint.style/guide/migration",
					plugin: {
						name: "@stylistic/eslint-plugin-js",
						url: "https://eslint.style/packages/js",
					***REMOVED***,
					rule: {
						name: "block-spacing",
						url: "https://eslint.style/rules/js/block-spacing",
					***REMOVED***,
				***REMOVED***,
			],
		***REMOVED***,
		type: "layout",

		docs: {
			description:
				"Disallow or enforce spaces inside of blocks after opening block and before closing block",
			recommended: false,
			url: "https://eslint.org/docs/latest/rules/block-spacing",
		***REMOVED***,

		fixable: "whitespace",

		schema: [{ enum: ["always", "never"] ***REMOVED***],

		messages: {
			missing: "Requires a space {{location***REMOVED******REMOVED*** '{{token***REMOVED******REMOVED***'.",
			extra: "Unexpected space(s) {{location***REMOVED******REMOVED*** '{{token***REMOVED******REMOVED***'.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const always = context.options[0] !== "never",
			messageId = always ? "missing" : "extra",
			sourceCode = context.sourceCode;

		/**
		 * Gets the open brace token from a given node.
		 * @param {ASTNode***REMOVED*** node A BlockStatement/StaticBlock/SwitchStatement node to get.
		 * @returns {Token***REMOVED*** The token of the open brace.
		 */
		function getOpenBrace(node) {
			if (node.type === "SwitchStatement") {
				if (node.cases.length > 0) {
					return sourceCode.getTokenBefore(node.cases[0]);
				***REMOVED***
				return sourceCode.getLastToken(node, 1);
			***REMOVED***

			if (node.type === "StaticBlock") {
				return sourceCode.getFirstToken(node, { skip: 1 ***REMOVED***); // skip the `static` token
			***REMOVED***

			// "BlockStatement"
			return sourceCode.getFirstToken(node);
		***REMOVED***

		/**
		 * Checks whether or not:
		 *   - given tokens are on same line.
		 *   - there is/isn't a space between given tokens.
		 * @param {Token***REMOVED*** left A token to check.
		 * @param {Token***REMOVED*** right The token which is next to `left`.
		 * @returns {boolean***REMOVED***
		 *    When the option is `"always"`, `true` if there are one or more spaces between given tokens.
		 *    When the option is `"never"`, `true` if there are not any spaces between given tokens.
		 *    If given tokens are not on same line, it's always `true`.
		 */
		function isValid(left, right) {
			return (
				!util.isTokenOnSameLine(left, right) ||
				sourceCode.isSpaceBetweenTokens(left, right) === always
			);
		***REMOVED***

		/**
		 * Checks and reports invalid spacing style inside braces.
		 * @param {ASTNode***REMOVED*** node A BlockStatement/StaticBlock/SwitchStatement node to check.
		 * @returns {void***REMOVED***
		 */
		function checkSpacingInsideBraces(node) {
			// Gets braces and the first/last token of content.
			const openBrace = getOpenBrace(node);
			const closeBrace = sourceCode.getLastToken(node);
			const firstToken = sourceCode.getTokenAfter(openBrace, {
				includeComments: true,
			***REMOVED***);
			const lastToken = sourceCode.getTokenBefore(closeBrace, {
				includeComments: true,
			***REMOVED***);

			// Skip if the node is invalid or empty.
			if (
				openBrace.type !== "Punctuator" ||
				openBrace.value !== "{" ||
				closeBrace.type !== "Punctuator" ||
				closeBrace.value !== "***REMOVED***" ||
				firstToken === closeBrace
			) {
				return;
			***REMOVED***

			// Skip line comments for option never
			if (!always && firstToken.type === "Line") {
				return;
			***REMOVED***

			// Check.
			if (!isValid(openBrace, firstToken)) {
				let loc = openBrace.loc;

				if (messageId === "extra") {
					loc = {
						start: openBrace.loc.end,
						end: firstToken.loc.start,
					***REMOVED***;
				***REMOVED***

				context.report({
					node,
					loc,
					messageId,
					data: {
						location: "after",
						token: openBrace.value,
					***REMOVED***,
					fix(fixer) {
						if (always) {
							return fixer.insertTextBefore(firstToken, " ");
						***REMOVED***

						return fixer.removeRange([
							openBrace.range[1],
							firstToken.range[0],
						]);
					***REMOVED***,
				***REMOVED***);
			***REMOVED***
			if (!isValid(lastToken, closeBrace)) {
				let loc = closeBrace.loc;

				if (messageId === "extra") {
					loc = {
						start: lastToken.loc.end,
						end: closeBrace.loc.start,
					***REMOVED***;
				***REMOVED***
				context.report({
					node,
					loc,
					messageId,
					data: {
						location: "before",
						token: closeBrace.value,
					***REMOVED***,
					fix(fixer) {
						if (always) {
							return fixer.insertTextAfter(lastToken, " ");
						***REMOVED***

						return fixer.removeRange([
							lastToken.range[1],
							closeBrace.range[0],
						]);
					***REMOVED***,
				***REMOVED***);
			***REMOVED***
		***REMOVED***

		return {
			BlockStatement: checkSpacingInsideBraces,
			StaticBlock: checkSpacingInsideBraces,
			SwitchStatement: checkSpacingInsideBraces,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
