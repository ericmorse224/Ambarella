var test = require('tape');
var forEach = require('for-each');

var inspect = require('../');

test('bad indent options', function (t) {
    forEach([
        undefined,
        true,
        false,
        -1,
        1.2,
        Infinity,
        -Infinity,
        NaN
    ], function (indent) {
        t['throws'](
            function () { inspect('', { indent: indent ***REMOVED***); ***REMOVED***,
            TypeError,
            inspect(indent) + ' is invalid'
        );
    ***REMOVED***);

    t.end();
***REMOVED***);

test('simple object with indent', function (t) {
    t.plan(2);

    var obj = { a: 1, b: 2 ***REMOVED***;

    var expectedSpaces = [
        '{',
        '  a: 1,',
        '  b: 2',
        '***REMOVED***'
    ].join('\n');
    var expectedTabs = [
        '{',
        '	a: 1,',
        '	b: 2',
        '***REMOVED***'
    ].join('\n');

    t.equal(inspect(obj, { indent: 2 ***REMOVED***), expectedSpaces, 'two');
    t.equal(inspect(obj, { indent: '\t' ***REMOVED***), expectedTabs, 'tabs');
***REMOVED***);

test('two deep object with indent', function (t) {
    t.plan(2);

    var obj = { a: 1, b: { c: 3, d: 4 ***REMOVED*** ***REMOVED***;

    var expectedSpaces = [
        '{',
        '  a: 1,',
        '  b: {',
        '    c: 3,',
        '    d: 4',
        '  ***REMOVED***',
        '***REMOVED***'
    ].join('\n');
    var expectedTabs = [
        '{',
        '	a: 1,',
        '	b: {',
        '		c: 3,',
        '		d: 4',
        '	***REMOVED***',
        '***REMOVED***'
    ].join('\n');

    t.equal(inspect(obj, { indent: 2 ***REMOVED***), expectedSpaces, 'two');
    t.equal(inspect(obj, { indent: '\t' ***REMOVED***), expectedTabs, 'tabs');
***REMOVED***);

test('simple array with all single line elements', function (t) {
    t.plan(2);

    var obj = [1, 2, 3, 'asdf\nsdf'];

    var expected = '[ 1, 2, 3, \'asdf\\nsdf\' ]';

    t.equal(inspect(obj, { indent: 2 ***REMOVED***), expected, 'two');
    t.equal(inspect(obj, { indent: '\t' ***REMOVED***), expected, 'tabs');
***REMOVED***);

test('array with complex elements', function (t) {
    t.plan(2);

    var obj = [1, { a: 1, b: { c: 1 ***REMOVED*** ***REMOVED***, 'asdf\nsdf'];

    var expectedSpaces = [
        '[',
        '  1,',
        '  {',
        '    a: 1,',
        '    b: {',
        '      c: 1',
        '    ***REMOVED***',
        '  ***REMOVED***,',
        '  \'asdf\\nsdf\'',
        ']'
    ].join('\n');
    var expectedTabs = [
        '[',
        '	1,',
        '	{',
        '		a: 1,',
        '		b: {',
        '			c: 1',
        '		***REMOVED***',
        '	***REMOVED***,',
        '	\'asdf\\nsdf\'',
        ']'
    ].join('\n');

    t.equal(inspect(obj, { indent: 2 ***REMOVED***), expectedSpaces, 'two');
    t.equal(inspect(obj, { indent: '\t' ***REMOVED***), expectedTabs, 'tabs');
***REMOVED***);

test('values', function (t) {
    t.plan(2);
    var obj = [{***REMOVED***, [], { 'a-b': 5 ***REMOVED***];

    var expectedSpaces = [
        '[',
        '  {***REMOVED***,',
        '  [],',
        '  {',
        '    \'a-b\': 5',
        '  ***REMOVED***',
        ']'
    ].join('\n');
    var expectedTabs = [
        '[',
        '	{***REMOVED***,',
        '	[],',
        '	{',
        '		\'a-b\': 5',
        '	***REMOVED***',
        ']'
    ].join('\n');

    t.equal(inspect(obj, { indent: 2 ***REMOVED***), expectedSpaces, 'two');
    t.equal(inspect(obj, { indent: '\t' ***REMOVED***), expectedTabs, 'tabs');
***REMOVED***);

test('Map', { skip: typeof Map !== 'function' ***REMOVED***, function (t) {
    var map = new Map();
    map.set({ a: 1 ***REMOVED***, ['b']);
    map.set(3, NaN);

    var expectedStringSpaces = [
        'Map (2) {',
        '  { a: 1 ***REMOVED*** => [ \'b\' ],',
        '  3 => NaN',
        '***REMOVED***'
    ].join('\n');
    var expectedStringTabs = [
        'Map (2) {',
        '	{ a: 1 ***REMOVED*** => [ \'b\' ],',
        '	3 => NaN',
        '***REMOVED***'
    ].join('\n');
    var expectedStringTabsDoubleQuotes = [
        'Map (2) {',
        '	{ a: 1 ***REMOVED*** => [ "b" ],',
        '	3 => NaN',
        '***REMOVED***'
    ].join('\n');

    t.equal(
        inspect(map, { indent: 2 ***REMOVED***),
        expectedStringSpaces,
        'Map keys are not indented (two)'
    );
    t.equal(
        inspect(map, { indent: '\t' ***REMOVED***),
        expectedStringTabs,
        'Map keys are not indented (tabs)'
    );
    t.equal(
        inspect(map, { indent: '\t', quoteStyle: 'double' ***REMOVED***),
        expectedStringTabsDoubleQuotes,
        'Map keys are not indented (tabs + double quotes)'
    );

    t.equal(inspect(new Map(), { indent: 2 ***REMOVED***), 'Map (0) {***REMOVED***', 'empty Map should show as empty (two)');
    t.equal(inspect(new Map(), { indent: '\t' ***REMOVED***), 'Map (0) {***REMOVED***', 'empty Map should show as empty (tabs)');

    var nestedMap = new Map();
    nestedMap.set(nestedMap, map);
    var expectedNestedSpaces = [
        'Map (1) {',
        '  [Circular] => Map (2) {',
        '    { a: 1 ***REMOVED*** => [ \'b\' ],',
        '    3 => NaN',
        '  ***REMOVED***',
        '***REMOVED***'
    ].join('\n');
    var expectedNestedTabs = [
        'Map (1) {',
        '	[Circular] => Map (2) {',
        '		{ a: 1 ***REMOVED*** => [ \'b\' ],',
        '		3 => NaN',
        '	***REMOVED***',
        '***REMOVED***'
    ].join('\n');
    t.equal(inspect(nestedMap, { indent: 2 ***REMOVED***), expectedNestedSpaces, 'Map containing a Map should work (two)');
    t.equal(inspect(nestedMap, { indent: '\t' ***REMOVED***), expectedNestedTabs, 'Map containing a Map should work (tabs)');

    t.end();
***REMOVED***);

test('Set', { skip: typeof Set !== 'function' ***REMOVED***, function (t) {
    var set = new Set();
    set.add({ a: 1 ***REMOVED***);
    set.add(['b']);
    var expectedStringSpaces = [
        'Set (2) {',
        '  {',
        '    a: 1',
        '  ***REMOVED***,',
        '  [ \'b\' ]',
        '***REMOVED***'
    ].join('\n');
    var expectedStringTabs = [
        'Set (2) {',
        '	{',
        '		a: 1',
        '	***REMOVED***,',
        '	[ \'b\' ]',
        '***REMOVED***'
    ].join('\n');
    t.equal(inspect(set, { indent: 2 ***REMOVED***), expectedStringSpaces, 'new Set([{ a: 1 ***REMOVED***, ["b"]]) should show size and contents (two)');
    t.equal(inspect(set, { indent: '\t' ***REMOVED***), expectedStringTabs, 'new Set([{ a: 1 ***REMOVED***, ["b"]]) should show size and contents (tabs)');

    t.equal(inspect(new Set(), { indent: 2 ***REMOVED***), 'Set (0) {***REMOVED***', 'empty Set should show as empty (two)');
    t.equal(inspect(new Set(), { indent: '\t' ***REMOVED***), 'Set (0) {***REMOVED***', 'empty Set should show as empty (tabs)');

    var nestedSet = new Set();
    nestedSet.add(set);
    nestedSet.add(nestedSet);
    var expectedNestedSpaces = [
        'Set (2) {',
        '  Set (2) {',
        '    {',
        '      a: 1',
        '    ***REMOVED***,',
        '    [ \'b\' ]',
        '  ***REMOVED***,',
        '  [Circular]',
        '***REMOVED***'
    ].join('\n');
    var expectedNestedTabs = [
        'Set (2) {',
        '	Set (2) {',
        '		{',
        '			a: 1',
        '		***REMOVED***,',
        '		[ \'b\' ]',
        '	***REMOVED***,',
        '	[Circular]',
        '***REMOVED***'
    ].join('\n');
    t.equal(inspect(nestedSet, { indent: 2 ***REMOVED***), expectedNestedSpaces, 'Set containing a Set should work (two)');
    t.equal(inspect(nestedSet, { indent: '\t' ***REMOVED***), expectedNestedTabs, 'Set containing a Set should work (tabs)');

    t.end();
***REMOVED***);
