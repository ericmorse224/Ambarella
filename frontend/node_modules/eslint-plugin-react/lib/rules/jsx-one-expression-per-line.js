/**
 * @fileoverview Limit to one expression per line in JSX
 * @author Mark Ivan Allen <Vydia.com>
 */

'use strict';

const docsUrl = require('../util/docsUrl');
const eslintUtil = require('../util/eslint');
const jsxUtil = require('../util/jsx');
const report = require('../util/report');

const getSourceCode = eslintUtil.getSourceCode;
const getText = eslintUtil.getText;

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

const optionDefaults = {
  allow: 'none',
***REMOVED***;

const messages = {
  moveToNewLine: '`{{descriptor***REMOVED******REMOVED***` must be placed on a new line',
***REMOVED***;

/** @type {import('eslint').Rule.RuleModule***REMOVED*** */
module.exports = {
  meta: {
    docs: {
      description: 'Require one JSX element per line',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('jsx-one-expression-per-line'),
    ***REMOVED***,
    fixable: 'whitespace',

    messages,

    schema: [
      {
        type: 'object',
        properties: {
          allow: {
            enum: ['none', 'literal', 'single-child', 'non-jsx'],
          ***REMOVED***,
        ***REMOVED***,
        default: optionDefaults,
        additionalProperties: false,
      ***REMOVED***,
    ],
  ***REMOVED***,

  create(context) {
    const options = Object.assign({***REMOVED***, optionDefaults, context.options[0]);

    function nodeKey(node) {
      return `${node.loc.start.line***REMOVED***,${node.loc.start.column***REMOVED***`;
    ***REMOVED***

    /**
     * @param {ASTNode***REMOVED*** n
     * @returns {string***REMOVED***
     */
    function nodeDescriptor(n) {
      return n.openingElement ? n.openingElement.name.name : getText(context, n).replace(/\n/g, '');
    ***REMOVED***

    function handleJSX(node) {
      const children = node.children;

      if (!children || !children.length) {
        return;
      ***REMOVED***

      if (
        options.allow === 'non-jsx'
        && !children.find((child) => (child.type === 'JSXFragment' || child.type === 'JSXElement'))
      ) {
        return;
      ***REMOVED***

      const openingElement = node.openingElement || node.openingFragment;
      const closingElement = node.closingElement || node.closingFragment;
      const openingElementStartLine = openingElement.loc.start.line;
      const openingElementEndLine = openingElement.loc.end.line;
      const closingElementStartLine = closingElement.loc.start.line;
      const closingElementEndLine = closingElement.loc.end.line;

      if (children.length === 1) {
        const child = children[0];
        if (
          openingElementStartLine === openingElementEndLine
          && openingElementEndLine === closingElementStartLine
          && closingElementStartLine === closingElementEndLine
          && closingElementEndLine === child.loc.start.line
          && child.loc.start.line === child.loc.end.line
        ) {
          if (
            options.allow === 'single-child'
            || (options.allow === 'literal' && (child.type === 'Literal' || child.type === 'JSXText'))
          ) {
            return;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      const childrenGroupedByLine = {***REMOVED***;
      const fixDetailsByNode = {***REMOVED***;

      children.forEach((child) => {
        let countNewLinesBeforeContent = 0;
        let countNewLinesAfterContent = 0;

        if (child.type === 'Literal' || child.type === 'JSXText') {
          if (jsxUtil.isWhiteSpaces(child.raw)) {
            return;
          ***REMOVED***

          countNewLinesBeforeContent = (child.raw.match(/^\s*\n/g) || []).length;
          countNewLinesAfterContent = (child.raw.match(/\n\s*$/g) || []).length;
        ***REMOVED***

        const startLine = child.loc.start.line + countNewLinesBeforeContent;
        const endLine = child.loc.end.line - countNewLinesAfterContent;

        if (startLine === endLine) {
          if (!childrenGroupedByLine[startLine]) {
            childrenGroupedByLine[startLine] = [];
          ***REMOVED***
          childrenGroupedByLine[startLine].push(child);
        ***REMOVED*** else {
          if (!childrenGroupedByLine[startLine]) {
            childrenGroupedByLine[startLine] = [];
          ***REMOVED***
          childrenGroupedByLine[startLine].push(child);
          if (!childrenGroupedByLine[endLine]) {
            childrenGroupedByLine[endLine] = [];
          ***REMOVED***
          childrenGroupedByLine[endLine].push(child);
        ***REMOVED***
      ***REMOVED***);

      Object.keys(childrenGroupedByLine).forEach((_line) => {
        const line = parseInt(_line, 10);
        const firstIndex = 0;
        const lastIndex = childrenGroupedByLine[line].length - 1;

        childrenGroupedByLine[line].forEach((child, i) => {
          let prevChild;
          let nextChild;

          if (i === firstIndex) {
            if (line === openingElementEndLine) {
              prevChild = openingElement;
            ***REMOVED***
          ***REMOVED*** else {
            prevChild = childrenGroupedByLine[line][i - 1];
          ***REMOVED***

          if (i === lastIndex) {
            if (line === closingElementStartLine) {
              nextChild = closingElement;
            ***REMOVED***
          ***REMOVED*** else {
            // We don't need to append a trailing because the next child will prepend a leading.
            // nextChild = childrenGroupedByLine[line][i + 1];
          ***REMOVED***

          function spaceBetweenPrev() {
            return ((prevChild.type === 'Literal' || prevChild.type === 'JSXText') && / $/.test(prevChild.raw))
              || ((child.type === 'Literal' || child.type === 'JSXText') && /^ /.test(child.raw))
              || getSourceCode(context).isSpaceBetweenTokens(prevChild, child);
          ***REMOVED***

          function spaceBetweenNext() {
            return ((nextChild.type === 'Literal' || nextChild.type === 'JSXText') && /^ /.test(nextChild.raw))
              || ((child.type === 'Literal' || child.type === 'JSXText') && / $/.test(child.raw))
              || getSourceCode(context).isSpaceBetweenTokens(child, nextChild);
          ***REMOVED***

          if (!prevChild && !nextChild) {
            return;
          ***REMOVED***

          const source = getText(context, child);
          const leadingSpace = !!(prevChild && spaceBetweenPrev());
          const trailingSpace = !!(nextChild && spaceBetweenNext());
          const leadingNewLine = !!prevChild;
          const trailingNewLine = !!nextChild;

          const key = nodeKey(child);

          if (!fixDetailsByNode[key]) {
            fixDetailsByNode[key] = {
              node: child,
              source,
              descriptor: nodeDescriptor(child),
            ***REMOVED***;
          ***REMOVED***

          if (leadingSpace) {
            fixDetailsByNode[key].leadingSpace = true;
          ***REMOVED***
          if (leadingNewLine) {
            fixDetailsByNode[key].leadingNewLine = true;
          ***REMOVED***
          if (trailingNewLine) {
            fixDetailsByNode[key].trailingNewLine = true;
          ***REMOVED***
          if (trailingSpace) {
            fixDetailsByNode[key].trailingSpace = true;
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***);

      Object.keys(fixDetailsByNode).forEach((key) => {
        const details = fixDetailsByNode[key];

        const nodeToReport = details.node;
        const descriptor = details.descriptor;
        const source = details.source.replace(/(^ +| +(?=\n)*$)/g, '');

        const leadingSpaceString = details.leadingSpace ? '\n{\' \'***REMOVED***' : '';
        const trailingSpaceString = details.trailingSpace ? '{\' \'***REMOVED***\n' : '';
        const leadingNewLineString = details.leadingNewLine ? '\n' : '';
        const trailingNewLineString = details.trailingNewLine ? '\n' : '';

        const replaceText = `${leadingSpaceString***REMOVED***${leadingNewLineString***REMOVED***${source***REMOVED***${trailingNewLineString***REMOVED***${trailingSpaceString***REMOVED***`;

        report(context, messages.moveToNewLine, 'moveToNewLine', {
          node: nodeToReport,
          data: {
            descriptor,
          ***REMOVED***,
          fix(fixer) {
            return fixer.replaceText(nodeToReport, replaceText);
          ***REMOVED***,
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***

    return {
      JSXElement: handleJSX,
      JSXFragment: handleJSX,
    ***REMOVED***;
  ***REMOVED***,
***REMOVED***;
