/**
 * @fileoverview Rule to disallow useless backreferences in regular expressions
 * @author Milos Djermanovic
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const {
	CALL,
	CONSTRUCT,
	ReferenceTracker,
	getStringIfConstant,
***REMOVED*** = require("@eslint-community/eslint-utils");
const { RegExpParser, visitRegExpAST ***REMOVED*** = require("@eslint-community/regexpp");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const parser = new RegExpParser();

/**
 * Finds the path from the given `regexpp` AST node to the root node.
 * @param {regexpp.Node***REMOVED*** node Node.
 * @returns {regexpp.Node[]***REMOVED*** Array that starts with the given node and ends with the root node.
 */
function getPathToRoot(node) {
	const path = [];
	let current = node;

	do {
		path.push(current);
		current = current.parent;
	***REMOVED*** while (current);

	return path;
***REMOVED***

/**
 * Determines whether the given `regexpp` AST node is a lookaround node.
 * @param {regexpp.Node***REMOVED*** node Node.
 * @returns {boolean***REMOVED*** `true` if it is a lookaround node.
 */
function isLookaround(node) {
	return (
		node.type === "Assertion" &&
		(node.kind === "lookahead" || node.kind === "lookbehind")
	);
***REMOVED***

/**
 * Determines whether the given `regexpp` AST node is a negative lookaround node.
 * @param {regexpp.Node***REMOVED*** node Node.
 * @returns {boolean***REMOVED*** `true` if it is a negative lookaround node.
 */
function isNegativeLookaround(node) {
	return isLookaround(node) && node.negate;
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "problem",

		docs: {
			description:
				"Disallow useless backreferences in regular expressions",
			recommended: true,
			url: "https://eslint.org/docs/latest/rules/no-useless-backreference",
		***REMOVED***,

		schema: [],

		messages: {
			nested: "Backreference '{{ bref ***REMOVED******REMOVED***' will be ignored. It references group '{{ group ***REMOVED******REMOVED***'{{ otherGroups ***REMOVED******REMOVED*** from within that group.",
			forward:
				"Backreference '{{ bref ***REMOVED******REMOVED***' will be ignored. It references group '{{ group ***REMOVED******REMOVED***'{{ otherGroups ***REMOVED******REMOVED*** which appears later in the pattern.",
			backward:
				"Backreference '{{ bref ***REMOVED******REMOVED***' will be ignored. It references group '{{ group ***REMOVED******REMOVED***'{{ otherGroups ***REMOVED******REMOVED*** which appears before in the same lookbehind.",
			disjunctive:
				"Backreference '{{ bref ***REMOVED******REMOVED***' will be ignored. It references group '{{ group ***REMOVED******REMOVED***'{{ otherGroups ***REMOVED******REMOVED*** which is in another alternative.",
			intoNegativeLookaround:
				"Backreference '{{ bref ***REMOVED******REMOVED***' will be ignored. It references group '{{ group ***REMOVED******REMOVED***'{{ otherGroups ***REMOVED******REMOVED*** which is in a negative lookaround.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const sourceCode = context.sourceCode;

		/**
		 * Checks and reports useless backreferences in the given regular expression.
		 * @param {ASTNode***REMOVED*** node Node that represents regular expression. A regex literal or RegExp constructor call.
		 * @param {string***REMOVED*** pattern Regular expression pattern.
		 * @param {string***REMOVED*** flags Regular expression flags.
		 * @returns {void***REMOVED***
		 */
		function checkRegex(node, pattern, flags) {
			let regExpAST;

			try {
				regExpAST = parser.parsePattern(pattern, 0, pattern.length, {
					unicode: flags.includes("u"),
					unicodeSets: flags.includes("v"),
				***REMOVED***);
			***REMOVED*** catch {
				// Ignore regular expressions with syntax errors
				return;
			***REMOVED***

			visitRegExpAST(regExpAST, {
				onBackreferenceEnter(bref) {
					const groups = [bref.resolved].flat(),
						brefPath = getPathToRoot(bref);

					const problems = groups.map(group => {
						const groupPath = getPathToRoot(group);

						if (brefPath.includes(group)) {
							// group is bref's ancestor => bref is nested ('nested reference') => group hasn't matched yet when bref starts to match.
							return {
								messageId: "nested",
								group,
							***REMOVED***;
						***REMOVED***

						// Start from the root to find the lowest common ancestor.
						let i = brefPath.length - 1,
							j = groupPath.length - 1;

						do {
							i--;
							j--;
						***REMOVED*** while (brefPath[i] === groupPath[j]);

						const indexOfLowestCommonAncestor = j + 1,
							groupCut = groupPath.slice(
								0,
								indexOfLowestCommonAncestor,
							),
							commonPath = groupPath.slice(
								indexOfLowestCommonAncestor,
							),
							lowestCommonLookaround =
								commonPath.find(isLookaround),
							isMatchingBackward =
								lowestCommonLookaround &&
								lowestCommonLookaround.kind === "lookbehind";

						if (groupCut.at(-1).type === "Alternative") {
							// group's and bref's ancestor nodes below the lowest common ancestor are sibling alternatives => they're disjunctive.
							return {
								messageId: "disjunctive",
								group,
							***REMOVED***;
						***REMOVED***
						if (!isMatchingBackward && bref.end <= group.start) {
							// bref is left, group is right ('forward reference') => group hasn't matched yet when bref starts to match.
							return {
								messageId: "forward",
								group,
							***REMOVED***;
						***REMOVED***
						if (isMatchingBackward && group.end <= bref.start) {
							// the opposite of the previous when the regex is matching backward in a lookbehind context.
							return {
								messageId: "backward",
								group,
							***REMOVED***;
						***REMOVED***
						if (groupCut.some(isNegativeLookaround)) {
							// group is in a negative lookaround which isn't bref's ancestor => group has already failed when bref starts to match.
							return {
								messageId: "intoNegativeLookaround",
								group,
							***REMOVED***;
						***REMOVED***

						return null;
					***REMOVED***);

					if (
						problems.length === 0 ||
						problems.some(problem => !problem)
					) {
						// If there are no problems or no problems with any group then do not report it.
						return;
					***REMOVED***

					let problemsToReport;

					// Gets problems that appear in the same disjunction.
					const problemsInSameDisjunction = problems.filter(
						problem => problem.messageId !== "disjunctive",
					);

					if (problemsInSameDisjunction.length) {
						// Only report problems that appear in the same disjunction.
						problemsToReport = problemsInSameDisjunction;
					***REMOVED*** else {
						// If all groups appear in different disjunctions, report it.
						problemsToReport = problems;
					***REMOVED***

					const [{ messageId, group ***REMOVED***, ...other] = problemsToReport;
					let otherGroups = "";

					if (other.length === 1) {
						otherGroups = " and another group";
					***REMOVED*** else if (other.length > 1) {
						otherGroups = ` and other ${other.length***REMOVED*** groups`;
					***REMOVED***
					context.report({
						node,
						messageId,
						data: {
							bref: bref.raw,
							group: group.raw,
							otherGroups,
						***REMOVED***,
					***REMOVED***);
				***REMOVED***,
			***REMOVED***);
		***REMOVED***

		return {
			"Literal[regex]"(node) {
				const { pattern, flags ***REMOVED*** = node.regex;

				checkRegex(node, pattern, flags);
			***REMOVED***,
			Program(node) {
				const scope = sourceCode.getScope(node),
					tracker = new ReferenceTracker(scope),
					traceMap = {
						RegExp: {
							[CALL]: true,
							[CONSTRUCT]: true,
						***REMOVED***,
					***REMOVED***;

				for (const { node: refNode ***REMOVED*** of tracker.iterateGlobalReferences(
					traceMap,
				)) {
					const [patternNode, flagsNode] = refNode.arguments,
						pattern = getStringIfConstant(patternNode, scope),
						flags = getStringIfConstant(flagsNode, scope);

					if (typeof pattern === "string") {
						checkRegex(refNode, pattern, flags || "");
					***REMOVED***
				***REMOVED***
			***REMOVED***,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
