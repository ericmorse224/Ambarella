/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { ConcatSource, RawSource ***REMOVED*** = require("webpack-sources");
const RuntimeGlobals = require("../RuntimeGlobals");
const Template = require("../Template");
const { getUndoPath ***REMOVED*** = require("../util/identifier");
const {
	getChunkFilenameTemplate,
	getCompilationHooks
***REMOVED*** = require("./JavascriptModulesPlugin");
const {
	generateEntryStartup,
	updateHashForEntryStartup
***REMOVED*** = require("./StartupHelpers");

/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../Entrypoint")***REMOVED*** Entrypoint */

class CommonJsChunkFormatPlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		compiler.hooks.thisCompilation.tap(
			"CommonJsChunkFormatPlugin",
			compilation => {
				compilation.hooks.additionalChunkRuntimeRequirements.tap(
					"CommonJsChunkFormatPlugin",
					(chunk, set, { chunkGraph ***REMOVED***) => {
						if (chunk.hasRuntime()) return;
						if (chunkGraph.getNumberOfEntryModules(chunk) > 0) {
							set.add(RuntimeGlobals.require);
							set.add(RuntimeGlobals.startupEntrypoint);
							set.add(RuntimeGlobals.externalInstallChunk);
						***REMOVED***
					***REMOVED***
				);
				const hooks = getCompilationHooks(compilation);
				hooks.renderChunk.tap(
					"CommonJsChunkFormatPlugin",
					(modules, renderContext) => {
						const { chunk, chunkGraph, runtimeTemplate ***REMOVED*** = renderContext;
						const source = new ConcatSource();
						source.add(`exports.id = ${JSON.stringify(chunk.id)***REMOVED***;\n`);
						source.add(`exports.ids = ${JSON.stringify(chunk.ids)***REMOVED***;\n`);
						source.add("exports.modules = ");
						source.add(modules);
						source.add(";\n");
						const runtimeModules =
							chunkGraph.getChunkRuntimeModulesInOrder(chunk);
						if (runtimeModules.length > 0) {
							source.add("exports.runtime =\n");
							source.add(
								Template.renderChunkRuntimeModules(
									runtimeModules,
									renderContext
								)
							);
						***REMOVED***
						const entries = Array.from(
							chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk)
						);
						if (entries.length > 0) {
							const runtimeChunk =
								/** @type {Entrypoint***REMOVED*** */
								(entries[0][1]).getRuntimeChunk();
							const currentOutputName = compilation
								.getPath(
									getChunkFilenameTemplate(chunk, compilation.outputOptions),
									{
										chunk,
										contentHashType: "javascript"
									***REMOVED***
								)
								.replace(/^\/+/g, "")
								.split("/");
							const runtimeOutputName = compilation
								.getPath(
									getChunkFilenameTemplate(
										/** @type {Chunk***REMOVED*** */
										(runtimeChunk),
										compilation.outputOptions
									),
									{
										chunk: /** @type {Chunk***REMOVED*** */ (runtimeChunk),
										contentHashType: "javascript"
									***REMOVED***
								)
								.replace(/^\/+/g, "")
								.split("/");

							// remove common parts
							while (
								currentOutputName.length > 1 &&
								runtimeOutputName.length > 1 &&
								currentOutputName[0] === runtimeOutputName[0]
							) {
								currentOutputName.shift();
								runtimeOutputName.shift();
							***REMOVED***
							const last = runtimeOutputName.join("/");
							// create final path
							const runtimePath =
								getUndoPath(currentOutputName.join("/"), last, true) + last;

							const entrySource = new ConcatSource();
							entrySource.add(
								`(${
									runtimeTemplate.supportsArrowFunction()
										? "() => "
										: "function() "
								***REMOVED***{\n`
							);
							entrySource.add("var exports = {***REMOVED***;\n");
							entrySource.add(source);
							entrySource.add(";\n\n// load runtime\n");
							entrySource.add(
								`var ${RuntimeGlobals.require***REMOVED*** = require(${JSON.stringify(
									runtimePath
								)***REMOVED***);\n`
							);
							entrySource.add(
								`${RuntimeGlobals.externalInstallChunk***REMOVED***(exports);\n`
							);
							const startupSource = new RawSource(
								generateEntryStartup(
									chunkGraph,
									runtimeTemplate,
									entries,
									chunk,
									false
								)
							);
							entrySource.add(
								hooks.renderStartup.call(
									startupSource,
									entries[entries.length - 1][0],
									{
										...renderContext,
										inlined: false
									***REMOVED***
								)
							);
							entrySource.add("\n***REMOVED***)()");
							return entrySource;
						***REMOVED***
						return source;
					***REMOVED***
				);
				hooks.chunkHash.tap(
					"CommonJsChunkFormatPlugin",
					(chunk, hash, { chunkGraph ***REMOVED***) => {
						if (chunk.hasRuntime()) return;
						hash.update("CommonJsChunkFormatPlugin");
						hash.update("1");
						const entries = Array.from(
							chunkGraph.getChunkEntryModulesWithChunkGroupIterable(chunk)
						);
						updateHashForEntryStartup(hash, chunkGraph, entries, chunk);
					***REMOVED***
				);
			***REMOVED***
		);
	***REMOVED***
***REMOVED***

module.exports = CommonJsChunkFormatPlugin;
