"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.arrowFunctionToExpression = arrowFunctionToExpression;
exports.ensureBlock = ensureBlock;
exports.ensureFunctionName = ensureFunctionName;
exports.splitExportDeclaration = splitExportDeclaration;
exports.toComputedKey = toComputedKey;
exports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
var _t = require("@babel/types");
var _template = require("@babel/template");
var _visitors = require("../visitors.js");
var _context = require("./context.js");
const {
  arrowFunctionExpression,
  assignmentExpression,
  binaryExpression,
  blockStatement,
  callExpression,
  conditionalExpression,
  expressionStatement,
  identifier,
  isIdentifier,
  jsxIdentifier,
  logicalExpression,
  LOGICAL_OPERATORS,
  memberExpression,
  metaProperty,
  numericLiteral,
  objectExpression,
  restElement,
  returnStatement,
  sequenceExpression,
  spreadElement,
  stringLiteral,
  super: _super,
  thisExpression,
  toExpression,
  unaryExpression,
  toBindingIdentifierName,
  isFunction,
  isAssignmentPattern,
  isRestElement,
  getFunctionName,
  cloneNode,
  variableDeclaration,
  variableDeclarator,
  exportNamedDeclaration,
  exportSpecifier,
  inherits
***REMOVED*** = _t;
function toComputedKey() {
  let key;
  if (this.isMemberExpression()) {
    key = this.node.property;
  ***REMOVED*** else if (this.isProperty() || this.isMethod()) {
    key = this.node.key;
  ***REMOVED*** else {
    throw new ReferenceError("todo");
  ***REMOVED***
  if (!this.node.computed) {
    if (isIdentifier(key)) key = stringLiteral(key.name);
  ***REMOVED***
  return key;
***REMOVED***
function ensureBlock() {
  const body = this.get("body");
  const bodyNode = body.node;
  if (Array.isArray(body)) {
    throw new Error("Can't convert array path to a block statement");
  ***REMOVED***
  if (!bodyNode) {
    throw new Error("Can't convert node without a body");
  ***REMOVED***
  if (body.isBlockStatement()) {
    return bodyNode;
  ***REMOVED***
  const statements = [];
  let stringPath = "body";
  let key;
  let listKey;
  if (body.isStatement()) {
    listKey = "body";
    key = 0;
    statements.push(body.node);
  ***REMOVED*** else {
    stringPath += ".body.0";
    if (this.isFunction()) {
      key = "argument";
      statements.push(returnStatement(body.node));
    ***REMOVED*** else {
      key = "expression";
      statements.push(expressionStatement(body.node));
    ***REMOVED***
  ***REMOVED***
  this.node.body = blockStatement(statements);
  const parentPath = this.get(stringPath);
  _context.setup.call(body, parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
  return this.node;
***REMOVED***
{
  exports.arrowFunctionToShadowed = function () {
    if (!this.isArrowFunctionExpression()) return;
    this.arrowFunctionToExpression();
  ***REMOVED***;
***REMOVED***
function unwrapFunctionEnvironment() {
  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
    throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
  ***REMOVED***
  hoistFunctionEnvironment(this);
***REMOVED***
function setType(path, type) {
  path.node.type = type;
***REMOVED***
function arrowFunctionToExpression({
  allowInsertArrow = true,
  allowInsertArrowWithRest = allowInsertArrow,
  noNewArrows = !(_arguments$ => (_arguments$ = arguments[0]) == null ? void 0 : _arguments$.specCompliant)()
***REMOVED*** = {***REMOVED***) {
  if (!this.isArrowFunctionExpression()) {
    throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
  ***REMOVED***
  let self = this;
  if (!noNewArrows) {
    var _self$ensureFunctionN;
    self = (_self$ensureFunctionN = self.ensureFunctionName(false)) != null ? _self$ensureFunctionN : self;
  ***REMOVED***
  const {
    thisBinding,
    fnPath: fn
  ***REMOVED*** = hoistFunctionEnvironment(self, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
  fn.ensureBlock();
  setType(fn, "FunctionExpression");
  if (!noNewArrows) {
    const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
    if (checkBinding) {
      fn.parentPath.scope.push({
        id: checkBinding,
        init: objectExpression([])
      ***REMOVED***);
    ***REMOVED***
    fn.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));
    fn.replaceWith(callExpression(memberExpression(fn.node, identifier("bind")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));
    return fn.get("callee.object");
  ***REMOVED***
  return fn;
***REMOVED***
const getSuperCallsVisitor = (0, _visitors.environmentVisitor)({
  CallExpression(child, {
    allSuperCalls
  ***REMOVED***) {
    if (!child.get("callee").isSuper()) return;
    allSuperCalls.push(child);
  ***REMOVED***
***REMOVED***);
function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {
  let arrowParent;
  let thisEnvFn = fnPath.findParent(p => {
    if (p.isArrowFunctionExpression()) {
      arrowParent != null ? arrowParent : arrowParent = p;
      return false;
    ***REMOVED***
    return p.isFunction() || p.isProgram() || p.isClassProperty({
      static: false
    ***REMOVED***) || p.isClassPrivateProperty({
      static: false
    ***REMOVED***);
  ***REMOVED***);
  const inConstructor = thisEnvFn.isClassMethod({
    kind: "constructor"
  ***REMOVED***);
  if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
    if (arrowParent) {
      thisEnvFn = arrowParent;
    ***REMOVED*** else if (allowInsertArrow) {
      fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));
      thisEnvFn = fnPath.get("callee");
      fnPath = thisEnvFn.get("body");
    ***REMOVED*** else {
      throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
    ***REMOVED***
  ***REMOVED***
  const {
    thisPaths,
    argumentsPaths,
    newTargetPaths,
    superProps,
    superCalls
  ***REMOVED*** = getScopeInformation(fnPath);
  if (inConstructor && superCalls.length > 0) {
    if (!allowInsertArrow) {
      throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', " + "it's not possible to compile `super()` in an arrow function without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
    ***REMOVED***
    if (!allowInsertArrowWithRest) {
      throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', " + "it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
    ***REMOVED***
    const allSuperCalls = [];
    thisEnvFn.traverse(getSuperCallsVisitor, {
      allSuperCalls
    ***REMOVED***);
    const superBinding = getSuperBinding(thisEnvFn);
    allSuperCalls.forEach(superCall => {
      const callee = identifier(superBinding);
      callee.loc = superCall.node.callee.loc;
      superCall.get("callee").replaceWith(callee);
    ***REMOVED***);
  ***REMOVED***
  if (argumentsPaths.length > 0) {
    const argumentsBinding = getBinding(thisEnvFn, "arguments", () => {
      const args = () => identifier("arguments");
      if (thisEnvFn.scope.path.isProgram()) {
        return conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
      ***REMOVED*** else {
        return args();
      ***REMOVED***
    ***REMOVED***);
    argumentsPaths.forEach(argumentsChild => {
      const argsRef = identifier(argumentsBinding);
      argsRef.loc = argumentsChild.node.loc;
      argumentsChild.replaceWith(argsRef);
    ***REMOVED***);
  ***REMOVED***
  if (newTargetPaths.length > 0) {
    const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty(identifier("new"), identifier("target")));
    newTargetPaths.forEach(targetChild => {
      const targetRef = identifier(newTargetBinding);
      targetRef.loc = targetChild.node.loc;
      targetChild.replaceWith(targetRef);
    ***REMOVED***);
  ***REMOVED***
  if (superProps.length > 0) {
    if (!allowInsertArrow) {
      throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', " + "it's not possible to compile `super.prop` in an arrow function without compiling classes.\n" + "Please add '@babel/plugin-transform-classes' to your Babel configuration.");
    ***REMOVED***
    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
    flatSuperProps.forEach(superProp => {
      const key = superProp.node.computed ? "" : superProp.get("property").node.name;
      const superParentPath = superProp.parentPath;
      const isAssignment = superParentPath.isAssignmentExpression({
        left: superProp.node
      ***REMOVED***);
      const isCall = superParentPath.isCallExpression({
        callee: superProp.node
      ***REMOVED***);
      const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
        tag: superProp.node
      ***REMOVED***);
      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
      const args = [];
      if (superProp.node.computed) {
        args.push(superProp.get("property").node);
      ***REMOVED***
      if (isAssignment) {
        const value = superParentPath.node.right;
        args.push(value);
      ***REMOVED***
      const call = callExpression(identifier(superBinding), args);
      if (isCall) {
        superParentPath.unshiftContainer("arguments", thisExpression());
        superProp.replaceWith(memberExpression(call, identifier("call")));
        thisPaths.push(superParentPath.get("arguments.0"));
      ***REMOVED*** else if (isAssignment) {
        superParentPath.replaceWith(call);
      ***REMOVED*** else if (isTaggedTemplate) {
        superProp.replaceWith(callExpression(memberExpression(call, identifier("bind"), false), [thisExpression()]));
        thisPaths.push(superProp.get("arguments.0"));
      ***REMOVED*** else {
        superProp.replaceWith(call);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***
  let thisBinding;
  if (thisPaths.length > 0 || !noNewArrows) {
    thisBinding = getThisBinding(thisEnvFn, inConstructor);
    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
      thisPaths.forEach(thisChild => {
        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
        thisRef.loc = thisChild.node.loc;
        thisChild.replaceWith(thisRef);
      ***REMOVED***);
      if (!noNewArrows) thisBinding = null;
    ***REMOVED***
  ***REMOVED***
  return {
    thisBinding,
    fnPath
  ***REMOVED***;
***REMOVED***
function isLogicalOp(op) {
  return LOGICAL_OPERATORS.includes(op);
***REMOVED***
function standardizeSuperProperty(superProp) {
  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
    const assignmentPath = superProp.parentPath;
    const op = assignmentPath.node.operator.slice(0, -1);
    const value = assignmentPath.node.right;
    const isLogicalAssignment = isLogicalOp(op);
    if (superProp.node.computed) {
      const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
      const object = superProp.node.object;
      const property = superProp.node.property;
      assignmentPath.get("left").replaceWith(memberExpression(object, assignmentExpression("=", tmp, property), true));
      assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(tmp.name), true), value));
    ***REMOVED*** else {
      const object = superProp.node.object;
      const property = superProp.node.property;
      assignmentPath.get("left").replaceWith(memberExpression(object, property));
      assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object, identifier(property.name)), value));
    ***REMOVED***
    if (isLogicalAssignment) {
      assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));
    ***REMOVED*** else {
      assignmentPath.node.operator = "=";
    ***REMOVED***
    return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
  ***REMOVED*** else if (superProp.parentPath.isUpdateExpression()) {
    const updateExpr = superProp.parentPath;
    const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
    const parts = [assignmentExpression("=", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];
    if (!superProp.parentPath.node.prefix) {
      parts.push(identifier(tmp.name));
    ***REMOVED***
    updateExpr.replaceWith(sequenceExpression(parts));
    const left = updateExpr.get("expressions.0.right");
    const right = updateExpr.get("expressions.1.left");
    return [left, right];
  ***REMOVED***
  return [superProp];
  function rightExpression(op, left, right) {
    if (op === "=") {
      return assignmentExpression("=", left, right);
    ***REMOVED*** else {
      return binaryExpression(op, left, right);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
function hasSuperClass(thisEnvFn) {
  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
***REMOVED***
const assignSuperThisVisitor = (0, _visitors.environmentVisitor)({
  CallExpression(child, {
    supers,
    thisBinding
  ***REMOVED***) {
    if (!child.get("callee").isSuper()) return;
    if (supers.has(child.node)) return;
    supers.add(child.node);
    child.replaceWithMultiple([child.node, assignmentExpression("=", identifier(thisBinding), identifier("this"))]);
  ***REMOVED***
***REMOVED***);
function getThisBinding(thisEnvFn, inConstructor) {
  return getBinding(thisEnvFn, "this", thisBinding => {
    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();
    thisEnvFn.traverse(assignSuperThisVisitor, {
      supers: new WeakSet(),
      thisBinding
    ***REMOVED***);
  ***REMOVED***);
***REMOVED***
function getSuperBinding(thisEnvFn) {
  return getBinding(thisEnvFn, "supercall", () => {
    const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));
  ***REMOVED***);
***REMOVED***
function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
  const op = isAssignment ? "set" : "get";
  return getBinding(thisEnvFn, `superprop_${op***REMOVED***:${propName || ""***REMOVED***`, () => {
    const argsList = [];
    let fnBody;
    if (propName) {
      fnBody = memberExpression(_super(), identifier(propName));
    ***REMOVED*** else {
      const method = thisEnvFn.scope.generateUidIdentifier("prop");
      argsList.unshift(method);
      fnBody = memberExpression(_super(), identifier(method.name), true);
    ***REMOVED***
    if (isAssignment) {
      const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
      argsList.push(valueIdent);
      fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));
    ***REMOVED***
    return arrowFunctionExpression(argsList, fnBody);
  ***REMOVED***);
***REMOVED***
function getBinding(thisEnvFn, key, init) {
  const cacheKey = "binding:" + key;
  let data = thisEnvFn.getData(cacheKey);
  if (!data) {
    const id = thisEnvFn.scope.generateUidIdentifier(key);
    data = id.name;
    thisEnvFn.setData(cacheKey, data);
    thisEnvFn.scope.push({
      id: id,
      init: init(data)
    ***REMOVED***);
  ***REMOVED***
  return data;
***REMOVED***
const getScopeInformationVisitor = (0, _visitors.environmentVisitor)({
  ThisExpression(child, {
    thisPaths
  ***REMOVED***) {
    thisPaths.push(child);
  ***REMOVED***,
  JSXIdentifier(child, {
    thisPaths
  ***REMOVED***) {
    if (child.node.name !== "this") return;
    if (!child.parentPath.isJSXMemberExpression({
      object: child.node
    ***REMOVED***) && !child.parentPath.isJSXOpeningElement({
      name: child.node
    ***REMOVED***)) {
      return;
    ***REMOVED***
    thisPaths.push(child);
  ***REMOVED***,
  CallExpression(child, {
    superCalls
  ***REMOVED***) {
    if (child.get("callee").isSuper()) superCalls.push(child);
  ***REMOVED***,
  MemberExpression(child, {
    superProps
  ***REMOVED***) {
    if (child.get("object").isSuper()) superProps.push(child);
  ***REMOVED***,
  Identifier(child, {
    argumentsPaths
  ***REMOVED***) {
    if (!child.isReferencedIdentifier({
      name: "arguments"
    ***REMOVED***)) return;
    let curr = child.scope;
    do {
      if (curr.hasOwnBinding("arguments")) {
        curr.rename("arguments");
        return;
      ***REMOVED***
      if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
        break;
      ***REMOVED***
    ***REMOVED*** while (curr = curr.parent);
    argumentsPaths.push(child);
  ***REMOVED***,
  MetaProperty(child, {
    newTargetPaths
  ***REMOVED***) {
    if (!child.get("meta").isIdentifier({
      name: "new"
    ***REMOVED***)) return;
    if (!child.get("property").isIdentifier({
      name: "target"
    ***REMOVED***)) return;
    newTargetPaths.push(child);
  ***REMOVED***
***REMOVED***);
function getScopeInformation(fnPath) {
  const thisPaths = [];
  const argumentsPaths = [];
  const newTargetPaths = [];
  const superProps = [];
  const superCalls = [];
  fnPath.traverse(getScopeInformationVisitor, {
    thisPaths,
    argumentsPaths,
    newTargetPaths,
    superProps,
    superCalls
  ***REMOVED***);
  return {
    thisPaths,
    argumentsPaths,
    newTargetPaths,
    superProps,
    superCalls
  ***REMOVED***;
***REMOVED***
function splitExportDeclaration() {
  if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {
    throw new Error("Only default and named export declarations can be split.");
  ***REMOVED***
  if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0) {
    throw new Error("It doesn't make sense to split exported specifiers.");
  ***REMOVED***
  const declaration = this.get("declaration");
  if (this.isExportDefaultDeclaration()) {
    const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();
    const exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression();
    const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
    let id = declaration.node.id;
    let needBindingRegistration = false;
    if (!id) {
      needBindingRegistration = true;
      id = scope.generateUidIdentifier("default");
      if (standaloneDeclaration || exportExpr) {
        declaration.node.id = cloneNode(id);
      ***REMOVED***
    ***REMOVED*** else if (exportExpr && scope.hasBinding(id.name)) {
      needBindingRegistration = true;
      id = scope.generateUidIdentifier(id.name);
    ***REMOVED***
    const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration("var", [variableDeclarator(cloneNode(id), declaration.node)]);
    const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id), identifier("default"))]);
    this.insertAfter(updatedExportDeclaration);
    this.replaceWith(updatedDeclaration);
    if (needBindingRegistration) {
      scope.registerDeclaration(this);
    ***REMOVED***
    return this;
  ***REMOVED*** else if (this.get("specifiers").length > 0) {
    throw new Error("It doesn't make sense to split exported specifiers.");
  ***REMOVED***
  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
  const specifiers = Object.keys(bindingIdentifiers).map(name => {
    return exportSpecifier(identifier(name), identifier(name));
  ***REMOVED***);
  const aliasDeclar = exportNamedDeclaration(null, specifiers);
  this.insertAfter(aliasDeclar);
  this.replaceWith(declaration.node);
  return this;
***REMOVED***
const refersOuterBindingVisitor = {
  "ReferencedIdentifier|BindingIdentifier"(path, state) {
    if (path.node.name !== state.name) return;
    state.needsRename = true;
    path.stop();
  ***REMOVED***,
  Scope(path, state) {
    if (path.scope.hasOwnBinding(state.name)) {
      path.skip();
    ***REMOVED***
  ***REMOVED***
***REMOVED***;
function ensureFunctionName(supportUnicodeId) {
  if (this.node.id) return this;
  const res = getFunctionName(this.node, this.parent);
  if (res == null) return this;
  let {
    name
  ***REMOVED*** = res;
  if (!supportUnicodeId && /[\uD800-\uDFFF]/.test(name)) {
    return null;
  ***REMOVED***
  if (name.startsWith("get ") || name.startsWith("set ")) {
    return null;
  ***REMOVED***
  name = toBindingIdentifierName(name.replace(/[/ ]/g, "_"));
  const id = identifier(name);
  inherits(id, res.originalNode);
  const state = {
    needsRename: false,
    name
  ***REMOVED***;
  const {
    scope
  ***REMOVED*** = this;
  const binding = scope.getOwnBinding(name);
  if (binding) {
    if (binding.kind === "param") {
      state.needsRename = true;
    ***REMOVED*** else {***REMOVED***
  ***REMOVED*** else if (scope.parent.hasBinding(name) || scope.hasGlobal(name)) {
    this.traverse(refersOuterBindingVisitor, state);
  ***REMOVED***
  if (!state.needsRename) {
    this.node.id = id;
    scope.getProgramParent().references[id.name] = true;
    return this;
  ***REMOVED***
  if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {
    scope.rename(id.name);
    this.node.id = id;
    scope.getProgramParent().references[id.name] = true;
    return this;
  ***REMOVED***
  if (!isFunction(this.node)) return null;
  const key = scope.generateUidIdentifier(id.name);
  const params = [];
  for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {
    params.push(scope.generateUidIdentifier("x"));
  ***REMOVED***
  const call = _template.default.expression.ast`
    (function (${key***REMOVED***) {
      function ${id***REMOVED***(${params***REMOVED***) {
        return ${cloneNode(key)***REMOVED***.apply(this, arguments);
      ***REMOVED***

      ${cloneNode(id)***REMOVED***.toString = function () {
        return ${cloneNode(key)***REMOVED***.toString();
      ***REMOVED***

      return ${cloneNode(id)***REMOVED***;
    ***REMOVED***)(${toExpression(this.node)***REMOVED***)
  `;
  return this.replaceWith(call)[0].get("arguments.0");
***REMOVED***
function getFunctionArity(node) {
  const count = node.params.findIndex(param => isAssignmentPattern(param) || isRestElement(param));
  return count === -1 ? node.params.length : count;
***REMOVED***

//# sourceMappingURL=conversion.js.map
