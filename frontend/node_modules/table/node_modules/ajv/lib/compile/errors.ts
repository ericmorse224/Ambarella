import type {KeywordErrorCxt, KeywordErrorDefinition***REMOVED*** from "../types"
import type {SchemaCxt***REMOVED*** from "./index"
import {CodeGen, _, str, strConcat, Code, Name***REMOVED*** from "./codegen"
import {SafeExpr***REMOVED*** from "./codegen/code"
import {getErrorPath, Type***REMOVED*** from "./util"
import N from "./names"

export const keywordError: KeywordErrorDefinition = {
  message: ({keyword***REMOVED***) => str`must pass "${keyword***REMOVED***" keyword validation`,
***REMOVED***

export const keyword$DataError: KeywordErrorDefinition = {
  message: ({keyword, schemaType***REMOVED***) =>
    schemaType
      ? str`"${keyword***REMOVED***" keyword must be ${schemaType***REMOVED*** ($data)`
      : str`"${keyword***REMOVED***" keyword is invalid ($data)`,
***REMOVED***

export interface ErrorPaths {
  instancePath?: Code
  schemaPath?: string
  parentSchema?: boolean
***REMOVED***

export function reportError(
  cxt: KeywordErrorCxt,
  error: KeywordErrorDefinition = keywordError,
  errorPaths?: ErrorPaths,
  overrideAllErrors?: boolean
): void {
  const {it***REMOVED*** = cxt
  const {gen, compositeRule, allErrors***REMOVED*** = it
  const errObj = errorObjectCode(cxt, error, errorPaths)
  if (overrideAllErrors ?? (compositeRule || allErrors)) {
    addError(gen, errObj)
  ***REMOVED*** else {
    returnErrors(it, _`[${errObj***REMOVED***]`)
  ***REMOVED***
***REMOVED***

export function reportExtraError(
  cxt: KeywordErrorCxt,
  error: KeywordErrorDefinition = keywordError,
  errorPaths?: ErrorPaths
): void {
  const {it***REMOVED*** = cxt
  const {gen, compositeRule, allErrors***REMOVED*** = it
  const errObj = errorObjectCode(cxt, error, errorPaths)
  addError(gen, errObj)
  if (!(compositeRule || allErrors)) {
    returnErrors(it, N.vErrors)
  ***REMOVED***
***REMOVED***

export function resetErrorsCount(gen: CodeGen, errsCount: Name): void {
  gen.assign(N.errors, errsCount)
  gen.if(_`${N.vErrors***REMOVED*** !== null`, () =>
    gen.if(
      errsCount,
      () => gen.assign(_`${N.vErrors***REMOVED***.length`, errsCount),
      () => gen.assign(N.vErrors, null)
    )
  )
***REMOVED***

export function extendErrors({
  gen,
  keyword,
  schemaValue,
  data,
  errsCount,
  it,
***REMOVED***: KeywordErrorCxt): void {
  /* istanbul ignore if */
  if (errsCount === undefined) throw new Error("ajv implementation error")
  const err = gen.name("err")
  gen.forRange("i", errsCount, N.errors, (i) => {
    gen.const(err, _`${N.vErrors***REMOVED***[${i***REMOVED***]`)
    gen.if(_`${err***REMOVED***.instancePath === undefined`, () =>
      gen.assign(_`${err***REMOVED***.instancePath`, strConcat(N.instancePath, it.errorPath))
    )
    gen.assign(_`${err***REMOVED***.schemaPath`, str`${it.errSchemaPath***REMOVED***/${keyword***REMOVED***`)
    if (it.opts.verbose) {
      gen.assign(_`${err***REMOVED***.schema`, schemaValue)
      gen.assign(_`${err***REMOVED***.data`, data)
    ***REMOVED***
  ***REMOVED***)
***REMOVED***

function addError(gen: CodeGen, errObj: Code): void {
  const err = gen.const("err", errObj)
  gen.if(
    _`${N.vErrors***REMOVED*** === null`,
    () => gen.assign(N.vErrors, _`[${err***REMOVED***]`),
    _`${N.vErrors***REMOVED***.push(${err***REMOVED***)`
  )
  gen.code(_`${N.errors***REMOVED***++`)
***REMOVED***

function returnErrors(it: SchemaCxt, errs: Code): void {
  const {gen, validateName, schemaEnv***REMOVED*** = it
  if (schemaEnv.$async) {
    gen.throw(_`new ${it.ValidationError as Name***REMOVED***(${errs***REMOVED***)`)
  ***REMOVED*** else {
    gen.assign(_`${validateName***REMOVED***.errors`, errs)
    gen.return(false)
  ***REMOVED***
***REMOVED***

const E = {
  keyword: new Name("keyword"),
  schemaPath: new Name("schemaPath"), // also used in JTD errors
  params: new Name("params"),
  propertyName: new Name("propertyName"),
  message: new Name("message"),
  schema: new Name("schema"),
  parentSchema: new Name("parentSchema"),
***REMOVED***

function errorObjectCode(
  cxt: KeywordErrorCxt,
  error: KeywordErrorDefinition,
  errorPaths?: ErrorPaths
): Code {
  const {createErrors***REMOVED*** = cxt.it
  if (createErrors === false) return _`{***REMOVED***`
  return errorObject(cxt, error, errorPaths)
***REMOVED***

function errorObject(
  cxt: KeywordErrorCxt,
  error: KeywordErrorDefinition,
  errorPaths: ErrorPaths = {***REMOVED***
): Code {
  const {gen, it***REMOVED*** = cxt
  const keyValues: [Name, SafeExpr | string][] = [
    errorInstancePath(it, errorPaths),
    errorSchemaPath(cxt, errorPaths),
  ]
  extraErrorProps(cxt, error, keyValues)
  return gen.object(...keyValues)
***REMOVED***

function errorInstancePath({errorPath***REMOVED***: SchemaCxt, {instancePath***REMOVED***: ErrorPaths): [Name, Code] {
  const instPath = instancePath
    ? str`${errorPath***REMOVED***${getErrorPath(instancePath, Type.Str)***REMOVED***`
    : errorPath
  return [N.instancePath, strConcat(N.instancePath, instPath)]
***REMOVED***

function errorSchemaPath(
  {keyword, it: {errSchemaPath***REMOVED******REMOVED***: KeywordErrorCxt,
  {schemaPath, parentSchema***REMOVED***: ErrorPaths
): [Name, string | Code] {
  let schPath = parentSchema ? errSchemaPath : str`${errSchemaPath***REMOVED***/${keyword***REMOVED***`
  if (schemaPath) {
    schPath = str`${schPath***REMOVED***${getErrorPath(schemaPath, Type.Str)***REMOVED***`
  ***REMOVED***
  return [E.schemaPath, schPath]
***REMOVED***

function extraErrorProps(
  cxt: KeywordErrorCxt,
  {params, message***REMOVED***: KeywordErrorDefinition,
  keyValues: [Name, SafeExpr | string][]
): void {
  const {keyword, data, schemaValue, it***REMOVED*** = cxt
  const {opts, propertyName, topSchemaRef, schemaPath***REMOVED*** = it
  keyValues.push(
    [E.keyword, keyword],
    [E.params, typeof params == "function" ? params(cxt) : params || _`{***REMOVED***`]
  )
  if (opts.messages) {
    keyValues.push([E.message, typeof message == "function" ? message(cxt) : message])
  ***REMOVED***
  if (opts.verbose) {
    keyValues.push(
      [E.schema, schemaValue],
      [E.parentSchema, _`${topSchemaRef***REMOVED***${schemaPath***REMOVED***`],
      [N.data, data]
    )
  ***REMOVED***
  if (propertyName) keyValues.push([E.propertyName, propertyName])
***REMOVED***
