/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { forEachBail ***REMOVED*** = require("enhanced-resolve");
const asyncLib = require("neo-async");
const getLazyHashedEtag = require("./cache/getLazyHashedEtag");
const mergeEtags = require("./cache/mergeEtags");

/** @typedef {import("./Cache")***REMOVED*** Cache */
/** @typedef {import("./Cache").Etag***REMOVED*** Etag */
/** @typedef {import("./WebpackError")***REMOVED*** WebpackError */
/** @typedef {import("./cache/getLazyHashedEtag").HashableObject***REMOVED*** HashableObject */
/** @typedef {typeof import("./util/Hash")***REMOVED*** HashConstructor */

/**
 * @template T
 * @callback CallbackCache
 * @param {(Error | null)=***REMOVED*** err
 * @param {(T | null)=***REMOVED*** result
 * @returns {void***REMOVED***
 */

/**
 * @template T
 * @callback CallbackNormalErrorCache
 * @param {(Error | null)=***REMOVED*** err
 * @param {T=***REMOVED*** result
 * @returns {void***REMOVED***
 */

class MultiItemCache {
	/**
	 * @param {ItemCacheFacade[]***REMOVED*** items item caches
	 */
	constructor(items) {
		this._items = items;
		// eslint-disable-next-line no-constructor-return
		if (items.length === 1) return /** @type {TODO***REMOVED*** */ (items[0]);
	***REMOVED***

	/**
	 * @template T
	 * @param {CallbackCache<T>***REMOVED*** callback signals when the value is retrieved
	 * @returns {void***REMOVED***
	 */
	get(callback) {
		forEachBail(this._items, (item, callback) => item.get(callback), callback);
	***REMOVED***

	/**
	 * @template T
	 * @returns {Promise<T>***REMOVED*** promise with the data
	 */
	getPromise() {
		/**
		 * @param {number***REMOVED*** i index
		 * @returns {Promise<T>***REMOVED*** promise with the data
		 */
		const next = i =>
			this._items[i].getPromise().then(result => {
				if (result !== undefined) return result;
				if (++i < this._items.length) return next(i);
			***REMOVED***);
		return next(0);
	***REMOVED***

	/**
	 * @template T
	 * @param {T***REMOVED*** data the value to store
	 * @param {CallbackCache<void>***REMOVED*** callback signals when the value is stored
	 * @returns {void***REMOVED***
	 */
	store(data, callback) {
		asyncLib.each(
			this._items,
			(item, callback) => item.store(data, callback),
			callback
		);
	***REMOVED***

	/**
	 * @template T
	 * @param {T***REMOVED*** data the value to store
	 * @returns {Promise<void>***REMOVED*** promise signals when the value is stored
	 */
	storePromise(data) {
		return Promise.all(this._items.map(item => item.storePromise(data))).then(
			() => {***REMOVED***
		);
	***REMOVED***
***REMOVED***

class ItemCacheFacade {
	/**
	 * @param {Cache***REMOVED*** cache the root cache
	 * @param {string***REMOVED*** name the child cache item name
	 * @param {Etag | null***REMOVED*** etag the etag
	 */
	constructor(cache, name, etag) {
		this._cache = cache;
		this._name = name;
		this._etag = etag;
	***REMOVED***

	/**
	 * @template T
	 * @param {CallbackCache<T>***REMOVED*** callback signals when the value is retrieved
	 * @returns {void***REMOVED***
	 */
	get(callback) {
		this._cache.get(this._name, this._etag, callback);
	***REMOVED***

	/**
	 * @template T
	 * @returns {Promise<T>***REMOVED*** promise with the data
	 */
	getPromise() {
		return new Promise((resolve, reject) => {
			this._cache.get(this._name, this._etag, (err, data) => {
				if (err) {
					reject(err);
				***REMOVED*** else {
					resolve(data);
				***REMOVED***
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	/**
	 * @template T
	 * @param {T***REMOVED*** data the value to store
	 * @param {CallbackCache<void>***REMOVED*** callback signals when the value is stored
	 * @returns {void***REMOVED***
	 */
	store(data, callback) {
		this._cache.store(this._name, this._etag, data, callback);
	***REMOVED***

	/**
	 * @template T
	 * @param {T***REMOVED*** data the value to store
	 * @returns {Promise<void>***REMOVED*** promise signals when the value is stored
	 */
	storePromise(data) {
		return new Promise((resolve, reject) => {
			this._cache.store(this._name, this._etag, data, err => {
				if (err) {
					reject(err);
				***REMOVED*** else {
					resolve();
				***REMOVED***
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	/**
	 * @template T
	 * @param {(callback: CallbackNormalErrorCache<T>) => void***REMOVED*** computer function to compute the value if not cached
	 * @param {CallbackNormalErrorCache<T>***REMOVED*** callback signals when the value is retrieved
	 * @returns {void***REMOVED***
	 */
	provide(computer, callback) {
		this.get((err, cacheEntry) => {
			if (err) return callback(err);
			if (cacheEntry !== undefined) return cacheEntry;
			computer((err, result) => {
				if (err) return callback(err);
				this.store(result, err => {
					if (err) return callback(err);
					callback(null, result);
				***REMOVED***);
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	/**
	 * @template T
	 * @param {() => Promise<T> | T***REMOVED*** computer function to compute the value if not cached
	 * @returns {Promise<T>***REMOVED*** promise with the data
	 */
	async providePromise(computer) {
		const cacheEntry = await this.getPromise();
		if (cacheEntry !== undefined) return cacheEntry;
		const result = await computer();
		await this.storePromise(result);
		return result;
	***REMOVED***
***REMOVED***

class CacheFacade {
	/**
	 * @param {Cache***REMOVED*** cache the root cache
	 * @param {string***REMOVED*** name the child cache name
	 * @param {(string | HashConstructor)=***REMOVED*** hashFunction the hash function to use
	 */
	constructor(cache, name, hashFunction) {
		this._cache = cache;
		this._name = name;
		this._hashFunction = hashFunction;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** name the child cache name#
	 * @returns {CacheFacade***REMOVED*** child cache
	 */
	getChildCache(name) {
		return new CacheFacade(
			this._cache,
			`${this._name***REMOVED***|${name***REMOVED***`,
			this._hashFunction
		);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** identifier the cache identifier
	 * @param {Etag | null***REMOVED*** etag the etag
	 * @returns {ItemCacheFacade***REMOVED*** item cache
	 */
	getItemCache(identifier, etag) {
		return new ItemCacheFacade(
			this._cache,
			`${this._name***REMOVED***|${identifier***REMOVED***`,
			etag
		);
	***REMOVED***

	/**
	 * @param {HashableObject***REMOVED*** obj an hashable object
	 * @returns {Etag***REMOVED*** an etag that is lazy hashed
	 */
	getLazyHashedEtag(obj) {
		return getLazyHashedEtag(obj, this._hashFunction);
	***REMOVED***

	/**
	 * @param {Etag***REMOVED*** a an etag
	 * @param {Etag***REMOVED*** b another etag
	 * @returns {Etag***REMOVED*** an etag that represents both
	 */
	mergeEtags(a, b) {
		return mergeEtags(a, b);
	***REMOVED***

	/**
	 * @template T
	 * @param {string***REMOVED*** identifier the cache identifier
	 * @param {Etag | null***REMOVED*** etag the etag
	 * @param {CallbackCache<T>***REMOVED*** callback signals when the value is retrieved
	 * @returns {void***REMOVED***
	 */
	get(identifier, etag, callback) {
		this._cache.get(`${this._name***REMOVED***|${identifier***REMOVED***`, etag, callback);
	***REMOVED***

	/**
	 * @template T
	 * @param {string***REMOVED*** identifier the cache identifier
	 * @param {Etag | null***REMOVED*** etag the etag
	 * @returns {Promise<T>***REMOVED*** promise with the data
	 */
	getPromise(identifier, etag) {
		return new Promise((resolve, reject) => {
			this._cache.get(`${this._name***REMOVED***|${identifier***REMOVED***`, etag, (err, data) => {
				if (err) {
					reject(err);
				***REMOVED*** else {
					resolve(data);
				***REMOVED***
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	/**
	 * @template T
	 * @param {string***REMOVED*** identifier the cache identifier
	 * @param {Etag | null***REMOVED*** etag the etag
	 * @param {T***REMOVED*** data the value to store
	 * @param {CallbackCache<void>***REMOVED*** callback signals when the value is stored
	 * @returns {void***REMOVED***
	 */
	store(identifier, etag, data, callback) {
		this._cache.store(`${this._name***REMOVED***|${identifier***REMOVED***`, etag, data, callback);
	***REMOVED***

	/**
	 * @template T
	 * @param {string***REMOVED*** identifier the cache identifier
	 * @param {Etag | null***REMOVED*** etag the etag
	 * @param {T***REMOVED*** data the value to store
	 * @returns {Promise<void>***REMOVED*** promise signals when the value is stored
	 */
	storePromise(identifier, etag, data) {
		return new Promise((resolve, reject) => {
			this._cache.store(`${this._name***REMOVED***|${identifier***REMOVED***`, etag, data, err => {
				if (err) {
					reject(err);
				***REMOVED*** else {
					resolve();
				***REMOVED***
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	/**
	 * @template T
	 * @param {string***REMOVED*** identifier the cache identifier
	 * @param {Etag | null***REMOVED*** etag the etag
	 * @param {(callback: CallbackNormalErrorCache<T>) => void***REMOVED*** computer function to compute the value if not cached
	 * @param {CallbackNormalErrorCache<T>***REMOVED*** callback signals when the value is retrieved
	 * @returns {void***REMOVED***
	 */
	provide(identifier, etag, computer, callback) {
		this.get(identifier, etag, (err, cacheEntry) => {
			if (err) return callback(err);
			if (cacheEntry !== undefined) return cacheEntry;
			computer((err, result) => {
				if (err) return callback(err);
				this.store(identifier, etag, result, err => {
					if (err) return callback(err);
					callback(null, result);
				***REMOVED***);
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	/**
	 * @template T
	 * @param {string***REMOVED*** identifier the cache identifier
	 * @param {Etag | null***REMOVED*** etag the etag
	 * @param {() => Promise<T> | T***REMOVED*** computer function to compute the value if not cached
	 * @returns {Promise<T>***REMOVED*** promise with the data
	 */
	async providePromise(identifier, etag, computer) {
		const cacheEntry = await this.getPromise(identifier, etag);
		if (cacheEntry !== undefined) return cacheEntry;
		const result = await computer();
		await this.storePromise(identifier, etag, result);
		return result;
	***REMOVED***
***REMOVED***

module.exports = CacheFacade;
module.exports.ItemCacheFacade = ItemCacheFacade;
module.exports.MultiItemCache = MultiItemCache;
