'use strict';

/**
 * @typedef {import('css-tree').Rule***REMOVED*** CsstreeRule
 * @typedef {import('./types').Specificity***REMOVED*** Specificity
 * @typedef {import('./types').Stylesheet***REMOVED*** Stylesheet
 * @typedef {import('./types').StylesheetRule***REMOVED*** StylesheetRule
 * @typedef {import('./types').StylesheetDeclaration***REMOVED*** StylesheetDeclaration
 * @typedef {import('./types').ComputedStyles***REMOVED*** ComputedStyles
 * @typedef {import('./types').XastRoot***REMOVED*** XastRoot
 * @typedef {import('./types').XastElement***REMOVED*** XastElement
 * @typedef {import('./types').XastParent***REMOVED*** XastParent
 * @typedef {import('./types').XastChild***REMOVED*** XastChild
 */

const stable = require('stable');
const csstree = require('css-tree');
// @ts-ignore not defined in @types/csso
const specificity = require('csso/lib/restructure/prepare/specificity');
const { visit, matches ***REMOVED*** = require('./xast.js');
const {
  attrsGroups,
  inheritableAttrs,
  presentationNonInheritableGroupAttrs,
***REMOVED*** = require('../plugins/_collections.js');

// @ts-ignore not defined in @types/csstree
const csstreeWalkSkip = csstree.walk.skip;

/**
 * @type {(ruleNode: CsstreeRule, dynamic: boolean) => StylesheetRule***REMOVED***
 */
const parseRule = (ruleNode, dynamic) => {
  let selectors;
  let selectorsSpecificity;
  /**
   * @type {Array<StylesheetDeclaration>***REMOVED***
   */
  const declarations = [];
  csstree.walk(ruleNode, (cssNode) => {
    if (cssNode.type === 'SelectorList') {
      // compute specificity from original node to consider pseudo classes
      selectorsSpecificity = specificity(cssNode);
      const newSelectorsNode = csstree.clone(cssNode);
      csstree.walk(newSelectorsNode, (pseudoClassNode, item, list) => {
        if (pseudoClassNode.type === 'PseudoClassSelector') {
          dynamic = true;
          list.remove(item);
        ***REMOVED***
      ***REMOVED***);
      selectors = csstree.generate(newSelectorsNode);
      return csstreeWalkSkip;
    ***REMOVED***
    if (cssNode.type === 'Declaration') {
      declarations.push({
        name: cssNode.property,
        value: csstree.generate(cssNode.value),
        important: cssNode.important === true,
      ***REMOVED***);
      return csstreeWalkSkip;
    ***REMOVED***
  ***REMOVED***);
  if (selectors == null || selectorsSpecificity == null) {
    throw Error('assert');
  ***REMOVED***
  return {
    dynamic,
    selectors,
    specificity: selectorsSpecificity,
    declarations,
  ***REMOVED***;
***REMOVED***;

/**
 * @type {(css: string, dynamic: boolean) => Array<StylesheetRule>***REMOVED***
 */
const parseStylesheet = (css, dynamic) => {
  /**
   * @type {Array<StylesheetRule>***REMOVED***
   */
  const rules = [];
  const ast = csstree.parse(css, {
    parseValue: false,
    parseAtrulePrelude: false,
  ***REMOVED***);
  csstree.walk(ast, (cssNode) => {
    if (cssNode.type === 'Rule') {
      rules.push(parseRule(cssNode, dynamic || false));
      return csstreeWalkSkip;
    ***REMOVED***
    if (cssNode.type === 'Atrule') {
      if (cssNode.name === 'keyframes') {
        return csstreeWalkSkip;
      ***REMOVED***
      csstree.walk(cssNode, (ruleNode) => {
        if (ruleNode.type === 'Rule') {
          rules.push(parseRule(ruleNode, dynamic || true));
          return csstreeWalkSkip;
        ***REMOVED***
      ***REMOVED***);
      return csstreeWalkSkip;
    ***REMOVED***
  ***REMOVED***);
  return rules;
***REMOVED***;

/**
 * @type {(css: string) => Array<StylesheetDeclaration>***REMOVED***
 */
const parseStyleDeclarations = (css) => {
  /**
   * @type {Array<StylesheetDeclaration>***REMOVED***
   */
  const declarations = [];
  const ast = csstree.parse(css, {
    context: 'declarationList',
    parseValue: false,
  ***REMOVED***);
  csstree.walk(ast, (cssNode) => {
    if (cssNode.type === 'Declaration') {
      declarations.push({
        name: cssNode.property,
        value: csstree.generate(cssNode.value),
        important: cssNode.important === true,
      ***REMOVED***);
    ***REMOVED***
  ***REMOVED***);
  return declarations;
***REMOVED***;

/**
 * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles***REMOVED***
 */
const computeOwnStyle = (stylesheet, node) => {
  /**
   * @type {ComputedStyles***REMOVED***
   */
  const computedStyle = {***REMOVED***;
  const importantStyles = new Map();

  // collect attributes
  for (const [name, value] of Object.entries(node.attributes)) {
    if (attrsGroups.presentation.includes(name)) {
      computedStyle[name] = { type: 'static', inherited: false, value ***REMOVED***;
      importantStyles.set(name, false);
    ***REMOVED***
  ***REMOVED***

  // collect matching rules
  for (const { selectors, declarations, dynamic ***REMOVED*** of stylesheet.rules) {
    if (matches(node, selectors)) {
      for (const { name, value, important ***REMOVED*** of declarations) {
        const computed = computedStyle[name];
        if (computed && computed.type === 'dynamic') {
          continue;
        ***REMOVED***
        if (dynamic) {
          computedStyle[name] = { type: 'dynamic', inherited: false ***REMOVED***;
          continue;
        ***REMOVED***
        if (
          computed == null ||
          important === true ||
          importantStyles.get(name) === false
        ) {
          computedStyle[name] = { type: 'static', inherited: false, value ***REMOVED***;
          importantStyles.set(name, important);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  // collect inline styles
  const styleDeclarations =
    node.attributes.style == null
      ? []
      : parseStyleDeclarations(node.attributes.style);
  for (const { name, value, important ***REMOVED*** of styleDeclarations) {
    const computed = computedStyle[name];
    if (computed && computed.type === 'dynamic') {
      continue;
    ***REMOVED***
    if (
      computed == null ||
      important === true ||
      importantStyles.get(name) === false
    ) {
      computedStyle[name] = { type: 'static', inherited: false, value ***REMOVED***;
      importantStyles.set(name, important);
    ***REMOVED***
  ***REMOVED***

  return computedStyle;
***REMOVED***;

/**
 * Compares two selector specificities.
 * extracted from https://github.com/keeganstreet/specificity/blob/master/specificity.js#L211
 *
 * @type {(a: Specificity, b: Specificity) => number***REMOVED***
 */
const compareSpecificity = (a, b) => {
  for (var i = 0; i < 4; i += 1) {
    if (a[i] < b[i]) {
      return -1;
    ***REMOVED*** else if (a[i] > b[i]) {
      return 1;
    ***REMOVED***
  ***REMOVED***

  return 0;
***REMOVED***;

/**
 * @type {(root: XastRoot) => Stylesheet***REMOVED***
 */
const collectStylesheet = (root) => {
  /**
   * @type {Array<StylesheetRule>***REMOVED***
   */
  const rules = [];
  /**
   * @type {Map<XastElement, XastParent>***REMOVED***
   */
  const parents = new Map();
  visit(root, {
    element: {
      enter: (node, parentNode) => {
        // store parents
        parents.set(node, parentNode);
        // find and parse all styles
        if (node.name === 'style') {
          const dynamic =
            node.attributes.media != null && node.attributes.media !== 'all';
          if (
            node.attributes.type == null ||
            node.attributes.type === '' ||
            node.attributes.type === 'text/css'
          ) {
            const children = node.children;
            for (const child of children) {
              if (child.type === 'text' || child.type === 'cdata') {
                rules.push(...parseStylesheet(child.value, dynamic));
              ***REMOVED***
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***,
    ***REMOVED***,
  ***REMOVED***);
  // sort by selectors specificity
  stable.inplace(rules, (a, b) =>
    compareSpecificity(a.specificity, b.specificity)
  );
  return { rules, parents ***REMOVED***;
***REMOVED***;
exports.collectStylesheet = collectStylesheet;

/**
 * @type {(stylesheet: Stylesheet, node: XastElement) => ComputedStyles***REMOVED***
 */
const computeStyle = (stylesheet, node) => {
  const { parents ***REMOVED*** = stylesheet;
  // collect inherited styles
  const computedStyles = computeOwnStyle(stylesheet, node);
  let parent = parents.get(node);
  while (parent != null && parent.type !== 'root') {
    const inheritedStyles = computeOwnStyle(stylesheet, parent);
    for (const [name, computed] of Object.entries(inheritedStyles)) {
      if (
        computedStyles[name] == null &&
        // ignore not inheritable styles
        inheritableAttrs.includes(name) === true &&
        presentationNonInheritableGroupAttrs.includes(name) === false
      ) {
        computedStyles[name] = { ...computed, inherited: true ***REMOVED***;
      ***REMOVED***
    ***REMOVED***
    parent = parents.get(parent);
  ***REMOVED***
  return computedStyles;
***REMOVED***;
exports.computeStyle = computeStyle;
