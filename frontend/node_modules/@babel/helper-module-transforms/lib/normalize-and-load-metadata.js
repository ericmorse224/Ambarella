"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.default = normalizeModuleAndLoadMetadata;
exports.hasExports = hasExports;
exports.isSideEffectImport = isSideEffectImport;
exports.validateImportInteropOption = validateImportInteropOption;
var _path = require("path");
var _helperValidatorIdentifier = require("@babel/helper-validator-identifier");
function hasExports(metadata) {
  return metadata.hasExports;
***REMOVED***
function isSideEffectImport(source) {
  return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;
***REMOVED***
function validateImportInteropOption(importInterop) {
  if (typeof importInterop !== "function" && importInterop !== "none" && importInterop !== "babel" && importInterop !== "node") {
    throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${importInterop***REMOVED***).`);
  ***REMOVED***
  return importInterop;
***REMOVED***
function resolveImportInterop(importInterop, source, filename) {
  if (typeof importInterop === "function") {
    return validateImportInteropOption(importInterop(source, filename));
  ***REMOVED***
  return importInterop;
***REMOVED***
function normalizeModuleAndLoadMetadata(programPath, exportName, {
  importInterop,
  initializeReexports = false,
  getWrapperPayload,
  esNamespaceOnly = false,
  filename
***REMOVED***) {
  if (!exportName) {
    exportName = programPath.scope.generateUidIdentifier("exports").name;
  ***REMOVED***
  const stringSpecifiers = new Set();
  nameAnonymousExports(programPath);
  const {
    local,
    sources,
    hasExports
  ***REMOVED*** = getModuleMetadata(programPath, {
    initializeReexports,
    getWrapperPayload
  ***REMOVED***, stringSpecifiers);
  removeImportExportDeclarations(programPath);
  for (const [source, metadata] of sources) {
    const {
      importsNamespace,
      imports
    ***REMOVED*** = metadata;
    if (importsNamespace.size > 0 && imports.size === 0) {
      const [nameOfnamespace] = importsNamespace;
      metadata.name = nameOfnamespace;
    ***REMOVED***
    const resolvedInterop = resolveImportInterop(importInterop, source, filename);
    if (resolvedInterop === "none") {
      metadata.interop = "none";
    ***REMOVED*** else if (resolvedInterop === "node" && metadata.interop === "namespace") {
      metadata.interop = "node-namespace";
    ***REMOVED*** else if (resolvedInterop === "node" && metadata.interop === "default") {
      metadata.interop = "node-default";
    ***REMOVED*** else if (esNamespaceOnly && metadata.interop === "namespace") {
      metadata.interop = "default";
    ***REMOVED***
  ***REMOVED***
  return {
    exportName,
    exportNameListName: null,
    hasExports,
    local,
    source: sources,
    stringSpecifiers
  ***REMOVED***;
***REMOVED***
function getExportSpecifierName(path, stringSpecifiers) {
  if (path.isIdentifier()) {
    return path.node.name;
  ***REMOVED*** else if (path.isStringLiteral()) {
    const stringValue = path.node.value;
    if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {
      stringSpecifiers.add(stringValue);
    ***REMOVED***
    return stringValue;
  ***REMOVED*** else {
    throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path.node.type***REMOVED***`);
  ***REMOVED***
***REMOVED***
function assertExportSpecifier(path) {
  if (path.isExportSpecifier()) {
    return;
  ***REMOVED*** else if (path.isExportNamespaceSpecifier()) {
    throw path.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.");
  ***REMOVED*** else {
    throw path.buildCodeFrameError("Unexpected export specifier type");
  ***REMOVED***
***REMOVED***
function getModuleMetadata(programPath, {
  getWrapperPayload,
  initializeReexports
***REMOVED***, stringSpecifiers) {
  const localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers);
  const importNodes = new Map();
  const sourceData = new Map();
  const getData = (sourceNode, node) => {
    const source = sourceNode.value;
    let data = sourceData.get(source);
    if (!data) {
      data = {
        name: programPath.scope.generateUidIdentifier((0, _path.basename)(source, (0, _path.extname)(source))).name,
        interop: "none",
        loc: null,
        imports: new Map(),
        importsNamespace: new Set(),
        reexports: new Map(),
        reexportNamespace: new Set(),
        reexportAll: null,
        wrap: null,
        get lazy() {
          return this.wrap === "lazy";
        ***REMOVED***,
        referenced: false
      ***REMOVED***;
      sourceData.set(source, data);
      importNodes.set(source, [node]);
    ***REMOVED*** else {
      importNodes.get(source).push(node);
    ***REMOVED***
    return data;
  ***REMOVED***;
  let hasExports = false;
  programPath.get("body").forEach(child => {
    if (child.isImportDeclaration()) {
      const data = getData(child.node.source, child.node);
      if (!data.loc) data.loc = child.node.loc;
      child.get("specifiers").forEach(spec => {
        if (spec.isImportDefaultSpecifier()) {
          const localName = spec.get("local").node.name;
          data.imports.set(localName, "default");
          const reexport = localData.get(localName);
          if (reexport) {
            localData.delete(localName);
            reexport.names.forEach(name => {
              data.reexports.set(name, "default");
            ***REMOVED***);
            data.referenced = true;
          ***REMOVED***
        ***REMOVED*** else if (spec.isImportNamespaceSpecifier()) {
          const localName = spec.get("local").node.name;
          data.importsNamespace.add(localName);
          const reexport = localData.get(localName);
          if (reexport) {
            localData.delete(localName);
            reexport.names.forEach(name => {
              data.reexportNamespace.add(name);
            ***REMOVED***);
            data.referenced = true;
          ***REMOVED***
        ***REMOVED*** else if (spec.isImportSpecifier()) {
          const importName = getExportSpecifierName(spec.get("imported"), stringSpecifiers);
          const localName = spec.get("local").node.name;
          data.imports.set(localName, importName);
          const reexport = localData.get(localName);
          if (reexport) {
            localData.delete(localName);
            reexport.names.forEach(name => {
              data.reexports.set(name, importName);
            ***REMOVED***);
            data.referenced = true;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED*** else if (child.isExportAllDeclaration()) {
      hasExports = true;
      const data = getData(child.node.source, child.node);
      if (!data.loc) data.loc = child.node.loc;
      data.reexportAll = {
        loc: child.node.loc
      ***REMOVED***;
      data.referenced = true;
    ***REMOVED*** else if (child.isExportNamedDeclaration() && child.node.source) {
      hasExports = true;
      const data = getData(child.node.source, child.node);
      if (!data.loc) data.loc = child.node.loc;
      child.get("specifiers").forEach(spec => {
        assertExportSpecifier(spec);
        const importName = getExportSpecifierName(spec.get("local"), stringSpecifiers);
        const exportName = getExportSpecifierName(spec.get("exported"), stringSpecifiers);
        data.reexports.set(exportName, importName);
        data.referenced = true;
        if (exportName === "__esModule") {
          throw spec.get("exported").buildCodeFrameError('Illegal export "__esModule".');
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED*** else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {
      hasExports = true;
    ***REMOVED***
  ***REMOVED***);
  for (const metadata of sourceData.values()) {
    let needsDefault = false;
    let needsNamed = false;
    if (metadata.importsNamespace.size > 0) {
      needsDefault = true;
      needsNamed = true;
    ***REMOVED***
    if (metadata.reexportAll) {
      needsNamed = true;
    ***REMOVED***
    for (const importName of metadata.imports.values()) {
      if (importName === "default") needsDefault = true;else needsNamed = true;
    ***REMOVED***
    for (const importName of metadata.reexports.values()) {
      if (importName === "default") needsDefault = true;else needsNamed = true;
    ***REMOVED***
    if (needsDefault && needsNamed) {
      metadata.interop = "namespace";
    ***REMOVED*** else if (needsDefault) {
      metadata.interop = "default";
    ***REMOVED***
  ***REMOVED***
  if (getWrapperPayload) {
    for (const [source, metadata] of sourceData) {
      metadata.wrap = getWrapperPayload(source, metadata, importNodes.get(source));
    ***REMOVED***
  ***REMOVED***
  return {
    hasExports,
    local: localData,
    sources: sourceData
  ***REMOVED***;
***REMOVED***
function getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers) {
  const bindingKindLookup = new Map();
  programPath.get("body").forEach(child => {
    let kind;
    if (child.isImportDeclaration()) {
      kind = "import";
    ***REMOVED*** else {
      if (child.isExportDefaultDeclaration()) {
        child = child.get("declaration");
      ***REMOVED***
      if (child.isExportNamedDeclaration()) {
        if (child.node.declaration) {
          child = child.get("declaration");
        ***REMOVED*** else if (initializeReexports && child.node.source && child.get("source").isStringLiteral()) {
          child.get("specifiers").forEach(spec => {
            assertExportSpecifier(spec);
            bindingKindLookup.set(spec.get("local").node.name, "block");
          ***REMOVED***);
          return;
        ***REMOVED***
      ***REMOVED***
      if (child.isFunctionDeclaration()) {
        kind = "hoisted";
      ***REMOVED*** else if (child.isClassDeclaration()) {
        kind = "block";
      ***REMOVED*** else if (child.isVariableDeclaration({
        kind: "var"
      ***REMOVED***)) {
        kind = "var";
      ***REMOVED*** else if (child.isVariableDeclaration()) {
        kind = "block";
      ***REMOVED*** else {
        return;
      ***REMOVED***
    ***REMOVED***
    Object.keys(child.getOuterBindingIdentifiers()).forEach(name => {
      bindingKindLookup.set(name, kind);
    ***REMOVED***);
  ***REMOVED***);
  const localMetadata = new Map();
  const getLocalMetadata = idPath => {
    const localName = idPath.node.name;
    let metadata = localMetadata.get(localName);
    if (!metadata) {
      const kind = bindingKindLookup.get(localName);
      if (kind === undefined) {
        throw idPath.buildCodeFrameError(`Exporting local "${localName***REMOVED***", which is not declared.`);
      ***REMOVED***
      metadata = {
        names: [],
        kind
      ***REMOVED***;
      localMetadata.set(localName, metadata);
    ***REMOVED***
    return metadata;
  ***REMOVED***;
  programPath.get("body").forEach(child => {
    if (child.isExportNamedDeclaration() && (initializeReexports || !child.node.source)) {
      if (child.node.declaration) {
        const declaration = child.get("declaration");
        const ids = declaration.getOuterBindingIdentifierPaths();
        Object.keys(ids).forEach(name => {
          if (name === "__esModule") {
            throw declaration.buildCodeFrameError('Illegal export "__esModule".');
          ***REMOVED***
          getLocalMetadata(ids[name]).names.push(name);
        ***REMOVED***);
      ***REMOVED*** else {
        child.get("specifiers").forEach(spec => {
          const local = spec.get("local");
          const exported = spec.get("exported");
          const localMetadata = getLocalMetadata(local);
          const exportName = getExportSpecifierName(exported, stringSpecifiers);
          if (exportName === "__esModule") {
            throw exported.buildCodeFrameError('Illegal export "__esModule".');
          ***REMOVED***
          localMetadata.names.push(exportName);
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED*** else if (child.isExportDefaultDeclaration()) {
      const declaration = child.get("declaration");
      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
        getLocalMetadata(declaration.get("id")).names.push("default");
      ***REMOVED*** else {
        throw declaration.buildCodeFrameError("Unexpected default expression export.");
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);
  return localMetadata;
***REMOVED***
function nameAnonymousExports(programPath) {
  programPath.get("body").forEach(child => {
    if (!child.isExportDefaultDeclaration()) return;
    {
      var _child$splitExportDec;
      (_child$splitExportDec = child.splitExportDeclaration) != null ? _child$splitExportDec : child.splitExportDeclaration = require("@babel/traverse").NodePath.prototype.splitExportDeclaration;
    ***REMOVED***
    child.splitExportDeclaration();
  ***REMOVED***);
***REMOVED***
function removeImportExportDeclarations(programPath) {
  programPath.get("body").forEach(child => {
    if (child.isImportDeclaration()) {
      child.remove();
    ***REMOVED*** else if (child.isExportNamedDeclaration()) {
      if (child.node.declaration) {
        child.node.declaration._blockHoist = child.node._blockHoist;
        child.replaceWith(child.node.declaration);
      ***REMOVED*** else {
        child.remove();
      ***REMOVED***
    ***REMOVED*** else if (child.isExportDefaultDeclaration()) {
      const declaration = child.get("declaration");
      if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
        declaration._blockHoist = child.node._blockHoist;
        child.replaceWith(declaration);
      ***REMOVED*** else {
        throw declaration.buildCodeFrameError("Unexpected default expression export.");
      ***REMOVED***
    ***REMOVED*** else if (child.isExportAllDeclaration()) {
      child.remove();
    ***REMOVED***
  ***REMOVED***);
***REMOVED***

//# sourceMappingURL=normalize-and-load-metadata.js.map
