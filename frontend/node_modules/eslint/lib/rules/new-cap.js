/**
 * @fileoverview Rule to flag use of constructors without capital letters
 * @author Nicholas C. Zakas
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const CAPS_ALLOWED = [
    "Array",
    "Boolean",
    "Date",
    "Error",
    "Function",
    "Number",
    "Object",
    "RegExp",
    "String",
    "Symbol",
    "BigInt"
];

/**
 * Ensure that if the key is provided, it must be an array.
 * @param {Object***REMOVED*** obj Object to check with `key`.
 * @param {string***REMOVED*** key Object key to check on `obj`.
 * @param {****REMOVED*** fallback If obj[key] is not present, this will be returned.
 * @returns {string[]***REMOVED*** Returns obj[key] if it's an Array, otherwise `fallback`
 */
function checkArray(obj, key, fallback) {

    /* istanbul ignore if */
    if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {
        throw new TypeError(`${key***REMOVED***, if provided, must be an Array`);
    ***REMOVED***
    return obj[key] || fallback;
***REMOVED***

/**
 * A reducer function to invert an array to an Object mapping the string form of the key, to `true`.
 * @param {Object***REMOVED*** map Accumulator object for the reduce.
 * @param {string***REMOVED*** key Object key to set to `true`.
 * @returns {Object***REMOVED*** Returns the updated Object for further reduction.
 */
function invert(map, key) {
    map[key] = true;
    return map;
***REMOVED***

/**
 * Creates an object with the cap is new exceptions as its keys and true as their values.
 * @param {Object***REMOVED*** config Rule configuration
 * @returns {Object***REMOVED*** Object with cap is new exceptions.
 */
function calculateCapIsNewExceptions(config) {
    let capIsNewExceptions = checkArray(config, "capIsNewExceptions", CAPS_ALLOWED);

    if (capIsNewExceptions !== CAPS_ALLOWED) {
        capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);
    ***REMOVED***

    return capIsNewExceptions.reduce(invert, {***REMOVED***);
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "require constructor names to begin with a capital letter",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/new-cap"
        ***REMOVED***,

        schema: [
            {
                type: "object",
                properties: {
                    newIsCap: {
                        type: "boolean",
                        default: true
                    ***REMOVED***,
                    capIsNew: {
                        type: "boolean",
                        default: true
                    ***REMOVED***,
                    newIsCapExceptions: {
                        type: "array",
                        items: {
                            type: "string"
                        ***REMOVED***
                    ***REMOVED***,
                    newIsCapExceptionPattern: {
                        type: "string"
                    ***REMOVED***,
                    capIsNewExceptions: {
                        type: "array",
                        items: {
                            type: "string"
                        ***REMOVED***
                    ***REMOVED***,
                    capIsNewExceptionPattern: {
                        type: "string"
                    ***REMOVED***,
                    properties: {
                        type: "boolean",
                        default: true
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],
        messages: {
            upper: "A function with a name starting with an uppercase letter should only be used as a constructor.",
            lower: "A constructor name should not start with a lowercase letter."
        ***REMOVED***
    ***REMOVED***,

    create(context) {

        const config = Object.assign({***REMOVED***, context.options[0]);

        config.newIsCap = config.newIsCap !== false;
        config.capIsNew = config.capIsNew !== false;
        const skipProperties = config.properties === false;

        const newIsCapExceptions = checkArray(config, "newIsCapExceptions", []).reduce(invert, {***REMOVED***);
        const newIsCapExceptionPattern = config.newIsCapExceptionPattern ? new RegExp(config.newIsCapExceptionPattern, "u") : null;

        const capIsNewExceptions = calculateCapIsNewExceptions(config);
        const capIsNewExceptionPattern = config.capIsNewExceptionPattern ? new RegExp(config.capIsNewExceptionPattern, "u") : null;

        const listeners = {***REMOVED***;

        const sourceCode = context.getSourceCode();

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Get exact callee name from expression
         * @param {ASTNode***REMOVED*** node CallExpression or NewExpression node
         * @returns {string***REMOVED*** name
         */
        function extractNameFromExpression(node) {
            return node.callee.type === "Identifier"
                ? node.callee.name
                : astUtils.getStaticPropertyName(node.callee) || "";
        ***REMOVED***

        /**
         * Returns the capitalization state of the string -
         * Whether the first character is uppercase, lowercase, or non-alphabetic
         * @param {string***REMOVED*** str String
         * @returns {string***REMOVED*** capitalization state: "non-alpha", "lower", or "upper"
         */
        function getCap(str) {
            const firstChar = str.charAt(0);

            const firstCharLower = firstChar.toLowerCase();
            const firstCharUpper = firstChar.toUpperCase();

            if (firstCharLower === firstCharUpper) {

                // char has no uppercase variant, so it's non-alphabetic
                return "non-alpha";
            ***REMOVED***
            if (firstChar === firstCharLower) {
                return "lower";
            ***REMOVED***
            return "upper";

        ***REMOVED***

        /**
         * Check if capitalization is allowed for a CallExpression
         * @param {Object***REMOVED*** allowedMap Object mapping calleeName to a Boolean
         * @param {ASTNode***REMOVED*** node CallExpression node
         * @param {string***REMOVED*** calleeName Capitalized callee name from a CallExpression
         * @param {Object***REMOVED*** pattern RegExp object from options pattern
         * @returns {boolean***REMOVED*** Returns true if the callee may be capitalized
         */
        function isCapAllowed(allowedMap, node, calleeName, pattern) {
            const sourceText = sourceCode.getText(node.callee);

            if (allowedMap[calleeName] || allowedMap[sourceText]) {
                return true;
            ***REMOVED***

            if (pattern && pattern.test(sourceText)) {
                return true;
            ***REMOVED***

            const callee = astUtils.skipChainExpression(node.callee);

            if (calleeName === "UTC" && callee.type === "MemberExpression") {

                // allow if callee is Date.UTC
                return callee.object.type === "Identifier" &&
                    callee.object.name === "Date";
            ***REMOVED***

            return skipProperties && callee.type === "MemberExpression";
        ***REMOVED***

        /**
         * Reports the given messageId for the given node. The location will be the start of the property or the callee.
         * @param {ASTNode***REMOVED*** node CallExpression or NewExpression node.
         * @param {string***REMOVED*** messageId The messageId to report.
         * @returns {void***REMOVED***
         */
        function report(node, messageId) {
            let callee = astUtils.skipChainExpression(node.callee);

            if (callee.type === "MemberExpression") {
                callee = callee.property;
            ***REMOVED***

            context.report({ node, loc: callee.loc, messageId ***REMOVED***);
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        if (config.newIsCap) {
            listeners.NewExpression = function(node) {

                const constructorName = extractNameFromExpression(node);

                if (constructorName) {
                    const capitalization = getCap(constructorName);
                    const isAllowed = capitalization !== "lower" || isCapAllowed(newIsCapExceptions, node, constructorName, newIsCapExceptionPattern);

                    if (!isAllowed) {
                        report(node, "lower");
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***;
        ***REMOVED***

        if (config.capIsNew) {
            listeners.CallExpression = function(node) {

                const calleeName = extractNameFromExpression(node);

                if (calleeName) {
                    const capitalization = getCap(calleeName);
                    const isAllowed = capitalization !== "upper" || isCapAllowed(capIsNewExceptions, node, calleeName, capIsNewExceptionPattern);

                    if (!isAllowed) {
                        report(node, "upper");
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***;
        ***REMOVED***

        return listeners;
    ***REMOVED***
***REMOVED***;
