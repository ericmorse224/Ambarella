/**
 * @fileoverview Rule to disallow calls to the `Object` constructor without an argument
 * @author Francesco Trotta
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const {
    getVariableByName,
    isArrowToken,
    isStartOfExpressionStatement,
    needsPrecedingSemicolon
***REMOVED*** = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule***REMOVED*** */
module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "Disallow calls to the `Object` constructor without an argument",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/no-object-constructor"
        ***REMOVED***,

        hasSuggestions: true,

        schema: [],

        messages: {
            preferLiteral: "The object literal notation {***REMOVED*** is preferable.",
            useLiteral: "Replace with '{{replacement***REMOVED******REMOVED***'.",
            useLiteralAfterSemicolon: "Replace with '{{replacement***REMOVED******REMOVED***', add preceding semicolon."
        ***REMOVED***
    ***REMOVED***,

    create(context) {

        const sourceCode = context.sourceCode;

        /**
         * Determines whether or not an object literal that replaces a specified node needs to be enclosed in parentheses.
         * @param {ASTNode***REMOVED*** node The node to be replaced.
         * @returns {boolean***REMOVED*** Whether or not parentheses around the object literal are required.
         */
        function needsParentheses(node) {
            if (isStartOfExpressionStatement(node)) {
                return true;
            ***REMOVED***

            const prevToken = sourceCode.getTokenBefore(node);

            if (prevToken && isArrowToken(prevToken)) {
                return true;
            ***REMOVED***

            return false;
        ***REMOVED***

        /**
         * Reports on nodes where the `Object` constructor is called without arguments.
         * @param {ASTNode***REMOVED*** node The node to evaluate.
         * @returns {void***REMOVED***
         */
        function check(node) {
            if (node.callee.type !== "Identifier" || node.callee.name !== "Object" || node.arguments.length) {
                return;
            ***REMOVED***

            const variable = getVariableByName(sourceCode.getScope(node), "Object");

            if (variable && variable.identifiers.length === 0) {
                let replacement;
                let fixText;
                let messageId = "useLiteral";

                if (needsParentheses(node)) {
                    replacement = "({***REMOVED***)";
                    if (needsPrecedingSemicolon(sourceCode, node)) {
                        fixText = ";({***REMOVED***)";
                        messageId = "useLiteralAfterSemicolon";
                    ***REMOVED*** else {
                        fixText = "({***REMOVED***)";
                    ***REMOVED***
                ***REMOVED*** else {
                    replacement = fixText = "{***REMOVED***";
                ***REMOVED***

                context.report({
                    node,
                    messageId: "preferLiteral",
                    suggest: [
                        {
                            messageId,
                            data: { replacement ***REMOVED***,
                            fix: fixer => fixer.replaceText(node, fixText)
                        ***REMOVED***
                    ]
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        return {
            CallExpression: check,
            NewExpression: check
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
