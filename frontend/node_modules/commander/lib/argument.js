const { InvalidArgumentError ***REMOVED*** = require('./error.js');

// @ts-check

class Argument {
  /**
   * Initialize a new command argument with the given name and description.
   * The default is that the argument is required, and you can explicitly
   * indicate this with <> around the name. Put [] around the name for an optional argument.
   *
   * @param {string***REMOVED*** name
   * @param {string***REMOVED*** [description]
   */

  constructor(name, description) {
    this.description = description || '';
    this.variadic = false;
    this.parseArg = undefined;
    this.defaultValue = undefined;
    this.defaultValueDescription = undefined;
    this.argChoices = undefined;

    switch (name[0]) {
      case '<': // e.g. <required>
        this.required = true;
        this._name = name.slice(1, -1);
        break;
      case '[': // e.g. [optional]
        this.required = false;
        this._name = name.slice(1, -1);
        break;
      default:
        this.required = true;
        this._name = name;
        break;
    ***REMOVED***

    if (this._name.length > 3 && this._name.slice(-3) === '...') {
      this.variadic = true;
      this._name = this._name.slice(0, -3);
    ***REMOVED***
  ***REMOVED***

  /**
   * Return argument name.
   *
   * @return {string***REMOVED***
   */

  name() {
    return this._name;
  ***REMOVED***;

  /**
   * @api private
   */

  _concatValue(value, previous) {
    if (previous === this.defaultValue || !Array.isArray(previous)) {
      return [value];
    ***REMOVED***

    return previous.concat(value);
  ***REMOVED***

  /**
   * Set the default value, and optionally supply the description to be displayed in the help.
   *
   * @param {any***REMOVED*** value
   * @param {string***REMOVED*** [description]
   * @return {Argument***REMOVED***
   */

  default(value, description) {
    this.defaultValue = value;
    this.defaultValueDescription = description;
    return this;
  ***REMOVED***;

  /**
   * Set the custom handler for processing CLI command arguments into argument values.
   *
   * @param {Function***REMOVED*** [fn]
   * @return {Argument***REMOVED***
   */

  argParser(fn) {
    this.parseArg = fn;
    return this;
  ***REMOVED***;

  /**
   * Only allow option value to be one of choices.
   *
   * @param {string[]***REMOVED*** values
   * @return {Argument***REMOVED***
   */

  choices(values) {
    this.argChoices = values;
    this.parseArg = (arg, previous) => {
      if (!values.includes(arg)) {
        throw new InvalidArgumentError(`Allowed choices are ${values.join(', ')***REMOVED***.`);
      ***REMOVED***
      if (this.variadic) {
        return this._concatValue(arg, previous);
      ***REMOVED***
      return arg;
    ***REMOVED***;
    return this;
  ***REMOVED***;

  /**
   * Make option-argument required.
   */
  argRequired() {
    this.required = true;
    return this;
  ***REMOVED***

  /**
   * Make option-argument optional.
   */
  argOptional() {
    this.required = false;
    return this;
  ***REMOVED***
***REMOVED***

/**
 * Takes an argument and returns its human readable equivalent for help usage.
 *
 * @param {Argument***REMOVED*** arg
 * @return {string***REMOVED***
 * @api private
 */

function humanReadableArgName(arg) {
  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');

  return arg.required
    ? '<' + nameOutput + '>'
    : '[' + nameOutput + ']';
***REMOVED***

exports.Argument = Argument;
exports.humanReadableArgName = humanReadableArgName;
