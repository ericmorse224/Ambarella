import { isScalar, isCollection ***REMOVED*** from '../nodes/identity.js';
import { visit ***REMOVED*** from '../visit.js';

/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */
function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{***REMOVED***]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa***REMOVED***`;
        throw new Error(msg);
    ***REMOVED***
    return true;
***REMOVED***
function anchorNames(root) {
    const anchors = new Set();
    visit(root, {
        Value(_key, node) {
            if (node.anchor)
                anchors.add(node.anchor);
        ***REMOVED***
    ***REMOVED***);
    return anchors;
***REMOVED***
/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
function findNewAnchor(prefix, exclude) {
    for (let i = 1; true; ++i) {
        const name = `${prefix***REMOVED***${i***REMOVED***`;
        if (!exclude.has(name))
            return name;
    ***REMOVED***
***REMOVED***
function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map();
    let prevAnchors = null;
    return {
        onAnchor: (source) => {
            aliasObjects.push(source);
            if (!prevAnchors)
                prevAnchors = anchorNames(doc);
            const anchor = findNewAnchor(prefix, prevAnchors);
            prevAnchors.add(anchor);
            return anchor;
        ***REMOVED***,
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
            for (const source of aliasObjects) {
                const ref = sourceObjects.get(source);
                if (typeof ref === 'object' &&
                    ref.anchor &&
                    (isScalar(ref.node) || isCollection(ref.node))) {
                    ref.node.anchor = ref.anchor;
                ***REMOVED***
                else {
                    const error = new Error('Failed to resolve repeated object (this should not happen)');
                    error.source = source;
                    throw error;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***,
        sourceObjects
    ***REMOVED***;
***REMOVED***

export { anchorIsValid, anchorNames, createNodeAnchors, findNewAnchor ***REMOVED***;
