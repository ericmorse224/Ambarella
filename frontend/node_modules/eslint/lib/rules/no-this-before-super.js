/**
 * @fileoverview A rule to disallow using `this`/`super` before `super()`.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks whether or not a given node is a constructor.
 * @param {ASTNode***REMOVED*** node A node to check. This node type is one of
 *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and
 *   `ArrowFunctionExpression`.
 * @returns {boolean***REMOVED*** `true` if the node is a constructor.
 */
function isConstructorFunction(node) {
	return (
		node.type === "FunctionExpression" &&
		node.parent.type === "MethodDefinition" &&
		node.parent.kind === "constructor"
	);
***REMOVED***

/*
 * Information for each code path segment.
 * - superCalled:  The flag which shows `super()` called in all code paths.
 * - invalidNodes: The array of invalid ThisExpression and Super nodes.
 */
/**
 *
 */
class SegmentInfo {
	/**
	 * Indicates whether `super()` is called in all code paths.
	 * @type {boolean***REMOVED***
	 */
	superCalled = false;

	/**
	 * The array of invalid ThisExpression and Super nodes.
	 * @type {ASTNode[]***REMOVED***
	 */
	invalidNodes = [];
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "problem",

		docs: {
			description:
				"Disallow `this`/`super` before calling `super()` in constructors",
			recommended: true,
			url: "https://eslint.org/docs/latest/rules/no-this-before-super",
		***REMOVED***,

		schema: [],

		messages: {
			noBeforeSuper: "'{{kind***REMOVED******REMOVED***' is not allowed before 'super()'.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		/*
		 * Information for each constructor.
		 * - upper:      Information of the upper constructor.
		 * - hasExtends: A flag which shows whether the owner class has a valid
		 *   `extends` part.
		 * - scope:      The scope of the owner class.
		 * - codePath:   The code path of this constructor.
		 */
		let funcInfo = null;

		/** @type {Record<string, SegmentInfo>***REMOVED*** */
		let segInfoMap = Object.create(null);

		/**
		 * Gets whether or not `super()` is called in a given code path segment.
		 * @param {CodePathSegment***REMOVED*** segment A code path segment to get.
		 * @returns {boolean***REMOVED*** `true` if `super()` is called.
		 */
		function isCalled(segment) {
			return !segment.reachable || segInfoMap[segment.id]?.superCalled;
		***REMOVED***

		/**
		 * Checks whether or not this is in a constructor.
		 * @returns {boolean***REMOVED*** `true` if this is in a constructor.
		 */
		function isInConstructorOfDerivedClass() {
			return Boolean(
				funcInfo && funcInfo.isConstructor && funcInfo.hasExtends,
			);
		***REMOVED***

		/**
		 * Determines if every segment in a set has been called.
		 * @param {Set<CodePathSegment>***REMOVED*** segments The segments to search.
		 * @returns {boolean***REMOVED*** True if every segment has been called; false otherwise.
		 */
		function isEverySegmentCalled(segments) {
			for (const segment of segments) {
				if (!isCalled(segment)) {
					return false;
				***REMOVED***
			***REMOVED***

			return true;
		***REMOVED***

		/**
		 * Checks whether or not this is before `super()` is called.
		 * @returns {boolean***REMOVED*** `true` if this is before `super()` is called.
		 */
		function isBeforeCallOfSuper() {
			return (
				isInConstructorOfDerivedClass() &&
				!isEverySegmentCalled(funcInfo.currentSegments)
			);
		***REMOVED***

		/**
		 * Sets a given node as invalid.
		 * @param {ASTNode***REMOVED*** node A node to set as invalid. This is one of
		 *      a ThisExpression and a Super.
		 * @returns {void***REMOVED***
		 */
		function setInvalid(node) {
			const segments = funcInfo.currentSegments;

			for (const segment of segments) {
				if (segment.reachable) {
					segInfoMap[segment.id].invalidNodes.push(node);
				***REMOVED***
			***REMOVED***
		***REMOVED***

		/**
		 * Sets the current segment as `super` was called.
		 * @returns {void***REMOVED***
		 */
		function setSuperCalled() {
			const segments = funcInfo.currentSegments;

			for (const segment of segments) {
				if (segment.reachable) {
					segInfoMap[segment.id].superCalled = true;
				***REMOVED***
			***REMOVED***
		***REMOVED***

		return {
			/**
			 * Adds information of a constructor into the stack.
			 * @param {CodePath***REMOVED*** codePath A code path which was started.
			 * @param {ASTNode***REMOVED*** node The current node.
			 * @returns {void***REMOVED***
			 */
			onCodePathStart(codePath, node) {
				if (isConstructorFunction(node)) {
					// Class > ClassBody > MethodDefinition > FunctionExpression
					const classNode = node.parent.parent.parent;

					funcInfo = {
						upper: funcInfo,
						isConstructor: true,
						hasExtends: Boolean(
							classNode.superClass &&
								!astUtils.isNullOrUndefined(
									classNode.superClass,
								),
						),
						codePath,
						currentSegments: new Set(),
					***REMOVED***;
				***REMOVED*** else {
					funcInfo = {
						upper: funcInfo,
						isConstructor: false,
						hasExtends: false,
						codePath,
						currentSegments: new Set(),
					***REMOVED***;
				***REMOVED***
			***REMOVED***,

			/**
			 * Removes the top of stack item.
			 *
			 * And this traverses all segments of this code path then reports every
			 * invalid node.
			 * @param {CodePath***REMOVED*** codePath A code path which was ended.
			 * @returns {void***REMOVED***
			 */
			onCodePathEnd(codePath) {
				const isDerivedClass = funcInfo.hasExtends;

				funcInfo = funcInfo.upper;
				if (!isDerivedClass) {
					return;
				***REMOVED***

				/**
				 * A collection of nodes to avoid duplicate reports.
				 * @type {Set<ASTNode>***REMOVED***
				 */
				const reported = new Set();

				codePath.traverseSegments((segment, controller) => {
					const info = segInfoMap[segment.id];
					const invalidNodes = info.invalidNodes.filter(
						/*
						 * Avoid duplicate reports.
						 * When there is a `finally`, invalidNodes may contain already reported node.
						 */
						node => !reported.has(node),
					);

					for (const invalidNode of invalidNodes) {
						reported.add(invalidNode);

						context.report({
							messageId: "noBeforeSuper",
							node: invalidNode,
							data: {
								kind:
									invalidNode.type === "Super"
										? "super"
										: "this",
							***REMOVED***,
						***REMOVED***);
					***REMOVED***

					if (info.superCalled) {
						controller.skip();
					***REMOVED***
				***REMOVED***);
			***REMOVED***,

			/**
			 * Initialize information of a given code path segment.
			 * @param {CodePathSegment***REMOVED*** segment A code path segment to initialize.
			 * @returns {void***REMOVED***
			 */
			onCodePathSegmentStart(segment) {
				funcInfo.currentSegments.add(segment);

				if (!isInConstructorOfDerivedClass()) {
					return;
				***REMOVED***

				// Initialize info.
				segInfoMap[segment.id] = {
					superCalled:
						segment.prevSegments.length > 0 &&
						segment.prevSegments.every(isCalled),
					invalidNodes: [],
				***REMOVED***;
			***REMOVED***,

			onUnreachableCodePathSegmentStart(segment) {
				funcInfo.currentSegments.add(segment);
			***REMOVED***,

			onUnreachableCodePathSegmentEnd(segment) {
				funcInfo.currentSegments.delete(segment);
			***REMOVED***,

			onCodePathSegmentEnd(segment) {
				funcInfo.currentSegments.delete(segment);
			***REMOVED***,

			/**
			 * Update information of the code path segment when a code path was
			 * looped.
			 * @param {CodePathSegment***REMOVED*** fromSegment The code path segment of the
			 *      end of a loop.
			 * @param {CodePathSegment***REMOVED*** toSegment A code path segment of the head
			 *      of a loop.
			 * @returns {void***REMOVED***
			 */
			onCodePathSegmentLoop(fromSegment, toSegment) {
				if (!isInConstructorOfDerivedClass()) {
					return;
				***REMOVED***

				// Update information inside of the loop.
				funcInfo.codePath.traverseSegments(
					{ first: toSegment, last: fromSegment ***REMOVED***,
					(segment, controller) => {
						const info =
							segInfoMap[segment.id] ?? new SegmentInfo();

						if (info.superCalled) {
							controller.skip();
						***REMOVED*** else if (
							segment.prevSegments.length > 0 &&
							segment.prevSegments.every(isCalled)
						) {
							info.superCalled = true;
						***REMOVED***

						segInfoMap[segment.id] = info;
					***REMOVED***,
				);
			***REMOVED***,

			/**
			 * Reports if this is before `super()`.
			 * @param {ASTNode***REMOVED*** node A target node.
			 * @returns {void***REMOVED***
			 */
			ThisExpression(node) {
				if (isBeforeCallOfSuper()) {
					setInvalid(node);
				***REMOVED***
			***REMOVED***,

			/**
			 * Reports if this is before `super()`.
			 * @param {ASTNode***REMOVED*** node A target node.
			 * @returns {void***REMOVED***
			 */
			Super(node) {
				if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {
					setInvalid(node);
				***REMOVED***
			***REMOVED***,

			/**
			 * Marks `super()` called.
			 * @param {ASTNode***REMOVED*** node A target node.
			 * @returns {void***REMOVED***
			 */
			"CallExpression:exit"(node) {
				if (node.callee.type === "Super" && isBeforeCallOfSuper()) {
					setSuperCalled();
				***REMOVED***
			***REMOVED***,

			/**
			 * Resets state.
			 * @returns {void***REMOVED***
			 */
			"Program:exit"() {
				segInfoMap = Object.create(null);
			***REMOVED***,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
