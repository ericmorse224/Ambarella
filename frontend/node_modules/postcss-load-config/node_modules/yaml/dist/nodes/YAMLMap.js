'use strict';

var stringifyCollection = require('../stringify/stringifyCollection.js');
var addPairToJSMap = require('./addPairToJSMap.js');
var Collection = require('./Collection.js');
var identity = require('./identity.js');
var Pair = require('./Pair.js');
var Scalar = require('./Scalar.js');

function findPair(items, key) {
    const k = identity.isScalar(key) ? key.value : key;
    for (const it of items) {
        if (identity.isPair(it)) {
            if (it.key === key || it.key === k)
                return it;
            if (identity.isScalar(it.key) && it.key.value === k)
                return it;
        ***REMOVED***
    ***REMOVED***
    return undefined;
***REMOVED***
class YAMLMap extends Collection.Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:map';
    ***REMOVED***
    constructor(schema) {
        super(identity.MAP, schema);
        this.items = [];
    ***REMOVED***
    /**
     * A generic collection parsing method that can be extended
     * to other node classes that inherit from YAMLMap
     */
    static from(schema, obj, ctx) {
        const { keepUndefined, replacer ***REMOVED*** = ctx;
        const map = new this(schema);
        const add = (key, value) => {
            if (typeof replacer === 'function')
                value = replacer.call(obj, key, value);
            else if (Array.isArray(replacer) && !replacer.includes(key))
                return;
            if (value !== undefined || keepUndefined)
                map.items.push(Pair.createPair(key, value, ctx));
        ***REMOVED***;
        if (obj instanceof Map) {
            for (const [key, value] of obj)
                add(key, value);
        ***REMOVED***
        else if (obj && typeof obj === 'object') {
            for (const key of Object.keys(obj))
                add(key, obj[key]);
        ***REMOVED***
        if (typeof schema.sortMapEntries === 'function') {
            map.items.sort(schema.sortMapEntries);
        ***REMOVED***
        return map;
    ***REMOVED***
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */
    add(pair, overwrite) {
        let _pair;
        if (identity.isPair(pair))
            _pair = pair;
        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {
            // In TypeScript, this never happens.
            _pair = new Pair.Pair(pair, pair?.value);
        ***REMOVED***
        else
            _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
            if (!overwrite)
                throw new Error(`Key ${_pair.key***REMOVED*** already set`);
            // For scalars, keep the old node & its comments and anchors
            if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
                prev.value.value = _pair.value;
            else
                prev.value = _pair.value;
        ***REMOVED***
        else if (sortEntries) {
            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);
            if (i === -1)
                this.items.push(_pair);
            else
                this.items.splice(i, 0, _pair);
        ***REMOVED***
        else {
            this.items.push(_pair);
        ***REMOVED***
    ***REMOVED***
    delete(key) {
        const it = findPair(this.items, key);
        if (!it)
            return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
    ***REMOVED***
    get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;
    ***REMOVED***
    has(key) {
        return !!findPair(this.items, key);
    ***REMOVED***
    set(key, value) {
        this.add(new Pair.Pair(key, value), true);
    ***REMOVED***
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class***REMOVED*** Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */
    toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {***REMOVED***;
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const item of this.items)
            addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
    ***REMOVED***
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        for (const item of this.items) {
            if (!identity.isPair(item))
                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)***REMOVED*** instead`);
        ***REMOVED***
        if (!ctx.allNullValues && this.hasAllNullValues(false))
            ctx = Object.assign({***REMOVED***, ctx, { allNullValues: true ***REMOVED***);
        return stringifyCollection.stringifyCollection(this, ctx, {
            blockItemPrefix: '',
            flowChars: { start: '{', end: '***REMOVED***' ***REMOVED***,
            itemIndent: ctx.indent || '',
            onChompKeep,
            onComment
        ***REMOVED***);
    ***REMOVED***
***REMOVED***

exports.YAMLMap = YAMLMap;
exports.findPair = findPair;
