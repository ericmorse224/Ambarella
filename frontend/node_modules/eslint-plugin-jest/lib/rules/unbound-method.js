"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.default = void 0;

var _utils = require("./utils");

const toThrowMatchers = ['toThrow', 'toThrowError', 'toThrowErrorMatchingSnapshot', 'toThrowErrorMatchingInlineSnapshot'];

const isJestExpectToThrowCall = node => {
  if (!(0, _utils.isExpectCall)(node)) {
    return false;
  ***REMOVED***

  const {
    matcher
  ***REMOVED*** = (0, _utils.parseExpectCall)(node);

  if (!matcher) {
    return false;
  ***REMOVED***

  return !toThrowMatchers.includes(matcher.name);
***REMOVED***;

const baseRule = (() => {
  try {
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const TSESLintPlugin = require('@typescript-eslint/eslint-plugin');

    return TSESLintPlugin.rules['unbound-method'];
  ***REMOVED*** catch (e) {
    const error = e;

    if (error.code === 'MODULE_NOT_FOUND') {
      return null;
    ***REMOVED***

    throw error;
  ***REMOVED***
***REMOVED***)();

const tryCreateBaseRule = context => {
  try {
    return baseRule === null || baseRule === void 0 ? void 0 : baseRule.create(context);
  ***REMOVED*** catch {
    return null;
  ***REMOVED***
***REMOVED***;

const DEFAULT_MESSAGE = 'This rule requires `@typescript-eslint/eslint-plugin`';

var _default = (0, _utils.createRule)({
  defaultOptions: [{
    ignoreStatic: false
  ***REMOVED***],
  ...baseRule,
  name: __filename,
  meta: {
    messages: {
      unbound: DEFAULT_MESSAGE,
      unboundWithoutThisAnnotation: DEFAULT_MESSAGE
    ***REMOVED***,
    schema: [],
    type: 'problem',
    ...(baseRule === null || baseRule === void 0 ? void 0 : baseRule.meta),
    docs: {
      category: 'Best Practices',
      description: 'Enforces unbound methods are called with their expected scope',
      requiresTypeChecking: true,
      ...(baseRule === null || baseRule === void 0 ? void 0 : baseRule.meta.docs),
      recommended: false
    ***REMOVED***
  ***REMOVED***,

  create(context) {
    const baseSelectors = tryCreateBaseRule(context);

    if (!baseSelectors) {
      return {***REMOVED***;
    ***REMOVED***

    let inExpectToThrowCall = false;
    return { ...baseSelectors,

      CallExpression(node) {
        inExpectToThrowCall = isJestExpectToThrowCall(node);
      ***REMOVED***,

      'CallExpression:exit'(node) {
        if (inExpectToThrowCall && isJestExpectToThrowCall(node)) {
          inExpectToThrowCall = false;
        ***REMOVED***
      ***REMOVED***,

      MemberExpression(node) {
        var _baseSelectors$Member;

        if (inExpectToThrowCall) {
          return;
        ***REMOVED***

        (_baseSelectors$Member = baseSelectors.MemberExpression) === null || _baseSelectors$Member === void 0 ? void 0 : _baseSelectors$Member.call(baseSelectors, node);
      ***REMOVED***

    ***REMOVED***;
  ***REMOVED***

***REMOVED***);

exports.default = _default;