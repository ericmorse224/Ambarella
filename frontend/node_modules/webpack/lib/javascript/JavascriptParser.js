/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { Parser: AcornParser, tokTypes ***REMOVED*** = require("acorn");
const { SyncBailHook, HookMap ***REMOVED*** = require("tapable");
const vm = require("vm");
const Parser = require("../Parser");
const StackedMap = require("../util/StackedMap");
const binarySearchBounds = require("../util/binarySearchBounds");
const {
	webpackCommentRegExp,
	createMagicCommentContext
***REMOVED*** = require("../util/magicComment");
const memoize = require("../util/memoize");
const BasicEvaluatedExpression = require("./BasicEvaluatedExpression");

/** @typedef {import("acorn").Options***REMOVED*** AcornOptions */
/** @typedef {import("estree").AssignmentExpression***REMOVED*** AssignmentExpression */
/** @typedef {import("estree").BinaryExpression***REMOVED*** BinaryExpression */
/** @typedef {import("estree").BlockStatement***REMOVED*** BlockStatement */
/** @typedef {import("estree").SequenceExpression***REMOVED*** SequenceExpression */
/** @typedef {import("estree").CallExpression***REMOVED*** CallExpression */
/** @typedef {import("estree").BaseCallExpression***REMOVED*** BaseCallExpression */
/** @typedef {import("estree").StaticBlock***REMOVED*** StaticBlock */
/** @typedef {import("estree").ClassDeclaration***REMOVED*** ClassDeclaration */
/** @typedef {import("estree").ForStatement***REMOVED*** ForStatement */
/** @typedef {import("estree").SwitchStatement***REMOVED*** SwitchStatement */
/** @typedef {import("estree").ClassExpression***REMOVED*** ClassExpression */
/** @typedef {import("estree").Comment***REMOVED*** Comment */
/** @typedef {import("estree").ConditionalExpression***REMOVED*** ConditionalExpression */
/** @typedef {import("estree").Declaration***REMOVED*** Declaration */
/** @typedef {import("estree").PrivateIdentifier***REMOVED*** PrivateIdentifier */
/** @typedef {import("estree").PropertyDefinition***REMOVED*** PropertyDefinition */
/** @typedef {import("estree").Expression***REMOVED*** Expression */
/** @typedef {import("estree").Identifier***REMOVED*** Identifier */
/** @typedef {import("estree").VariableDeclaration***REMOVED*** VariableDeclaration */
/** @typedef {import("estree").IfStatement***REMOVED*** IfStatement */
/** @typedef {import("estree").LabeledStatement***REMOVED*** LabeledStatement */
/** @typedef {import("estree").Literal***REMOVED*** Literal */
/** @typedef {import("estree").LogicalExpression***REMOVED*** LogicalExpression */
/** @typedef {import("estree").ChainExpression***REMOVED*** ChainExpression */
/** @typedef {import("estree").MemberExpression***REMOVED*** MemberExpression */
/** @typedef {import("estree").YieldExpression***REMOVED*** YieldExpression */
/** @typedef {import("estree").MetaProperty***REMOVED*** MetaProperty */
/** @typedef {import("estree").Property***REMOVED*** Property */
/** @typedef {import("estree").AssignmentPattern***REMOVED*** AssignmentPattern */
/** @typedef {import("estree").ChainElement***REMOVED*** ChainElement */
/** @typedef {import("estree").Pattern***REMOVED*** Pattern */
/** @typedef {import("estree").UpdateExpression***REMOVED*** UpdateExpression */
/** @typedef {import("estree").ObjectExpression***REMOVED*** ObjectExpression */
/** @typedef {import("estree").UnaryExpression***REMOVED*** UnaryExpression */
/** @typedef {import("estree").ArrayExpression***REMOVED*** ArrayExpression */
/** @typedef {import("estree").ArrayPattern***REMOVED*** ArrayPattern */
/** @typedef {import("estree").AwaitExpression***REMOVED*** AwaitExpression */
/** @typedef {import("estree").ThisExpression***REMOVED*** ThisExpression */
/** @typedef {import("estree").RestElement***REMOVED*** RestElement */
/** @typedef {import("estree").ObjectPattern***REMOVED*** ObjectPattern */
/** @typedef {import("estree").SwitchCase***REMOVED*** SwitchCase */
/** @typedef {import("estree").CatchClause***REMOVED*** CatchClause */
/** @typedef {import("estree").VariableDeclarator***REMOVED*** VariableDeclarator */
/** @typedef {import("estree").ForInStatement***REMOVED*** ForInStatement */
/** @typedef {import("estree").ForOfStatement***REMOVED*** ForOfStatement */
/** @typedef {import("estree").ReturnStatement***REMOVED*** ReturnStatement */
/** @typedef {import("estree").WithStatement***REMOVED*** WithStatement */
/** @typedef {import("estree").ThrowStatement***REMOVED*** ThrowStatement */
/** @typedef {import("estree").MethodDefinition***REMOVED*** MethodDefinition */
/** @typedef {import("estree").NewExpression***REMOVED*** NewExpression */
/** @typedef {import("estree").SpreadElement***REMOVED*** SpreadElement */
/** @typedef {import("estree").FunctionExpression***REMOVED*** FunctionExpression */
/** @typedef {import("estree").WhileStatement***REMOVED*** WhileStatement */
/** @typedef {import("estree").ArrowFunctionExpression***REMOVED*** ArrowFunctionExpression */
/** @typedef {import("estree").ExpressionStatement***REMOVED*** ExpressionStatement */
/** @typedef {import("estree").FunctionDeclaration***REMOVED*** FunctionDeclaration */
/** @typedef {import("estree").DoWhileStatement***REMOVED*** DoWhileStatement */
/** @typedef {import("estree").TryStatement***REMOVED*** TryStatement */
/** @typedef {import("estree").Node***REMOVED*** Node */
/** @typedef {import("estree").Program***REMOVED*** Program */
/** @typedef {import("estree").Directive***REMOVED*** Directive */
/** @typedef {import("estree").Statement***REMOVED*** Statement */
/** @typedef {import("estree").ExportDefaultDeclaration***REMOVED*** ExportDefaultDeclaration */
/** @typedef {import("estree").Super***REMOVED*** Super */
/** @typedef {import("estree").TaggedTemplateExpression***REMOVED*** TaggedTemplateExpression */
/** @typedef {import("estree").TemplateLiteral***REMOVED*** TemplateLiteral */
/** @typedef {import("estree").AssignmentProperty***REMOVED*** AssignmentProperty */
/** @typedef {import("estree").MaybeNamedFunctionDeclaration***REMOVED*** MaybeNamedFunctionDeclaration */
/** @typedef {import("estree").MaybeNamedClassDeclaration***REMOVED*** MaybeNamedClassDeclaration */
/**
 * @template T
 * @typedef {import("tapable").AsArray<T>***REMOVED*** AsArray<T>
 */
/** @typedef {import("../Parser").ParserState***REMOVED*** ParserState */
/** @typedef {import("../Parser").PreparsedAst***REMOVED*** PreparsedAst */
/** @typedef {{ name: string | VariableInfo, rootInfo: string | VariableInfo, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[] ***REMOVED******REMOVED*** GetInfoResult */
/** @typedef {Statement | ModuleDeclaration | Expression | MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration***REMOVED*** StatementPathItem */
/** @typedef {(ident: string) => void***REMOVED*** OnIdentString */
/** @typedef {(ident: string, identifier: Identifier) => void***REMOVED*** OnIdent */
/** @typedef {StatementPathItem[]***REMOVED*** StatementPath */

// TODO remove cast when @types/estree has been updated to import assertions
/** @typedef {import("estree").BaseNode & { type: "ImportAttribute", key: Identifier | Literal, value: Literal ***REMOVED******REMOVED*** ImportAttribute */
/** @typedef {import("estree").ImportDeclaration & { attributes?: Array<ImportAttribute> ***REMOVED******REMOVED*** ImportDeclaration */
/** @typedef {import("estree").ExportNamedDeclaration & { attributes?: Array<ImportAttribute> ***REMOVED******REMOVED*** ExportNamedDeclaration */
/** @typedef {import("estree").ExportAllDeclaration & { attributes?: Array<ImportAttribute> ***REMOVED******REMOVED*** ExportAllDeclaration */
/** @typedef {import("estree").ImportExpression & { options?: Expression | null ***REMOVED******REMOVED*** ImportExpression */
/** @typedef {ImportDeclaration | ExportNamedDeclaration | ExportDefaultDeclaration | ExportAllDeclaration***REMOVED*** ModuleDeclaration */

/** @type {string[]***REMOVED*** */
const EMPTY_ARRAY = [];
const ALLOWED_MEMBER_TYPES_CALL_EXPRESSION = 0b01;
const ALLOWED_MEMBER_TYPES_EXPRESSION = 0b10;
const ALLOWED_MEMBER_TYPES_ALL = 0b11;

const LEGACY_ASSERT_ATTRIBUTES = Symbol("assert");

/** @type {(BaseParser: typeof AcornParser) => typeof AcornParser***REMOVED*** */
const importAssertions = Parser =>
	class extends Parser {
		/**
		 * @this {TODO***REMOVED***
		 * @returns {ImportAttribute[]***REMOVED*** import attributes
		 */
		parseWithClause() {
			/** @type {ImportAttribute[]***REMOVED*** */
			const nodes = [];

			const isAssertLegacy = this.value === "assert";

			if (isAssertLegacy) {
				if (!this.eat(tokTypes.name)) {
					return nodes;
				***REMOVED***
			***REMOVED*** else if (!this.eat(tokTypes._with)) {
				return nodes;
			***REMOVED***

			this.expect(tokTypes.braceL);

			/** @type {Record<string, boolean>***REMOVED*** */
			const attributeKeys = {***REMOVED***;
			let first = true;

			while (!this.eat(tokTypes.braceR)) {
				if (!first) {
					this.expect(tokTypes.comma);
					if (this.afterTrailingComma(tokTypes.braceR)) {
						break;
					***REMOVED***
				***REMOVED*** else {
					first = false;
				***REMOVED***

				const attr =
					/** @type {ImportAttribute***REMOVED*** */
					this.parseImportAttribute();
				const keyName =
					attr.key.type === "Identifier" ? attr.key.name : attr.key.value;

				if (Object.prototype.hasOwnProperty.call(attributeKeys, keyName)) {
					this.raiseRecoverable(
						attr.key.start,
						`Duplicate attribute key '${keyName***REMOVED***'`
					);
				***REMOVED***

				attributeKeys[keyName] = true;
				nodes.push(attr);
			***REMOVED***

			if (isAssertLegacy) {
				/** @type {EXPECTED_ANY***REMOVED*** */
				(nodes)[LEGACY_ASSERT_ATTRIBUTES] = true;
			***REMOVED***

			return nodes;
		***REMOVED***
	***REMOVED***;

// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API
const parser = AcornParser.extend(importAssertions);

/** @typedef {Record<string, string> & { _isLegacyAssert?: boolean ***REMOVED******REMOVED*** ImportAttributes */

/**
 * @param {ImportDeclaration | ExportNamedDeclaration | ExportAllDeclaration | ImportExpression***REMOVED*** node node with assertions
 * @returns {ImportAttributes | undefined***REMOVED*** import attributes
 */
const getImportAttributes = node => {
	if (node.type === "ImportExpression") {
		if (
			node.options &&
			node.options.type === "ObjectExpression" &&
			node.options.properties[0] &&
			node.options.properties[0].type === "Property" &&
			node.options.properties[0].key.type === "Identifier" &&
			(node.options.properties[0].key.name === "with" ||
				node.options.properties[0].key.name === "assert") &&
			node.options.properties[0].value.type === "ObjectExpression" &&
			node.options.properties[0].value.properties.length > 0
		) {
			const properties =
				/** @type {Property[]***REMOVED*** */
				(node.options.properties[0].value.properties);
			const result = /** @type {ImportAttributes***REMOVED*** */ ({***REMOVED***);
			for (const property of properties) {
				const key =
					/** @type {string***REMOVED*** */
					(
						property.key.type === "Identifier"
							? property.key.name
							: /** @type {Literal***REMOVED*** */ (property.key).value
					);
				result[key] =
					/** @type {string***REMOVED*** */
					(/** @type {Literal***REMOVED*** */ (property.value).value);
			***REMOVED***
			const key =
				node.options.properties[0].key.type === "Identifier"
					? node.options.properties[0].key.name
					: /** @type {Literal***REMOVED*** */ (node.options.properties[0].key).value;

			if (key === "assert") {
				result._isLegacyAssert = true;
			***REMOVED***

			return result;
		***REMOVED***

		return;
	***REMOVED***

	if (node.attributes === undefined || node.attributes.length === 0) {
		return;
	***REMOVED***

	const result = /** @type {ImportAttributes***REMOVED*** */ ({***REMOVED***);

	for (const attribute of node.attributes) {
		const key =
			/** @type {string***REMOVED*** */
			(
				attribute.key.type === "Identifier"
					? attribute.key.name
					: attribute.key.value
			);

		result[key] = /** @type {string***REMOVED*** */ (attribute.value.value);
	***REMOVED***

	if (/** @type {EXPECTED_ANY***REMOVED*** */ (node.attributes)[LEGACY_ASSERT_ATTRIBUTES]) {
		result._isLegacyAssert = true;
	***REMOVED***

	return result;
***REMOVED***;

class VariableInfo {
	/**
	 * @param {ScopeInfo***REMOVED*** declaredScope scope in which the variable is declared
	 * @param {string | true | undefined***REMOVED*** freeName which free name the variable aliases, or true when none
	 * @param {TagInfo | undefined***REMOVED*** tagInfo info about tags
	 */
	constructor(declaredScope, freeName, tagInfo) {
		this.declaredScope = declaredScope;
		this.freeName = freeName;
		this.tagInfo = tagInfo;
	***REMOVED***
***REMOVED***

/** @typedef {string | ScopeInfo | VariableInfo***REMOVED*** ExportedVariableInfo */
/** @typedef {Literal | string | null | undefined***REMOVED*** ImportSource */
/** @typedef {Omit<AcornOptions, "sourceType" | "ecmaVersion"> & { sourceType: "module" | "script" | "auto", ecmaVersion?: AcornOptions["ecmaVersion"] ***REMOVED******REMOVED*** ParseOptions */

/** @typedef {symbol***REMOVED*** Tag */
/** @typedef {Record<string, TODO>***REMOVED*** TagData */

/**
 * @typedef {object***REMOVED*** TagInfo
 * @property {Tag***REMOVED*** tag
 * @property {TagData=***REMOVED*** data
 * @property {TagInfo | undefined***REMOVED*** next
 */

const SCOPE_INFO_TERMINATED_RETURN = 1;
const SCOPE_INFO_TERMINATED_THROW = 2;

/**
 * @typedef {object***REMOVED*** ScopeInfo
 * @property {StackedMap<string, VariableInfo | ScopeInfo>***REMOVED*** definitions
 * @property {boolean | "arrow"***REMOVED*** topLevelScope
 * @property {boolean | string***REMOVED*** inShorthand
 * @property {boolean***REMOVED*** inTaggedTemplateTag
 * @property {boolean***REMOVED*** inTry
 * @property {boolean***REMOVED*** isStrict
 * @property {boolean***REMOVED*** isAsmJs
 * @property {undefined | 1 | 2***REMOVED*** terminated
 */

/** @typedef {[number, number]***REMOVED*** Range */

/**
 * @typedef {object***REMOVED*** DestructuringAssignmentProperty
 * @property {string***REMOVED*** id
 * @property {Range | undefined=***REMOVED*** range
 * @property {boolean | string***REMOVED*** shorthand
 */

/**
 * Helper function for joining two ranges into a single range. This is useful
 * when working with AST nodes, as it allows you to combine the ranges of child nodes
 * to create the range of the _parent node_.
 * @param {Range***REMOVED*** startRange start range to join
 * @param {Range***REMOVED*** endRange end range to join
 * @returns {Range***REMOVED*** joined range
 * @example
 * ```js
 * 	const startRange = [0, 5];
 * 	const endRange = [10, 15];
 * 	const joinedRange = joinRanges(startRange, endRange);
 * 	console.log(joinedRange); // [0, 15]
 * ```
 */
const joinRanges = (startRange, endRange) => {
	if (!endRange) return startRange;
	if (!startRange) return endRange;
	return [startRange[0], endRange[1]];
***REMOVED***;

/**
 * Helper function used to generate a string representation of a
 * [member expression](https://github.com/estree/estree/blob/master/es5.md#memberexpression).
 * @param {string***REMOVED*** object object to name
 * @param {string[]***REMOVED*** membersReversed reversed list of members
 * @returns {string***REMOVED*** member expression as a string
 * @example
 * ```js
 * const membersReversed = ["property1", "property2", "property3"]; // Members parsed from the AST
 * const name = objectAndMembersToName("myObject", membersReversed);
 *
 * console.log(name); // "myObject.property1.property2.property3"
 * ```
 */
const objectAndMembersToName = (object, membersReversed) => {
	let name = object;
	for (let i = membersReversed.length - 1; i >= 0; i--) {
		name = `${name***REMOVED***.${membersReversed[i]***REMOVED***`;
	***REMOVED***
	return name;
***REMOVED***;

/**
 * Grabs the name of a given expression and returns it as a string or undefined. Has particular
 * handling for [Identifiers](https://github.com/estree/estree/blob/master/es5.md#identifier),
 * [ThisExpressions](https://github.com/estree/estree/blob/master/es5.md#identifier), and
 * [MetaProperties](https://github.com/estree/estree/blob/master/es2015.md#metaproperty) which is
 * specifically for handling the `new.target` meta property.
 * @param {Expression | SpreadElement | Super***REMOVED*** expression expression
 * @returns {string | "this" | undefined***REMOVED*** name or variable info
 */
const getRootName = expression => {
	switch (expression.type) {
		case "Identifier":
			return expression.name;
		case "ThisExpression":
			return "this";
		case "MetaProperty":
			return `${expression.meta.name***REMOVED***.${expression.property.name***REMOVED***`;
		default:
			return undefined;
	***REMOVED***
***REMOVED***;

/** @type {AcornOptions***REMOVED*** */
const defaultParserOptions = {
	ranges: true,
	locations: true,
	ecmaVersion: "latest",
	sourceType: "module",
	// https://github.com/tc39/proposal-hashbang
	allowHashBang: true,
	onComment: undefined
***REMOVED***;

const EMPTY_COMMENT_OPTIONS = {
	options: null,
	errors: null
***REMOVED***;

const CLASS_NAME = "JavascriptParser";

class JavascriptParser extends Parser {
	/**
	 * @param {"module" | "script" | "auto"***REMOVED*** sourceType default source type
	 */
	constructor(sourceType = "auto") {
		super();
		this.hooks = Object.freeze({
			/** @type {HookMap<SyncBailHook<[UnaryExpression], BasicEvaluatedExpression | null | undefined>>***REMOVED*** */
			evaluateTypeof: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[Expression | SpreadElement | PrivateIdentifier | Super], BasicEvaluatedExpression | null | undefined>>***REMOVED*** */
			evaluate: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[Identifier | ThisExpression | MemberExpression | MetaProperty], BasicEvaluatedExpression | null | undefined>>***REMOVED*** */
			evaluateIdentifier: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[Identifier | ThisExpression | MemberExpression], BasicEvaluatedExpression | null | undefined>>***REMOVED*** */
			evaluateDefinedIdentifier: new HookMap(
				() => new SyncBailHook(["expression"])
			),
			/** @type {HookMap<SyncBailHook<[NewExpression], BasicEvaluatedExpression | null | undefined>>***REMOVED*** */
			evaluateNewExpression: new HookMap(
				() => new SyncBailHook(["expression"])
			),
			/** @type {HookMap<SyncBailHook<[CallExpression], BasicEvaluatedExpression | null | undefined>>***REMOVED*** */
			evaluateCallExpression: new HookMap(
				() => new SyncBailHook(["expression"])
			),
			/** @type {HookMap<SyncBailHook<[CallExpression, BasicEvaluatedExpression], BasicEvaluatedExpression | null | undefined>>***REMOVED*** */
			evaluateCallExpressionMember: new HookMap(
				() => new SyncBailHook(["expression", "param"])
			),
			/** @type {HookMap<SyncBailHook<[Expression | Declaration | PrivateIdentifier | MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration, number], boolean | void>>***REMOVED*** */
			isPure: new HookMap(
				() => new SyncBailHook(["expression", "commentsStartPosition"])
			),
			/** @type {SyncBailHook<[Statement | ModuleDeclaration | MaybeNamedClassDeclaration | MaybeNamedFunctionDeclaration], boolean | void>***REMOVED*** */
			preStatement: new SyncBailHook(["statement"]),

			/** @type {SyncBailHook<[Statement | ModuleDeclaration | MaybeNamedClassDeclaration | MaybeNamedFunctionDeclaration], boolean | void>***REMOVED*** */
			blockPreStatement: new SyncBailHook(["declaration"]),
			/** @type {SyncBailHook<[Statement | ModuleDeclaration | MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration], boolean | void>***REMOVED*** */
			statement: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[IfStatement], boolean | void>***REMOVED*** */
			statementIf: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[Expression, ClassExpression | ClassDeclaration | MaybeNamedClassDeclaration], boolean | void>***REMOVED*** */
			classExtendsExpression: new SyncBailHook([
				"expression",
				"classDefinition"
			]),
			/** @type {SyncBailHook<[MethodDefinition | PropertyDefinition | StaticBlock, ClassExpression | ClassDeclaration | MaybeNamedClassDeclaration], boolean | void>***REMOVED*** */
			classBodyElement: new SyncBailHook(["element", "classDefinition"]),
			/** @type {SyncBailHook<[Expression, MethodDefinition | PropertyDefinition, ClassExpression | ClassDeclaration | MaybeNamedClassDeclaration], boolean | void>***REMOVED*** */
			classBodyValue: new SyncBailHook([
				"expression",
				"element",
				"classDefinition"
			]),
			/** @type {HookMap<SyncBailHook<[LabeledStatement], boolean | void>>***REMOVED*** */
			label: new HookMap(() => new SyncBailHook(["statement"])),
			/** @type {SyncBailHook<[ImportDeclaration, ImportSource], boolean | void>***REMOVED*** */
			import: new SyncBailHook(["statement", "source"]),
			/** @type {SyncBailHook<[ImportDeclaration, ImportSource, string | null, string], boolean | void>***REMOVED*** */
			importSpecifier: new SyncBailHook([
				"statement",
				"source",
				"exportName",
				"identifierName"
			]),
			/** @type {SyncBailHook<[ExportDefaultDeclaration | ExportNamedDeclaration], boolean | void>***REMOVED*** */
			export: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, ImportSource], boolean | void>***REMOVED*** */
			exportImport: new SyncBailHook(["statement", "source"]),
			/** @type {SyncBailHook<[ExportDefaultDeclaration | ExportNamedDeclaration | ExportAllDeclaration, Declaration], boolean | void>***REMOVED*** */
			exportDeclaration: new SyncBailHook(["statement", "declaration"]),
			/** @type {SyncBailHook<[ExportDefaultDeclaration, MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration | Expression], boolean | void>***REMOVED*** */
			exportExpression: new SyncBailHook(["statement", "node"]),
			/** @type {SyncBailHook<[ExportDefaultDeclaration | ExportNamedDeclaration | ExportAllDeclaration, string, string, number | undefined], boolean | void>***REMOVED*** */
			exportSpecifier: new SyncBailHook([
				"statement",
				"identifierName",
				"exportName",
				"index"
			]),
			/** @type {SyncBailHook<[ExportNamedDeclaration | ExportAllDeclaration, ImportSource, string | null, string | null, number | undefined], boolean | void>***REMOVED*** */
			exportImportSpecifier: new SyncBailHook([
				"statement",
				"source",
				"identifierName",
				"exportName",
				"index"
			]),
			/** @type {SyncBailHook<[VariableDeclarator, Statement], boolean | void>***REMOVED*** */
			preDeclarator: new SyncBailHook(["declarator", "statement"]),
			/** @type {SyncBailHook<[VariableDeclarator, Statement], boolean | void>***REMOVED*** */
			declarator: new SyncBailHook(["declarator", "statement"]),
			/** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>***REMOVED*** */
			varDeclaration: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>***REMOVED*** */
			varDeclarationLet: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>***REMOVED*** */
			varDeclarationConst: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[Declaration], boolean | void>>***REMOVED*** */
			varDeclarationVar: new HookMap(() => new SyncBailHook(["declaration"])),
			/** @type {HookMap<SyncBailHook<[Identifier], boolean | void>>***REMOVED*** */
			pattern: new HookMap(() => new SyncBailHook(["pattern"])),
			/** @type {HookMap<SyncBailHook<[Expression], boolean | void>>***REMOVED*** */
			canRename: new HookMap(() => new SyncBailHook(["initExpression"])),
			/** @type {HookMap<SyncBailHook<[Expression], boolean | void>>***REMOVED*** */
			rename: new HookMap(() => new SyncBailHook(["initExpression"])),
			/** @type {HookMap<SyncBailHook<[AssignmentExpression], boolean | void>>***REMOVED*** */
			assign: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[AssignmentExpression, string[]], boolean | void>>***REMOVED*** */
			assignMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** @type {HookMap<SyncBailHook<[Expression], boolean | void>>***REMOVED*** */
			typeof: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {SyncBailHook<[ImportExpression], boolean | void>***REMOVED*** */
			importCall: new SyncBailHook(["expression"]),
			/** @type {SyncBailHook<[Expression | ForOfStatement], boolean | void>***REMOVED*** */
			topLevelAwait: new SyncBailHook(["expression"]),
			/** @type {HookMap<SyncBailHook<[CallExpression], boolean | void>>***REMOVED*** */
			call: new HookMap(() => new SyncBailHook(["expression"])),
			/** Something like "a.b()" */
			/** @type {HookMap<SyncBailHook<[CallExpression, string[], boolean[], Range[]], boolean | void>>***REMOVED*** */
			callMemberChain: new HookMap(
				() =>
					new SyncBailHook([
						"expression",
						"members",
						"membersOptionals",
						"memberRanges"
					])
			),
			/** Something like "a.b().c.d" */
			/** @type {HookMap<SyncBailHook<[Expression, string[], CallExpression, string[], Range[]], boolean | void>>***REMOVED*** */
			memberChainOfCallMemberChain: new HookMap(
				() =>
					new SyncBailHook([
						"expression",
						"calleeMembers",
						"callExpression",
						"members",
						"memberRanges"
					])
			),
			/** Something like "a.b().c.d()"" */
			/** @type {HookMap<SyncBailHook<[CallExpression, string[], CallExpression, string[], Range[]], boolean | void>>***REMOVED*** */
			callMemberChainOfCallMemberChain: new HookMap(
				() =>
					new SyncBailHook([
						"expression",
						"calleeMembers",
						"innerCallExpression",
						"members",
						"memberRanges"
					])
			),
			/** @type {SyncBailHook<[ChainExpression], boolean | void>***REMOVED*** */
			optionalChaining: new SyncBailHook(["optionalChaining"]),
			/** @type {HookMap<SyncBailHook<[NewExpression], boolean | void>>***REMOVED*** */
			new: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {SyncBailHook<[BinaryExpression], boolean | void>***REMOVED*** */
			binaryExpression: new SyncBailHook(["binaryExpression"]),
			/** @type {HookMap<SyncBailHook<[Expression], boolean | void>>***REMOVED*** */
			expression: new HookMap(() => new SyncBailHook(["expression"])),
			/** @type {HookMap<SyncBailHook<[MemberExpression, string[], boolean[], Range[]], boolean | void>>***REMOVED*** */
			expressionMemberChain: new HookMap(
				() =>
					new SyncBailHook([
						"expression",
						"members",
						"membersOptionals",
						"memberRanges"
					])
			),
			/** @type {HookMap<SyncBailHook<[MemberExpression, string[]], boolean | void>>***REMOVED*** */
			unhandledExpressionMemberChain: new HookMap(
				() => new SyncBailHook(["expression", "members"])
			),
			/** @type {SyncBailHook<[ConditionalExpression], boolean | void>***REMOVED*** */
			expressionConditionalOperator: new SyncBailHook(["expression"]),
			/** @type {SyncBailHook<[LogicalExpression], boolean | void>***REMOVED*** */
			expressionLogicalOperator: new SyncBailHook(["expression"]),
			/** @type {SyncBailHook<[Program, Comment[]], boolean | void>***REMOVED*** */
			program: new SyncBailHook(["ast", "comments"]),
			/** @type {SyncBailHook<[ThrowStatement | ReturnStatement], boolean | void>***REMOVED*** */
			terminate: new SyncBailHook(["statement"]),
			/** @type {SyncBailHook<[Program, Comment[]], boolean | void>***REMOVED*** */
			finish: new SyncBailHook(["ast", "comments"])
		***REMOVED***);
		this.sourceType = sourceType;
		/** @type {ScopeInfo***REMOVED*** */
		this.scope = /** @type {TODO***REMOVED*** */ (undefined);
		/** @type {ParserState***REMOVED*** */
		this.state = /** @type {TODO***REMOVED*** */ (undefined);
		/** @type {Comment[] | undefined***REMOVED*** */
		this.comments = undefined;
		/** @type {Set<number> | undefined***REMOVED*** */
		this.semicolons = undefined;
		/** @type {StatementPath | undefined***REMOVED*** */
		this.statementPath = undefined;
		/** @type {Statement | ModuleDeclaration | Expression | MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration | undefined***REMOVED*** */
		this.prevStatement = undefined;
		/** @type {WeakMap<Expression, Set<DestructuringAssignmentProperty>> | undefined***REMOVED*** */
		this.destructuringAssignmentProperties = undefined;
		/** @type {TagData | undefined***REMOVED*** */
		this.currentTagData = undefined;
		this.magicCommentContext = createMagicCommentContext();
		this._initializeEvaluating();
	***REMOVED***

	_initializeEvaluating() {
		this.hooks.evaluate.for("Literal").tap(CLASS_NAME, _expr => {
			const expr = /** @type {Literal***REMOVED*** */ (_expr);

			switch (typeof expr.value) {
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(expr.value)
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(expr.value)
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				case "string":
					return new BasicEvaluatedExpression()
						.setString(expr.value)
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(expr.value)
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
			***REMOVED***
			if (expr.value === null) {
				return new BasicEvaluatedExpression()
					.setNull()
					.setRange(/** @type {Range***REMOVED*** */ (expr.range));
			***REMOVED***
			if (expr.value instanceof RegExp) {
				return new BasicEvaluatedExpression()
					.setRegExp(expr.value)
					.setRange(/** @type {Range***REMOVED*** */ (expr.range));
			***REMOVED***
		***REMOVED***);
		this.hooks.evaluate.for("NewExpression").tap(CLASS_NAME, _expr => {
			const expr = /** @type {NewExpression***REMOVED*** */ (_expr);
			const callee = expr.callee;
			if (callee.type !== "Identifier") return;
			if (callee.name !== "RegExp") {
				return this.callHooksForName(
					this.hooks.evaluateNewExpression,
					callee.name,
					expr
				);
			***REMOVED*** else if (
				expr.arguments.length > 2 ||
				this.getVariableInfo("RegExp") !== "RegExp"
			)
				return;

			let regExp;
			const arg1 = expr.arguments[0];

			if (arg1) {
				if (arg1.type === "SpreadElement") return;

				const evaluatedRegExp = this.evaluateExpression(arg1);

				if (!evaluatedRegExp) return;

				regExp = evaluatedRegExp.asString();

				if (!regExp) return;
			***REMOVED*** else {
				return (
					new BasicEvaluatedExpression()
						// eslint-disable-next-line prefer-regex-literals
						.setRegExp(new RegExp(""))
						.setRange(/** @type {Range***REMOVED*** */ (expr.range))
				);
			***REMOVED***

			let flags;
			const arg2 = expr.arguments[1];

			if (arg2) {
				if (arg2.type === "SpreadElement") return;

				const evaluatedFlags = this.evaluateExpression(arg2);

				if (!evaluatedFlags) return;

				if (!evaluatedFlags.isUndefined()) {
					flags = evaluatedFlags.asString();

					if (
						flags === undefined ||
						!BasicEvaluatedExpression.isValidRegExpFlags(flags)
					)
						return;
				***REMOVED***
			***REMOVED***

			return new BasicEvaluatedExpression()
				.setRegExp(flags ? new RegExp(regExp, flags) : new RegExp(regExp))
				.setRange(/** @type {Range***REMOVED*** */ (expr.range));
		***REMOVED***);
		this.hooks.evaluate.for("LogicalExpression").tap(CLASS_NAME, _expr => {
			const expr = /** @type {LogicalExpression***REMOVED*** */ (_expr);

			const left = this.evaluateExpression(expr.left);
			let returnRight = false;
			/** @type {boolean | undefined***REMOVED*** */
			let allowedRight;
			if (expr.operator === "&&") {
				const leftAsBool = left.asBool();
				if (leftAsBool === false)
					return left.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				returnRight = leftAsBool === true;
				allowedRight = false;
			***REMOVED*** else if (expr.operator === "||") {
				const leftAsBool = left.asBool();
				if (leftAsBool === true)
					return left.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				returnRight = leftAsBool === false;
				allowedRight = true;
			***REMOVED*** else if (expr.operator === "??") {
				const leftAsNullish = left.asNullish();
				if (leftAsNullish === false)
					return left.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				if (leftAsNullish !== true) return;
				returnRight = true;
			***REMOVED*** else return;
			const right = this.evaluateExpression(expr.right);
			if (returnRight) {
				if (left.couldHaveSideEffects()) right.setSideEffects();
				return right.setRange(/** @type {Range***REMOVED*** */ (expr.range));
			***REMOVED***

			const asBool = right.asBool();

			if (allowedRight === true && asBool === true) {
				return new BasicEvaluatedExpression()
					.setRange(/** @type {Range***REMOVED*** */ (expr.range))
					.setTruthy();
			***REMOVED*** else if (allowedRight === false && asBool === false) {
				return new BasicEvaluatedExpression()
					.setRange(/** @type {Range***REMOVED*** */ (expr.range))
					.setFalsy();
			***REMOVED***
		***REMOVED***);

		/**
		 * In simple logical cases, we can use valueAsExpression to assist us in evaluating the expression on
		 * either side of a [BinaryExpression](https://github.com/estree/estree/blob/master/es5.md#binaryexpression).
		 * This supports scenarios in webpack like conditionally `import()`'ing modules based on some simple evaluation:
		 *
		 * ```js
		 * if (1 === 3) {
		 *  import("./moduleA"); // webpack will auto evaluate this and not import the modules
		 * ***REMOVED***
		 * ```
		 *
		 * Additional scenarios include evaluation of strings inside of dynamic import statements:
		 *
		 * ```js
		 * const foo = "foo";
		 * const bar = "bar";
		 *
		 * import("./" + foo + bar); // webpack will auto evaluate this into import("./foobar")
		 * ```
		 * @param {boolean | number | bigint | string***REMOVED*** value the value to convert to an expression
		 * @param {BinaryExpression | UnaryExpression***REMOVED*** expr the expression being evaluated
		 * @param {boolean***REMOVED*** sideEffects whether the expression has side effects
		 * @returns {BasicEvaluatedExpression | undefined***REMOVED*** the evaluated expression
		 * @example
		 *
		 * ```js
		 * const binaryExpr = new BinaryExpression("+",
		 * 	{ type: "Literal", value: 2 ***REMOVED***,
		 * 	{ type: "Literal", value: 3 ***REMOVED***
		 * );
		 *
		 * const leftValue = 2;
		 * const rightValue = 3;
		 *
		 * const leftExpr = valueAsExpression(leftValue, binaryExpr.left, false);
		 * const rightExpr = valueAsExpression(rightValue, binaryExpr.right, false);
		 * const result = new BasicEvaluatedExpression()
		 * 	.setNumber(leftExpr.number + rightExpr.number)
		 * 	.setRange(binaryExpr.range);
		 *
		 * console.log(result.number); // Output: 5
		 * ```
		 */
		const valueAsExpression = (value, expr, sideEffects) => {
			switch (typeof value) {
				case "boolean":
					return new BasicEvaluatedExpression()
						.setBoolean(value)
						.setSideEffects(sideEffects)
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				case "number":
					return new BasicEvaluatedExpression()
						.setNumber(value)
						.setSideEffects(sideEffects)
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				case "bigint":
					return new BasicEvaluatedExpression()
						.setBigInt(value)
						.setSideEffects(sideEffects)
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				case "string":
					return new BasicEvaluatedExpression()
						.setString(value)
						.setSideEffects(sideEffects)
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
			***REMOVED***
		***REMOVED***;

		this.hooks.evaluate.for("BinaryExpression").tap(CLASS_NAME, _expr => {
			const expr = /** @type {BinaryExpression***REMOVED*** */ (_expr);

			/**
			 * Evaluates a binary expression if and only if it is a const operation (e.g. 1 + 2, "a" + "b", etc.).
			 * @template T
			 * @param {(leftOperand: T, rightOperand: T) => boolean | number | bigint | string***REMOVED*** operandHandler the handler for the operation (e.g. (a, b) => a + b)
			 * @returns {BasicEvaluatedExpression | undefined***REMOVED*** the evaluated expression
			 */
			const handleConstOperation = operandHandler => {
				const left = this.evaluateExpression(expr.left);
				if (!left.isCompileTimeValue()) return;

				const right = this.evaluateExpression(expr.right);
				if (!right.isCompileTimeValue()) return;

				const result = operandHandler(
					/** @type {T***REMOVED*** */ (left.asCompileTimeValue()),
					/** @type {T***REMOVED*** */ (right.asCompileTimeValue())
				);
				return valueAsExpression(
					result,
					expr,
					left.couldHaveSideEffects() || right.couldHaveSideEffects()
				);
			***REMOVED***;

			/**
			 * Helper function to determine if two booleans are always different. This is used in `handleStrictEqualityComparison`
			 * to determine if an expressions boolean or nullish conversion is equal or not.
			 * @param {boolean***REMOVED*** a first boolean to compare
			 * @param {boolean***REMOVED*** b second boolean to compare
			 * @returns {boolean***REMOVED*** true if the two booleans are always different, false otherwise
			 */
			const isAlwaysDifferent = (a, b) =>
				(a === true && b === false) || (a === false && b === true);

			/**
			 * @param {BasicEvaluatedExpression***REMOVED*** left left
			 * @param {BasicEvaluatedExpression***REMOVED*** right right
			 * @param {BasicEvaluatedExpression***REMOVED*** res res
			 * @param {boolean***REMOVED*** eql true for "===" and false for "!=="
			 * @returns {BasicEvaluatedExpression | undefined***REMOVED*** result
			 */
			const handleTemplateStringCompare = (left, right, res, eql) => {
				/**
				 * @param {BasicEvaluatedExpression[]***REMOVED*** parts parts
				 * @returns {string***REMOVED*** value
				 */
				const getPrefix = parts => {
					let value = "";
					for (const p of parts) {
						const v = p.asString();
						if (v !== undefined) value += v;
						else break;
					***REMOVED***
					return value;
				***REMOVED***;
				/**
				 * @param {BasicEvaluatedExpression[]***REMOVED*** parts parts
				 * @returns {string***REMOVED*** value
				 */
				const getSuffix = parts => {
					let value = "";
					for (let i = parts.length - 1; i >= 0; i--) {
						const v = parts[i].asString();
						if (v !== undefined) value = v + value;
						else break;
					***REMOVED***
					return value;
				***REMOVED***;
				const leftPrefix = getPrefix(
					/** @type {BasicEvaluatedExpression[]***REMOVED*** */ (left.parts)
				);
				const rightPrefix = getPrefix(
					/** @type {BasicEvaluatedExpression[]***REMOVED*** */ (right.parts)
				);
				const leftSuffix = getSuffix(
					/** @type {BasicEvaluatedExpression[]***REMOVED*** */ (left.parts)
				);
				const rightSuffix = getSuffix(
					/** @type {BasicEvaluatedExpression[]***REMOVED*** */ (right.parts)
				);
				const lenPrefix = Math.min(leftPrefix.length, rightPrefix.length);
				const lenSuffix = Math.min(leftSuffix.length, rightSuffix.length);
				const prefixMismatch =
					lenPrefix > 0 &&
					leftPrefix.slice(0, lenPrefix) !== rightPrefix.slice(0, lenPrefix);
				const suffixMismatch =
					lenSuffix > 0 &&
					leftSuffix.slice(-lenSuffix) !== rightSuffix.slice(-lenSuffix);
				if (prefixMismatch || suffixMismatch) {
					return res
						.setBoolean(!eql)
						.setSideEffects(
							left.couldHaveSideEffects() || right.couldHaveSideEffects()
						);
				***REMOVED***
			***REMOVED***;

			/**
			 * Helper function to handle BinaryExpressions using strict equality comparisons (e.g. "===" and "!==").
			 * @param {boolean***REMOVED*** eql true for "===" and false for "!=="
			 * @returns {BasicEvaluatedExpression | undefined***REMOVED*** the evaluated expression
			 */
			const handleStrictEqualityComparison = eql => {
				const left = this.evaluateExpression(expr.left);
				const right = this.evaluateExpression(expr.right);
				const res = new BasicEvaluatedExpression();
				res.setRange(/** @type {Range***REMOVED*** */ (expr.range));

				const leftConst = left.isCompileTimeValue();
				const rightConst = right.isCompileTimeValue();

				if (leftConst && rightConst) {
					return res
						.setBoolean(
							eql === (left.asCompileTimeValue() === right.asCompileTimeValue())
						)
						.setSideEffects(
							left.couldHaveSideEffects() || right.couldHaveSideEffects()
						);
				***REMOVED***

				if (left.isArray() && right.isArray()) {
					return res
						.setBoolean(!eql)
						.setSideEffects(
							left.couldHaveSideEffects() || right.couldHaveSideEffects()
						);
				***REMOVED***
				if (left.isTemplateString() && right.isTemplateString()) {
					return handleTemplateStringCompare(left, right, res, eql);
				***REMOVED***

				const leftPrimitive = left.isPrimitiveType();
				const rightPrimitive = right.isPrimitiveType();

				if (
					// Primitive !== Object or
					// compile-time object types are never equal to something at runtime
					(leftPrimitive === false && (leftConst || rightPrimitive === true)) ||
					(rightPrimitive === false &&
						(rightConst || leftPrimitive === true)) ||
					// Different nullish or boolish status also means not equal
					isAlwaysDifferent(
						/** @type {boolean***REMOVED*** */ (left.asBool()),
						/** @type {boolean***REMOVED*** */ (right.asBool())
					) ||
					isAlwaysDifferent(
						/** @type {boolean***REMOVED*** */ (left.asNullish()),
						/** @type {boolean***REMOVED*** */ (right.asNullish())
					)
				) {
					return res
						.setBoolean(!eql)
						.setSideEffects(
							left.couldHaveSideEffects() || right.couldHaveSideEffects()
						);
				***REMOVED***
			***REMOVED***;

			/**
			 * Helper function to handle BinaryExpressions using abstract equality comparisons (e.g. "==" and "!=").
			 * @param {boolean***REMOVED*** eql true for "==" and false for "!="
			 * @returns {BasicEvaluatedExpression | undefined***REMOVED*** the evaluated expression
			 */
			const handleAbstractEqualityComparison = eql => {
				const left = this.evaluateExpression(expr.left);
				const right = this.evaluateExpression(expr.right);
				const res = new BasicEvaluatedExpression();
				res.setRange(/** @type {Range***REMOVED*** */ (expr.range));

				const leftConst = left.isCompileTimeValue();
				const rightConst = right.isCompileTimeValue();

				if (leftConst && rightConst) {
					return res
						.setBoolean(
							eql ===
								// eslint-disable-next-line eqeqeq
								(left.asCompileTimeValue() == right.asCompileTimeValue())
						)
						.setSideEffects(
							left.couldHaveSideEffects() || right.couldHaveSideEffects()
						);
				***REMOVED***

				if (left.isArray() && right.isArray()) {
					return res
						.setBoolean(!eql)
						.setSideEffects(
							left.couldHaveSideEffects() || right.couldHaveSideEffects()
						);
				***REMOVED***
				if (left.isTemplateString() && right.isTemplateString()) {
					return handleTemplateStringCompare(left, right, res, eql);
				***REMOVED***
			***REMOVED***;

			if (expr.operator === "+") {
				const left = this.evaluateExpression(expr.left);
				const right = this.evaluateExpression(expr.right);
				const res = new BasicEvaluatedExpression();
				if (left.isString()) {
					if (right.isString()) {
						res.setString(
							/** @type {string***REMOVED*** */ (left.string) +
								/** @type {string***REMOVED*** */ (right.string)
						);
					***REMOVED*** else if (right.isNumber()) {
						res.setString(/** @type {string***REMOVED*** */ (left.string) + right.number);
					***REMOVED*** else if (
						right.isWrapped() &&
						right.prefix &&
						right.prefix.isString()
					) {
						// "left" + ("prefix" + inner + "postfix")
						// => ("leftPrefix" + inner + "postfix")
						res.setWrapped(
							new BasicEvaluatedExpression()
								.setString(
									/** @type {string***REMOVED*** */ (left.string) +
										/** @type {string***REMOVED*** */ (right.prefix.string)
								)
								.setRange(
									joinRanges(
										/** @type {Range***REMOVED*** */ (left.range),
										/** @type {Range***REMOVED*** */ (right.prefix.range)
									)
								),
							right.postfix,
							right.wrappedInnerExpressions
						);
					***REMOVED*** else if (right.isWrapped()) {
						// "left" + ([null] + inner + "postfix")
						// => ("left" + inner + "postfix")
						res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);
					***REMOVED*** else {
						// "left" + expr
						// => ("left" + expr + "")
						res.setWrapped(left, null, [right]);
					***REMOVED***
				***REMOVED*** else if (left.isNumber()) {
					if (right.isString()) {
						res.setString(left.number + /** @type {string***REMOVED*** */ (right.string));
					***REMOVED*** else if (right.isNumber()) {
						res.setNumber(
							/** @type {number***REMOVED*** */ (left.number) +
								/** @type {number***REMOVED*** */ (right.number)
						);
					***REMOVED*** else {
						return;
					***REMOVED***
				***REMOVED*** else if (left.isBigInt()) {
					if (right.isBigInt()) {
						res.setBigInt(
							/** @type {bigint***REMOVED*** */ (left.bigint) +
								/** @type {bigint***REMOVED*** */ (right.bigint)
						);
					***REMOVED***
				***REMOVED*** else if (left.isWrapped()) {
					if (left.postfix && left.postfix.isString() && right.isString()) {
						// ("prefix" + inner + "postfix") + "right"
						// => ("prefix" + inner + "postfixRight")
						res.setWrapped(
							left.prefix,
							new BasicEvaluatedExpression()
								.setString(
									/** @type {string***REMOVED*** */ (left.postfix.string) +
										/** @type {string***REMOVED*** */ (right.string)
								)
								.setRange(
									joinRanges(
										/** @type {Range***REMOVED*** */ (left.postfix.range),
										/** @type {Range***REMOVED*** */ (right.range)
									)
								),
							left.wrappedInnerExpressions
						);
					***REMOVED*** else if (
						left.postfix &&
						left.postfix.isString() &&
						right.isNumber()
					) {
						// ("prefix" + inner + "postfix") + 123
						// => ("prefix" + inner + "postfix123")
						res.setWrapped(
							left.prefix,
							new BasicEvaluatedExpression()
								.setString(
									/** @type {string***REMOVED*** */ (left.postfix.string) +
										/** @type {number***REMOVED*** */ (right.number)
								)
								.setRange(
									joinRanges(
										/** @type {Range***REMOVED*** */ (left.postfix.range),
										/** @type {Range***REMOVED*** */ (right.range)
									)
								),
							left.wrappedInnerExpressions
						);
					***REMOVED*** else if (right.isString()) {
						// ("prefix" + inner + [null]) + "right"
						// => ("prefix" + inner + "right")
						res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);
					***REMOVED*** else if (right.isNumber()) {
						// ("prefix" + inner + [null]) + 123
						// => ("prefix" + inner + "123")
						res.setWrapped(
							left.prefix,
							new BasicEvaluatedExpression()
								.setString(String(right.number))
								.setRange(/** @type {Range***REMOVED*** */ (right.range)),
							left.wrappedInnerExpressions
						);
					***REMOVED*** else if (right.isWrapped()) {
						// ("prefix1" + inner1 + "postfix1") + ("prefix2" + inner2 + "postfix2")
						// ("prefix1" + inner1 + "postfix1" + "prefix2" + inner2 + "postfix2")
						res.setWrapped(
							left.prefix,
							right.postfix,
							left.wrappedInnerExpressions &&
								right.wrappedInnerExpressions &&
								left.wrappedInnerExpressions
									.concat(left.postfix ? [left.postfix] : [])
									.concat(right.prefix ? [right.prefix] : [])
									.concat(right.wrappedInnerExpressions)
						);
					***REMOVED*** else {
						// ("prefix" + inner + postfix) + expr
						// => ("prefix" + inner + postfix + expr + [null])
						res.setWrapped(
							left.prefix,
							null,
							left.wrappedInnerExpressions &&
								left.wrappedInnerExpressions.concat(
									left.postfix ? [left.postfix, right] : [right]
								)
						);
					***REMOVED***
				***REMOVED*** else if (right.isString()) {
					// left + "right"
					// => ([null] + left + "right")
					res.setWrapped(null, right, [left]);
				***REMOVED*** else if (right.isWrapped()) {
					// left + (prefix + inner + "postfix")
					// => ([null] + left + prefix + inner + "postfix")
					res.setWrapped(
						null,
						right.postfix,
						right.wrappedInnerExpressions &&
							(right.prefix ? [left, right.prefix] : [left]).concat(
								right.wrappedInnerExpressions
							)
					);
				***REMOVED*** else {
					return;
				***REMOVED***
				if (left.couldHaveSideEffects() || right.couldHaveSideEffects())
					res.setSideEffects();
				res.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				return res;
			***REMOVED*** else if (expr.operator === "-") {
				return handleConstOperation((l, r) => l - r);
			***REMOVED*** else if (expr.operator === "*") {
				return handleConstOperation((l, r) => l * r);
			***REMOVED*** else if (expr.operator === "/") {
				return handleConstOperation((l, r) => l / r);
			***REMOVED*** else if (expr.operator === "**") {
				return handleConstOperation((l, r) => l ** r);
			***REMOVED*** else if (expr.operator === "===") {
				return handleStrictEqualityComparison(true);
			***REMOVED*** else if (expr.operator === "==") {
				return handleAbstractEqualityComparison(true);
			***REMOVED*** else if (expr.operator === "!==") {
				return handleStrictEqualityComparison(false);
			***REMOVED*** else if (expr.operator === "!=") {
				return handleAbstractEqualityComparison(false);
			***REMOVED*** else if (expr.operator === "&") {
				return handleConstOperation((l, r) => l & r);
			***REMOVED*** else if (expr.operator === "|") {
				return handleConstOperation((l, r) => l | r);
			***REMOVED*** else if (expr.operator === "^") {
				return handleConstOperation((l, r) => l ^ r);
			***REMOVED*** else if (expr.operator === ">>>") {
				return handleConstOperation((l, r) => l >>> r);
			***REMOVED*** else if (expr.operator === ">>") {
				return handleConstOperation((l, r) => l >> r);
			***REMOVED*** else if (expr.operator === "<<") {
				return handleConstOperation((l, r) => l << r);
			***REMOVED*** else if (expr.operator === "<") {
				return handleConstOperation((l, r) => l < r);
			***REMOVED*** else if (expr.operator === ">") {
				return handleConstOperation((l, r) => l > r);
			***REMOVED*** else if (expr.operator === "<=") {
				return handleConstOperation((l, r) => l <= r);
			***REMOVED*** else if (expr.operator === ">=") {
				return handleConstOperation((l, r) => l >= r);
			***REMOVED***
		***REMOVED***);
		this.hooks.evaluate.for("UnaryExpression").tap(CLASS_NAME, _expr => {
			const expr = /** @type {UnaryExpression***REMOVED*** */ (_expr);

			/**
			 * Evaluates a UnaryExpression if and only if it is a basic const operator (e.g. +a, -a, ~a).
			 * @template T
			 * @param {(operand: T) => boolean | number | bigint | string***REMOVED*** operandHandler handler for the operand
			 * @returns {BasicEvaluatedExpression | undefined***REMOVED*** evaluated expression
			 */
			const handleConstOperation = operandHandler => {
				const argument = this.evaluateExpression(expr.argument);
				if (!argument.isCompileTimeValue()) return;
				const result = operandHandler(
					/** @type {T***REMOVED*** */ (argument.asCompileTimeValue())
				);
				return valueAsExpression(result, expr, argument.couldHaveSideEffects());
			***REMOVED***;

			if (expr.operator === "typeof") {
				switch (expr.argument.type) {
					case "Identifier": {
						const res = this.callHooksForName(
							this.hooks.evaluateTypeof,
							expr.argument.name,
							expr
						);
						if (res !== undefined) return res;
						break;
					***REMOVED***
					case "MetaProperty": {
						const res = this.callHooksForName(
							this.hooks.evaluateTypeof,
							/** @type {string***REMOVED*** */
							(getRootName(expr.argument)),
							expr
						);
						if (res !== undefined) return res;
						break;
					***REMOVED***
					case "MemberExpression": {
						const res = this.callHooksForExpression(
							this.hooks.evaluateTypeof,
							expr.argument,
							expr
						);
						if (res !== undefined) return res;
						break;
					***REMOVED***
					case "ChainExpression": {
						const res = this.callHooksForExpression(
							this.hooks.evaluateTypeof,
							expr.argument.expression,
							expr
						);
						if (res !== undefined) return res;
						break;
					***REMOVED***
					case "FunctionExpression": {
						return new BasicEvaluatedExpression()
							.setString("function")
							.setRange(/** @type {Range***REMOVED*** */ (expr.range));
					***REMOVED***
				***REMOVED***
				const arg = this.evaluateExpression(expr.argument);
				if (arg.isUnknown()) return;
				if (arg.isString()) {
					return new BasicEvaluatedExpression()
						.setString("string")
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				***REMOVED***
				if (arg.isWrapped()) {
					return new BasicEvaluatedExpression()
						.setString("string")
						.setSideEffects()
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				***REMOVED***
				if (arg.isUndefined()) {
					return new BasicEvaluatedExpression()
						.setString("undefined")
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				***REMOVED***
				if (arg.isNumber()) {
					return new BasicEvaluatedExpression()
						.setString("number")
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				***REMOVED***
				if (arg.isBigInt()) {
					return new BasicEvaluatedExpression()
						.setString("bigint")
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				***REMOVED***
				if (arg.isBoolean()) {
					return new BasicEvaluatedExpression()
						.setString("boolean")
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				***REMOVED***
				if (arg.isConstArray() || arg.isRegExp() || arg.isNull()) {
					return new BasicEvaluatedExpression()
						.setString("object")
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				***REMOVED***
				if (arg.isArray()) {
					return new BasicEvaluatedExpression()
						.setString("object")
						.setSideEffects(arg.couldHaveSideEffects())
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				***REMOVED***
			***REMOVED*** else if (expr.operator === "!") {
				const argument = this.evaluateExpression(expr.argument);
				const bool = argument.asBool();
				if (typeof bool !== "boolean") return;
				return new BasicEvaluatedExpression()
					.setBoolean(!bool)
					.setSideEffects(argument.couldHaveSideEffects())
					.setRange(/** @type {Range***REMOVED*** */ (expr.range));
			***REMOVED*** else if (expr.operator === "~") {
				return handleConstOperation(v => ~v);
			***REMOVED*** else if (expr.operator === "+") {
				// eslint-disable-next-line no-implicit-coercion
				return handleConstOperation(v => +v);
			***REMOVED*** else if (expr.operator === "-") {
				return handleConstOperation(v => -v);
			***REMOVED***
		***REMOVED***);
		this.hooks.evaluateTypeof
			.for("undefined")
			.tap(CLASS_NAME, expr =>
				new BasicEvaluatedExpression()
					.setString("undefined")
					.setRange(/** @type {Range***REMOVED*** */ (expr.range))
			);
		this.hooks.evaluate.for("Identifier").tap(CLASS_NAME, expr => {
			if (/** @type {Identifier***REMOVED*** */ (expr).name === "undefined") {
				return new BasicEvaluatedExpression()
					.setUndefined()
					.setRange(/** @type {Range***REMOVED*** */ (expr.range));
			***REMOVED***
		***REMOVED***);
		/**
		 * @param {"Identifier" | "ThisExpression" | "MemberExpression"***REMOVED*** exprType expression type name
		 * @param {(node: Expression | SpreadElement) => GetInfoResult | undefined***REMOVED*** getInfo get info
		 * @returns {void***REMOVED***
		 */
		const tapEvaluateWithVariableInfo = (exprType, getInfo) => {
			/** @type {Expression | undefined***REMOVED*** */
			let cachedExpression;
			/** @type {GetInfoResult | undefined***REMOVED*** */
			let cachedInfo;
			this.hooks.evaluate.for(exprType).tap(CLASS_NAME, expr => {
				const expression =
					/** @type {Identifier | ThisExpression | MemberExpression***REMOVED*** */ (expr);

				const info = getInfo(expression);
				if (info !== undefined) {
					return this.callHooksForInfoWithFallback(
						this.hooks.evaluateIdentifier,
						info.name,
						name => {
							cachedExpression = expression;
							cachedInfo = info;
						***REMOVED***,
						name => {
							const hook = this.hooks.evaluateDefinedIdentifier.get(name);
							if (hook !== undefined) {
								return hook.call(expression);
							***REMOVED***
						***REMOVED***,
						expression
					);
				***REMOVED***
			***REMOVED***);
			this.hooks.evaluate
				.for(exprType)
				.tap({ name: CLASS_NAME, stage: 100 ***REMOVED***, expr => {
					const expression =
						/** @type {Identifier | ThisExpression | MemberExpression***REMOVED*** */
						(expr);
					const info =
						cachedExpression === expression ? cachedInfo : getInfo(expression);
					if (info !== undefined) {
						return new BasicEvaluatedExpression()
							.setIdentifier(
								info.name,
								info.rootInfo,
								info.getMembers,
								info.getMembersOptionals,
								info.getMemberRanges
							)
							.setRange(/** @type {Range***REMOVED*** */ (expression.range));
					***REMOVED***
				***REMOVED***);
			this.hooks.finish.tap(CLASS_NAME, () => {
				// Cleanup for GC
				cachedExpression = cachedInfo = undefined;
			***REMOVED***);
		***REMOVED***;
		tapEvaluateWithVariableInfo("Identifier", expr => {
			const info = this.getVariableInfo(/** @type {Identifier***REMOVED*** */ (expr).name);
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return {
					name: info,
					rootInfo: info,
					getMembers: () => [],
					getMembersOptionals: () => [],
					getMemberRanges: () => []
				***REMOVED***;
			***REMOVED***
		***REMOVED***);
		tapEvaluateWithVariableInfo("ThisExpression", expr => {
			const info = this.getVariableInfo("this");
			if (
				typeof info === "string" ||
				(info instanceof VariableInfo && typeof info.freeName === "string")
			) {
				return {
					name: info,
					rootInfo: info,
					getMembers: () => [],
					getMembersOptionals: () => [],
					getMemberRanges: () => []
				***REMOVED***;
			***REMOVED***
		***REMOVED***);
		this.hooks.evaluate.for("MetaProperty").tap(CLASS_NAME, expr => {
			const metaProperty = /** @type {MetaProperty***REMOVED*** */ (expr);

			return this.callHooksForName(
				this.hooks.evaluateIdentifier,
				/** @type {string***REMOVED*** */
				(getRootName(metaProperty)),
				metaProperty
			);
		***REMOVED***);
		tapEvaluateWithVariableInfo("MemberExpression", expr =>
			this.getMemberExpressionInfo(
				/** @type {MemberExpression***REMOVED*** */ (expr),
				ALLOWED_MEMBER_TYPES_EXPRESSION
			)
		);

		this.hooks.evaluate.for("CallExpression").tap(CLASS_NAME, _expr => {
			const expr = /** @type {CallExpression***REMOVED*** */ (_expr);
			if (
				expr.callee.type === "MemberExpression" &&
				expr.callee.property.type ===
					(expr.callee.computed ? "Literal" : "Identifier")
			) {
				// type Super also possible here
				const param = this.evaluateExpression(
					/** @type {Expression***REMOVED*** */ (expr.callee.object)
				);
				const property =
					expr.callee.property.type === "Literal"
						? `${expr.callee.property.value***REMOVED***`
						: expr.callee.property.name;
				const hook = this.hooks.evaluateCallExpressionMember.get(property);
				if (hook !== undefined) {
					return hook.call(expr, param);
				***REMOVED***
			***REMOVED*** else if (expr.callee.type === "Identifier") {
				return this.callHooksForName(
					this.hooks.evaluateCallExpression,
					expr.callee.name,
					expr
				);
			***REMOVED***
		***REMOVED***);
		this.hooks.evaluateCallExpressionMember
			.for("indexOf")
			.tap(CLASS_NAME, (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length === 0) return;
				const [arg1, arg2] = expr.arguments;
				if (arg1.type === "SpreadElement") return;
				const arg1Eval = this.evaluateExpression(arg1);
				if (!arg1Eval.isString()) return;
				const arg1Value = /** @type {string***REMOVED*** */ (arg1Eval.string);

				let result;
				if (arg2) {
					if (arg2.type === "SpreadElement") return;
					const arg2Eval = this.evaluateExpression(arg2);
					if (!arg2Eval.isNumber()) return;
					result = /** @type {string***REMOVED*** */ (param.string).indexOf(
						arg1Value,
						arg2Eval.number
					);
				***REMOVED*** else {
					result = /** @type {string***REMOVED*** */ (param.string).indexOf(arg1Value);
				***REMOVED***
				return new BasicEvaluatedExpression()
					.setNumber(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(/** @type {Range***REMOVED*** */ (expr.range));
			***REMOVED***);
		this.hooks.evaluateCallExpressionMember
			.for("replace")
			.tap(CLASS_NAME, (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 2) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				if (expr.arguments[1].type === "SpreadElement") return;
				const arg1 = this.evaluateExpression(expr.arguments[0]);
				const arg2 = this.evaluateExpression(expr.arguments[1]);
				if (!arg1.isString() && !arg1.isRegExp()) return;
				const arg1Value = /** @type {string | RegExp***REMOVED*** */ (
					arg1.regExp || arg1.string
				);
				if (!arg2.isString()) return;
				const arg2Value = /** @type {string***REMOVED*** */ (arg2.string);
				return new BasicEvaluatedExpression()
					.setString(
						/** @type {string***REMOVED*** */ (param.string).replace(arg1Value, arg2Value)
					)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(/** @type {Range***REMOVED*** */ (expr.range));
			***REMOVED***);
		for (const fn of ["substr", "substring", "slice"]) {
			this.hooks.evaluateCallExpressionMember
				.for(fn)
				.tap(CLASS_NAME, (expr, param) => {
					if (!param.isString()) return;
					let arg1;
					let result;
					const str = /** @type {string***REMOVED*** */ (param.string);
					switch (expr.arguments.length) {
						case 1:
							if (expr.arguments[0].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							if (!arg1.isNumber()) return;
							result = str[
								/** @type {"substr" | "substring" | "slice"***REMOVED*** */ (fn)
							](/** @type {number***REMOVED*** */ (arg1.number));
							break;
						case 2: {
							if (expr.arguments[0].type === "SpreadElement") return;
							if (expr.arguments[1].type === "SpreadElement") return;
							arg1 = this.evaluateExpression(expr.arguments[0]);
							const arg2 = this.evaluateExpression(expr.arguments[1]);
							if (!arg1.isNumber()) return;
							if (!arg2.isNumber()) return;
							result = str[
								/** @type {"substr" | "substring" | "slice"***REMOVED*** */ (fn)
							](
								/** @type {number***REMOVED*** */ (arg1.number),
								/** @type {number***REMOVED*** */ (arg2.number)
							);
							break;
						***REMOVED***
						default:
							return;
					***REMOVED***
					return new BasicEvaluatedExpression()
						.setString(result)
						.setSideEffects(param.couldHaveSideEffects())
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				***REMOVED***);
		***REMOVED***

		/**
		 * @param {"cooked" | "raw"***REMOVED*** kind kind of values to get
		 * @param {TemplateLiteral***REMOVED*** templateLiteralExpr TemplateLiteral expr
		 * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]***REMOVED******REMOVED*** Simplified template
		 */
		const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {
			/** @type {BasicEvaluatedExpression[]***REMOVED*** */
			const quasis = [];
			/** @type {BasicEvaluatedExpression[]***REMOVED*** */
			const parts = [];

			for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {
				const quasiExpr = templateLiteralExpr.quasis[i];
				const quasi = quasiExpr.value[kind];

				if (i > 0) {
					const prevExpr = parts[parts.length - 1];
					const expr = this.evaluateExpression(
						templateLiteralExpr.expressions[i - 1]
					);
					const exprAsString = expr.asString();
					if (
						typeof exprAsString === "string" &&
						!expr.couldHaveSideEffects()
					) {
						// We can merge quasi + expr + quasi when expr
						// is a const string

						prevExpr.setString(prevExpr.string + exprAsString + quasi);
						prevExpr.setRange([
							/** @type {Range***REMOVED*** */ (prevExpr.range)[0],
							/** @type {Range***REMOVED*** */ (quasiExpr.range)[1]
						]);
						// We unset the expression as it doesn't match to a single expression
						prevExpr.setExpression(undefined);
						continue;
					***REMOVED***
					parts.push(expr);
				***REMOVED***

				const part = new BasicEvaluatedExpression()
					.setString(/** @type {string***REMOVED*** */ (quasi))
					.setRange(/** @type {Range***REMOVED*** */ (quasiExpr.range))
					.setExpression(quasiExpr);
				quasis.push(part);
				parts.push(part);
			***REMOVED***
			return {
				quasis,
				parts
			***REMOVED***;
		***REMOVED***;

		this.hooks.evaluate.for("TemplateLiteral").tap(CLASS_NAME, _node => {
			const node = /** @type {TemplateLiteral***REMOVED*** */ (_node);

			const { quasis, parts ***REMOVED*** = getSimplifiedTemplateResult("cooked", node);
			if (parts.length === 1) {
				return parts[0].setRange(/** @type {Range***REMOVED*** */ (node.range));
			***REMOVED***
			return new BasicEvaluatedExpression()
				.setTemplateString(quasis, parts, "cooked")
				.setRange(/** @type {Range***REMOVED*** */ (node.range));
		***REMOVED***);
		this.hooks.evaluate
			.for("TaggedTemplateExpression")
			.tap(CLASS_NAME, _node => {
				const node = /** @type {TaggedTemplateExpression***REMOVED*** */ (_node);
				const tag = this.evaluateExpression(node.tag);

				if (tag.isIdentifier() && tag.identifier === "String.raw") {
					const { quasis, parts ***REMOVED*** = getSimplifiedTemplateResult(
						"raw",
						node.quasi
					);
					return new BasicEvaluatedExpression()
						.setTemplateString(quasis, parts, "raw")
						.setRange(/** @type {Range***REMOVED*** */ (node.range));
				***REMOVED***
			***REMOVED***);

		this.hooks.evaluateCallExpressionMember
			.for("concat")
			.tap(CLASS_NAME, (expr, param) => {
				if (!param.isString() && !param.isWrapped()) return;
				let stringSuffix = null;
				let hasUnknownParams = false;
				const innerExpressions = [];
				for (let i = expr.arguments.length - 1; i >= 0; i--) {
					const arg = expr.arguments[i];
					if (arg.type === "SpreadElement") return;
					const argExpr = this.evaluateExpression(arg);
					if (
						hasUnknownParams ||
						(!argExpr.isString() && !argExpr.isNumber())
					) {
						hasUnknownParams = true;
						innerExpressions.push(argExpr);
						continue;
					***REMOVED***

					const value = argExpr.isString()
						? /** @type {string***REMOVED*** */ (argExpr.string)
						: String(argExpr.number);

					/** @type {string***REMOVED*** */
					const newString =
						value +
						(stringSuffix ? /** @type {string***REMOVED*** */ (stringSuffix.string) : "");
					const newRange = /** @type {Range***REMOVED*** */ ([
						/** @type {Range***REMOVED*** */ (argExpr.range)[0],
						/** @type {Range***REMOVED*** */ ((stringSuffix || argExpr).range)[1]
					]);
					stringSuffix = new BasicEvaluatedExpression()
						.setString(newString)
						.setSideEffects(
							(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
								argExpr.couldHaveSideEffects()
						)
						.setRange(newRange);
				***REMOVED***

				if (hasUnknownParams) {
					const prefix = param.isString() ? param : param.prefix;
					const inner =
						param.isWrapped() && param.wrappedInnerExpressions
							? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
							: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(prefix, stringSuffix, inner)
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				***REMOVED*** else if (param.isWrapped()) {
					const postfix = stringSuffix || param.postfix;
					const inner = param.wrappedInnerExpressions
						? param.wrappedInnerExpressions.concat(innerExpressions.reverse())
						: innerExpressions.reverse();
					return new BasicEvaluatedExpression()
						.setWrapped(param.prefix, postfix, inner)
						.setRange(/** @type {Range***REMOVED*** */ (expr.range));
				***REMOVED***
				const newString =
					/** @type {string***REMOVED*** */ (param.string) +
					(stringSuffix ? stringSuffix.string : "");
				return new BasicEvaluatedExpression()
					.setString(newString)
					.setSideEffects(
						(stringSuffix && stringSuffix.couldHaveSideEffects()) ||
							param.couldHaveSideEffects()
					)
					.setRange(/** @type {Range***REMOVED*** */ (expr.range));
			***REMOVED***);
		this.hooks.evaluateCallExpressionMember
			.for("split")
			.tap(CLASS_NAME, (expr, param) => {
				if (!param.isString()) return;
				if (expr.arguments.length !== 1) return;
				if (expr.arguments[0].type === "SpreadElement") return;
				let result;
				const arg = this.evaluateExpression(expr.arguments[0]);
				if (arg.isString()) {
					result =
						/** @type {string***REMOVED*** */
						(param.string).split(/** @type {string***REMOVED*** */ (arg.string));
				***REMOVED*** else if (arg.isRegExp()) {
					result = /** @type {string***REMOVED*** */ (param.string).split(
						/** @type {RegExp***REMOVED*** */ (arg.regExp)
					);
				***REMOVED*** else {
					return;
				***REMOVED***
				return new BasicEvaluatedExpression()
					.setArray(result)
					.setSideEffects(param.couldHaveSideEffects())
					.setRange(/** @type {Range***REMOVED*** */ (expr.range));
			***REMOVED***);
		this.hooks.evaluate.for("ConditionalExpression").tap(CLASS_NAME, _expr => {
			const expr = /** @type {ConditionalExpression***REMOVED*** */ (_expr);

			const condition = this.evaluateExpression(expr.test);
			const conditionValue = condition.asBool();
			let res;
			if (conditionValue === undefined) {
				const consequent = this.evaluateExpression(expr.consequent);
				const alternate = this.evaluateExpression(expr.alternate);
				res = new BasicEvaluatedExpression();
				if (consequent.isConditional()) {
					res.setOptions(
						/** @type {BasicEvaluatedExpression[]***REMOVED*** */ (consequent.options)
					);
				***REMOVED*** else {
					res.setOptions([consequent]);
				***REMOVED***
				if (alternate.isConditional()) {
					res.addOptions(
						/** @type {BasicEvaluatedExpression[]***REMOVED*** */ (alternate.options)
					);
				***REMOVED*** else {
					res.addOptions([alternate]);
				***REMOVED***
			***REMOVED*** else {
				res = this.evaluateExpression(
					conditionValue ? expr.consequent : expr.alternate
				);
				if (condition.couldHaveSideEffects()) res.setSideEffects();
			***REMOVED***
			res.setRange(/** @type {Range***REMOVED*** */ (expr.range));
			return res;
		***REMOVED***);
		this.hooks.evaluate.for("ArrayExpression").tap(CLASS_NAME, _expr => {
			const expr = /** @type {ArrayExpression***REMOVED*** */ (_expr);

			const items = expr.elements.map(
				element =>
					element !== null &&
					element.type !== "SpreadElement" &&
					this.evaluateExpression(element)
			);
			if (!items.every(Boolean)) return;
			return new BasicEvaluatedExpression()
				.setItems(/** @type {BasicEvaluatedExpression[]***REMOVED*** */ (items))
				.setRange(/** @type {Range***REMOVED*** */ (expr.range));
		***REMOVED***);
		this.hooks.evaluate.for("ChainExpression").tap(CLASS_NAME, _expr => {
			const expr = /** @type {ChainExpression***REMOVED*** */ (_expr);
			/** @type {Expression[]***REMOVED*** */
			const optionalExpressionsStack = [];
			/** @type {Expression|Super***REMOVED*** */
			let next = expr.expression;

			while (
				next.type === "MemberExpression" ||
				next.type === "CallExpression"
			) {
				if (next.type === "MemberExpression") {
					if (next.optional) {
						// SuperNode can not be optional
						optionalExpressionsStack.push(
							/** @type {Expression***REMOVED*** */ (next.object)
						);
					***REMOVED***
					next = next.object;
				***REMOVED*** else {
					if (next.optional) {
						// SuperNode can not be optional
						optionalExpressionsStack.push(
							/** @type {Expression***REMOVED*** */ (next.callee)
						);
					***REMOVED***
					next = next.callee;
				***REMOVED***
			***REMOVED***

			while (optionalExpressionsStack.length > 0) {
				const expression =
					/** @type {Expression***REMOVED*** */
					(optionalExpressionsStack.pop());
				const evaluated = this.evaluateExpression(expression);

				if (evaluated.asNullish()) {
					return evaluated.setRange(/** @type {Range***REMOVED*** */ (_expr.range));
				***REMOVED***
			***REMOVED***
			return this.evaluateExpression(expr.expression);
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {Expression***REMOVED*** node node
	 * @returns {Set<DestructuringAssignmentProperty> | undefined***REMOVED*** destructured identifiers
	 */
	destructuringAssignmentPropertiesFor(node) {
		if (!this.destructuringAssignmentProperties) return;
		return this.destructuringAssignmentProperties.get(node);
	***REMOVED***

	/**
	 * @param {Expression | SpreadElement***REMOVED*** expr expression
	 * @returns {string | VariableInfo | undefined***REMOVED*** identifier
	 */
	getRenameIdentifier(expr) {
		const result = this.evaluateExpression(expr);
		if (result.isIdentifier()) {
			return result.identifier;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ClassExpression | ClassDeclaration | MaybeNamedClassDeclaration***REMOVED*** classy a class node
	 * @returns {void***REMOVED***
	 */
	walkClass(classy) {
		if (
			classy.superClass &&
			!this.hooks.classExtendsExpression.call(classy.superClass, classy)
		) {
			this.walkExpression(classy.superClass);
		***REMOVED***
		if (classy.body && classy.body.type === "ClassBody") {
			const scopeParams = [];
			// Add class name in scope for recursive calls
			if (classy.id) {
				scopeParams.push(classy.id);
			***REMOVED***
			this.inClassScope(true, scopeParams, () => {
				for (const classElement of /** @type {TODO***REMOVED*** */ (classy.body.body)) {
					if (!this.hooks.classBodyElement.call(classElement, classy)) {
						if (classElement.computed && classElement.key) {
							this.walkExpression(classElement.key);
						***REMOVED***
						if (classElement.value) {
							if (
								!this.hooks.classBodyValue.call(
									classElement.value,
									classElement,
									classy
								)
							) {
								const wasTopLevel = this.scope.topLevelScope;
								this.scope.topLevelScope = false;
								this.walkExpression(classElement.value);
								this.scope.topLevelScope = wasTopLevel;
							***REMOVED***
						***REMOVED*** else if (classElement.type === "StaticBlock") {
							const wasTopLevel = this.scope.topLevelScope;
							this.scope.topLevelScope = false;
							this.walkBlockStatement(classElement);
							this.scope.topLevelScope = wasTopLevel;
						***REMOVED***
					***REMOVED***
				***REMOVED***
			***REMOVED***);
		***REMOVED***
	***REMOVED***

	/**
	 * Pre walking iterates the scope for variable declarations
	 * @param {(Statement | ModuleDeclaration)[]***REMOVED*** statements statements
	 */
	preWalkStatements(statements) {
		for (let index = 0, len = statements.length; index < len; index++) {
			const statement = statements[index];
			this.preWalkStatement(statement);
		***REMOVED***
	***REMOVED***

	/**
	 * Block pre walking iterates the scope for block variable declarations
	 * @param {(Statement | ModuleDeclaration)[]***REMOVED*** statements statements
	 */
	blockPreWalkStatements(statements) {
		for (let index = 0, len = statements.length; index < len; index++) {
			const statement = statements[index];
			this.blockPreWalkStatement(statement);
		***REMOVED***
	***REMOVED***

	/**
	 * Walking iterates the statements and expressions and processes them
	 * @param {(Statement | ModuleDeclaration)[]***REMOVED*** statements statements
	 */
	walkStatements(statements) {
		let onlyFunctionDeclaration = false;

		for (let index = 0, len = statements.length; index < len; index++) {
			const statement = statements[index];

			if (onlyFunctionDeclaration && statement.type !== "FunctionDeclaration")
				continue;

			this.walkStatement(statement);

			if (this.scope.terminated) {
				onlyFunctionDeclaration = true;
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * Walking iterates the statements and expressions and processes them
	 * @param {Statement | ModuleDeclaration | MaybeNamedClassDeclaration | MaybeNamedFunctionDeclaration***REMOVED*** statement statement
	 */
	preWalkStatement(statement) {
		/** @type {StatementPath***REMOVED*** */
		(this.statementPath).push(statement);
		if (this.hooks.preStatement.call(statement)) {
			this.prevStatement =
				/** @type {StatementPath***REMOVED*** */
				(this.statementPath).pop();
			return;
		***REMOVED***
		switch (statement.type) {
			case "BlockStatement":
				this.preWalkBlockStatement(statement);
				break;
			case "DoWhileStatement":
				this.preWalkDoWhileStatement(statement);
				break;
			case "ForInStatement":
				this.preWalkForInStatement(statement);
				break;
			case "ForOfStatement":
				this.preWalkForOfStatement(statement);
				break;
			case "ForStatement":
				this.preWalkForStatement(statement);
				break;
			case "FunctionDeclaration":
				this.preWalkFunctionDeclaration(statement);
				break;
			case "IfStatement":
				this.preWalkIfStatement(statement);
				break;
			case "LabeledStatement":
				this.preWalkLabeledStatement(statement);
				break;
			case "SwitchStatement":
				this.preWalkSwitchStatement(statement);
				break;
			case "TryStatement":
				this.preWalkTryStatement(statement);
				break;
			case "VariableDeclaration":
				this.preWalkVariableDeclaration(statement);
				break;
			case "WhileStatement":
				this.preWalkWhileStatement(statement);
				break;
			case "WithStatement":
				this.preWalkWithStatement(statement);
				break;
		***REMOVED***
		this.prevStatement =
			/** @type {StatementPath***REMOVED*** */
			(this.statementPath).pop();
	***REMOVED***

	/**
	 * @param {Statement | ModuleDeclaration | MaybeNamedClassDeclaration | MaybeNamedFunctionDeclaration***REMOVED*** statement statement
	 */
	blockPreWalkStatement(statement) {
		/** @type {StatementPath***REMOVED*** */
		(this.statementPath).push(statement);
		if (this.hooks.blockPreStatement.call(statement)) {
			this.prevStatement =
				/** @type {StatementPath***REMOVED*** */
				(this.statementPath).pop();
			return;
		***REMOVED***
		switch (statement.type) {
			case "ImportDeclaration":
				this.blockPreWalkImportDeclaration(statement);
				break;
			case "ExportAllDeclaration":
				this.blockPreWalkExportAllDeclaration(statement);
				break;
			case "ExportDefaultDeclaration":
				this.blockPreWalkExportDefaultDeclaration(statement);
				break;
			case "ExportNamedDeclaration":
				this.blockPreWalkExportNamedDeclaration(statement);
				break;
			case "VariableDeclaration":
				this.blockPreWalkVariableDeclaration(statement);
				break;
			case "ClassDeclaration":
				this.blockPreWalkClassDeclaration(statement);
				break;
			case "ExpressionStatement":
				this.blockPreWalkExpressionStatement(statement);
		***REMOVED***
		this.prevStatement =
			/** @type {StatementPath***REMOVED*** */
			(this.statementPath).pop();
	***REMOVED***

	/**
	 * @param {Statement | ModuleDeclaration | MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration***REMOVED*** statement statement
	 */
	walkStatement(statement) {
		/** @type {StatementPath***REMOVED*** */
		(this.statementPath).push(statement);
		if (this.hooks.statement.call(statement) !== undefined) {
			this.prevStatement =
				/** @type {StatementPath***REMOVED*** */
				(this.statementPath).pop();
			return;
		***REMOVED***
		switch (statement.type) {
			case "BlockStatement":
				this.walkBlockStatement(statement);
				break;
			case "ClassDeclaration":
				this.walkClassDeclaration(statement);
				break;
			case "DoWhileStatement":
				this.walkDoWhileStatement(statement);
				break;
			case "ExportDefaultDeclaration":
				this.walkExportDefaultDeclaration(statement);
				break;
			case "ExportNamedDeclaration":
				this.walkExportNamedDeclaration(statement);
				break;
			case "ExpressionStatement":
				this.walkExpressionStatement(statement);
				break;
			case "ForInStatement":
				this.walkForInStatement(statement);
				break;
			case "ForOfStatement":
				this.walkForOfStatement(statement);
				break;
			case "ForStatement":
				this.walkForStatement(statement);
				break;
			case "FunctionDeclaration":
				this.walkFunctionDeclaration(statement);
				break;
			case "IfStatement":
				this.walkIfStatement(statement);
				break;
			case "LabeledStatement":
				this.walkLabeledStatement(statement);
				break;
			case "ReturnStatement":
				this.walkReturnStatement(statement);
				break;
			case "SwitchStatement":
				this.walkSwitchStatement(statement);
				break;
			case "ThrowStatement":
				this.walkThrowStatement(statement);
				break;
			case "TryStatement":
				this.walkTryStatement(statement);
				break;
			case "VariableDeclaration":
				this.walkVariableDeclaration(statement);
				break;
			case "WhileStatement":
				this.walkWhileStatement(statement);
				break;
			case "WithStatement":
				this.walkWithStatement(statement);
				break;
		***REMOVED***
		this.prevStatement =
			/** @type {StatementPath***REMOVED*** */
			(this.statementPath).pop();
	***REMOVED***

	/**
	 * Walks a statements that is nested within a parent statement
	 * and can potentially be a non-block statement.
	 * This enforces the nested statement to never be in ASI position.
	 * @param {Statement***REMOVED*** statement the nested statement
	 */
	walkNestedStatement(statement) {
		this.prevStatement = undefined;
		this.walkStatement(statement);
	***REMOVED***

	// Real Statements
	/**
	 * @param {BlockStatement***REMOVED*** statement block statement
	 */
	preWalkBlockStatement(statement) {
		this.preWalkStatements(statement.body);
	***REMOVED***

	/**
	 * @param {BlockStatement***REMOVED*** statement block statement
	 */
	walkBlockStatement(statement) {
		this.inBlockScope(() => {
			const body = statement.body;
			const prev = this.prevStatement;
			this.blockPreWalkStatements(body);
			this.prevStatement = prev;
			this.walkStatements(body);
		***REMOVED***, true);
	***REMOVED***

	/**
	 * @param {ExpressionStatement***REMOVED*** statement expression statement
	 */
	walkExpressionStatement(statement) {
		this.walkExpression(statement.expression);
	***REMOVED***

	/**
	 * @param {IfStatement***REMOVED*** statement if statement
	 */
	preWalkIfStatement(statement) {
		this.preWalkStatement(statement.consequent);
		if (statement.alternate) {
			this.preWalkStatement(statement.alternate);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {IfStatement***REMOVED*** statement if statement
	 */
	walkIfStatement(statement) {
		const result = this.hooks.statementIf.call(statement);
		if (result === undefined) {
			this.walkExpression(statement.test);
			this.walkNestedStatement(statement.consequent);

			const consequentTerminated = this.scope.terminated;
			this.scope.terminated = undefined;

			if (statement.alternate) {
				this.walkNestedStatement(statement.alternate);
			***REMOVED***

			const alternateTerminated = this.scope.terminated;

			this.scope.terminated =
				consequentTerminated && alternateTerminated
					? alternateTerminated
					: undefined;
		***REMOVED*** else if (result) {
			this.walkNestedStatement(statement.consequent);
		***REMOVED*** else if (statement.alternate) {
			this.walkNestedStatement(statement.alternate);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {LabeledStatement***REMOVED*** statement with statement
	 */
	preWalkLabeledStatement(statement) {
		this.preWalkStatement(statement.body);
	***REMOVED***

	/**
	 * @param {LabeledStatement***REMOVED*** statement with statement
	 */
	walkLabeledStatement(statement) {
		const hook = this.hooks.label.get(statement.label.name);
		if (hook !== undefined) {
			const result = hook.call(statement);
			if (result === true) return;
		***REMOVED***
		this.inBlockScope(() => {
			this.walkNestedStatement(statement.body);
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {WithStatement***REMOVED*** statement with statement
	 */
	preWalkWithStatement(statement) {
		this.preWalkStatement(statement.body);
	***REMOVED***

	/**
	 * @param {WithStatement***REMOVED*** statement with statement
	 */
	walkWithStatement(statement) {
		this.inBlockScope(() => {
			this.walkExpression(statement.object);
			this.walkNestedStatement(statement.body);
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {SwitchStatement***REMOVED*** statement switch statement
	 */
	preWalkSwitchStatement(statement) {
		this.preWalkSwitchCases(statement.cases);
	***REMOVED***

	/**
	 * @param {SwitchStatement***REMOVED*** statement switch statement
	 */
	walkSwitchStatement(statement) {
		this.walkExpression(statement.discriminant);
		this.walkSwitchCases(statement.cases);
	***REMOVED***

	/**
	 * @param {ReturnStatement | ThrowStatement***REMOVED*** statement return or throw statement
	 */
	walkTerminatingStatement(statement) {
		if (statement.argument) this.walkExpression(statement.argument);
		// Skip top level scope because to handle `export` and `module.exports` after terminate
		if (this.scope.topLevelScope === true) return;
		if (this.hooks.terminate.call(statement)) {
			this.scope.terminated =
				statement.type === "ReturnStatement"
					? SCOPE_INFO_TERMINATED_RETURN
					: SCOPE_INFO_TERMINATED_THROW;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ReturnStatement***REMOVED*** statement return statement
	 */
	walkReturnStatement(statement) {
		this.walkTerminatingStatement(statement);
	***REMOVED***

	/**
	 * @param {ThrowStatement***REMOVED*** statement return statement
	 */
	walkThrowStatement(statement) {
		this.walkTerminatingStatement(statement);
	***REMOVED***

	/**
	 * @param {TryStatement***REMOVED*** statement try statement
	 */
	preWalkTryStatement(statement) {
		this.preWalkStatement(statement.block);
		if (statement.handler) this.preWalkCatchClause(statement.handler);
		if (statement.finalizer) this.preWalkStatement(statement.finalizer);
	***REMOVED***

	/**
	 * @param {TryStatement***REMOVED*** statement try statement
	 */
	walkTryStatement(statement) {
		if (this.scope.inTry) {
			this.walkStatement(statement.block);
		***REMOVED*** else {
			this.scope.inTry = true;
			this.walkStatement(statement.block);
			this.scope.inTry = false;
		***REMOVED***

		const tryTerminated = this.scope.terminated;
		this.scope.terminated = undefined;

		if (statement.handler) this.walkCatchClause(statement.handler);

		const handlerTerminated = this.scope.terminated;
		this.scope.terminated = undefined;

		if (statement.finalizer) {
			this.walkStatement(statement.finalizer);
		***REMOVED***

		const finalizerTerminated = this.scope.terminated;
		this.scope.terminated = undefined;

		if (finalizerTerminated) {
			this.scope.terminated = finalizerTerminated;
		***REMOVED*** else if (
			tryTerminated &&
			(statement.handler ? handlerTerminated : true)
		) {
			this.scope.terminated = handlerTerminated || tryTerminated;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {WhileStatement***REMOVED*** statement while statement
	 */
	preWalkWhileStatement(statement) {
		this.preWalkStatement(statement.body);
	***REMOVED***

	/**
	 * @param {WhileStatement***REMOVED*** statement while statement
	 */
	walkWhileStatement(statement) {
		this.inBlockScope(() => {
			this.walkExpression(statement.test);
			this.walkNestedStatement(statement.body);
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {DoWhileStatement***REMOVED*** statement do while statement
	 */
	preWalkDoWhileStatement(statement) {
		this.preWalkStatement(statement.body);
	***REMOVED***

	/**
	 * @param {DoWhileStatement***REMOVED*** statement do while statement
	 */
	walkDoWhileStatement(statement) {
		this.inBlockScope(() => {
			this.walkNestedStatement(statement.body);
			this.walkExpression(statement.test);
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {ForStatement***REMOVED*** statement for statement
	 */
	preWalkForStatement(statement) {
		if (statement.init && statement.init.type === "VariableDeclaration") {
			this.preWalkStatement(statement.init);
		***REMOVED***
		this.preWalkStatement(statement.body);
	***REMOVED***

	/**
	 * @param {ForStatement***REMOVED*** statement for statement
	 */
	walkForStatement(statement) {
		this.inBlockScope(() => {
			if (statement.init) {
				if (statement.init.type === "VariableDeclaration") {
					this.blockPreWalkVariableDeclaration(statement.init);
					this.prevStatement = undefined;
					this.walkStatement(statement.init);
				***REMOVED*** else {
					this.walkExpression(statement.init);
				***REMOVED***
			***REMOVED***
			if (statement.test) {
				this.walkExpression(statement.test);
			***REMOVED***
			if (statement.update) {
				this.walkExpression(statement.update);
			***REMOVED***

			const body = statement.body;

			if (body.type === "BlockStatement") {
				// no need to add additional scope
				const prev = this.prevStatement;
				this.blockPreWalkStatements(body.body);
				this.prevStatement = prev;
				this.walkStatements(body.body);
			***REMOVED*** else {
				this.walkNestedStatement(body);
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {ForInStatement***REMOVED*** statement for statement
	 */
	preWalkForInStatement(statement) {
		if (statement.left.type === "VariableDeclaration") {
			this.preWalkVariableDeclaration(statement.left);
		***REMOVED***
		this.preWalkStatement(statement.body);
	***REMOVED***

	/**
	 * @param {ForInStatement***REMOVED*** statement for statement
	 */
	walkForInStatement(statement) {
		this.inBlockScope(() => {
			if (statement.left.type === "VariableDeclaration") {
				this.blockPreWalkVariableDeclaration(statement.left);
				this.walkVariableDeclaration(statement.left);
			***REMOVED*** else {
				this.walkPattern(statement.left);
			***REMOVED***

			this.walkExpression(statement.right);

			const body = statement.body;

			if (body.type === "BlockStatement") {
				// no need to add additional scope
				const prev = this.prevStatement;
				this.blockPreWalkStatements(body.body);
				this.prevStatement = prev;
				this.walkStatements(body.body);
			***REMOVED*** else {
				this.walkNestedStatement(body);
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {ForOfStatement***REMOVED*** statement statement
	 */
	preWalkForOfStatement(statement) {
		if (statement.await && this.scope.topLevelScope === true) {
			this.hooks.topLevelAwait.call(statement);
		***REMOVED***
		if (statement.left.type === "VariableDeclaration") {
			this.preWalkVariableDeclaration(statement.left);
		***REMOVED***
		this.preWalkStatement(statement.body);
	***REMOVED***

	/**
	 * @param {ForOfStatement***REMOVED*** statement for statement
	 */
	walkForOfStatement(statement) {
		this.inBlockScope(() => {
			if (statement.left.type === "VariableDeclaration") {
				this.blockPreWalkVariableDeclaration(statement.left);
				this.walkVariableDeclaration(statement.left);
			***REMOVED*** else {
				this.walkPattern(statement.left);
			***REMOVED***

			this.walkExpression(statement.right);

			const body = statement.body;

			if (body.type === "BlockStatement") {
				// no need to add additional scope
				const prev = this.prevStatement;
				this.blockPreWalkStatements(body.body);
				this.prevStatement = prev;
				this.walkStatements(body.body);
			***REMOVED*** else {
				this.walkNestedStatement(body);
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {FunctionDeclaration | MaybeNamedFunctionDeclaration***REMOVED*** statement function declaration
	 */
	preWalkFunctionDeclaration(statement) {
		if (statement.id) {
			this.defineVariable(statement.id.name);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {FunctionDeclaration | MaybeNamedFunctionDeclaration***REMOVED*** statement function declaration
	 */
	walkFunctionDeclaration(statement) {
		const wasTopLevel = this.scope.topLevelScope;
		this.scope.topLevelScope = false;
		this.inFunctionScope(true, statement.params, () => {
			for (const param of statement.params) {
				this.walkPattern(param);
			***REMOVED***

			this.detectMode(statement.body.body);

			const prev = this.prevStatement;

			this.preWalkStatement(statement.body);
			this.prevStatement = prev;
			this.walkStatement(statement.body);
		***REMOVED***);
		this.scope.topLevelScope = wasTopLevel;
	***REMOVED***

	/**
	 * @param {ExpressionStatement***REMOVED*** statement expression statement
	 */
	blockPreWalkExpressionStatement(statement) {
		const expression = statement.expression;
		switch (expression.type) {
			case "AssignmentExpression":
				this.preWalkAssignmentExpression(expression);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {AssignmentExpression***REMOVED*** expression assignment expression
	 */
	preWalkAssignmentExpression(expression) {
		if (
			expression.left.type !== "ObjectPattern" ||
			!this.destructuringAssignmentProperties
		)
			return;
		const keys = this._preWalkObjectPattern(expression.left);
		if (!keys) return;

		// check multiple assignments
		if (this.destructuringAssignmentProperties.has(expression)) {
			const set =
				/** @type {Set<DestructuringAssignmentProperty>***REMOVED*** */
				(this.destructuringAssignmentProperties.get(expression));
			this.destructuringAssignmentProperties.delete(expression);
			for (const id of set) keys.add(id);
		***REMOVED***

		this.destructuringAssignmentProperties.set(
			expression.right.type === "AwaitExpression"
				? expression.right.argument
				: expression.right,
			keys
		);

		if (expression.right.type === "AssignmentExpression") {
			this.preWalkAssignmentExpression(expression.right);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ImportDeclaration***REMOVED*** statement statement
	 */
	blockPreWalkImportDeclaration(statement) {
		const source = /** @type {ImportSource***REMOVED*** */ (statement.source.value);
		this.hooks.import.call(statement, source);
		for (const specifier of statement.specifiers) {
			const name = specifier.local.name;
			switch (specifier.type) {
				case "ImportDefaultSpecifier":
					if (
						!this.hooks.importSpecifier.call(statement, source, "default", name)
					) {
						this.defineVariable(name);
					***REMOVED***
					break;
				case "ImportSpecifier":
					if (
						!this.hooks.importSpecifier.call(
							statement,
							source,
							/** @type {Identifier***REMOVED*** */
							(specifier.imported).name ||
								/** @type {string***REMOVED*** */
								(
									/** @type {Literal***REMOVED*** */
									(specifier.imported).value
								),
							name
						)
					) {
						this.defineVariable(name);
					***REMOVED***
					break;
				case "ImportNamespaceSpecifier":
					if (!this.hooks.importSpecifier.call(statement, source, null, name)) {
						this.defineVariable(name);
					***REMOVED***
					break;
				default:
					this.defineVariable(name);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Declaration***REMOVED*** declaration declaration
	 * @param {OnIdent***REMOVED*** onIdent on ident callback
	 */
	enterDeclaration(declaration, onIdent) {
		switch (declaration.type) {
			case "VariableDeclaration":
				for (const declarator of declaration.declarations) {
					switch (declarator.type) {
						case "VariableDeclarator": {
							this.enterPattern(declarator.id, onIdent);
							break;
						***REMOVED***
					***REMOVED***
				***REMOVED***
				break;
			case "FunctionDeclaration":
				this.enterPattern(declaration.id, onIdent);
				break;
			case "ClassDeclaration":
				this.enterPattern(declaration.id, onIdent);
				break;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ExportNamedDeclaration***REMOVED*** statement statement
	 */
	blockPreWalkExportNamedDeclaration(statement) {
		let source;
		if (statement.source) {
			source = /** @type {ImportSource***REMOVED*** */ (statement.source.value);
			this.hooks.exportImport.call(statement, source);
		***REMOVED*** else {
			this.hooks.export.call(statement);
		***REMOVED***
		if (
			statement.declaration &&
			!this.hooks.exportDeclaration.call(statement, statement.declaration)
		) {
			const prev = this.prevStatement;
			this.preWalkStatement(statement.declaration);
			this.prevStatement = prev;
			this.blockPreWalkStatement(statement.declaration);
			let index = 0;
			this.enterDeclaration(statement.declaration, def => {
				this.hooks.exportSpecifier.call(statement, def, def, index++);
			***REMOVED***);
		***REMOVED***
		if (statement.specifiers) {
			for (
				let specifierIndex = 0;
				specifierIndex < statement.specifiers.length;
				specifierIndex++
			) {
				const specifier = statement.specifiers[specifierIndex];
				switch (specifier.type) {
					case "ExportSpecifier": {
						const localName =
							/** @type {Identifier***REMOVED*** */ (specifier.local).name ||
							/** @type {string***REMOVED*** */ (
								/** @type {Literal***REMOVED*** */ (specifier.local).value
							);
						const name =
							/** @type {Identifier***REMOVED*** */
							(specifier.exported).name ||
							/** @type {string***REMOVED*** */
							(/** @type {Literal***REMOVED*** */ (specifier.exported).value);
						if (source) {
							this.hooks.exportImportSpecifier.call(
								statement,
								source,
								localName,
								name,
								specifierIndex
							);
						***REMOVED*** else {
							this.hooks.exportSpecifier.call(
								statement,
								localName,
								name,
								specifierIndex
							);
						***REMOVED***
						break;
					***REMOVED***
				***REMOVED***
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ExportNamedDeclaration***REMOVED*** statement the statement
	 */
	walkExportNamedDeclaration(statement) {
		if (statement.declaration) {
			this.walkStatement(statement.declaration);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ExportDefaultDeclaration***REMOVED*** statement statement
	 */
	blockPreWalkExportDefaultDeclaration(statement) {
		const prev = this.prevStatement;

		this.preWalkStatement(/** @type {TODO***REMOVED*** */ (statement.declaration));
		this.prevStatement = prev;
		this.blockPreWalkStatement(/** @type {TODO***REMOVED*** */ (statement.declaration));

		if (
			/** @type {MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration***REMOVED*** */
			(statement.declaration).id &&
			statement.declaration.type !== "FunctionExpression" &&
			statement.declaration.type !== "ClassExpression"
		) {
			const declaration =
				/** @type {MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration***REMOVED*** */
				(statement.declaration);

			this.hooks.exportSpecifier.call(
				statement,
				/** @type {Identifier***REMOVED*** */
				(declaration.id).name,
				"default",
				undefined
			);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ExportDefaultDeclaration***REMOVED*** statement statement
	 */
	walkExportDefaultDeclaration(statement) {
		this.hooks.export.call(statement);
		if (
			/** @type {FunctionDeclaration | ClassDeclaration***REMOVED*** */
			(statement.declaration).id &&
			statement.declaration.type !== "FunctionExpression" &&
			statement.declaration.type !== "ClassExpression"
		) {
			const declaration =
				/** @type {FunctionDeclaration | ClassDeclaration***REMOVED*** */
				(statement.declaration);
			if (!this.hooks.exportDeclaration.call(statement, declaration)) {
				this.walkStatement(declaration);
			***REMOVED***
		***REMOVED*** else {
			// Acorn parses `export default function() {***REMOVED***` as `FunctionDeclaration` and
			// `export default class {***REMOVED***` as `ClassDeclaration`, both with `id = null`.
			// These nodes must be treated as expressions.
			if (
				statement.declaration.type === "FunctionDeclaration" ||
				statement.declaration.type === "ClassDeclaration"
			) {
				this.walkStatement(statement.declaration);
			***REMOVED*** else {
				this.walkExpression(statement.declaration);
			***REMOVED***

			if (!this.hooks.exportExpression.call(statement, statement.declaration)) {
				this.hooks.exportSpecifier.call(
					statement,
					/** @type {TODO***REMOVED*** */
					(statement.declaration),
					"default",
					undefined
				);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ExportAllDeclaration***REMOVED*** statement statement
	 */
	blockPreWalkExportAllDeclaration(statement) {
		const source = /** @type {ImportSource***REMOVED*** */ (statement.source.value);
		const name = statement.exported
			? /** @type {Identifier***REMOVED*** */
				(statement.exported).name ||
				/** @type {string***REMOVED*** */
				(/** @type {Literal***REMOVED*** */ (statement.exported).value)
			: null;
		this.hooks.exportImport.call(statement, source);
		this.hooks.exportImportSpecifier.call(statement, source, null, name, 0);
	***REMOVED***

	/**
	 * @param {VariableDeclaration***REMOVED*** statement variable declaration
	 */
	preWalkVariableDeclaration(statement) {
		if (statement.kind !== "var") return;
		this._preWalkVariableDeclaration(statement, this.hooks.varDeclarationVar);
	***REMOVED***

	/**
	 * @param {VariableDeclaration***REMOVED*** statement variable declaration
	 */
	blockPreWalkVariableDeclaration(statement) {
		if (statement.kind === "var") return;
		const hookMap =
			statement.kind === "const"
				? this.hooks.varDeclarationConst
				: this.hooks.varDeclarationLet;
		this._preWalkVariableDeclaration(statement, hookMap);
	***REMOVED***

	/**
	 * @param {VariableDeclaration***REMOVED*** statement variable declaration
	 * @param {TODO***REMOVED*** hookMap map of hooks
	 */
	_preWalkVariableDeclaration(statement, hookMap) {
		for (const declarator of statement.declarations) {
			switch (declarator.type) {
				case "VariableDeclarator": {
					this.preWalkVariableDeclarator(declarator);
					if (!this.hooks.preDeclarator.call(declarator, statement)) {
						this.enterPattern(declarator.id, (name, decl) => {
							let hook = hookMap.get(name);
							if (hook === undefined || !hook.call(decl)) {
								hook = this.hooks.varDeclaration.get(name);
								if (hook === undefined || !hook.call(decl)) {
									this.defineVariable(name);
								***REMOVED***
							***REMOVED***
						***REMOVED***);
					***REMOVED***
					break;
				***REMOVED***
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ObjectPattern***REMOVED*** objectPattern object pattern
	 * @returns {Set<DestructuringAssignmentProperty> | undefined***REMOVED*** set of names or undefined if not all keys are identifiers
	 */
	_preWalkObjectPattern(objectPattern) {
		/** @type {Set<DestructuringAssignmentProperty>***REMOVED*** */
		const props = new Set();
		const properties = objectPattern.properties;
		for (let i = 0; i < properties.length; i++) {
			const property = properties[i];
			if (property.type !== "Property") return;
			if (property.shorthand && property.value.type === "Identifier") {
				this.scope.inShorthand = property.value.name;
			***REMOVED***
			const key = property.key;
			if (key.type === "Identifier") {
				props.add({
					id: key.name,
					range: key.range,
					shorthand: this.scope.inShorthand
				***REMOVED***);
			***REMOVED*** else {
				const id = this.evaluateExpression(key);
				const str = id.asString();
				if (str) {
					props.add({
						id: str,
						range: key.range,
						shorthand: this.scope.inShorthand
					***REMOVED***);
				***REMOVED*** else {
					// could not evaluate key
					return;
				***REMOVED***
			***REMOVED***
			this.scope.inShorthand = false;
		***REMOVED***

		return props;
	***REMOVED***

	/**
	 * @param {VariableDeclarator***REMOVED*** declarator variable declarator
	 */
	preWalkVariableDeclarator(declarator) {
		if (
			!declarator.init ||
			declarator.id.type !== "ObjectPattern" ||
			!this.destructuringAssignmentProperties
		)
			return;
		const keys = this._preWalkObjectPattern(declarator.id);

		if (!keys) return;
		this.destructuringAssignmentProperties.set(
			declarator.init.type === "AwaitExpression"
				? declarator.init.argument
				: declarator.init,
			keys
		);

		if (declarator.init.type === "AssignmentExpression") {
			this.preWalkAssignmentExpression(declarator.init);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {VariableDeclaration***REMOVED*** statement variable declaration
	 */
	walkVariableDeclaration(statement) {
		for (const declarator of statement.declarations) {
			switch (declarator.type) {
				case "VariableDeclarator": {
					const renameIdentifier =
						declarator.init && this.getRenameIdentifier(declarator.init);
					if (renameIdentifier && declarator.id.type === "Identifier") {
						const hook = this.hooks.canRename.get(renameIdentifier);
						if (
							hook !== undefined &&
							hook.call(/** @type {Expression***REMOVED*** */ (declarator.init))
						) {
							// renaming with "var a = b;"
							const hook = this.hooks.rename.get(renameIdentifier);
							if (
								hook === undefined ||
								!hook.call(/** @type {Expression***REMOVED*** */ (declarator.init))
							) {
								this.setVariable(declarator.id.name, renameIdentifier);
							***REMOVED***
							break;
						***REMOVED***
					***REMOVED***
					if (!this.hooks.declarator.call(declarator, statement)) {
						this.walkPattern(declarator.id);
						if (declarator.init) this.walkExpression(declarator.init);
					***REMOVED***
					break;
				***REMOVED***
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ClassDeclaration | MaybeNamedClassDeclaration***REMOVED*** statement class declaration
	 */
	blockPreWalkClassDeclaration(statement) {
		if (statement.id) {
			this.defineVariable(statement.id.name);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ClassDeclaration | MaybeNamedClassDeclaration***REMOVED*** statement class declaration
	 */
	walkClassDeclaration(statement) {
		this.walkClass(statement);
	***REMOVED***

	/**
	 * @param {SwitchCase[]***REMOVED*** switchCases switch statement
	 */
	preWalkSwitchCases(switchCases) {
		for (let index = 0, len = switchCases.length; index < len; index++) {
			const switchCase = switchCases[index];
			this.preWalkStatements(switchCase.consequent);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {SwitchCase[]***REMOVED*** switchCases switch statement
	 */
	walkSwitchCases(switchCases) {
		this.inBlockScope(() => {
			const len = switchCases.length;

			// we need to pre walk all statements first since we can have invalid code
			// import A from "module";
			// switch(1) {
			//    case 1:
			//      console.log(A); // should fail at runtime
			//    case 2:
			//      const A = 1;
			// ***REMOVED***
			for (let index = 0; index < len; index++) {
				const switchCase = switchCases[index];

				if (switchCase.consequent.length > 0) {
					const prev = this.prevStatement;
					this.blockPreWalkStatements(switchCase.consequent);
					this.prevStatement = prev;
				***REMOVED***
			***REMOVED***

			for (let index = 0; index < len; index++) {
				const switchCase = switchCases[index];

				if (switchCase.test) {
					this.walkExpression(switchCase.test);
				***REMOVED***

				if (switchCase.consequent.length > 0) {
					this.walkStatements(switchCase.consequent);
					this.scope.terminated = undefined;
				***REMOVED***
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {CatchClause***REMOVED*** catchClause catch clause
	 */
	preWalkCatchClause(catchClause) {
		this.preWalkStatement(catchClause.body);
	***REMOVED***

	/**
	 * @param {CatchClause***REMOVED*** catchClause catch clause
	 */
	walkCatchClause(catchClause) {
		this.inBlockScope(() => {
			// Error binding is optional in catch clause since ECMAScript 2019
			if (catchClause.param !== null) {
				this.enterPattern(catchClause.param, ident => {
					this.defineVariable(ident);
				***REMOVED***);
				this.walkPattern(catchClause.param);
			***REMOVED***
			const prev = this.prevStatement;
			this.blockPreWalkStatement(catchClause.body);
			this.prevStatement = prev;
			this.walkStatement(catchClause.body);
		***REMOVED***, true);
	***REMOVED***

	/**
	 * @param {Pattern***REMOVED*** pattern pattern
	 */
	walkPattern(pattern) {
		switch (pattern.type) {
			case "ArrayPattern":
				this.walkArrayPattern(pattern);
				break;
			case "AssignmentPattern":
				this.walkAssignmentPattern(pattern);
				break;
			case "MemberExpression":
				this.walkMemberExpression(pattern);
				break;
			case "ObjectPattern":
				this.walkObjectPattern(pattern);
				break;
			case "RestElement":
				this.walkRestElement(pattern);
				break;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {AssignmentPattern***REMOVED*** pattern assignment pattern
	 */
	walkAssignmentPattern(pattern) {
		this.walkExpression(pattern.right);
		this.walkPattern(pattern.left);
	***REMOVED***

	/**
	 * @param {ObjectPattern***REMOVED*** pattern pattern
	 */
	walkObjectPattern(pattern) {
		for (let i = 0, len = pattern.properties.length; i < len; i++) {
			const prop = pattern.properties[i];
			if (prop) {
				if (prop.type === "RestElement") {
					continue;
				***REMOVED***
				if (prop.computed) this.walkExpression(prop.key);
				if (prop.value) this.walkPattern(prop.value);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ArrayPattern***REMOVED*** pattern array pattern
	 */
	walkArrayPattern(pattern) {
		for (let i = 0, len = pattern.elements.length; i < len; i++) {
			const element = pattern.elements[i];
			if (element) this.walkPattern(element);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {RestElement***REMOVED*** pattern rest element
	 */
	walkRestElement(pattern) {
		this.walkPattern(pattern.argument);
	***REMOVED***

	/**
	 * @param {(Expression | SpreadElement | null)[]***REMOVED*** expressions expressions
	 */
	walkExpressions(expressions) {
		for (const expression of expressions) {
			if (expression) {
				this.walkExpression(expression);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Expression | SpreadElement | PrivateIdentifier | Super***REMOVED*** expression expression
	 */
	walkExpression(expression) {
		switch (expression.type) {
			case "ArrayExpression":
				this.walkArrayExpression(expression);
				break;
			case "ArrowFunctionExpression":
				this.walkArrowFunctionExpression(expression);
				break;
			case "AssignmentExpression":
				this.walkAssignmentExpression(expression);
				break;
			case "AwaitExpression":
				this.walkAwaitExpression(expression);
				break;
			case "BinaryExpression":
				this.walkBinaryExpression(expression);
				break;
			case "CallExpression":
				this.walkCallExpression(expression);
				break;
			case "ChainExpression":
				this.walkChainExpression(expression);
				break;
			case "ClassExpression":
				this.walkClassExpression(expression);
				break;
			case "ConditionalExpression":
				this.walkConditionalExpression(expression);
				break;
			case "FunctionExpression":
				this.walkFunctionExpression(expression);
				break;
			case "Identifier":
				this.walkIdentifier(expression);
				break;
			case "ImportExpression":
				this.walkImportExpression(expression);
				break;
			case "LogicalExpression":
				this.walkLogicalExpression(expression);
				break;
			case "MetaProperty":
				this.walkMetaProperty(expression);
				break;
			case "MemberExpression":
				this.walkMemberExpression(expression);
				break;
			case "NewExpression":
				this.walkNewExpression(expression);
				break;
			case "ObjectExpression":
				this.walkObjectExpression(expression);
				break;
			case "SequenceExpression":
				this.walkSequenceExpression(expression);
				break;
			case "SpreadElement":
				this.walkSpreadElement(expression);
				break;
			case "TaggedTemplateExpression":
				this.walkTaggedTemplateExpression(expression);
				break;
			case "TemplateLiteral":
				this.walkTemplateLiteral(expression);
				break;
			case "ThisExpression":
				this.walkThisExpression(expression);
				break;
			case "UnaryExpression":
				this.walkUnaryExpression(expression);
				break;
			case "UpdateExpression":
				this.walkUpdateExpression(expression);
				break;
			case "YieldExpression":
				this.walkYieldExpression(expression);
				break;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {AwaitExpression***REMOVED*** expression await expression
	 */
	walkAwaitExpression(expression) {
		if (this.scope.topLevelScope === true)
			this.hooks.topLevelAwait.call(expression);
		this.walkExpression(expression.argument);
	***REMOVED***

	/**
	 * @param {ArrayExpression***REMOVED*** expression array expression
	 */
	walkArrayExpression(expression) {
		if (expression.elements) {
			this.walkExpressions(expression.elements);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {SpreadElement***REMOVED*** expression spread element
	 */
	walkSpreadElement(expression) {
		if (expression.argument) {
			this.walkExpression(expression.argument);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ObjectExpression***REMOVED*** expression object expression
	 */
	walkObjectExpression(expression) {
		for (
			let propIndex = 0, len = expression.properties.length;
			propIndex < len;
			propIndex++
		) {
			const prop = expression.properties[propIndex];
			this.walkProperty(prop);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Property | SpreadElement***REMOVED*** prop property or spread element
	 */
	walkProperty(prop) {
		if (prop.type === "SpreadElement") {
			this.walkExpression(prop.argument);
			return;
		***REMOVED***
		if (prop.computed) {
			this.walkExpression(prop.key);
		***REMOVED***
		if (prop.shorthand && prop.value && prop.value.type === "Identifier") {
			this.scope.inShorthand = prop.value.name;
			this.walkIdentifier(prop.value);
			this.scope.inShorthand = false;
		***REMOVED*** else {
			this.walkExpression(
				/** @type {Exclude<Property["value"], AssignmentPattern | ObjectPattern | ArrayPattern | RestElement>***REMOVED*** */
				(prop.value)
			);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {FunctionExpression***REMOVED*** expression arrow function expression
	 */
	walkFunctionExpression(expression) {
		const wasTopLevel = this.scope.topLevelScope;
		this.scope.topLevelScope = false;
		const scopeParams = [...expression.params];

		// Add function name in scope for recursive calls
		if (expression.id) {
			scopeParams.push(expression.id);
		***REMOVED***

		this.inFunctionScope(true, scopeParams, () => {
			for (const param of expression.params) {
				this.walkPattern(param);
			***REMOVED***

			this.detectMode(expression.body.body);

			const prev = this.prevStatement;

			this.preWalkStatement(expression.body);
			this.prevStatement = prev;
			this.walkStatement(expression.body);
		***REMOVED***);
		this.scope.topLevelScope = wasTopLevel;
	***REMOVED***

	/**
	 * @param {ArrowFunctionExpression***REMOVED*** expression arrow function expression
	 */
	walkArrowFunctionExpression(expression) {
		const wasTopLevel = this.scope.topLevelScope;
		this.scope.topLevelScope = wasTopLevel ? "arrow" : false;
		this.inFunctionScope(false, expression.params, () => {
			for (const param of expression.params) {
				this.walkPattern(param);
			***REMOVED***
			if (expression.body.type === "BlockStatement") {
				this.detectMode(expression.body.body);
				const prev = this.prevStatement;
				this.preWalkStatement(expression.body);
				this.prevStatement = prev;
				this.walkStatement(expression.body);
			***REMOVED*** else {
				this.walkExpression(expression.body);
			***REMOVED***
		***REMOVED***);
		this.scope.topLevelScope = wasTopLevel;
	***REMOVED***

	/**
	 * @param {SequenceExpression***REMOVED*** expression the sequence
	 */
	walkSequenceExpression(expression) {
		if (!expression.expressions) return;
		// We treat sequence expressions like statements when they are one statement level
		// This has some benefits for optimizations that only work on statement level
		const currentStatement =
			/** @type {StatementPath***REMOVED*** */
			(this.statementPath)[
				/** @type {StatementPath***REMOVED*** */
				(this.statementPath).length - 1
			];
		if (
			currentStatement === expression ||
			(currentStatement.type === "ExpressionStatement" &&
				currentStatement.expression === expression)
		) {
			const old =
				/** @type {StatementPathItem***REMOVED*** */
				(/** @type {StatementPath***REMOVED*** */ (this.statementPath).pop());
			const prev = this.prevStatement;
			for (const expr of expression.expressions) {
				/** @type {StatementPath***REMOVED*** */
				(this.statementPath).push(expr);
				this.walkExpression(expr);
				this.prevStatement =
					/** @type {StatementPath***REMOVED*** */
					(this.statementPath).pop();
			***REMOVED***
			this.prevStatement = prev;
			/** @type {StatementPath***REMOVED*** */
			(this.statementPath).push(old);
		***REMOVED*** else {
			this.walkExpressions(expression.expressions);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {UpdateExpression***REMOVED*** expression the update expression
	 */
	walkUpdateExpression(expression) {
		this.walkExpression(expression.argument);
	***REMOVED***

	/**
	 * @param {UnaryExpression***REMOVED*** expression the unary expression
	 */
	walkUnaryExpression(expression) {
		if (expression.operator === "typeof") {
			const result = this.callHooksForExpression(
				this.hooks.typeof,
				expression.argument,
				expression
			);
			if (result === true) return;
			if (expression.argument.type === "ChainExpression") {
				const result = this.callHooksForExpression(
					this.hooks.typeof,
					expression.argument.expression,
					expression
				);
				if (result === true) return;
			***REMOVED***
		***REMOVED***
		this.walkExpression(expression.argument);
	***REMOVED***

	/**
	 * @param {LogicalExpression | BinaryExpression***REMOVED*** expression the expression
	 */
	walkLeftRightExpression(expression) {
		this.walkExpression(expression.left);
		this.walkExpression(expression.right);
	***REMOVED***

	/**
	 * @param {BinaryExpression***REMOVED*** expression the binary expression
	 */
	walkBinaryExpression(expression) {
		if (this.hooks.binaryExpression.call(expression) === undefined) {
			this.walkLeftRightExpression(expression);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {LogicalExpression***REMOVED*** expression the logical expression
	 */
	walkLogicalExpression(expression) {
		const result = this.hooks.expressionLogicalOperator.call(expression);
		if (result === undefined) {
			this.walkLeftRightExpression(expression);
		***REMOVED*** else if (result) {
			this.walkExpression(expression.right);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {AssignmentExpression***REMOVED*** expression assignment expression
	 */
	walkAssignmentExpression(expression) {
		if (expression.left.type === "Identifier") {
			const renameIdentifier = this.getRenameIdentifier(expression.right);
			if (
				renameIdentifier &&
				this.callHooksForInfo(
					this.hooks.canRename,
					renameIdentifier,
					expression.right
				)
			) {
				// renaming "a = b;"
				if (
					!this.callHooksForInfo(
						this.hooks.rename,
						renameIdentifier,
						expression.right
					)
				) {
					this.setVariable(
						expression.left.name,
						typeof renameIdentifier === "string"
							? this.getVariableInfo(renameIdentifier)
							: renameIdentifier
					);
				***REMOVED***
				return;
			***REMOVED***
			this.walkExpression(expression.right);
			this.enterPattern(expression.left, (name, decl) => {
				if (!this.callHooksForName(this.hooks.assign, name, expression)) {
					this.walkExpression(
						/** @type {MemberExpression***REMOVED*** */
						(expression.left)
					);
				***REMOVED***
			***REMOVED***);
		***REMOVED*** else if (expression.left.type.endsWith("Pattern")) {
			this.walkExpression(expression.right);
			this.enterPattern(expression.left, (name, decl) => {
				if (!this.callHooksForName(this.hooks.assign, name, expression)) {
					this.defineVariable(name);
				***REMOVED***
			***REMOVED***);
			this.walkPattern(expression.left);
		***REMOVED*** else if (expression.left.type === "MemberExpression") {
			const exprName = this.getMemberExpressionInfo(
				expression.left,
				ALLOWED_MEMBER_TYPES_EXPRESSION
			);
			if (
				exprName &&
				this.callHooksForInfo(
					this.hooks.assignMemberChain,
					exprName.rootInfo,
					expression,
					exprName.getMembers()
				)
			) {
				return;
			***REMOVED***
			this.walkExpression(expression.right);
			this.walkExpression(expression.left);
		***REMOVED*** else {
			this.walkExpression(expression.right);
			this.walkExpression(
				/** @type {Exclude<AssignmentExpression["left"], Identifier | RestElement | MemberExpression | ObjectPattern | ArrayPattern | AssignmentPattern>***REMOVED*** */
				(expression.left)
			);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ConditionalExpression***REMOVED*** expression conditional expression
	 */
	walkConditionalExpression(expression) {
		const result = this.hooks.expressionConditionalOperator.call(expression);
		if (result === undefined) {
			this.walkExpression(expression.test);
			this.walkExpression(expression.consequent);

			if (expression.alternate) {
				this.walkExpression(expression.alternate);
			***REMOVED***
		***REMOVED*** else if (result) {
			this.walkExpression(expression.consequent);
		***REMOVED*** else if (expression.alternate) {
			this.walkExpression(expression.alternate);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {NewExpression***REMOVED*** expression new expression
	 */
	walkNewExpression(expression) {
		const result = this.callHooksForExpression(
			this.hooks.new,
			expression.callee,
			expression
		);
		if (result === true) return;
		this.walkExpression(expression.callee);
		if (expression.arguments) {
			this.walkExpressions(expression.arguments);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {YieldExpression***REMOVED*** expression yield expression
	 */
	walkYieldExpression(expression) {
		if (expression.argument) {
			this.walkExpression(expression.argument);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {TemplateLiteral***REMOVED*** expression template literal
	 */
	walkTemplateLiteral(expression) {
		if (expression.expressions) {
			this.walkExpressions(expression.expressions);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {TaggedTemplateExpression***REMOVED*** expression tagged template expression
	 */
	walkTaggedTemplateExpression(expression) {
		if (expression.tag) {
			this.scope.inTaggedTemplateTag = true;
			this.walkExpression(expression.tag);
			this.scope.inTaggedTemplateTag = false;
		***REMOVED***
		if (expression.quasi && expression.quasi.expressions) {
			this.walkExpressions(expression.quasi.expressions);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ClassExpression***REMOVED*** expression the class expression
	 */
	walkClassExpression(expression) {
		this.walkClass(expression);
	***REMOVED***

	/**
	 * @param {ChainExpression***REMOVED*** expression expression
	 */
	walkChainExpression(expression) {
		const result = this.hooks.optionalChaining.call(expression);

		if (result === undefined) {
			if (expression.expression.type === "CallExpression") {
				this.walkCallExpression(expression.expression);
			***REMOVED*** else {
				this.walkMemberExpression(expression.expression);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @private
	 * @param {FunctionExpression | ArrowFunctionExpression***REMOVED*** functionExpression function expression
	 * @param {(Expression | SpreadElement)[]***REMOVED*** options options
	 * @param {Expression | SpreadElement | null***REMOVED*** currentThis current this
	 */
	_walkIIFE(functionExpression, options, currentThis) {
		/**
		 * @param {Expression | SpreadElement***REMOVED*** argOrThis arg or this
		 * @returns {string | VariableInfo | undefined***REMOVED*** var info
		 */
		const getVarInfo = argOrThis => {
			const renameIdentifier = this.getRenameIdentifier(argOrThis);
			if (
				renameIdentifier &&
				this.callHooksForInfo(
					this.hooks.canRename,
					renameIdentifier,
					/** @type {Expression***REMOVED*** */
					(argOrThis)
				) &&
				!this.callHooksForInfo(
					this.hooks.rename,
					renameIdentifier,
					/** @type {Expression***REMOVED*** */
					(argOrThis)
				)
			) {
				return typeof renameIdentifier === "string"
					? /** @type {string***REMOVED*** */ (this.getVariableInfo(renameIdentifier))
					: renameIdentifier;
			***REMOVED***
			this.walkExpression(argOrThis);
		***REMOVED***;
		const { params, type ***REMOVED*** = functionExpression;
		const arrow = type === "ArrowFunctionExpression";
		const renameThis = currentThis ? getVarInfo(currentThis) : null;
		const varInfoForArgs = options.map(getVarInfo);
		const wasTopLevel = this.scope.topLevelScope;
		this.scope.topLevelScope = wasTopLevel && arrow ? "arrow" : false;
		const scopeParams =
			/** @type {(Identifier | string)[]***REMOVED*** */
			(params.filter((identifier, idx) => !varInfoForArgs[idx]));

		// Add function name in scope for recursive calls
		if (
			functionExpression.type === "FunctionExpression" &&
			functionExpression.id
		) {
			scopeParams.push(functionExpression.id.name);
		***REMOVED***

		this.inFunctionScope(true, scopeParams, () => {
			if (renameThis && !arrow) {
				this.setVariable("this", renameThis);
			***REMOVED***
			for (let i = 0; i < varInfoForArgs.length; i++) {
				const varInfo = varInfoForArgs[i];
				if (!varInfo) continue;
				if (!params[i] || params[i].type !== "Identifier") continue;
				this.setVariable(/** @type {Identifier***REMOVED*** */ (params[i]).name, varInfo);
			***REMOVED***
			if (functionExpression.body.type === "BlockStatement") {
				this.detectMode(functionExpression.body.body);
				const prev = this.prevStatement;
				this.preWalkStatement(functionExpression.body);
				this.prevStatement = prev;
				this.walkStatement(functionExpression.body);
			***REMOVED*** else {
				this.walkExpression(functionExpression.body);
			***REMOVED***
		***REMOVED***);
		this.scope.topLevelScope = wasTopLevel;
	***REMOVED***

	/**
	 * @param {ImportExpression***REMOVED*** expression import expression
	 */
	walkImportExpression(expression) {
		const result = this.hooks.importCall.call(expression);
		if (result === true) return;

		this.walkExpression(expression.source);
	***REMOVED***

	/**
	 * @param {CallExpression***REMOVED*** expression expression
	 */
	walkCallExpression(expression) {
		/**
		 * @param {FunctionExpression | ArrowFunctionExpression***REMOVED*** fn function
		 * @returns {boolean***REMOVED*** true when simple function
		 */
		const isSimpleFunction = fn =>
			fn.params.every(p => p.type === "Identifier");
		if (
			expression.callee.type === "MemberExpression" &&
			expression.callee.object.type.endsWith("FunctionExpression") &&
			!expression.callee.computed &&
			/** @type {boolean***REMOVED*** */
			(
				/** @type {Identifier***REMOVED*** */
				(expression.callee.property).name === "call" ||
					/** @type {Identifier***REMOVED*** */
					(expression.callee.property).name === "bind"
			) &&
			expression.arguments.length > 0 &&
			isSimpleFunction(
				/** @type {FunctionExpression | ArrowFunctionExpression***REMOVED*** */
				(expression.callee.object)
			)
		) {
			// (function() { ***REMOVED***.call/bind(?, ))
			this._walkIIFE(
				/** @type {FunctionExpression | ArrowFunctionExpression***REMOVED*** */
				(expression.callee.object),
				expression.arguments.slice(1),
				expression.arguments[0]
			);
		***REMOVED*** else if (
			expression.callee.type.endsWith("FunctionExpression") &&
			isSimpleFunction(
				/** @type {FunctionExpression | ArrowFunctionExpression***REMOVED*** */
				(expression.callee)
			)
		) {
			// (function() { ***REMOVED***())
			this._walkIIFE(
				/** @type {FunctionExpression | ArrowFunctionExpression***REMOVED*** */
				(expression.callee),
				expression.arguments,
				null
			);
		***REMOVED*** else {
			if (expression.callee.type === "MemberExpression") {
				const exprInfo = this.getMemberExpressionInfo(
					expression.callee,
					ALLOWED_MEMBER_TYPES_CALL_EXPRESSION
				);
				if (exprInfo && exprInfo.type === "call") {
					const result = this.callHooksForInfo(
						this.hooks.callMemberChainOfCallMemberChain,
						exprInfo.rootInfo,
						expression,
						exprInfo.getCalleeMembers(),
						exprInfo.call,
						exprInfo.getMembers(),
						exprInfo.getMemberRanges()
					);
					if (result === true) return;
				***REMOVED***
			***REMOVED***
			const callee = this.evaluateExpression(expression.callee);
			if (callee.isIdentifier()) {
				const result1 = this.callHooksForInfo(
					this.hooks.callMemberChain,
					/** @type {NonNullable<BasicEvaluatedExpression["rootInfo"]>***REMOVED*** */
					(callee.rootInfo),
					expression,
					/** @type {NonNullable<BasicEvaluatedExpression["getMembers"]>***REMOVED*** */
					(callee.getMembers)(),
					callee.getMembersOptionals
						? callee.getMembersOptionals()
						: /** @type {NonNullable<BasicEvaluatedExpression["getMembers"]>***REMOVED*** */
							(callee.getMembers)().map(() => false),
					callee.getMemberRanges ? callee.getMemberRanges() : []
				);
				if (result1 === true) return;
				const result2 = this.callHooksForInfo(
					this.hooks.call,
					/** @type {NonNullable<BasicEvaluatedExpression["identifier"]>***REMOVED*** */
					(callee.identifier),
					expression
				);
				if (result2 === true) return;
			***REMOVED***

			if (expression.callee) {
				if (expression.callee.type === "MemberExpression") {
					// because of call context we need to walk the call context as expression
					this.walkExpression(expression.callee.object);
					if (expression.callee.computed === true)
						this.walkExpression(expression.callee.property);
				***REMOVED*** else {
					this.walkExpression(expression.callee);
				***REMOVED***
			***REMOVED***
			if (expression.arguments) this.walkExpressions(expression.arguments);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {MemberExpression***REMOVED*** expression member expression
	 */
	walkMemberExpression(expression) {
		const exprInfo = this.getMemberExpressionInfo(
			expression,
			ALLOWED_MEMBER_TYPES_ALL
		);
		if (exprInfo) {
			switch (exprInfo.type) {
				case "expression": {
					const result1 = this.callHooksForInfo(
						this.hooks.expression,
						exprInfo.name,
						expression
					);
					if (result1 === true) return;
					const members = exprInfo.getMembers();
					const membersOptionals = exprInfo.getMembersOptionals();
					const memberRanges = exprInfo.getMemberRanges();
					const result2 = this.callHooksForInfo(
						this.hooks.expressionMemberChain,
						exprInfo.rootInfo,
						expression,
						members,
						membersOptionals,
						memberRanges
					);
					if (result2 === true) return;
					this.walkMemberExpressionWithExpressionName(
						expression,
						exprInfo.name,
						exprInfo.rootInfo,
						members.slice(),
						() =>
							this.callHooksForInfo(
								this.hooks.unhandledExpressionMemberChain,
								exprInfo.rootInfo,
								expression,
								members
							)
					);
					return;
				***REMOVED***
				case "call": {
					const result = this.callHooksForInfo(
						this.hooks.memberChainOfCallMemberChain,
						exprInfo.rootInfo,
						expression,
						exprInfo.getCalleeMembers(),
						exprInfo.call,
						exprInfo.getMembers(),
						exprInfo.getMemberRanges()
					);
					if (result === true) return;
					// Fast skip over the member chain as we already called memberChainOfCallMemberChain
					// and call computed property are literals anyway
					this.walkExpression(exprInfo.call);
					return;
				***REMOVED***
			***REMOVED***
		***REMOVED***
		this.walkExpression(expression.object);
		if (expression.computed === true) this.walkExpression(expression.property);
	***REMOVED***

	/**
	 * @template R
	 * @param {MemberExpression***REMOVED*** expression member expression
	 * @param {string***REMOVED*** name name
	 * @param {string | VariableInfo***REMOVED*** rootInfo root info
	 * @param {string[]***REMOVED*** members members
	 * @param {() => R | undefined***REMOVED*** onUnhandled on unhandled callback
	 */
	walkMemberExpressionWithExpressionName(
		expression,
		name,
		rootInfo,
		members,
		onUnhandled
	) {
		if (expression.object.type === "MemberExpression") {
			// optimize the case where expression.object is a MemberExpression too.
			// we can keep info here when calling walkMemberExpression directly
			const property =
				/** @type {Identifier***REMOVED*** */
				(expression.property).name ||
				`${/** @type {Literal***REMOVED*** */ (expression.property).value***REMOVED***`;
			name = name.slice(0, -property.length - 1);
			members.pop();
			const result = this.callHooksForInfo(
				this.hooks.expression,
				name,
				expression.object
			);
			if (result === true) return;
			this.walkMemberExpressionWithExpressionName(
				expression.object,
				name,
				rootInfo,
				members,
				onUnhandled
			);
		***REMOVED*** else if (!onUnhandled || !onUnhandled()) {
			this.walkExpression(expression.object);
		***REMOVED***
		if (expression.computed === true) this.walkExpression(expression.property);
	***REMOVED***

	/**
	 * @param {ThisExpression***REMOVED*** expression this expression
	 */
	walkThisExpression(expression) {
		this.callHooksForName(this.hooks.expression, "this", expression);
	***REMOVED***

	/**
	 * @param {Identifier***REMOVED*** expression identifier
	 */
	walkIdentifier(expression) {
		this.callHooksForName(this.hooks.expression, expression.name, expression);
	***REMOVED***

	/**
	 * @param {MetaProperty***REMOVED*** metaProperty meta property
	 */
	walkMetaProperty(metaProperty) {
		this.hooks.expression.for(getRootName(metaProperty)).call(metaProperty);
	***REMOVED***

	/**
	 * @template T
	 * @template R
	 * @param {HookMap<SyncBailHook<T, R>>***REMOVED*** hookMap hooks the should be called
	 * @param {Expression | Super***REMOVED*** expr expression
	 * @param {AsArray<T>***REMOVED*** args args for the hook
	 * @returns {R | undefined***REMOVED*** result of hook
	 */
	callHooksForExpression(hookMap, expr, ...args) {
		return this.callHooksForExpressionWithFallback(
			hookMap,
			expr,
			undefined,
			undefined,
			...args
		);
	***REMOVED***

	/**
	 * @template T
	 * @template R
	 * @param {HookMap<SyncBailHook<T, R>>***REMOVED*** hookMap hooks the should be called
	 * @param {Expression | Super***REMOVED*** expr expression info
	 * @param {((name: string, rootInfo: string | ScopeInfo | VariableInfo, getMembers: () => string[]) => TODO) | undefined***REMOVED*** fallback callback when variable in not handled by hooks
	 * @param {((result?: string) => R | undefined) | undefined***REMOVED*** defined callback when variable is defined
	 * @param {AsArray<T>***REMOVED*** args args for the hook
	 * @returns {R | undefined***REMOVED*** result of hook
	 */
	callHooksForExpressionWithFallback(
		hookMap,
		expr,
		fallback,
		defined,
		...args
	) {
		const exprName = this.getMemberExpressionInfo(
			expr,
			ALLOWED_MEMBER_TYPES_EXPRESSION
		);
		if (exprName !== undefined) {
			const members = exprName.getMembers();
			return this.callHooksForInfoWithFallback(
				hookMap,
				members.length === 0 ? exprName.rootInfo : exprName.name,
				fallback &&
					(name => fallback(name, exprName.rootInfo, exprName.getMembers)),
				defined && (() => defined(exprName.name)),
				...args
			);
		***REMOVED***
	***REMOVED***

	/**
	 * @template T
	 * @template R
	 * @param {HookMap<SyncBailHook<T, R>>***REMOVED*** hookMap hooks the should be called
	 * @param {string***REMOVED*** name key in map
	 * @param {AsArray<T>***REMOVED*** args args for the hook
	 * @returns {R | undefined***REMOVED*** result of hook
	 */
	callHooksForName(hookMap, name, ...args) {
		return this.callHooksForNameWithFallback(
			hookMap,
			name,
			undefined,
			undefined,
			...args
		);
	***REMOVED***

	/**
	 * @template T
	 * @template R
	 * @param {HookMap<SyncBailHook<T, R>>***REMOVED*** hookMap hooks that should be called
	 * @param {ExportedVariableInfo***REMOVED*** info variable info
	 * @param {AsArray<T>***REMOVED*** args args for the hook
	 * @returns {R | undefined***REMOVED*** result of hook
	 */
	callHooksForInfo(hookMap, info, ...args) {
		return this.callHooksForInfoWithFallback(
			hookMap,
			info,
			undefined,
			undefined,
			...args
		);
	***REMOVED***

	/**
	 * @template T
	 * @template R
	 * @param {HookMap<SyncBailHook<T, R>>***REMOVED*** hookMap hooks the should be called
	 * @param {ExportedVariableInfo***REMOVED*** info variable info
	 * @param {((name: string) => TODO) | undefined***REMOVED*** fallback callback when variable in not handled by hooks
	 * @param {((result?: string) => TODO) | undefined***REMOVED*** defined callback when variable is defined
	 * @param {AsArray<T>***REMOVED*** args args for the hook
	 * @returns {R | undefined***REMOVED*** result of hook
	 */
	callHooksForInfoWithFallback(hookMap, info, fallback, defined, ...args) {
		let name;
		if (typeof info === "string") {
			name = info;
		***REMOVED*** else {
			if (!(info instanceof VariableInfo)) {
				if (defined !== undefined) {
					return defined();
				***REMOVED***
				return;
			***REMOVED***
			let tagInfo = info.tagInfo;
			while (tagInfo !== undefined) {
				const hook = hookMap.get(tagInfo.tag);
				if (hook !== undefined) {
					this.currentTagData = tagInfo.data;
					const result = hook.call(...args);
					this.currentTagData = undefined;
					if (result !== undefined) return result;
				***REMOVED***
				tagInfo = tagInfo.next;
			***REMOVED***
			if (info.freeName === true) {
				if (defined !== undefined) {
					return defined();
				***REMOVED***
				return;
			***REMOVED***
			name = info.freeName;
		***REMOVED***
		const hook = hookMap.get(name);
		if (hook !== undefined) {
			const result = hook.call(...args);
			if (result !== undefined) return result;
		***REMOVED***
		if (fallback !== undefined) {
			return fallback(/** @type {string***REMOVED*** */ (name));
		***REMOVED***
	***REMOVED***

	/**
	 * @template T
	 * @template R
	 * @param {HookMap<SyncBailHook<T, R>>***REMOVED*** hookMap hooks the should be called
	 * @param {string***REMOVED*** name key in map
	 * @param {((value: string) => R | undefined) | undefined***REMOVED*** fallback callback when variable in not handled by hooks
	 * @param {(() => R) | undefined***REMOVED*** defined callback when variable is defined
	 * @param {AsArray<T>***REMOVED*** args args for the hook
	 * @returns {R | undefined***REMOVED*** result of hook
	 */
	callHooksForNameWithFallback(hookMap, name, fallback, defined, ...args) {
		return this.callHooksForInfoWithFallback(
			hookMap,
			this.getVariableInfo(name),
			fallback,
			defined,
			...args
		);
	***REMOVED***

	/**
	 * @deprecated
	 * @param {(string | Pattern | Property)[]***REMOVED*** params scope params
	 * @param {() => void***REMOVED*** fn inner function
	 * @returns {void***REMOVED***
	 */
	inScope(params, fn) {
		const oldScope = this.scope;
		this.scope = {
			topLevelScope: oldScope.topLevelScope,
			inTry: false,
			inShorthand: false,
			inTaggedTemplateTag: false,
			isStrict: oldScope.isStrict,
			isAsmJs: oldScope.isAsmJs,
			terminated: undefined,
			definitions: oldScope.definitions.createChild()
		***REMOVED***;

		this.undefineVariable("this");

		this.enterPatterns(params, ident => {
			this.defineVariable(ident);
		***REMOVED***);

		fn();

		this.scope = oldScope;
	***REMOVED***

	/**
	 * @param {boolean***REMOVED*** hasThis true, when this is defined
	 * @param {Identifier[]***REMOVED*** params scope params
	 * @param {() => void***REMOVED*** fn inner function
	 * @returns {void***REMOVED***
	 */
	inClassScope(hasThis, params, fn) {
		const oldScope = this.scope;
		this.scope = {
			topLevelScope: oldScope.topLevelScope,
			inTry: false,
			inShorthand: false,
			inTaggedTemplateTag: false,
			isStrict: oldScope.isStrict,
			isAsmJs: oldScope.isAsmJs,
			terminated: undefined,
			definitions: oldScope.definitions.createChild()
		***REMOVED***;

		if (hasThis) {
			this.undefineVariable("this");
		***REMOVED***

		this.enterPatterns(params, ident => {
			this.defineVariable(ident);
		***REMOVED***);

		fn();

		this.scope = oldScope;
	***REMOVED***

	/**
	 * @param {boolean***REMOVED*** hasThis true, when this is defined
	 * @param {(Pattern | string)[]***REMOVED*** params scope params
	 * @param {() => void***REMOVED*** fn inner function
	 * @returns {void***REMOVED***
	 */
	inFunctionScope(hasThis, params, fn) {
		const oldScope = this.scope;
		this.scope = {
			topLevelScope: oldScope.topLevelScope,
			inTry: false,
			inShorthand: false,
			inTaggedTemplateTag: false,
			isStrict: oldScope.isStrict,
			isAsmJs: oldScope.isAsmJs,
			terminated: undefined,
			definitions: oldScope.definitions.createChild()
		***REMOVED***;

		if (hasThis) {
			this.undefineVariable("this");
		***REMOVED***

		this.enterPatterns(params, ident => {
			this.defineVariable(ident);
		***REMOVED***);

		fn();

		this.scope = oldScope;
	***REMOVED***

	/**
	 * @param {() => void***REMOVED*** fn inner function
	 * @param {boolean***REMOVED*** inExecutedPath executed state
	 * @returns {void***REMOVED***
	 */
	inBlockScope(fn, inExecutedPath = false) {
		const oldScope = this.scope;
		this.scope = {
			topLevelScope: oldScope.topLevelScope,
			inTry: oldScope.inTry,
			inShorthand: false,
			inTaggedTemplateTag: false,
			isStrict: oldScope.isStrict,
			isAsmJs: oldScope.isAsmJs,
			terminated: oldScope.terminated,
			definitions: oldScope.definitions.createChild()
		***REMOVED***;

		fn();

		const terminated = this.scope.terminated;

		if (inExecutedPath && terminated) {
			oldScope.terminated = terminated;
		***REMOVED***

		this.scope = oldScope;
	***REMOVED***

	/**
	 * @param {Array<Directive | Statement | ModuleDeclaration>***REMOVED*** statements statements
	 */
	detectMode(statements) {
		const isLiteral =
			statements.length >= 1 &&
			statements[0].type === "ExpressionStatement" &&
			statements[0].expression.type === "Literal";
		if (
			isLiteral &&
			/** @type {Literal***REMOVED*** */
			(/** @type {ExpressionStatement***REMOVED*** */ (statements[0]).expression).value ===
				"use strict"
		) {
			this.scope.isStrict = true;
		***REMOVED***
		if (
			isLiteral &&
			/** @type {Literal***REMOVED*** */
			(/** @type {ExpressionStatement***REMOVED*** */ (statements[0]).expression).value ===
				"use asm"
		) {
			this.scope.isAsmJs = true;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {(string | Pattern | Property)[]***REMOVED*** patterns patterns
	 * @param {OnIdentString***REMOVED*** onIdent on ident callback
	 */
	enterPatterns(patterns, onIdent) {
		for (const pattern of patterns) {
			if (typeof pattern !== "string") {
				this.enterPattern(pattern, onIdent);
			***REMOVED*** else if (pattern) {
				onIdent(pattern);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Pattern | Property***REMOVED*** pattern pattern
	 * @param {OnIdent***REMOVED*** onIdent on ident callback
	 */
	enterPattern(pattern, onIdent) {
		if (!pattern) return;
		switch (pattern.type) {
			case "ArrayPattern":
				this.enterArrayPattern(pattern, onIdent);
				break;
			case "AssignmentPattern":
				this.enterAssignmentPattern(pattern, onIdent);
				break;
			case "Identifier":
				this.enterIdentifier(pattern, onIdent);
				break;
			case "ObjectPattern":
				this.enterObjectPattern(pattern, onIdent);
				break;
			case "RestElement":
				this.enterRestElement(pattern, onIdent);
				break;
			case "Property":
				if (pattern.shorthand && pattern.value.type === "Identifier") {
					this.scope.inShorthand = pattern.value.name;
					this.enterIdentifier(pattern.value, onIdent);
					this.scope.inShorthand = false;
				***REMOVED*** else {
					this.enterPattern(/** @type {Pattern***REMOVED*** */ (pattern.value), onIdent);
				***REMOVED***
				break;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Identifier***REMOVED*** pattern identifier pattern
	 * @param {OnIdent***REMOVED*** onIdent callback
	 */
	enterIdentifier(pattern, onIdent) {
		if (!this.callHooksForName(this.hooks.pattern, pattern.name, pattern)) {
			onIdent(pattern.name, pattern);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ObjectPattern***REMOVED*** pattern object pattern
	 * @param {OnIdent***REMOVED*** onIdent callback
	 */
	enterObjectPattern(pattern, onIdent) {
		for (
			let propIndex = 0, len = pattern.properties.length;
			propIndex < len;
			propIndex++
		) {
			const prop = pattern.properties[propIndex];
			this.enterPattern(prop, onIdent);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ArrayPattern***REMOVED*** pattern object pattern
	 * @param {OnIdent***REMOVED*** onIdent callback
	 */
	enterArrayPattern(pattern, onIdent) {
		for (
			let elementIndex = 0, len = pattern.elements.length;
			elementIndex < len;
			elementIndex++
		) {
			const element = pattern.elements[elementIndex];

			if (element) {
				this.enterPattern(element, onIdent);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {RestElement***REMOVED*** pattern object pattern
	 * @param {OnIdent***REMOVED*** onIdent callback
	 */
	enterRestElement(pattern, onIdent) {
		this.enterPattern(pattern.argument, onIdent);
	***REMOVED***

	/**
	 * @param {AssignmentPattern***REMOVED*** pattern object pattern
	 * @param {OnIdent***REMOVED*** onIdent callback
	 */
	enterAssignmentPattern(pattern, onIdent) {
		this.enterPattern(pattern.left, onIdent);
	***REMOVED***

	/**
	 * @param {Expression | SpreadElement | PrivateIdentifier | Super***REMOVED*** expression expression node
	 * @returns {BasicEvaluatedExpression***REMOVED*** evaluation result
	 */
	evaluateExpression(expression) {
		try {
			const hook = this.hooks.evaluate.get(expression.type);
			if (hook !== undefined) {
				const result = hook.call(expression);
				if (result !== undefined && result !== null) {
					result.setExpression(expression);
					return result;
				***REMOVED***
			***REMOVED***
		***REMOVED*** catch (err) {
			// eslint-disable-next-line no-console
			console.warn(err);
			// ignore error
		***REMOVED***
		return new BasicEvaluatedExpression()
			.setRange(/** @type {Range***REMOVED*** */ (expression.range))
			.setExpression(expression);
	***REMOVED***

	/**
	 * @param {Expression***REMOVED*** expression expression
	 * @returns {string***REMOVED*** parsed string
	 */
	parseString(expression) {
		switch (expression.type) {
			case "BinaryExpression":
				if (expression.operator === "+") {
					return (
						this.parseString(/** @type {Expression***REMOVED*** */ (expression.left)) +
						this.parseString(expression.right)
					);
				***REMOVED***
				break;
			case "Literal":
				return String(expression.value);
		***REMOVED***
		throw new Error(
			`${expression.type***REMOVED*** is not supported as parameter for require`
		);
	***REMOVED***

	/**
	 * @param {Expression***REMOVED*** expression expression
	 * @returns {{ range?: Range, value: string, code: boolean, conditional: boolean | TODO ***REMOVED******REMOVED*** result
	 */
	parseCalculatedString(expression) {
		switch (expression.type) {
			case "BinaryExpression":
				if (expression.operator === "+") {
					const left = this.parseCalculatedString(
						/** @type {Expression***REMOVED*** */
						(expression.left)
					);
					const right = this.parseCalculatedString(expression.right);
					if (left.code) {
						return {
							range: left.range,
							value: left.value,
							code: true,
							conditional: false
						***REMOVED***;
					***REMOVED*** else if (right.code) {
						return {
							range: [
								/** @type {Range***REMOVED*** */
								(left.range)[0],
								right.range
									? right.range[1]
									: /** @type {Range***REMOVED*** */ (left.range)[1]
							],
							value: left.value + right.value,
							code: true,
							conditional: false
						***REMOVED***;
					***REMOVED***
					return {
						range: [
							/** @type {Range***REMOVED*** */
							(left.range)[0],
							/** @type {Range***REMOVED*** */
							(right.range)[1]
						],
						value: left.value + right.value,
						code: false,
						conditional: false
					***REMOVED***;
				***REMOVED***
				break;
			case "ConditionalExpression": {
				const consequent = this.parseCalculatedString(expression.consequent);
				const alternate = this.parseCalculatedString(expression.alternate);
				const items = [];
				if (consequent.conditional) {
					items.push(...consequent.conditional);
				***REMOVED*** else if (!consequent.code) {
					items.push(consequent);
				***REMOVED*** else {
					break;
				***REMOVED***
				if (alternate.conditional) {
					items.push(...alternate.conditional);
				***REMOVED*** else if (!alternate.code) {
					items.push(alternate);
				***REMOVED*** else {
					break;
				***REMOVED***
				return {
					range: undefined,
					value: "",
					code: true,
					conditional: items
				***REMOVED***;
			***REMOVED***
			case "Literal":
				return {
					range: expression.range,
					value: String(expression.value),
					code: false,
					conditional: false
				***REMOVED***;
		***REMOVED***
		return {
			range: undefined,
			value: "",
			code: true,
			conditional: false
		***REMOVED***;
	***REMOVED***

	/**
	 * @param {string | Buffer | PreparsedAst***REMOVED*** source the source to parse
	 * @param {ParserState***REMOVED*** state the parser state
	 * @returns {ParserState***REMOVED*** the parser state
	 */
	parse(source, state) {
		let ast;
		/** @type {import("acorn").Comment[]***REMOVED*** */
		let comments;
		const semicolons = new Set();
		if (source === null) {
			throw new Error("source must not be null");
		***REMOVED***
		if (Buffer.isBuffer(source)) {
			source = source.toString("utf-8");
		***REMOVED***
		if (typeof source === "object") {
			ast = /** @type {Program***REMOVED*** */ (source);
			comments = source.comments;
			if (source.semicolons) {
				// Forward semicolon information from the preparsed AST if present
				// This ensures the output is consistent with that of a fresh AST
				for (const pos of source.semicolons) {
					semicolons.add(pos);
				***REMOVED***
			***REMOVED***
		***REMOVED*** else {
			comments = [];
			ast = JavascriptParser._parse(source, {
				sourceType: this.sourceType,
				onComment: comments,
				onInsertedSemicolon: pos => semicolons.add(pos)
			***REMOVED***);
		***REMOVED***

		const oldScope = this.scope;
		const oldState = this.state;
		const oldComments = this.comments;
		const oldSemicolons = this.semicolons;
		const oldStatementPath = this.statementPath;
		const oldPrevStatement = this.prevStatement;
		this.scope = {
			topLevelScope: true,
			inTry: false,
			inShorthand: false,
			inTaggedTemplateTag: false,
			isStrict: false,
			isAsmJs: false,
			terminated: undefined,
			definitions: new StackedMap()
		***REMOVED***;
		this.state = /** @type {ParserState***REMOVED*** */ (state);
		this.comments = comments;
		this.semicolons = semicolons;
		this.statementPath = [];
		this.prevStatement = undefined;
		if (this.hooks.program.call(ast, comments) === undefined) {
			this.destructuringAssignmentProperties = new WeakMap();
			this.detectMode(ast.body);
			this.preWalkStatements(ast.body);
			this.prevStatement = undefined;
			this.blockPreWalkStatements(ast.body);
			this.prevStatement = undefined;
			this.walkStatements(ast.body);
			this.destructuringAssignmentProperties = undefined;
		***REMOVED***
		this.hooks.finish.call(ast, comments);
		this.scope = oldScope;
		this.state = oldState;
		this.comments = oldComments;
		this.semicolons = oldSemicolons;
		this.statementPath = oldStatementPath;
		this.prevStatement = oldPrevStatement;
		return state;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** source source code
	 * @returns {BasicEvaluatedExpression***REMOVED*** evaluation result
	 */
	evaluate(source) {
		const ast = JavascriptParser._parse(`(${source***REMOVED***)`, {
			sourceType: this.sourceType,
			locations: false
		***REMOVED***);
		if (ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement") {
			throw new Error("evaluate: Source is not a expression");
		***REMOVED***
		return this.evaluateExpression(ast.body[0].expression);
	***REMOVED***

	/**
	 * @param {Expression | Declaration | PrivateIdentifier | MaybeNamedFunctionDeclaration | MaybeNamedClassDeclaration | null | undefined***REMOVED*** expr an expression
	 * @param {number***REMOVED*** commentsStartPos source position from which annotation comments are checked
	 * @returns {boolean***REMOVED*** true, when the expression is pure
	 */
	isPure(expr, commentsStartPos) {
		if (!expr) return true;
		const result = this.hooks.isPure
			.for(expr.type)
			.call(expr, commentsStartPos);
		if (typeof result === "boolean") return result;
		switch (expr.type) {
			// TODO handle more cases
			case "ClassDeclaration":
			case "ClassExpression": {
				if (expr.body.type !== "ClassBody") return false;
				if (
					expr.superClass &&
					!this.isPure(expr.superClass, /** @type {Range***REMOVED*** */ (expr.range)[0])
				) {
					return false;
				***REMOVED***
				const items =
					/** @type {TODO[]***REMOVED*** */
					(expr.body.body);
				return items.every(item => {
					if (
						item.computed &&
						item.key &&
						!this.isPure(item.key, item.range[0])
					) {
						return false;
					***REMOVED***

					if (
						item.static &&
						item.value &&
						!this.isPure(
							item.value,
							item.key ? item.key.range[1] : item.range[0]
						)
					) {
						return false;
					***REMOVED***

					if (item.type === "StaticBlock") {
						return false;
					***REMOVED***

					if (
						expr.superClass &&
						item.type === "MethodDefinition" &&
						item.kind === "constructor"
					) {
						return false;
					***REMOVED***

					return true;
				***REMOVED***);
			***REMOVED***

			case "FunctionDeclaration":
			case "FunctionExpression":
			case "ArrowFunctionExpression":
			case "ThisExpression":
			case "Literal":
			case "TemplateLiteral":
			case "Identifier":
			case "PrivateIdentifier":
				return true;

			case "VariableDeclaration":
				return expr.declarations.every(decl =>
					this.isPure(decl.init, /** @type {Range***REMOVED*** */ (decl.range)[0])
				);

			case "ConditionalExpression":
				return (
					this.isPure(expr.test, commentsStartPos) &&
					this.isPure(
						expr.consequent,
						/** @type {Range***REMOVED*** */ (expr.test.range)[1]
					) &&
					this.isPure(
						expr.alternate,
						/** @type {Range***REMOVED*** */ (expr.consequent.range)[1]
					)
				);

			case "LogicalExpression":
				return (
					this.isPure(expr.left, commentsStartPos) &&
					this.isPure(expr.right, /** @type {Range***REMOVED*** */ (expr.left.range)[1])
				);

			case "SequenceExpression":
				return expr.expressions.every(expr => {
					const pureFlag = this.isPure(expr, commentsStartPos);
					commentsStartPos = /** @type {Range***REMOVED*** */ (expr.range)[1];
					return pureFlag;
				***REMOVED***);

			case "CallExpression": {
				const pureFlag =
					/** @type {Range***REMOVED*** */ (expr.range)[0] - commentsStartPos > 12 &&
					this.getComments([
						commentsStartPos,
						/** @type {Range***REMOVED*** */ (expr.range)[0]
					]).some(
						comment =>
							comment.type === "Block" &&
							/^\s*(#|@)__PURE__\s*$/.test(comment.value)
					);
				if (!pureFlag) return false;
				commentsStartPos = /** @type {Range***REMOVED*** */ (expr.callee.range)[1];
				return expr.arguments.every(arg => {
					if (arg.type === "SpreadElement") return false;
					const pureFlag = this.isPure(arg, commentsStartPos);
					commentsStartPos = /** @type {Range***REMOVED*** */ (arg.range)[1];
					return pureFlag;
				***REMOVED***);
			***REMOVED***
		***REMOVED***
		const evaluated = this.evaluateExpression(expr);
		return !evaluated.couldHaveSideEffects();
	***REMOVED***

	/**
	 * @param {Range***REMOVED*** range range
	 * @returns {Comment[]***REMOVED*** comments in the range
	 */
	getComments(range) {
		const [rangeStart, rangeEnd] = range;
		/**
		 * @param {Comment***REMOVED*** comment comment
		 * @param {number***REMOVED*** needle needle
		 * @returns {number***REMOVED*** compared
		 */
		const compare = (comment, needle) =>
			/** @type {Range***REMOVED*** */ (comment.range)[0] - needle;
		const comments = /** @type {Comment[]***REMOVED*** */ (this.comments);
		let idx = binarySearchBounds.ge(comments, rangeStart, compare);
		/** @type {Comment[]***REMOVED*** */
		const commentsInRange = [];
		while (
			comments[idx] &&
			/** @type {Range***REMOVED*** */ (comments[idx].range)[1] <= rangeEnd
		) {
			commentsInRange.push(comments[idx]);
			idx++;
		***REMOVED***

		return commentsInRange;
	***REMOVED***

	/**
	 * @param {number***REMOVED*** pos source code position
	 * @returns {boolean***REMOVED*** true when a semicolon has been inserted before this position, false if not
	 */
	isAsiPosition(pos) {
		const currentStatement =
			/** @type {StatementPath***REMOVED*** */
			(this.statementPath)[
				/** @type {StatementPath***REMOVED*** */
				(this.statementPath).length - 1
			];
		if (currentStatement === undefined) throw new Error("Not in statement");
		const range = /** @type {Range***REMOVED*** */ (currentStatement.range);

		return (
			// Either asking directly for the end position of the current statement
			(range[1] === pos &&
				/** @type {Set<number>***REMOVED*** */ (this.semicolons).has(pos)) ||
			// Or asking for the start position of the current statement,
			// here we have to check multiple things
			(range[0] === pos &&
				// is there a previous statement which might be relevant?
				this.prevStatement !== undefined &&
				// is the end position of the previous statement an ASI position?
				/** @type {Set<number>***REMOVED*** */ (this.semicolons).has(
					/** @type {Range***REMOVED*** */ (this.prevStatement.range)[1]
				))
		);
	***REMOVED***

	/**
	 * @param {number***REMOVED*** pos source code position
	 * @returns {void***REMOVED***
	 */
	setAsiPosition(pos) {
		/** @type {Set<number>***REMOVED*** */ (this.semicolons).add(pos);
	***REMOVED***

	/**
	 * @param {number***REMOVED*** pos source code position
	 * @returns {void***REMOVED***
	 */
	unsetAsiPosition(pos) {
		/** @type {Set<number>***REMOVED*** */ (this.semicolons).delete(pos);
	***REMOVED***

	/**
	 * @param {Expression***REMOVED*** expr expression
	 * @returns {boolean***REMOVED*** true, when the expression is a statement level expression
	 */
	isStatementLevelExpression(expr) {
		const currentStatement =
			/** @type {StatementPath***REMOVED*** */
			(this.statementPath)[
				/** @type {StatementPath***REMOVED*** */
				(this.statementPath).length - 1
			];
		return (
			expr === currentStatement ||
			(currentStatement.type === "ExpressionStatement" &&
				currentStatement.expression === expr)
		);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** name name
	 * @param {Tag***REMOVED*** tag tag info
	 * @returns {TagData | undefined***REMOVED*** tag data
	 */
	getTagData(name, tag) {
		const info = this.scope.definitions.get(name);
		if (info instanceof VariableInfo) {
			let tagInfo = info.tagInfo;
			while (tagInfo !== undefined) {
				if (tagInfo.tag === tag) return tagInfo.data;
				tagInfo = tagInfo.next;
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {string***REMOVED*** name name
	 * @param {Tag***REMOVED*** tag tag info
	 * @param {TagData=***REMOVED*** data data
	 */
	tagVariable(name, tag, data) {
		const oldInfo = this.scope.definitions.get(name);
		/** @type {VariableInfo***REMOVED*** */
		let newInfo;
		if (oldInfo === undefined) {
			newInfo = new VariableInfo(this.scope, name, {
				tag,
				data,
				next: undefined
			***REMOVED***);
		***REMOVED*** else if (oldInfo instanceof VariableInfo) {
			newInfo = new VariableInfo(oldInfo.declaredScope, oldInfo.freeName, {
				tag,
				data,
				next: oldInfo.tagInfo
			***REMOVED***);
		***REMOVED*** else {
			newInfo = new VariableInfo(oldInfo, true, {
				tag,
				data,
				next: undefined
			***REMOVED***);
		***REMOVED***
		this.scope.definitions.set(name, newInfo);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** name variable name
	 */
	defineVariable(name) {
		const oldInfo = this.scope.definitions.get(name);
		// Don't redefine variable in same scope to keep existing tags
		if (oldInfo instanceof VariableInfo && oldInfo.declaredScope === this.scope)
			return;
		this.scope.definitions.set(name, this.scope);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** name variable name
	 */
	undefineVariable(name) {
		this.scope.definitions.delete(name);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** name variable name
	 * @returns {boolean***REMOVED*** true, when variable is defined
	 */
	isVariableDefined(name) {
		const info = this.scope.definitions.get(name);
		if (info === undefined) return false;
		if (info instanceof VariableInfo) {
			return info.freeName === true;
		***REMOVED***
		return true;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** name variable name
	 * @returns {string | ExportedVariableInfo***REMOVED*** info for this variable
	 */
	getVariableInfo(name) {
		const value = this.scope.definitions.get(name);
		if (value === undefined) {
			return name;
		***REMOVED***
		return value;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** name variable name
	 * @param {string | ExportedVariableInfo***REMOVED*** variableInfo new info for this variable
	 * @returns {void***REMOVED***
	 */
	setVariable(name, variableInfo) {
		if (typeof variableInfo === "string") {
			if (variableInfo === name) {
				this.scope.definitions.delete(name);
			***REMOVED*** else {
				this.scope.definitions.set(
					name,
					new VariableInfo(this.scope, variableInfo, undefined)
				);
			***REMOVED***
		***REMOVED*** else {
			this.scope.definitions.set(name, variableInfo);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {TagInfo***REMOVED*** tagInfo tag info
	 * @returns {VariableInfo***REMOVED*** variable info
	 */
	evaluatedVariable(tagInfo) {
		return new VariableInfo(this.scope, undefined, tagInfo);
	***REMOVED***

	/**
	 * @param {Range***REMOVED*** range range of the comment
	 * @returns {{ options: Record<string, EXPECTED_ANY> | null, errors: (Error & { comment: Comment ***REMOVED***)[] | null ***REMOVED******REMOVED*** result
	 */
	parseCommentOptions(range) {
		const comments = this.getComments(range);
		if (comments.length === 0) {
			return EMPTY_COMMENT_OPTIONS;
		***REMOVED***
		/** @type {Record<string, EXPECTED_ANY> ***REMOVED*** */
		const options = {***REMOVED***;
		/** @type {(Error & { comment: Comment ***REMOVED***)[]***REMOVED*** */
		const errors = [];
		for (const comment of comments) {
			const { value ***REMOVED*** = comment;
			if (value && webpackCommentRegExp.test(value)) {
				// try compile only if webpack options comment is present
				try {
					for (let [key, val] of Object.entries(
						vm.runInContext(
							`(function(){return {${value***REMOVED******REMOVED***;***REMOVED***)()`,
							this.magicCommentContext
						)
					)) {
						if (typeof val === "object" && val !== null) {
							val =
								val.constructor.name === "RegExp"
									? new RegExp(val)
									: JSON.parse(JSON.stringify(val));
						***REMOVED***
						options[key] = val;
					***REMOVED***
				***REMOVED*** catch (err) {
					const newErr = new Error(String(/** @type {Error***REMOVED*** */ (err).message));
					newErr.stack = String(/** @type {Error***REMOVED*** */ (err).stack);
					Object.assign(newErr, { comment ***REMOVED***);
					errors.push(/** @type {(Error & { comment: Comment ***REMOVED***)***REMOVED*** */ (newErr));
				***REMOVED***
			***REMOVED***
		***REMOVED***
		return { options, errors ***REMOVED***;
	***REMOVED***

	/**
	 * @param {Expression | Super***REMOVED*** expression a member expression
	 * @returns {{ members: string[], object: Expression | Super, membersOptionals: boolean[], memberRanges: Range[] ***REMOVED******REMOVED*** member names (reverse order) and remaining object
	 */
	extractMemberExpressionChain(expression) {
		/** @type {Node***REMOVED*** */
		let expr = expression;
		const members = [];
		const membersOptionals = [];
		const memberRanges = [];
		while (expr.type === "MemberExpression") {
			if (expr.computed) {
				if (expr.property.type !== "Literal") break;
				members.push(`${expr.property.value***REMOVED***`); // the literal
				memberRanges.push(/** @type {Range***REMOVED*** */ (expr.object.range)); // the range of the expression fragment before the literal
			***REMOVED*** else {
				if (expr.property.type !== "Identifier") break;
				members.push(expr.property.name); // the identifier
				memberRanges.push(/** @type {Range***REMOVED*** */ (expr.object.range)); // the range of the expression fragment before the identifier
			***REMOVED***
			membersOptionals.push(expr.optional);
			expr = expr.object;
		***REMOVED***

		return {
			members,
			membersOptionals,
			memberRanges,
			object: expr
		***REMOVED***;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** varName variable name
	 * @returns {{name: string, info: VariableInfo | string***REMOVED*** | undefined***REMOVED*** name of the free variable and variable info for that
	 */
	getFreeInfoFromVariable(varName) {
		const info = this.getVariableInfo(varName);
		let name;
		if (info instanceof VariableInfo) {
			name = info.freeName;
			if (typeof name !== "string") return;
		***REMOVED*** else if (typeof info !== "string") {
			return;
		***REMOVED*** else {
			name = info;
		***REMOVED***
		return { info, name ***REMOVED***;
	***REMOVED***

	/** @typedef {{ type: "call", call: CallExpression, calleeName: string, rootInfo: string | VariableInfo, getCalleeMembers: () => string[], name: string, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[]***REMOVED******REMOVED*** CallExpressionInfo */
	/** @typedef {{ type: "expression", rootInfo: string | VariableInfo, name: string, getMembers: () => string[], getMembersOptionals: () => boolean[], getMemberRanges: () => Range[]***REMOVED******REMOVED*** ExpressionExpressionInfo */

	/**
	 * @param {Expression | Super***REMOVED*** expression a member expression
	 * @param {number***REMOVED*** allowedTypes which types should be returned, presented in bit mask
	 * @returns {CallExpressionInfo | ExpressionExpressionInfo | undefined***REMOVED*** expression info
	 */
	getMemberExpressionInfo(expression, allowedTypes) {
		const { object, members, membersOptionals, memberRanges ***REMOVED*** =
			this.extractMemberExpressionChain(expression);
		switch (object.type) {
			case "CallExpression": {
				if ((allowedTypes & ALLOWED_MEMBER_TYPES_CALL_EXPRESSION) === 0) return;
				let callee = object.callee;
				let rootMembers = EMPTY_ARRAY;
				if (callee.type === "MemberExpression") {
					({ object: callee, members: rootMembers ***REMOVED*** =
						this.extractMemberExpressionChain(callee));
				***REMOVED***
				const rootName = getRootName(callee);
				if (!rootName) return;
				const result = this.getFreeInfoFromVariable(rootName);
				if (!result) return;
				const { info: rootInfo, name: resolvedRoot ***REMOVED*** = result;
				const calleeName = objectAndMembersToName(resolvedRoot, rootMembers);
				return {
					type: "call",
					call: object,
					calleeName,
					rootInfo,
					getCalleeMembers: memoize(() => rootMembers.reverse()),
					name: objectAndMembersToName(`${calleeName***REMOVED***()`, members),
					getMembers: memoize(() => members.reverse()),
					getMembersOptionals: memoize(() => membersOptionals.reverse()),
					getMemberRanges: memoize(() => memberRanges.reverse())
				***REMOVED***;
			***REMOVED***
			case "Identifier":
			case "MetaProperty":
			case "ThisExpression": {
				if ((allowedTypes & ALLOWED_MEMBER_TYPES_EXPRESSION) === 0) return;
				const rootName = getRootName(object);
				if (!rootName) return;

				const result = this.getFreeInfoFromVariable(rootName);
				if (!result) return;
				const { info: rootInfo, name: resolvedRoot ***REMOVED*** = result;
				return {
					type: "expression",
					name: objectAndMembersToName(resolvedRoot, members),
					rootInfo,
					getMembers: memoize(() => members.reverse()),
					getMembersOptionals: memoize(() => membersOptionals.reverse()),
					getMemberRanges: memoize(() => memberRanges.reverse())
				***REMOVED***;
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {MemberExpression***REMOVED*** expression an expression
	 * @returns {{ name: string, rootInfo: ExportedVariableInfo, getMembers: () => string[]***REMOVED*** | undefined***REMOVED*** name info
	 */
	getNameForExpression(expression) {
		return this.getMemberExpressionInfo(
			expression,
			ALLOWED_MEMBER_TYPES_EXPRESSION
		);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** code source code
	 * @param {ParseOptions***REMOVED*** options parsing options
	 * @returns {Program***REMOVED*** parsed ast
	 */
	static _parse(code, options) {
		const type = options ? options.sourceType : "module";
		/** @type {AcornOptions***REMOVED*** */
		const parserOptions = {
			...defaultParserOptions,
			allowReturnOutsideFunction: type === "script",
			...options,
			sourceType: type === "auto" ? "module" : type
		***REMOVED***;

		/** @type {import("acorn").Program | undefined***REMOVED*** */
		let ast;
		let error;
		let threw = false;
		try {
			ast = parser.parse(code, parserOptions);
		***REMOVED*** catch (err) {
			error = err;
			threw = true;
		***REMOVED***

		if (threw && type === "auto") {
			parserOptions.sourceType = "script";
			if (!("allowReturnOutsideFunction" in options)) {
				parserOptions.allowReturnOutsideFunction = true;
			***REMOVED***
			if (Array.isArray(parserOptions.onComment)) {
				parserOptions.onComment.length = 0;
			***REMOVED***
			try {
				ast = parser.parse(code, parserOptions);
				threw = false;
			***REMOVED*** catch (_err) {
				// we use the error from first parse try
				// so nothing to do here
			***REMOVED***
		***REMOVED***

		if (threw) {
			throw error;
		***REMOVED***

		return /** @type {Program***REMOVED*** */ (ast);
	***REMOVED***
***REMOVED***

module.exports = JavascriptParser;
module.exports.ALLOWED_MEMBER_TYPES_ALL = ALLOWED_MEMBER_TYPES_ALL;
module.exports.ALLOWED_MEMBER_TYPES_EXPRESSION =
	ALLOWED_MEMBER_TYPES_EXPRESSION;
module.exports.ALLOWED_MEMBER_TYPES_CALL_EXPRESSION =
	ALLOWED_MEMBER_TYPES_CALL_EXPRESSION;
module.exports.getImportAttributes = getImportAttributes;
module.exports.VariableInfo = VariableInfo;
