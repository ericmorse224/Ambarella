import type {CodeKeywordDefinition, AnySchema***REMOVED*** from "../../types"
import type {KeywordCxt***REMOVED*** from "../../compile/validate"
import MissingRefError from "../../compile/ref_error"
import {callValidateCode***REMOVED*** from "../code"
import {_, nil, stringify, Code, Name***REMOVED*** from "../../compile/codegen"
import N from "../../compile/names"
import {SchemaEnv, resolveRef***REMOVED*** from "../../compile"
import {mergeEvaluated***REMOVED*** from "../../compile/util"

const def: CodeKeywordDefinition = {
  keyword: "$ref",
  schemaType: "string",
  code(cxt: KeywordCxt): void {
    const {gen, schema: $ref, it***REMOVED*** = cxt
    const {baseId, schemaEnv: env, validateName, opts, self***REMOVED*** = it
    const {root***REMOVED*** = env
    if (($ref === "#" || $ref === "#/") && baseId === root.baseId) return callRootRef()
    const schOrEnv = resolveRef.call(self, root, baseId, $ref)
    if (schOrEnv === undefined) throw new MissingRefError(it.opts.uriResolver, baseId, $ref)
    if (schOrEnv instanceof SchemaEnv) return callValidate(schOrEnv)
    return inlineRefSchema(schOrEnv)

    function callRootRef(): void {
      if (env === root) return callRef(cxt, validateName, env, env.$async)
      const rootName = gen.scopeValue("root", {ref: root***REMOVED***)
      return callRef(cxt, _`${rootName***REMOVED***.validate`, root, root.$async)
    ***REMOVED***

    function callValidate(sch: SchemaEnv): void {
      const v = getValidate(cxt, sch)
      callRef(cxt, v, sch, sch.$async)
    ***REMOVED***

    function inlineRefSchema(sch: AnySchema): void {
      const schName = gen.scopeValue(
        "schema",
        opts.code.source === true ? {ref: sch, code: stringify(sch)***REMOVED*** : {ref: sch***REMOVED***
      )
      const valid = gen.name("valid")
      const schCxt = cxt.subschema(
        {
          schema: sch,
          dataTypes: [],
          schemaPath: nil,
          topSchemaRef: schName,
          errSchemaPath: $ref,
        ***REMOVED***,
        valid
      )
      cxt.mergeEvaluated(schCxt)
      cxt.ok(valid)
    ***REMOVED***
  ***REMOVED***,
***REMOVED***

export function getValidate(cxt: KeywordCxt, sch: SchemaEnv): Code {
  const {gen***REMOVED*** = cxt
  return sch.validate
    ? gen.scopeValue("validate", {ref: sch.validate***REMOVED***)
    : _`${gen.scopeValue("wrapper", {ref: sch***REMOVED***)***REMOVED***.validate`
***REMOVED***

export function callRef(cxt: KeywordCxt, v: Code, sch?: SchemaEnv, $async?: boolean): void {
  const {gen, it***REMOVED*** = cxt
  const {allErrors, schemaEnv: env, opts***REMOVED*** = it
  const passCxt = opts.passContext ? N.this : nil
  if ($async) callAsyncRef()
  else callSyncRef()

  function callAsyncRef(): void {
    if (!env.$async) throw new Error("async schema referenced by sync schema")
    const valid = gen.let("valid")
    gen.try(
      () => {
        gen.code(_`await ${callValidateCode(cxt, v, passCxt)***REMOVED***`)
        addEvaluatedFrom(v) // TODO will not work with async, it has to be returned with the result
        if (!allErrors) gen.assign(valid, true)
      ***REMOVED***,
      (e) => {
        gen.if(_`!(${e***REMOVED*** instanceof ${it.ValidationError as Name***REMOVED***)`, () => gen.throw(e))
        addErrorsFrom(e)
        if (!allErrors) gen.assign(valid, false)
      ***REMOVED***
    )
    cxt.ok(valid)
  ***REMOVED***

  function callSyncRef(): void {
    cxt.result(
      callValidateCode(cxt, v, passCxt),
      () => addEvaluatedFrom(v),
      () => addErrorsFrom(v)
    )
  ***REMOVED***

  function addErrorsFrom(source: Code): void {
    const errs = _`${source***REMOVED***.errors`
    gen.assign(N.vErrors, _`${N.vErrors***REMOVED*** === null ? ${errs***REMOVED*** : ${N.vErrors***REMOVED***.concat(${errs***REMOVED***)`) // TODO tagged
    gen.assign(N.errors, _`${N.vErrors***REMOVED***.length`)
  ***REMOVED***

  function addEvaluatedFrom(source: Code): void {
    if (!it.opts.unevaluated) return
    const schEvaluated = sch?.validate?.evaluated
    // TODO refactor
    if (it.props !== true) {
      if (schEvaluated && !schEvaluated.dynamicProps) {
        if (schEvaluated.props !== undefined) {
          it.props = mergeEvaluated.props(gen, schEvaluated.props, it.props)
        ***REMOVED***
      ***REMOVED*** else {
        const props = gen.var("props", _`${source***REMOVED***.evaluated.props`)
        it.props = mergeEvaluated.props(gen, props, it.props, Name)
      ***REMOVED***
    ***REMOVED***
    if (it.items !== true) {
      if (schEvaluated && !schEvaluated.dynamicItems) {
        if (schEvaluated.items !== undefined) {
          it.items = mergeEvaluated.items(gen, schEvaluated.items, it.items)
        ***REMOVED***
      ***REMOVED*** else {
        const items = gen.var("items", _`${source***REMOVED***.evaluated.items`)
        it.items = mergeEvaluated.items(gen, items, it.items, Name)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***

export default def
