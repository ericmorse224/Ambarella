/**
 * @fileoverview Prevent JSX prop spreading
 * @author Ashish Gambhir
 */

'use strict';

const docsUrl = require('../util/docsUrl');
const report = require('../util/report');

// ------------------------------------------------------------------------------
// Constants
// ------------------------------------------------------------------------------

const OPTIONS = { ignore: 'ignore', enforce: 'enforce' ***REMOVED***;
const DEFAULTS = {
  html: OPTIONS.enforce,
  custom: OPTIONS.enforce,
  explicitSpread: OPTIONS.enforce,
  exceptions: [],
***REMOVED***;

const isException = (tag, allExceptions) => allExceptions.indexOf(tag) !== -1;
const isProperty = (property) => property.type === 'Property';
const getTagNameFromMemberExpression = (node) => {
  if (node.property.parent) {
    return `${node.property.parent.object.name***REMOVED***.${node.property.name***REMOVED***`;
  ***REMOVED***
  // for eslint 3
  return `${node.object.name***REMOVED***.${node.property.name***REMOVED***`;
***REMOVED***;

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

const messages = {
  noSpreading: 'Prop spreading is forbidden',
***REMOVED***;

/** @type {import('eslint').Rule.RuleModule***REMOVED*** */
module.exports = {
  meta: {
    docs: {
      description: 'Disallow JSX prop spreading',
      category: 'Best Practices',
      recommended: false,
      url: docsUrl('jsx-props-no-spreading'),
    ***REMOVED***,

    messages,

    schema: [{
      allOf: [{
        type: 'object',
        properties: {
          html: {
            enum: [OPTIONS.enforce, OPTIONS.ignore],
          ***REMOVED***,
          custom: {
            enum: [OPTIONS.enforce, OPTIONS.ignore],
          ***REMOVED***,
          explicitSpread: {
            enum: [OPTIONS.enforce, OPTIONS.ignore],
          ***REMOVED***,
          exceptions: {
            type: 'array',
            items: {
              type: 'string',
              uniqueItems: true,
            ***REMOVED***,
          ***REMOVED***,
        ***REMOVED***,
      ***REMOVED***, {
        not: {
          type: 'object',
          required: ['html', 'custom'],
          properties: {
            html: {
              enum: [OPTIONS.ignore],
            ***REMOVED***,
            custom: {
              enum: [OPTIONS.ignore],
            ***REMOVED***,
            exceptions: {
              type: 'array',
              minItems: 0,
              maxItems: 0,
            ***REMOVED***,
          ***REMOVED***,
        ***REMOVED***,
      ***REMOVED***],
    ***REMOVED***],
  ***REMOVED***,

  create(context) {
    const configuration = context.options[0] || {***REMOVED***;
    const ignoreHtmlTags = (configuration.html || DEFAULTS.html) === OPTIONS.ignore;
    const ignoreCustomTags = (configuration.custom || DEFAULTS.custom) === OPTIONS.ignore;
    const ignoreExplicitSpread = (configuration.explicitSpread || DEFAULTS.explicitSpread) === OPTIONS.ignore;
    const exceptions = configuration.exceptions || DEFAULTS.exceptions;
    return {
      JSXSpreadAttribute(node) {
        const jsxOpeningElement = node.parent.name;
        const type = jsxOpeningElement.type;

        let tagName;
        if (type === 'JSXIdentifier') {
          tagName = jsxOpeningElement.name;
        ***REMOVED*** else if (type === 'JSXMemberExpression') {
          tagName = getTagNameFromMemberExpression(jsxOpeningElement);
        ***REMOVED*** else {
          tagName = undefined;
        ***REMOVED***

        const isHTMLTag = tagName && tagName[0] !== tagName[0].toUpperCase();
        const isCustomTag = tagName && (tagName[0] === tagName[0].toUpperCase() || tagName.includes('.'));
        if (
          isHTMLTag
          && ((ignoreHtmlTags && !isException(tagName, exceptions))
          || (!ignoreHtmlTags && isException(tagName, exceptions)))
        ) {
          return;
        ***REMOVED***
        if (
          isCustomTag
          && ((ignoreCustomTags && !isException(tagName, exceptions))
          || (!ignoreCustomTags && isException(tagName, exceptions)))
        ) {
          return;
        ***REMOVED***
        if (
          ignoreExplicitSpread
          && node.argument.type === 'ObjectExpression'
          && node.argument.properties.every(isProperty)
        ) {
          return;
        ***REMOVED***
        report(context, messages.noSpreading, 'noSpreading', {
          node,
        ***REMOVED***);
      ***REMOVED***,
    ***REMOVED***;
  ***REMOVED***,
***REMOVED***;
