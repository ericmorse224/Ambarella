/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const {
	DEFAULT_EXPORT,
	NAMESPACE_OBJECT_EXPORT
***REMOVED*** = require("./util/concatenate");

/** @typedef {import("./Module")***REMOVED*** Module */
/** @typedef {import("./optimize/ConcatenatedModule").ConcatenatedModuleInfo***REMOVED*** ConcatenatedModuleInfo */
/** @typedef {import("./optimize/ConcatenatedModule").ModuleInfo***REMOVED*** ModuleInfo */

const MODULE_REFERENCE_REGEXP =
	/^__WEBPACK_MODULE_REFERENCE__(\d+)_([\da-f]+|ns)(_call)?(_directImport)?(?:_asiSafe(\d))?__$/;

/**
 * @typedef {object***REMOVED*** ModuleReferenceOptions
 * @property {string[]***REMOVED*** ids the properties/exports of the module
 * @property {boolean***REMOVED*** call true, when this referenced export is called
 * @property {boolean***REMOVED*** directImport true, when this referenced export is directly imported (not via property access)
 * @property {boolean | undefined***REMOVED*** asiSafe if the position is ASI safe or unknown
 */

class ConcatenationScope {
	/**
	 * @param {ModuleInfo[] | Map<Module, ModuleInfo>***REMOVED*** modulesMap all module info by module
	 * @param {ConcatenatedModuleInfo***REMOVED*** currentModule the current module info
	 */
	constructor(modulesMap, currentModule) {
		this._currentModule = currentModule;
		if (Array.isArray(modulesMap)) {
			const map = new Map();
			for (const info of modulesMap) {
				map.set(info.module, info);
			***REMOVED***
			modulesMap = map;
		***REMOVED***
		this._modulesMap = modulesMap;
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the referenced module
	 * @returns {boolean***REMOVED*** true, when it's in the scope
	 */
	isModuleInScope(module) {
		return this._modulesMap.has(module);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** exportName name of the export
	 * @param {string***REMOVED*** symbol identifier of the export in source code
	 */
	registerExport(exportName, symbol) {
		if (!this._currentModule.exportMap) {
			this._currentModule.exportMap = new Map();
		***REMOVED***
		if (!this._currentModule.exportMap.has(exportName)) {
			this._currentModule.exportMap.set(exportName, symbol);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {string***REMOVED*** exportName name of the export
	 * @param {string***REMOVED*** expression expression to be used
	 */
	registerRawExport(exportName, expression) {
		if (!this._currentModule.rawExportMap) {
			this._currentModule.rawExportMap = new Map();
		***REMOVED***
		if (!this._currentModule.rawExportMap.has(exportName)) {
			this._currentModule.rawExportMap.set(exportName, expression);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {string***REMOVED*** symbol identifier of the export in source code
	 */
	registerNamespaceExport(symbol) {
		this._currentModule.namespaceExportSymbol = symbol;
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the referenced module
	 * @param {Partial<ModuleReferenceOptions>***REMOVED*** options options
	 * @returns {string***REMOVED*** the reference as identifier
	 */
	createModuleReference(
		module,
		{ ids = undefined, call = false, directImport = false, asiSafe = false ***REMOVED***
	) {
		const info = /** @type {ModuleInfo***REMOVED*** */ (this._modulesMap.get(module));
		const callFlag = call ? "_call" : "";
		const directImportFlag = directImport ? "_directImport" : "";
		const asiSafeFlag = asiSafe
			? "_asiSafe1"
			: asiSafe === false
				? "_asiSafe0"
				: "";
		const exportData = ids
			? Buffer.from(JSON.stringify(ids), "utf-8").toString("hex")
			: "ns";
		// a "._" is appended to allow "delete ...", which would cause a SyntaxError in strict mode
		return `__WEBPACK_MODULE_REFERENCE__${info.index***REMOVED***_${exportData***REMOVED***${callFlag***REMOVED***${directImportFlag***REMOVED***${asiSafeFlag***REMOVED***__._`;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** name the identifier
	 * @returns {boolean***REMOVED*** true, when it's an module reference
	 */
	static isModuleReference(name) {
		return MODULE_REFERENCE_REGEXP.test(name);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** name the identifier
	 * @returns {ModuleReferenceOptions & { index: number ***REMOVED*** | null***REMOVED*** parsed options and index
	 */
	static matchModuleReference(name) {
		const match = MODULE_REFERENCE_REGEXP.exec(name);
		if (!match) return null;
		const index = Number(match[1]);
		const asiSafe = match[5];
		return {
			index,
			ids:
				match[2] === "ns"
					? []
					: JSON.parse(Buffer.from(match[2], "hex").toString("utf-8")),
			call: Boolean(match[3]),
			directImport: Boolean(match[4]),
			asiSafe: asiSafe ? asiSafe === "1" : undefined
		***REMOVED***;
	***REMOVED***
***REMOVED***

ConcatenationScope.DEFAULT_EXPORT = DEFAULT_EXPORT;
ConcatenationScope.NAMESPACE_OBJECT_EXPORT = NAMESPACE_OBJECT_EXPORT;

module.exports = ConcatenationScope;
