/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const asyncLib = require("neo-async");
const Queue = require("./util/Queue");

/** @typedef {import("./Compiler")***REMOVED*** Compiler */
/** @typedef {import("./DependenciesBlock")***REMOVED*** DependenciesBlock */
/** @typedef {import("./Dependency")***REMOVED*** Dependency */
/** @typedef {import("./Dependency").ExportSpec***REMOVED*** ExportSpec */
/** @typedef {import("./Dependency").ExportsSpec***REMOVED*** ExportsSpec */
/** @typedef {import("./ExportsInfo")***REMOVED*** ExportsInfo */
/** @typedef {import("./ExportsInfo").RestoreProvidedData***REMOVED*** RestoreProvidedData */
/** @typedef {import("./Module")***REMOVED*** Module */
/** @typedef {import("./Module").BuildInfo***REMOVED*** BuildInfo */

const PLUGIN_NAME = "FlagDependencyExportsPlugin";
const PLUGIN_LOGGER_NAME = `webpack.${PLUGIN_NAME***REMOVED***`;

class FlagDependencyExportsPlugin {
	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {
			const moduleGraph = compilation.moduleGraph;
			const cache = compilation.getCache(PLUGIN_NAME);
			compilation.hooks.finishModules.tapAsync(
				PLUGIN_NAME,
				(modules, callback) => {
					const logger = compilation.getLogger(PLUGIN_LOGGER_NAME);
					let statRestoredFromMemCache = 0;
					let statRestoredFromCache = 0;
					let statNoExports = 0;
					let statFlaggedUncached = 0;
					let statNotCached = 0;
					let statQueueItemsProcessed = 0;

					const { moduleMemCaches ***REMOVED*** = compilation;

					/** @type {Queue<Module>***REMOVED*** */
					const queue = new Queue();

					// Step 1: Try to restore cached provided export info from cache
					logger.time("restore cached provided exports");
					asyncLib.each(
						modules,
						(module, callback) => {
							const exportsInfo = moduleGraph.getExportsInfo(module);
							// If the module doesn't have an exportsType, it's a module
							// without declared exports.
							if (
								(!module.buildMeta || !module.buildMeta.exportsType) &&
								exportsInfo.otherExportsInfo.provided !== null
							) {
								// It's a module without declared exports
								statNoExports++;
								exportsInfo.setHasProvideInfo();
								exportsInfo.setUnknownExportsProvided();
								return callback();
							***REMOVED***
							// If the module has no hash, it's uncacheable
							if (
								typeof (/** @type {BuildInfo***REMOVED*** */ (module.buildInfo).hash) !==
								"string"
							) {
								statFlaggedUncached++;
								// Enqueue uncacheable module for determining the exports
								queue.enqueue(module);
								exportsInfo.setHasProvideInfo();
								return callback();
							***REMOVED***
							const memCache = moduleMemCaches && moduleMemCaches.get(module);
							const memCacheValue = memCache && memCache.get(this);
							if (memCacheValue !== undefined) {
								statRestoredFromMemCache++;
								exportsInfo.restoreProvided(memCacheValue);
								return callback();
							***REMOVED***
							cache.get(
								module.identifier(),
								/** @type {BuildInfo***REMOVED*** */
								(module.buildInfo).hash,
								(err, result) => {
									if (err) return callback(err);

									if (result !== undefined) {
										statRestoredFromCache++;
										exportsInfo.restoreProvided(result);
									***REMOVED*** else {
										statNotCached++;
										// Without cached info enqueue module for determining the exports
										queue.enqueue(module);
										exportsInfo.setHasProvideInfo();
									***REMOVED***
									callback();
								***REMOVED***
							);
						***REMOVED***,
						err => {
							logger.timeEnd("restore cached provided exports");
							if (err) return callback(err);

							/** @type {Set<Module>***REMOVED*** */
							const modulesToStore = new Set();

							/** @type {Map<Module, Set<Module>>***REMOVED*** */
							const dependencies = new Map();

							/** @type {Module***REMOVED*** */
							let module;

							/** @type {ExportsInfo***REMOVED*** */
							let exportsInfo;

							/** @type {Map<Dependency, ExportsSpec>***REMOVED*** */
							const exportsSpecsFromDependencies = new Map();

							let cacheable = true;
							let changed = false;

							/**
							 * @param {DependenciesBlock***REMOVED*** depBlock the dependencies block
							 * @returns {void***REMOVED***
							 */
							const processDependenciesBlock = depBlock => {
								for (const dep of depBlock.dependencies) {
									processDependency(dep);
								***REMOVED***
								for (const block of depBlock.blocks) {
									processDependenciesBlock(block);
								***REMOVED***
							***REMOVED***;

							/**
							 * @param {Dependency***REMOVED*** dep the dependency
							 * @returns {void***REMOVED***
							 */
							const processDependency = dep => {
								const exportDesc = dep.getExports(moduleGraph);
								if (!exportDesc) return;
								exportsSpecsFromDependencies.set(dep, exportDesc);
							***REMOVED***;

							/**
							 * @param {Dependency***REMOVED*** dep dependency
							 * @param {ExportsSpec***REMOVED*** exportDesc info
							 * @returns {void***REMOVED***
							 */
							const processExportsSpec = (dep, exportDesc) => {
								const exports = exportDesc.exports;
								const globalCanMangle = exportDesc.canMangle;
								const globalFrom = exportDesc.from;
								const globalPriority = exportDesc.priority;
								const globalTerminalBinding =
									exportDesc.terminalBinding || false;
								const exportDeps = exportDesc.dependencies;
								if (exportDesc.hideExports) {
									for (const name of exportDesc.hideExports) {
										const exportInfo = exportsInfo.getExportInfo(name);
										exportInfo.unsetTarget(dep);
									***REMOVED***
								***REMOVED***
								if (exports === true) {
									// unknown exports
									if (
										exportsInfo.setUnknownExportsProvided(
											globalCanMangle,
											exportDesc.excludeExports,
											globalFrom && dep,
											globalFrom,
											globalPriority
										)
									) {
										changed = true;
									***REMOVED***
								***REMOVED*** else if (Array.isArray(exports)) {
									/**
									 * merge in new exports
									 * @param {ExportsInfo***REMOVED*** exportsInfo own exports info
									 * @param {(ExportSpec | string)[]***REMOVED*** exports list of exports
									 */
									const mergeExports = (exportsInfo, exports) => {
										for (const exportNameOrSpec of exports) {
											let name;
											let canMangle = globalCanMangle;
											let terminalBinding = globalTerminalBinding;
											let exports;
											let from = globalFrom;
											let fromExport;
											let priority = globalPriority;
											let hidden = false;
											if (typeof exportNameOrSpec === "string") {
												name = exportNameOrSpec;
											***REMOVED*** else {
												name = exportNameOrSpec.name;
												if (exportNameOrSpec.canMangle !== undefined)
													canMangle = exportNameOrSpec.canMangle;
												if (exportNameOrSpec.export !== undefined)
													fromExport = exportNameOrSpec.export;
												if (exportNameOrSpec.exports !== undefined)
													exports = exportNameOrSpec.exports;
												if (exportNameOrSpec.from !== undefined)
													from = exportNameOrSpec.from;
												if (exportNameOrSpec.priority !== undefined)
													priority = exportNameOrSpec.priority;
												if (exportNameOrSpec.terminalBinding !== undefined)
													terminalBinding = exportNameOrSpec.terminalBinding;
												if (exportNameOrSpec.hidden !== undefined)
													hidden = exportNameOrSpec.hidden;
											***REMOVED***
											const exportInfo = exportsInfo.getExportInfo(name);

											if (
												exportInfo.provided === false ||
												exportInfo.provided === null
											) {
												exportInfo.provided = true;
												changed = true;
											***REMOVED***

											if (
												exportInfo.canMangleProvide !== false &&
												canMangle === false
											) {
												exportInfo.canMangleProvide = false;
												changed = true;
											***REMOVED***

											if (terminalBinding && !exportInfo.terminalBinding) {
												exportInfo.terminalBinding = true;
												changed = true;
											***REMOVED***

											if (exports) {
												const nestedExportsInfo =
													exportInfo.createNestedExportsInfo();
												mergeExports(
													/** @type {ExportsInfo***REMOVED*** */ (nestedExportsInfo),
													exports
												);
											***REMOVED***

											if (
												from &&
												(hidden
													? exportInfo.unsetTarget(dep)
													: exportInfo.setTarget(
															dep,
															from,
															fromExport === undefined ? [name] : fromExport,
															priority
														))
											) {
												changed = true;
											***REMOVED***

											// Recalculate target exportsInfo
											const target = exportInfo.getTarget(moduleGraph);
											let targetExportsInfo;
											if (target) {
												const targetModuleExportsInfo =
													moduleGraph.getExportsInfo(target.module);
												targetExportsInfo =
													targetModuleExportsInfo.getNestedExportsInfo(
														target.export
													);
												// add dependency for this module
												const set = dependencies.get(target.module);
												if (set === undefined) {
													dependencies.set(target.module, new Set([module]));
												***REMOVED*** else {
													set.add(module);
												***REMOVED***
											***REMOVED***

											if (exportInfo.exportsInfoOwned) {
												if (
													/** @type {ExportsInfo***REMOVED*** */
													(exportInfo.exportsInfo).setRedirectNamedTo(
														targetExportsInfo
													)
												) {
													changed = true;
												***REMOVED***
											***REMOVED*** else if (exportInfo.exportsInfo !== targetExportsInfo) {
												exportInfo.exportsInfo = targetExportsInfo;
												changed = true;
											***REMOVED***
										***REMOVED***
									***REMOVED***;
									mergeExports(exportsInfo, exports);
								***REMOVED***
								// store dependencies
								if (exportDeps) {
									cacheable = false;
									for (const exportDependency of exportDeps) {
										// add dependency for this module
										const set = dependencies.get(exportDependency);
										if (set === undefined) {
											dependencies.set(exportDependency, new Set([module]));
										***REMOVED*** else {
											set.add(module);
										***REMOVED***
									***REMOVED***
								***REMOVED***
							***REMOVED***;

							const notifyDependencies = () => {
								const deps = dependencies.get(module);
								if (deps !== undefined) {
									for (const dep of deps) {
										queue.enqueue(dep);
									***REMOVED***
								***REMOVED***
							***REMOVED***;

							logger.time("figure out provided exports");
							while (queue.length > 0) {
								module = /** @type {Module***REMOVED*** */ (queue.dequeue());

								statQueueItemsProcessed++;

								exportsInfo = moduleGraph.getExportsInfo(module);

								cacheable = true;
								changed = false;

								exportsSpecsFromDependencies.clear();
								moduleGraph.freeze();
								processDependenciesBlock(module);
								moduleGraph.unfreeze();
								for (const [dep, exportsSpec] of exportsSpecsFromDependencies) {
									processExportsSpec(dep, exportsSpec);
								***REMOVED***

								if (cacheable) {
									modulesToStore.add(module);
								***REMOVED***

								if (changed) {
									notifyDependencies();
								***REMOVED***
							***REMOVED***
							logger.timeEnd("figure out provided exports");

							logger.log(
								`${Math.round(
									(100 * (statFlaggedUncached + statNotCached)) /
										(statRestoredFromMemCache +
											statRestoredFromCache +
											statNotCached +
											statFlaggedUncached +
											statNoExports)
								)***REMOVED***% of exports of modules have been determined (${statNoExports***REMOVED*** no declared exports, ${statNotCached***REMOVED*** not cached, ${statFlaggedUncached***REMOVED*** flagged uncacheable, ${statRestoredFromCache***REMOVED*** from cache, ${statRestoredFromMemCache***REMOVED*** from mem cache, ${
									statQueueItemsProcessed - statNotCached - statFlaggedUncached
								***REMOVED*** additional calculations due to dependencies)`
							);

							logger.time("store provided exports into cache");
							asyncLib.each(
								modulesToStore,
								(module, callback) => {
									if (
										typeof (
											/** @type {BuildInfo***REMOVED*** */
											(module.buildInfo).hash
										) !== "string"
									) {
										// not cacheable
										return callback();
									***REMOVED***
									const cachedData = moduleGraph
										.getExportsInfo(module)
										.getRestoreProvidedData();
									const memCache =
										moduleMemCaches && moduleMemCaches.get(module);
									if (memCache) {
										memCache.set(this, cachedData);
									***REMOVED***
									cache.store(
										module.identifier(),
										/** @type {BuildInfo***REMOVED*** */
										(module.buildInfo).hash,
										cachedData,
										callback
									);
								***REMOVED***,
								err => {
									logger.timeEnd("store provided exports into cache");
									callback(err);
								***REMOVED***
							);
						***REMOVED***
					);
				***REMOVED***
			);

			/** @type {WeakMap<Module, RestoreProvidedData>***REMOVED*** */
			const providedExportsCache = new WeakMap();
			compilation.hooks.rebuildModule.tap(PLUGIN_NAME, module => {
				providedExportsCache.set(
					module,
					moduleGraph.getExportsInfo(module).getRestoreProvidedData()
				);
			***REMOVED***);
			compilation.hooks.finishRebuildingModule.tap(PLUGIN_NAME, module => {
				moduleGraph.getExportsInfo(module).restoreProvided(
					/** @type {RestoreProvidedData***REMOVED*** */
					(providedExportsCache.get(module))
				);
			***REMOVED***);
		***REMOVED***);
	***REMOVED***
***REMOVED***

module.exports = FlagDependencyExportsPlugin;
