/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/

"use strict";

const RuntimeGlobals = require("../RuntimeGlobals");
const RuntimeModule = require("../RuntimeModule");
const Template = require("../Template");
const { first ***REMOVED*** = require("../util/SetHelpers");

/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../Chunk").ChunkId***REMOVED*** ChunkId */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("../Compilation").AssetInfo***REMOVED*** AssetInfo */
/** @typedef {import("../TemplatedPathPlugin").TemplatePath***REMOVED*** TemplatePath */

class GetChunkFilenameRuntimeModule extends RuntimeModule {
	/**
	 * @param {string***REMOVED*** contentType the contentType to use the content hash for
	 * @param {string***REMOVED*** name kind of filename
	 * @param {string***REMOVED*** global function name to be assigned
	 * @param {(chunk: Chunk) => TemplatePath | false***REMOVED*** getFilenameForChunk functor to get the filename or function
	 * @param {boolean***REMOVED*** allChunks when false, only async chunks are included
	 */
	constructor(contentType, name, global, getFilenameForChunk, allChunks) {
		super(`get ${name***REMOVED*** chunk filename`);
		this.contentType = contentType;
		this.global = global;
		this.getFilenameForChunk = getFilenameForChunk;
		this.allChunks = allChunks;
		this.dependentHash = true;
	***REMOVED***

	/**
	 * @returns {string | null***REMOVED*** runtime code
	 */
	generate() {
		const { global, contentType, getFilenameForChunk, allChunks ***REMOVED*** = this;
		const compilation = /** @type {Compilation***REMOVED*** */ (this.compilation);
		const chunkGraph = /** @type {ChunkGraph***REMOVED*** */ (this.chunkGraph);
		const chunk = /** @type {Chunk***REMOVED*** */ (this.chunk);
		const { runtimeTemplate ***REMOVED*** = compilation;

		/** @type {Map<string | TemplatePath, Set<Chunk>>***REMOVED*** */
		const chunkFilenames = new Map();
		let maxChunks = 0;
		/** @type {string | undefined***REMOVED*** */
		let dynamicFilename;

		/**
		 * @param {Chunk***REMOVED*** c the chunk
		 * @returns {void***REMOVED***
		 */
		const addChunk = c => {
			const chunkFilename = getFilenameForChunk(c);
			if (chunkFilename) {
				let set = chunkFilenames.get(chunkFilename);
				if (set === undefined) {
					chunkFilenames.set(chunkFilename, (set = new Set()));
				***REMOVED***
				set.add(c);
				if (typeof chunkFilename === "string") {
					if (set.size < maxChunks) return;
					if (set.size === maxChunks) {
						if (
							chunkFilename.length <
							/** @type {string***REMOVED*** */ (dynamicFilename).length
						) {
							return;
						***REMOVED***

						if (
							chunkFilename.length ===
								/** @type {string***REMOVED*** */ (dynamicFilename).length &&
							chunkFilename < /** @type {string***REMOVED*** */ (dynamicFilename)
						) {
							return;
						***REMOVED***
					***REMOVED***
					maxChunks = set.size;
					dynamicFilename = chunkFilename;
				***REMOVED***
			***REMOVED***
		***REMOVED***;

		/** @type {string[]***REMOVED*** */
		const includedChunksMessages = [];
		if (allChunks) {
			includedChunksMessages.push("all chunks");
			for (const c of chunk.getAllReferencedChunks()) {
				addChunk(c);
			***REMOVED***
		***REMOVED*** else {
			includedChunksMessages.push("async chunks");
			for (const c of chunk.getAllAsyncChunks()) {
				addChunk(c);
			***REMOVED***
			const includeEntries = chunkGraph
				.getTreeRuntimeRequirements(chunk)
				.has(RuntimeGlobals.ensureChunkIncludeEntries);
			if (includeEntries) {
				includedChunksMessages.push("sibling chunks for the entrypoint");
				for (const c of chunkGraph.getChunkEntryDependentChunksIterable(
					chunk
				)) {
					addChunk(c);
				***REMOVED***
			***REMOVED***
		***REMOVED***
		for (const entrypoint of chunk.getAllReferencedAsyncEntrypoints()) {
			addChunk(entrypoint.chunks[entrypoint.chunks.length - 1]);
		***REMOVED***

		/** @type {Map<string, Set<string | number | null>>***REMOVED*** */
		const staticUrls = new Map();
		/** @type {Set<Chunk>***REMOVED*** */
		const dynamicUrlChunks = new Set();

		/**
		 * @param {Chunk***REMOVED*** c the chunk
		 * @param {string | TemplatePath***REMOVED*** chunkFilename the filename template for the chunk
		 * @returns {void***REMOVED***
		 */
		const addStaticUrl = (c, chunkFilename) => {
			/**
			 * @param {string | number***REMOVED*** value a value
			 * @returns {string***REMOVED*** string to put in quotes
			 */
			const unquotedStringify = value => {
				const str = `${value***REMOVED***`;
				if (str.length >= 5 && str === `${c.id***REMOVED***`) {
					// This is shorter and generates the same result
					return '" + chunkId + "';
				***REMOVED***
				const s = JSON.stringify(str);
				return s.slice(1, -1);
			***REMOVED***;
			/**
			 * @param {string***REMOVED*** value string
			 * @returns {(length: number) => string***REMOVED*** string to put in quotes with length
			 */
			const unquotedStringifyWithLength = value => length =>
				unquotedStringify(`${value***REMOVED***`.slice(0, length));
			const chunkFilenameValue =
				typeof chunkFilename === "function"
					? JSON.stringify(
							chunkFilename({
								chunk: c,
								contentHashType: contentType
							***REMOVED***)
						)
					: JSON.stringify(chunkFilename);
			const staticChunkFilename = compilation.getPath(chunkFilenameValue, {
				hash: `" + ${RuntimeGlobals.getFullHash***REMOVED***() + "`,
				hashWithLength: length =>
					`" + ${RuntimeGlobals.getFullHash***REMOVED***().slice(0, ${length***REMOVED***) + "`,
				chunk: {
					id: unquotedStringify(/** @type {ChunkId***REMOVED*** */ (c.id)),
					hash: unquotedStringify(/** @type {string***REMOVED*** */ (c.renderedHash)),
					hashWithLength: unquotedStringifyWithLength(
						/** @type {string***REMOVED*** */ (c.renderedHash)
					),
					name: unquotedStringify(c.name || /** @type {ChunkId***REMOVED*** */ (c.id)),
					contentHash: {
						[contentType]: unquotedStringify(c.contentHash[contentType])
					***REMOVED***,
					contentHashWithLength: {
						[contentType]: unquotedStringifyWithLength(
							c.contentHash[contentType]
						)
					***REMOVED***
				***REMOVED***,
				contentHashType: contentType
			***REMOVED***);
			let set = staticUrls.get(staticChunkFilename);
			if (set === undefined) {
				staticUrls.set(staticChunkFilename, (set = new Set()));
			***REMOVED***
			set.add(c.id);
		***REMOVED***;

		for (const [filename, chunks] of chunkFilenames) {
			if (filename !== dynamicFilename) {
				for (const c of chunks) addStaticUrl(c, filename);
			***REMOVED*** else {
				for (const c of chunks) dynamicUrlChunks.add(c);
			***REMOVED***
		***REMOVED***

		/**
		 * @param {(chunk: Chunk) => string | number***REMOVED*** fn function from chunk to value
		 * @returns {string***REMOVED*** code with static mapping of results of fn
		 */
		const createMap = fn => {
			/** @type {Record<number | string, number | string>***REMOVED*** */
			const obj = {***REMOVED***;
			let useId = false;
			/** @type {number | string | undefined***REMOVED*** */
			let lastKey;
			let entries = 0;
			for (const c of dynamicUrlChunks) {
				const value = fn(c);
				if (value === c.id) {
					useId = true;
				***REMOVED*** else {
					obj[/** @type {number | string***REMOVED*** */ (c.id)] = value;
					lastKey = /** @type {number | string***REMOVED*** */ (c.id);
					entries++;
				***REMOVED***
			***REMOVED***
			if (entries === 0) return "chunkId";
			if (entries === 1) {
				return useId
					? `(chunkId === ${JSON.stringify(lastKey)***REMOVED*** ? ${JSON.stringify(
							obj[/** @type {number | string***REMOVED*** */ (lastKey)]
						)***REMOVED*** : chunkId)`
					: JSON.stringify(obj[/** @type {number | string***REMOVED*** */ (lastKey)]);
			***REMOVED***
			return useId
				? `(${JSON.stringify(obj)***REMOVED***[chunkId] || chunkId)`
				: `${JSON.stringify(obj)***REMOVED***[chunkId]`;
		***REMOVED***;

		/**
		 * @param {(chunk: Chunk) => string | number***REMOVED*** fn function from chunk to value
		 * @returns {string***REMOVED*** code with static mapping of results of fn for including in quoted string
		 */
		const mapExpr = fn => `" + ${createMap(fn)***REMOVED*** + "`;

		/**
		 * @param {(chunk: Chunk) => string | number***REMOVED*** fn function from chunk to value
		 * @returns {(length: number) => string***REMOVED*** function which generates code with static mapping of results of fn for including in quoted string for specific length
		 */
		const mapExprWithLength = fn => length =>
			`" + ${createMap(c => `${fn(c)***REMOVED***`.slice(0, length))***REMOVED*** + "`;

		const url =
			dynamicFilename &&
			compilation.getPath(JSON.stringify(dynamicFilename), {
				hash: `" + ${RuntimeGlobals.getFullHash***REMOVED***() + "`,
				hashWithLength: length =>
					`" + ${RuntimeGlobals.getFullHash***REMOVED***().slice(0, ${length***REMOVED***) + "`,
				chunk: {
					id: '" + chunkId + "',
					hash: mapExpr(c => /** @type {string***REMOVED*** */ (c.renderedHash)),
					hashWithLength: mapExprWithLength(
						c => /** @type {string***REMOVED*** */ (c.renderedHash)
					),
					name: mapExpr(c => c.name || /** @type {number | string***REMOVED*** */ (c.id)),
					contentHash: {
						[contentType]: mapExpr(c => c.contentHash[contentType])
					***REMOVED***,
					contentHashWithLength: {
						[contentType]: mapExprWithLength(c => c.contentHash[contentType])
					***REMOVED***
				***REMOVED***,
				contentHashType: contentType
			***REMOVED***);

		return Template.asString([
			`// This function allow to reference ${includedChunksMessages.join(
				" and "
			)***REMOVED***`,
			`${global***REMOVED*** = ${runtimeTemplate.basicFunction(
				"chunkId",

				staticUrls.size > 0
					? [
							"// return url for filenames not based on template",
							// it minimizes to `x===1?"...":x===2?"...":"..."`
							Template.asString(
								Array.from(staticUrls, ([url, ids]) => {
									const condition =
										ids.size === 1
											? `chunkId === ${JSON.stringify(first(ids))***REMOVED***`
											: `{${Array.from(
													ids,
													id => `${JSON.stringify(id)***REMOVED***:1`
												).join(",")***REMOVED******REMOVED***[chunkId]`;
									return `if (${condition***REMOVED***) return ${url***REMOVED***;`;
								***REMOVED***)
							),
							"// return url for filenames based on template",
							`return ${url***REMOVED***;`
						]
					: ["// return url for filenames based on template", `return ${url***REMOVED***;`]
			)***REMOVED***;`
		]);
	***REMOVED***
***REMOVED***

module.exports = GetChunkFilenameRuntimeModule;
