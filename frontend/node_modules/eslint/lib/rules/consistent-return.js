/**
 * @fileoverview Rule to flag consistent return values
 * @author Nicholas C. Zakas
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");
const { upperCaseFirst ***REMOVED*** = require("../shared/string-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Checks all segments in a set and returns true if all are unreachable.
 * @param {Set<CodePathSegment>***REMOVED*** segments The segments to check.
 * @returns {boolean***REMOVED*** True if all segments are unreachable; false otherwise.
 */
function areAllSegmentsUnreachable(segments) {
	for (const segment of segments) {
		if (segment.reachable) {
			return false;
		***REMOVED***
	***REMOVED***

	return true;
***REMOVED***

/**
 * Checks whether a given node is a `constructor` method in an ES6 class
 * @param {ASTNode***REMOVED*** node A node to check
 * @returns {boolean***REMOVED*** `true` if the node is a `constructor` method
 */
function isClassConstructor(node) {
	return (
		node.type === "FunctionExpression" &&
		node.parent &&
		node.parent.type === "MethodDefinition" &&
		node.parent.kind === "constructor"
	);
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "suggestion",

		docs: {
			description:
				"Require `return` statements to either always or never specify values",
			recommended: false,
			url: "https://eslint.org/docs/latest/rules/consistent-return",
		***REMOVED***,

		schema: [
			{
				type: "object",
				properties: {
					treatUndefinedAsUnspecified: {
						type: "boolean",
					***REMOVED***,
				***REMOVED***,
				additionalProperties: false,
			***REMOVED***,
		],

		defaultOptions: [{ treatUndefinedAsUnspecified: false ***REMOVED***],

		messages: {
			missingReturn: "Expected to return a value at the end of {{name***REMOVED******REMOVED***.",
			missingReturnValue: "{{name***REMOVED******REMOVED*** expected a return value.",
			unexpectedReturnValue: "{{name***REMOVED******REMOVED*** expected no return value.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const [{ treatUndefinedAsUnspecified ***REMOVED***] = context.options;
		let funcInfo = null;

		/**
		 * Checks whether of not the implicit returning is consistent if the last
		 * code path segment is reachable.
		 * @param {ASTNode***REMOVED*** node A program/function node to check.
		 * @returns {void***REMOVED***
		 */
		function checkLastSegment(node) {
			let loc, name;

			/*
			 * Skip if it expected no return value or unreachable.
			 * When unreachable, all paths are returned or thrown.
			 */
			if (
				!funcInfo.hasReturnValue ||
				areAllSegmentsUnreachable(funcInfo.currentSegments) ||
				astUtils.isES5Constructor(node) ||
				isClassConstructor(node)
			) {
				return;
			***REMOVED***

			// Adjust a location and a message.
			if (node.type === "Program") {
				// The head of program.
				loc = { line: 1, column: 0 ***REMOVED***;
				name = "program";
			***REMOVED*** else if (node.type === "ArrowFunctionExpression") {
				// `=>` token
				loc = context.sourceCode.getTokenBefore(
					node.body,
					astUtils.isArrowToken,
				).loc;
			***REMOVED*** else if (
				node.parent.type === "MethodDefinition" ||
				(node.parent.type === "Property" && node.parent.method)
			) {
				// Method name.
				loc = node.parent.key.loc;
			***REMOVED*** else {
				// Function name or `function` keyword.
				loc = (node.id || context.sourceCode.getFirstToken(node)).loc;
			***REMOVED***

			if (!name) {
				name = astUtils.getFunctionNameWithKind(node);
			***REMOVED***

			// Reports.
			context.report({
				node,
				loc,
				messageId: "missingReturn",
				data: { name ***REMOVED***,
			***REMOVED***);
		***REMOVED***

		return {
			// Initializes/Disposes state of each code path.
			onCodePathStart(codePath, node) {
				funcInfo = {
					upper: funcInfo,
					codePath,
					hasReturn: false,
					hasReturnValue: false,
					messageId: "",
					node,
					currentSegments: new Set(),
				***REMOVED***;
			***REMOVED***,
			onCodePathEnd() {
				funcInfo = funcInfo.upper;
			***REMOVED***,

			onUnreachableCodePathSegmentStart(segment) {
				funcInfo.currentSegments.add(segment);
			***REMOVED***,

			onUnreachableCodePathSegmentEnd(segment) {
				funcInfo.currentSegments.delete(segment);
			***REMOVED***,

			onCodePathSegmentStart(segment) {
				funcInfo.currentSegments.add(segment);
			***REMOVED***,

			onCodePathSegmentEnd(segment) {
				funcInfo.currentSegments.delete(segment);
			***REMOVED***,

			// Reports a given return statement if it's inconsistent.
			ReturnStatement(node) {
				const argument = node.argument;
				let hasReturnValue = Boolean(argument);

				if (treatUndefinedAsUnspecified && hasReturnValue) {
					hasReturnValue =
						!astUtils.isSpecificId(argument, "undefined") &&
						argument.operator !== "void";
				***REMOVED***

				if (!funcInfo.hasReturn) {
					funcInfo.hasReturn = true;
					funcInfo.hasReturnValue = hasReturnValue;
					funcInfo.messageId = hasReturnValue
						? "missingReturnValue"
						: "unexpectedReturnValue";
					funcInfo.data = {
						name:
							funcInfo.node.type === "Program"
								? "Program"
								: upperCaseFirst(
										astUtils.getFunctionNameWithKind(
											funcInfo.node,
										),
									),
					***REMOVED***;
				***REMOVED*** else if (funcInfo.hasReturnValue !== hasReturnValue) {
					context.report({
						node,
						messageId: funcInfo.messageId,
						data: funcInfo.data,
					***REMOVED***);
				***REMOVED***
			***REMOVED***,

			// Reports a given program/function if the implicit returning is not consistent.
			"Program:exit": checkLastSegment,
			"FunctionDeclaration:exit": checkLastSegment,
			"FunctionExpression:exit": checkLastSegment,
			"ArrowFunctionExpression:exit": checkLastSegment,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
