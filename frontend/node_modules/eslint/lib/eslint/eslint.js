/**
 * @fileoverview Main class using flat config
 * @author Nicholas C. Zakas
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const fs = require("node:fs/promises");
const { existsSync ***REMOVED*** = require("node:fs");
const path = require("node:path");
const { version ***REMOVED*** = require("../../package.json");
const { Linter ***REMOVED*** = require("../linter");
const { getRuleFromConfig ***REMOVED*** = require("../config/flat-config-helpers");
const { defaultConfig ***REMOVED*** = require("../config/default-config");
const {
	Legacy: {
		ConfigOps: { getRuleSeverity ***REMOVED***,
		ModuleResolver,
		naming,
	***REMOVED***,
***REMOVED*** = require("@eslint/eslintrc");

const {
	findFiles,
	getCacheFile,

	isNonEmptyString,
	isArrayOfNonEmptyString,

	createIgnoreResult,
	isErrorMessage,
	calculateStatsPerFile,

	processOptions,
***REMOVED*** = require("./eslint-helpers");
const { pathToFileURL ***REMOVED*** = require("node:url");
const LintResultCache = require("../cli-engine/lint-result-cache");
const { Retrier ***REMOVED*** = require("@humanwhocodes/retry");
const { ConfigLoader, LegacyConfigLoader ***REMOVED*** = require("../config/config-loader");

/*
 * This is necessary to allow overwriting writeFile for testing purposes.
 * We can just use fs/promises once we drop Node.js 12 support.
 */

//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

// For VSCode IntelliSense
/**
 * @import { ConfigArray ***REMOVED*** from "../cli-engine/cli-engine.js";
 * @import { CLIEngineLintReport ***REMOVED*** from "./legacy-eslint.js";
 * @import { FlatConfigArray ***REMOVED*** from "../config/flat-config-array.js";
 * @import { RuleDefinition ***REMOVED*** from "@eslint/core";
 * @import { ConfigData, DeprecatedRuleInfo, LintMessage, LintResult, ResultsMeta ***REMOVED*** from "../shared/types.js";
 */

/** @typedef {ReturnType<ConfigArray.extractConfig>***REMOVED*** ExtractedConfig */
/** @typedef {import("../types").ESLint.Plugin***REMOVED*** Plugin */

/**
 * The options with which to configure the ESLint instance.
 * @typedef {Object***REMOVED*** ESLintOptions
 * @property {boolean***REMOVED*** [allowInlineConfig] Enable or disable inline configuration comments.
 * @property {ConfigData|Array<ConfigData>***REMOVED*** [baseConfig] Base config, extended by all configs used with this instance
 * @property {boolean***REMOVED*** [cache] Enable result caching.
 * @property {string***REMOVED*** [cacheLocation] The cache file to use instead of .eslintcache.
 * @property {"metadata" | "content"***REMOVED*** [cacheStrategy] The strategy used to detect changed files.
 * @property {string***REMOVED*** [cwd] The value to use for the current working directory.
 * @property {boolean***REMOVED*** [errorOnUnmatchedPattern] If `false` then `ESLint#lintFiles()` doesn't throw even if no target files found. Defaults to `true`.
 * @property {boolean|Function***REMOVED*** [fix] Execute in autofix mode. If a function, should return a boolean.
 * @property {string[]***REMOVED*** [fixTypes] Array of rule types to apply fixes for.
 * @property {string[]***REMOVED*** [flags] Array of feature flags to enable.
 * @property {boolean***REMOVED*** [globInputPaths] Set to false to skip glob resolution of input file paths to lint (default: true). If false, each input file paths is assumed to be a non-glob path to an existing file.
 * @property {boolean***REMOVED*** [ignore] False disables all ignore patterns except for the default ones.
 * @property {string[]***REMOVED*** [ignorePatterns] Ignore file patterns to use in addition to config ignores. These patterns are relative to `cwd`.
 * @property {ConfigData|Array<ConfigData>***REMOVED*** [overrideConfig] Override config, overrides all configs used with this instance
 * @property {boolean|string***REMOVED*** [overrideConfigFile] Searches for default config file when falsy;
 *      doesn't do any config file lookup when `true`; considered to be a config filename
 *      when a string.
 * @property {Record<string,Plugin>***REMOVED*** [plugins] An array of plugin implementations.
 * @property {boolean***REMOVED*** [stats] True enables added statistics on lint results.
 * @property {boolean***REMOVED*** [warnIgnored] Show warnings when the file list includes ignored files
 * @property {boolean***REMOVED*** [passOnNoPatterns=false] When set to true, missing patterns cause
 *      the linting operation to short circuit and not report any failures.
 */

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const debug = require("debug")("eslint:eslint");
const privateMembers = new WeakMap();
const removedFormatters = new Set([
	"checkstyle",
	"codeframe",
	"compact",
	"jslint-xml",
	"junit",
	"table",
	"tap",
	"unix",
	"visualstudio",
]);

/**
 * Create rulesMeta object.
 * @param {Map<string,RuleDefinition>***REMOVED*** rules a map of rules from which to generate the object.
 * @returns {Object***REMOVED*** metadata for all enabled rules.
 */
function createRulesMeta(rules) {
	return Array.from(rules).reduce((retVal, [id, rule]) => {
		retVal[id] = rule.meta;
		return retVal;
	***REMOVED***, {***REMOVED***);
***REMOVED***

/**
 * Return the absolute path of a file named `"__placeholder__.js"` in a given directory.
 * This is used as a replacement for a missing file path.
 * @param {string***REMOVED*** cwd An absolute directory path.
 * @returns {string***REMOVED*** The absolute path of a file named `"__placeholder__.js"` in the given directory.
 */
function getPlaceholderPath(cwd) {
	return path.join(cwd, "__placeholder__.js");
***REMOVED***

/** @type {WeakMap<ExtractedConfig, DeprecatedRuleInfo[]>***REMOVED*** */
const usedDeprecatedRulesCache = new WeakMap();

/**
 * Create used deprecated rule list.
 * @param {ESLint***REMOVED*** eslint The ESLint instance.
 * @param {string***REMOVED*** maybeFilePath The absolute path to a lint target file or `"<text>"`.
 * @returns {DeprecatedRuleInfo[]***REMOVED*** The used deprecated rule list.
 */
function getOrFindUsedDeprecatedRules(eslint, maybeFilePath) {
	const {
		options: { cwd ***REMOVED***,
		configLoader,
	***REMOVED*** = privateMembers.get(eslint);
	const filePath = path.isAbsolute(maybeFilePath)
		? maybeFilePath
		: getPlaceholderPath(cwd);
	const configs = configLoader.getCachedConfigArrayForFile(filePath);
	const config = configs.getConfig(filePath);

	// Most files use the same config, so cache it.
	if (config && !usedDeprecatedRulesCache.has(config)) {
		const retv = [];

		if (config.rules) {
			for (const [ruleId, ruleConf] of Object.entries(config.rules)) {
				if (getRuleSeverity(ruleConf) === 0) {
					continue;
				***REMOVED***
				const rule = getRuleFromConfig(ruleId, config);
				const meta = rule && rule.meta;

				if (meta && meta.deprecated) {
					const usesNewFormat = typeof meta.deprecated === "object";

					retv.push({
						ruleId,
						replacedBy: usesNewFormat
							? (meta.deprecated.replacedBy?.map(
									replacement =>
										`${replacement.plugin?.name !== void 0 ? `${naming.getShorthandName(replacement.plugin.name, "eslint-plugin")***REMOVED***/` : ""***REMOVED***${replacement.rule?.name ?? ""***REMOVED***`,
								) ?? [])
							: meta.replacedBy || [],
						info: usesNewFormat ? meta.deprecated : void 0,
					***REMOVED***);
				***REMOVED***
			***REMOVED***
		***REMOVED***

		usedDeprecatedRulesCache.set(config, Object.freeze(retv));
	***REMOVED***

	return config ? usedDeprecatedRulesCache.get(config) : Object.freeze([]);
***REMOVED***

/**
 * Processes the linting results generated by a CLIEngine linting report to
 * match the ESLint class's API.
 * @param {ESLint***REMOVED*** eslint The ESLint instance.
 * @param {CLIEngineLintReport***REMOVED*** report The CLIEngine linting report to process.
 * @returns {LintResult[]***REMOVED*** The processed linting results.
 */
function processLintReport(eslint, { results ***REMOVED***) {
	const descriptor = {
		configurable: true,
		enumerable: true,
		get() {
			return getOrFindUsedDeprecatedRules(eslint, this.filePath);
		***REMOVED***,
	***REMOVED***;

	for (const result of results) {
		Object.defineProperty(result, "usedDeprecatedRules", descriptor);
	***REMOVED***

	return results;
***REMOVED***

/**
 * An Array.prototype.sort() compatible compare function to order results by their file path.
 * @param {LintResult***REMOVED*** a The first lint result.
 * @param {LintResult***REMOVED*** b The second lint result.
 * @returns {number***REMOVED*** An integer representing the order in which the two results should occur.
 */
function compareResultsByFilePath(a, b) {
	if (a.filePath < b.filePath) {
		return -1;
	***REMOVED***

	if (a.filePath > b.filePath) {
		return 1;
	***REMOVED***

	return 0;
***REMOVED***

/**
 * Determines which config file to use. This is determined by seeing if an
 * override config file was passed, and if so, using it; otherwise, as long
 * as override config file is not explicitly set to `false`, it will search
 * upwards from the cwd for a file named `eslint.config.js`.
 *
 * This function is used primarily by the `--inspect-config` option. For now,
 * we will maintain the existing behavior, which is to search up from the cwd.
 * @param {ESLintOptions***REMOVED*** options The ESLint instance options.
 * @returns {Promise<{configFilePath:string|undefined;basePath:string***REMOVED***>***REMOVED*** Location information for
 *      the config file.
 */
async function locateConfigFileToUse({ configFile, cwd ***REMOVED***) {
	const configLoader = new ConfigLoader({
		cwd,
		configFile,
	***REMOVED***);

	const configFilePath = await configLoader.findConfigFileForPath(
		path.join(cwd, "__placeholder__.js"),
	);

	if (!configFilePath) {
		throw new Error("No ESLint configuration file was found.");
	***REMOVED***

	return {
		configFilePath,
		basePath: configFile ? cwd : path.dirname(configFilePath),
	***REMOVED***;
***REMOVED***

/**
 * Processes an source code using ESLint.
 * @param {Object***REMOVED*** config The config object.
 * @param {string***REMOVED*** config.text The source code to verify.
 * @param {string***REMOVED*** config.cwd The path to the current working directory.
 * @param {string|undefined***REMOVED*** config.filePath The path to the file of `text`. If this is undefined, it uses `<text>`.
 * @param {FlatConfigArray***REMOVED*** config.configs The config.
 * @param {boolean***REMOVED*** config.fix If `true` then it does fix.
 * @param {boolean***REMOVED*** config.allowInlineConfig If `true` then it uses directive comments.
 * @param {Function***REMOVED*** config.ruleFilter A predicate function to filter which rules should be run.
 * @param {boolean***REMOVED*** config.stats If `true`, then if reports extra statistics with the lint results.
 * @param {Linter***REMOVED*** config.linter The linter instance to verify.
 * @returns {LintResult***REMOVED*** The result of linting.
 * @private
 */
function verifyText({
	text,
	cwd,
	filePath: providedFilePath,
	configs,
	fix,
	allowInlineConfig,
	ruleFilter,
	stats,
	linter,
***REMOVED***) {
	const filePath = providedFilePath || "<text>";

	debug(`Lint ${filePath***REMOVED***`);

	/*
	 * Verify.
	 * `config.extractConfig(filePath)` requires an absolute path, but `linter`
	 * doesn't know CWD, so it gives `linter` an absolute path always.
	 */
	const filePathToVerify =
		filePath === "<text>" ? getPlaceholderPath(cwd) : filePath;
	const { fixed, messages, output ***REMOVED*** = linter.verifyAndFix(text, configs, {
		allowInlineConfig,
		filename: filePathToVerify,
		fix,
		ruleFilter,
		stats,

		/**
		 * Check if the linter should adopt a given code block or not.
		 * @param {string***REMOVED*** blockFilename The virtual filename of a code block.
		 * @returns {boolean***REMOVED*** `true` if the linter should adopt the code block.
		 */
		filterCodeBlock(blockFilename) {
			return configs.getConfig(blockFilename) !== void 0;
		***REMOVED***,
	***REMOVED***);

	// Tweak and return.
	const result = {
		filePath: filePath === "<text>" ? filePath : path.resolve(filePath),
		messages,
		suppressedMessages: linter.getSuppressedMessages(),
		...calculateStatsPerFile(messages),
	***REMOVED***;

	if (fixed) {
		result.output = output;
	***REMOVED***

	if (
		result.errorCount + result.warningCount > 0 &&
		typeof result.output === "undefined"
	) {
		result.source = text;
	***REMOVED***

	if (stats) {
		result.stats = {
			times: linter.getTimes(),
			fixPasses: linter.getFixPassCount(),
		***REMOVED***;
	***REMOVED***

	return result;
***REMOVED***

/**
 * Checks whether a message's rule type should be fixed.
 * @param {LintMessage***REMOVED*** message The message to check.
 * @param {FlatConfigArray***REMOVED*** config The config for the file that generated the message.
 * @param {string[]***REMOVED*** fixTypes An array of fix types to check.
 * @returns {boolean***REMOVED*** Whether the message should be fixed.
 */
function shouldMessageBeFixed(message, config, fixTypes) {
	if (!message.ruleId) {
		return fixTypes.has("directive");
	***REMOVED***

	const rule = message.ruleId && getRuleFromConfig(message.ruleId, config);

	return Boolean(rule && rule.meta && fixTypes.has(rule.meta.type));
***REMOVED***

/**
 * Creates an error to be thrown when an array of results passed to `getRulesMetaForResults` was not created by the current engine.
 * @returns {TypeError***REMOVED*** An error object.
 */
function createExtraneousResultsError() {
	return new TypeError(
		"Results object was not created from this ESLint instance.",
	);
***REMOVED***

/**
 * Creates a fixer function based on the provided fix, fixTypesSet, and config.
 * @param {Function|boolean***REMOVED*** fix The original fix option.
 * @param {Set<string>***REMOVED*** fixTypesSet A set of fix types to filter messages for fixing.
 * @param {FlatConfigArray***REMOVED*** config The config for the file that generated the message.
 * @returns {Function|boolean***REMOVED*** The fixer function or the original fix value.
 */
function getFixerForFixTypes(fix, fixTypesSet, config) {
	if (!fix || !fixTypesSet) {
		return fix;
	***REMOVED***

	const originalFix = typeof fix === "function" ? fix : () => true;

	return message =>
		shouldMessageBeFixed(message, config, fixTypesSet) &&
		originalFix(message);
***REMOVED***

//-----------------------------------------------------------------------------
// Main API
//-----------------------------------------------------------------------------

/**
 * Primary Node.js API for ESLint.
 */
class ESLint {
	/**
	 * The type of configuration used by this class.
	 * @type {string***REMOVED***
	 */
	static configType = "flat";

	/**
	 * The loader to use for finding config files.
	 * @type {ConfigLoader|LegacyConfigLoader***REMOVED***
	 */
	#configLoader;

	/**
	 * Creates a new instance of the main ESLint API.
	 * @param {ESLintOptions***REMOVED*** options The options for this instance.
	 */
	constructor(options = {***REMOVED***) {
		const defaultConfigs = [];
		const processedOptions = processOptions(options);
		const linter = new Linter({
			cwd: processedOptions.cwd,
			configType: "flat",
			flags: processedOptions.flags,
		***REMOVED***);

		const cacheFilePath = getCacheFile(
			processedOptions.cacheLocation,
			processedOptions.cwd,
		);

		const lintResultCache = processedOptions.cache
			? new LintResultCache(cacheFilePath, processedOptions.cacheStrategy)
			: null;

		const configLoaderOptions = {
			cwd: processedOptions.cwd,
			baseConfig: processedOptions.baseConfig,
			overrideConfig: processedOptions.overrideConfig,
			configFile: processedOptions.configFile,
			ignoreEnabled: processedOptions.ignore,
			ignorePatterns: processedOptions.ignorePatterns,
			defaultConfigs,
			hasUnstableNativeNodeJsTSConfigFlag: linter.hasFlag(
				"unstable_native_nodejs_ts_config",
			),
		***REMOVED***;

		this.#configLoader = linter.hasFlag("unstable_config_lookup_from_file")
			? new ConfigLoader(configLoaderOptions)
			: new LegacyConfigLoader(configLoaderOptions);

		debug(`Using config loader ${this.#configLoader.constructor.name***REMOVED***`);

		privateMembers.set(this, {
			options: processedOptions,
			linter,
			cacheFilePath,
			lintResultCache,
			defaultConfigs,
			configs: null,
			configLoader: this.#configLoader,
		***REMOVED***);

		/**
		 * If additional plugins are passed in, add that to the default
		 * configs for this instance.
		 */
		if (options.plugins) {
			const plugins = {***REMOVED***;

			for (const [pluginName, plugin] of Object.entries(
				options.plugins,
			)) {
				plugins[naming.getShorthandName(pluginName, "eslint-plugin")] =
					plugin;
			***REMOVED***

			defaultConfigs.push({
				plugins,
			***REMOVED***);
		***REMOVED***

		// Check for the .eslintignore file, and warn if it's present.
		if (existsSync(path.resolve(processedOptions.cwd, ".eslintignore"))) {
			process.emitWarning(
				'The ".eslintignore" file is no longer supported. Switch to using the "ignores" property in "eslint.config.js": https://eslint.org/docs/latest/use/configure/migration-guide#ignoring-files',
				"ESLintIgnoreWarning",
			);
		***REMOVED***
	***REMOVED***

	/**
	 * The version text.
	 * @type {string***REMOVED***
	 */
	static get version() {
		return version;
	***REMOVED***

	/**
	 * The default configuration that ESLint uses internally. This is provided for tooling that wants to calculate configurations using the same defaults as ESLint.
	 * Keep in mind that the default configuration may change from version to version, so you shouldn't rely on any particular keys or values to be present.
	 * @type {ConfigArray***REMOVED***
	 */
	static get defaultConfig() {
		return defaultConfig;
	***REMOVED***

	/**
	 * Outputs fixes from the given results to files.
	 * @param {LintResult[]***REMOVED*** results The lint results.
	 * @returns {Promise<void>***REMOVED*** Returns a promise that is used to track side effects.
	 */
	static async outputFixes(results) {
		if (!Array.isArray(results)) {
			throw new Error("'results' must be an array");
		***REMOVED***

		await Promise.all(
			results
				.filter(result => {
					if (typeof result !== "object" || result === null) {
						throw new Error("'results' must include only objects");
					***REMOVED***
					return (
						typeof result.output === "string" &&
						path.isAbsolute(result.filePath)
					);
				***REMOVED***)
				.map(r => fs.writeFile(r.filePath, r.output)),
		);
	***REMOVED***

	/**
	 * Returns results that only contains errors.
	 * @param {LintResult[]***REMOVED*** results The results to filter.
	 * @returns {LintResult[]***REMOVED*** The filtered results.
	 */
	static getErrorResults(results) {
		const filtered = [];

		results.forEach(result => {
			const filteredMessages = result.messages.filter(isErrorMessage);
			const filteredSuppressedMessages =
				result.suppressedMessages.filter(isErrorMessage);

			if (filteredMessages.length > 0) {
				filtered.push({
					...result,
					messages: filteredMessages,
					suppressedMessages: filteredSuppressedMessages,
					errorCount: filteredMessages.length,
					warningCount: 0,
					fixableErrorCount: result.fixableErrorCount,
					fixableWarningCount: 0,
				***REMOVED***);
			***REMOVED***
		***REMOVED***);

		return filtered;
	***REMOVED***

	/**
	 * Returns meta objects for each rule represented in the lint results.
	 * @param {LintResult[]***REMOVED*** results The results to fetch rules meta for.
	 * @returns {Object***REMOVED*** A mapping of ruleIds to rule meta objects.
	 * @throws {TypeError***REMOVED*** When the results object wasn't created from this ESLint instance.
	 * @throws {TypeError***REMOVED*** When a plugin or rule is missing.
	 */
	getRulesMetaForResults(results) {
		// short-circuit simple case
		if (results.length === 0) {
			return {***REMOVED***;
		***REMOVED***

		const resultRules = new Map();
		const {
			configLoader,
			options: { cwd ***REMOVED***,
		***REMOVED*** = privateMembers.get(this);

		for (const result of results) {
			/*
			 * Normalize filename for <text>.
			 */
			const filePath =
				result.filePath === "<text>"
					? getPlaceholderPath(cwd)
					: result.filePath;
			const allMessages = result.messages.concat(
				result.suppressedMessages,
			);

			for (const { ruleId ***REMOVED*** of allMessages) {
				if (!ruleId) {
					continue;
				***REMOVED***

				/*
				 * All of the plugin and rule information is contained within the
				 * calculated config for the given file.
				 */
				let configs;

				try {
					configs =
						configLoader.getCachedConfigArrayForFile(filePath);
				***REMOVED*** catch {
					throw createExtraneousResultsError();
				***REMOVED***

				const config = configs.getConfig(filePath);

				if (!config) {
					throw createExtraneousResultsError();
				***REMOVED***
				const rule = getRuleFromConfig(ruleId, config);

				// ignore unknown rules
				if (rule) {
					resultRules.set(ruleId, rule);
				***REMOVED***
			***REMOVED***
		***REMOVED***

		return createRulesMeta(resultRules);
	***REMOVED***

	/**
	 * Indicates if the given feature flag is enabled for this instance.
	 * @param {string***REMOVED*** flag The feature flag to check.
	 * @returns {boolean***REMOVED*** `true` if the feature flag is enabled, `false` if not.
	 */
	hasFlag(flag) {
		// note: Linter does validation of the flags
		return privateMembers.get(this).linter.hasFlag(flag);
	***REMOVED***

	/**
	 * Executes the current configuration on an array of file and directory names.
	 * @param {string|string[]***REMOVED*** patterns An array of file and directory names.
	 * @returns {Promise<LintResult[]>***REMOVED*** The results of linting the file patterns given.
	 */
	async lintFiles(patterns) {
		let normalizedPatterns = patterns;
		const {
			cacheFilePath,
			lintResultCache,
			linter,
			options: eslintOptions,
		***REMOVED*** = privateMembers.get(this);

		/*
		 * Special cases:
		 * 1. `patterns` is an empty string
		 * 2. `patterns` is an empty array
		 *
		 * In both cases, we use the cwd as the directory to lint.
		 */
		if (
			patterns === "" ||
			(Array.isArray(patterns) && patterns.length === 0)
		) {
			/*
			 * Special case: If `passOnNoPatterns` is true, then we just exit
			 * without doing any work.
			 */
			if (eslintOptions.passOnNoPatterns) {
				return [];
			***REMOVED***

			normalizedPatterns = ["."];
		***REMOVED*** else {
			if (
				!isNonEmptyString(patterns) &&
				!isArrayOfNonEmptyString(patterns)
			) {
				throw new Error(
					"'patterns' must be a non-empty string or an array of non-empty strings",
				);
			***REMOVED***

			if (typeof patterns === "string") {
				normalizedPatterns = [patterns];
			***REMOVED***
		***REMOVED***

		debug(`Using file patterns: ${normalizedPatterns***REMOVED***`);

		const {
			allowInlineConfig,
			cache,
			cwd,
			fix,
			fixTypes,
			ruleFilter,
			stats,
			globInputPaths,
			errorOnUnmatchedPattern,
			warnIgnored,
		***REMOVED*** = eslintOptions;
		const startTime = Date.now();
		const fixTypesSet = fixTypes ? new Set(fixTypes) : null;

		// Delete cache file; should this be done here?
		if (!cache && cacheFilePath) {
			debug(`Deleting cache file at ${cacheFilePath***REMOVED***`);

			try {
				if (existsSync(cacheFilePath)) {
					await fs.unlink(cacheFilePath);
				***REMOVED***
			***REMOVED*** catch (error) {
				if (existsSync(cacheFilePath)) {
					throw error;
				***REMOVED***
			***REMOVED***
		***REMOVED***

		const filePaths = await findFiles({
			patterns: normalizedPatterns,
			cwd,
			globInputPaths,
			configLoader: this.#configLoader,
			errorOnUnmatchedPattern,
		***REMOVED***);
		const controller = new AbortController();
		const retryCodes = new Set(["ENFILE", "EMFILE"]);
		const retrier = new Retrier(error => retryCodes.has(error.code), {
			concurrency: 100,
		***REMOVED***);

		debug(
			`${filePaths.length***REMOVED*** files found in: ${Date.now() - startTime***REMOVED***ms`,
		);

		/*
		 * Because we need to process multiple files, including reading from disk,
		 * it is most efficient to start by reading each file via promises so that
		 * they can be done in parallel. Then, we can lint the returned text. This
		 * ensures we are waiting the minimum amount of time in between lints.
		 */
		const results = await Promise.all(
			filePaths.map(async filePath => {
				const configs =
					await this.#configLoader.loadConfigArrayForFile(filePath);
				const config = configs.getConfig(filePath);

				/*
				 * If a filename was entered that cannot be matched
				 * to a config, then notify the user.
				 */
				if (!config) {
					if (warnIgnored) {
						const configStatus = configs.getConfigStatus(filePath);

						return createIgnoreResult(filePath, cwd, configStatus);
					***REMOVED***

					return void 0;
				***REMOVED***

				// Skip if there is cached result.
				if (lintResultCache) {
					const cachedResult = lintResultCache.getCachedLintResults(
						filePath,
						config,
					);

					if (cachedResult) {
						const hadMessages =
							cachedResult.messages &&
							cachedResult.messages.length > 0;

						if (hadMessages && fix) {
							debug(
								`Reprocessing cached file to allow autofix: ${filePath***REMOVED***`,
							);
						***REMOVED*** else {
							debug(
								`Skipping file since it hasn't changed: ${filePath***REMOVED***`,
							);
							return cachedResult;
						***REMOVED***
					***REMOVED***
				***REMOVED***

				// set up fixer for fixTypes if necessary
				const fixer = getFixerForFixTypes(fix, fixTypesSet, config);

				return retrier
					.retry(
						() =>
							fs
								.readFile(filePath, {
									encoding: "utf8",
									signal: controller.signal,
								***REMOVED***)
								.then(text => {
									// fail immediately if an error occurred in another file
									controller.signal.throwIfAborted();

									// do the linting
									const result = verifyText({
										text,
										filePath,
										configs,
										cwd,
										fix: fixer,
										allowInlineConfig,
										ruleFilter,
										stats,
										linter,
									***REMOVED***);

									/*
									 * Store the lint result in the LintResultCache.
									 * NOTE: The LintResultCache will remove the file source and any
									 * other properties that are difficult to serialize, and will
									 * hydrate those properties back in on future lint runs.
									 */
									if (lintResultCache) {
										lintResultCache.setCachedLintResults(
											filePath,
											config,
											result,
										);
									***REMOVED***

									return result;
								***REMOVED***),
						{ signal: controller.signal ***REMOVED***,
					)
					.catch(error => {
						controller.abort(error);
						throw error;
					***REMOVED***);
			***REMOVED***),
		);

		// Persist the cache to disk.
		if (lintResultCache) {
			lintResultCache.reconcile();
		***REMOVED***

		const finalResults = results.filter(result => !!result);

		return processLintReport(this, {
			results: finalResults,
		***REMOVED***);
	***REMOVED***

	/**
	 * Executes the current configuration on text.
	 * @param {string***REMOVED*** code A string of JavaScript code to lint.
	 * @param {Object***REMOVED*** [options] The options.
	 * @param {string***REMOVED*** [options.filePath] The path to the file of the source code.
	 * @param {boolean***REMOVED*** [options.warnIgnored] When set to true, warn if given filePath is an ignored path.
	 * @returns {Promise<LintResult[]>***REMOVED*** The results of linting the string of code given.
	 */
	async lintText(code, options = {***REMOVED***) {
		// Parameter validation

		if (typeof code !== "string") {
			throw new Error("'code' must be a string");
		***REMOVED***

		if (typeof options !== "object") {
			throw new Error("'options' must be an object, null, or undefined");
		***REMOVED***

		// Options validation

		const { filePath, warnIgnored, ...unknownOptions ***REMOVED*** = options || {***REMOVED***;

		const unknownOptionKeys = Object.keys(unknownOptions);

		if (unknownOptionKeys.length > 0) {
			throw new Error(
				`'options' must not include the unknown option(s): ${unknownOptionKeys.join(", ")***REMOVED***`,
			);
		***REMOVED***

		if (filePath !== void 0 && !isNonEmptyString(filePath)) {
			throw new Error(
				"'options.filePath' must be a non-empty string or undefined",
			);
		***REMOVED***

		if (
			typeof warnIgnored !== "boolean" &&
			typeof warnIgnored !== "undefined"
		) {
			throw new Error(
				"'options.warnIgnored' must be a boolean or undefined",
			);
		***REMOVED***

		// Now we can get down to linting

		const { linter, options: eslintOptions ***REMOVED*** = privateMembers.get(this);
		const {
			allowInlineConfig,
			cwd,
			fix,
			fixTypes,
			warnIgnored: constructorWarnIgnored,
			ruleFilter,
			stats,
		***REMOVED*** = eslintOptions;
		const results = [];
		const startTime = Date.now();
		const fixTypesSet = fixTypes ? new Set(fixTypes) : null;
		const resolvedFilename = path.resolve(
			cwd,
			filePath || "__placeholder__.js",
		);
		const configs =
			await this.#configLoader.loadConfigArrayForFile(resolvedFilename);
		const configStatus =
			configs?.getConfigStatus(resolvedFilename) ?? "unconfigured";

		// Clear the last used config arrays.
		if (resolvedFilename && configStatus !== "matched") {
			const shouldWarnIgnored =
				typeof warnIgnored === "boolean"
					? warnIgnored
					: constructorWarnIgnored;

			if (shouldWarnIgnored) {
				results.push(
					createIgnoreResult(resolvedFilename, cwd, configStatus),
				);
			***REMOVED***
		***REMOVED*** else {
			const config = configs.getConfig(resolvedFilename);
			const fixer = getFixerForFixTypes(fix, fixTypesSet, config);

			// Do lint.
			results.push(
				verifyText({
					text: code,
					filePath: resolvedFilename.endsWith("__placeholder__.js")
						? "<text>"
						: resolvedFilename,
					configs,
					cwd,
					fix: fixer,
					allowInlineConfig,
					ruleFilter,
					stats,
					linter,
				***REMOVED***),
			);
		***REMOVED***

		debug(`Linting complete in: ${Date.now() - startTime***REMOVED***ms`);

		return processLintReport(this, {
			results,
		***REMOVED***);
	***REMOVED***

	/**
	 * Returns the formatter representing the given formatter name.
	 * @param {string***REMOVED*** [name] The name of the formatter to load.
	 * The following values are allowed:
	 * - `undefined` ... Load `stylish` builtin formatter.
	 * - A builtin formatter name ... Load the builtin formatter.
	 * - A third-party formatter name:
	 *   - `foo` → `eslint-formatter-foo`
	 *   - `@foo` → `@foo/eslint-formatter`
	 *   - `@foo/bar` → `@foo/eslint-formatter-bar`
	 * - A file path ... Load the file.
	 * @returns {Promise<Formatter>***REMOVED*** A promise resolving to the formatter object.
	 * This promise will be rejected if the given formatter was not found or not
	 * a function.
	 */
	async loadFormatter(name = "stylish") {
		if (typeof name !== "string") {
			throw new Error("'name' must be a string");
		***REMOVED***

		// replace \ with / for Windows compatibility
		const normalizedFormatName = name.replace(/\\/gu, "/");
		const namespace = naming.getNamespaceFromTerm(normalizedFormatName);

		// grab our options
		const { cwd ***REMOVED*** = privateMembers.get(this).options;

		let formatterPath;

		// if there's a slash, then it's a file (TODO: this check seems dubious for scoped npm packages)
		if (!namespace && normalizedFormatName.includes("/")) {
			formatterPath = path.resolve(cwd, normalizedFormatName);
		***REMOVED*** else {
			try {
				const npmFormat = naming.normalizePackageName(
					normalizedFormatName,
					"eslint-formatter",
				);

				// TODO: This is pretty dirty...would be nice to clean up at some point.
				formatterPath = ModuleResolver.resolve(
					npmFormat,
					getPlaceholderPath(cwd),
				);
			***REMOVED*** catch {
				formatterPath = path.resolve(
					__dirname,
					"../",
					"cli-engine",
					"formatters",
					`${normalizedFormatName***REMOVED***.js`,
				);
			***REMOVED***
		***REMOVED***

		let formatter;

		try {
			formatter = (await import(pathToFileURL(formatterPath))).default;
		***REMOVED*** catch (ex) {
			// check for formatters that have been removed
			if (removedFormatters.has(name)) {
				ex.message = `The ${name***REMOVED*** formatter is no longer part of core ESLint. Install it manually with \`npm install -D eslint-formatter-${name***REMOVED***\``;
			***REMOVED*** else {
				ex.message = `There was a problem loading formatter: ${formatterPath***REMOVED***\nError: ${ex.message***REMOVED***`;
			***REMOVED***

			throw ex;
		***REMOVED***

		if (typeof formatter !== "function") {
			throw new TypeError(
				`Formatter must be a function, but got a ${typeof formatter***REMOVED***.`,
			);
		***REMOVED***

		const eslint = this;

		return {
			/**
			 * The main formatter method.
			 * @param {LintResult[]***REMOVED*** results The lint results to format.
			 * @param {ResultsMeta***REMOVED*** resultsMeta Warning count and max threshold.
			 * @returns {string***REMOVED*** The formatted lint results.
			 */
			format(results, resultsMeta) {
				let rulesMeta = null;

				results.sort(compareResultsByFilePath);

				return formatter(results, {
					...resultsMeta,
					cwd,
					get rulesMeta() {
						if (!rulesMeta) {
							rulesMeta = eslint.getRulesMetaForResults(results);
						***REMOVED***

						return rulesMeta;
					***REMOVED***,
				***REMOVED***);
			***REMOVED***,
		***REMOVED***;
	***REMOVED***

	/**
	 * Returns a configuration object for the given file based on the CLI options.
	 * This is the same logic used by the ESLint CLI executable to determine
	 * configuration for each file it processes.
	 * @param {string***REMOVED*** filePath The path of the file to retrieve a config object for.
	 * @returns {Promise<ConfigData|undefined>***REMOVED*** A configuration object for the file
	 *      or `undefined` if there is no configuration data for the object.
	 */
	async calculateConfigForFile(filePath) {
		if (!isNonEmptyString(filePath)) {
			throw new Error("'filePath' must be a non-empty string");
		***REMOVED***
		const options = privateMembers.get(this).options;
		const absolutePath = path.resolve(options.cwd, filePath);
		const configs =
			await this.#configLoader.loadConfigArrayForFile(absolutePath);

		if (!configs) {
			const error = new Error("Could not find config file.");

			error.messageTemplate = "config-file-missing";
			throw error;
		***REMOVED***

		return configs.getConfig(absolutePath);
	***REMOVED***

	/**
	 * Finds the config file being used by this instance based on the options
	 * passed to the constructor.
	 * @param {string***REMOVED*** [filePath] The path of the file to find the config file for.
	 * @returns {Promise<string|undefined>***REMOVED*** The path to the config file being used or
	 *      `undefined` if no config file is being used.
	 */
	findConfigFile(filePath) {
		const options = privateMembers.get(this).options;

		/*
		 * Because the new config lookup scheme skips the current directory
		 * and looks into the parent directories, we need to use a placeholder
		 * directory to ensure the file in cwd is checked.
		 */
		const fakeCwd = path.join(options.cwd, "__placeholder__");

		return this.#configLoader
			.findConfigFileForPath(filePath ?? fakeCwd)
			.catch(() => void 0);
	***REMOVED***

	/**
	 * Checks if a given path is ignored by ESLint.
	 * @param {string***REMOVED*** filePath The path of the file to check.
	 * @returns {Promise<boolean>***REMOVED*** Whether or not the given path is ignored.
	 */
	async isPathIgnored(filePath) {
		const config = await this.calculateConfigForFile(filePath);

		return config === void 0;
	***REMOVED***
***REMOVED***

/**
 * Returns whether flat config should be used.
 * @returns {Promise<boolean>***REMOVED*** Whether flat config should be used.
 */
async function shouldUseFlatConfig() {
	return process.env.ESLINT_USE_FLAT_CONFIG !== "false";
***REMOVED***

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = {
	ESLint,
	shouldUseFlatConfig,
	locateConfigFileToUse,
***REMOVED***;
