"use strict";

/* eslint-disable class-methods-use-this */

const path = require("path");
const {
  validate
***REMOVED*** = require("schema-utils");
const {
  SyncWaterfallHook
***REMOVED*** = require("tapable");
const schema = require("./plugin-options.json");
const {
  trueFn,
  MODULE_TYPE,
  AUTO_PUBLIC_PATH,
  ABSOLUTE_PUBLIC_PATH,
  SINGLE_DOT_PATH_SEGMENT,
  compareModulesByIdentifier,
  getUndoPath,
  BASE_URI,
  compileBooleanMatcher
***REMOVED*** = require("./utils");

/** @typedef {import("schema-utils/declarations/validate").Schema***REMOVED*** Schema */
/** @typedef {import("webpack").Compiler***REMOVED*** Compiler */
/** @typedef {import("webpack").Compilation***REMOVED*** Compilation */
/** @typedef {import("webpack").ChunkGraph***REMOVED*** ChunkGraph */
/** @typedef {import("webpack").Chunk***REMOVED*** Chunk */
/** @typedef {Parameters<import("webpack").Chunk["isInGroup"]>[0]***REMOVED*** ChunkGroup */
/** @typedef {import("webpack").Module***REMOVED*** Module */
/** @typedef {import("webpack").Dependency***REMOVED*** Dependency */
/** @typedef {import("webpack").sources.Source***REMOVED*** Source */
/** @typedef {import("webpack").Configuration***REMOVED*** Configuration */
/** @typedef {import("webpack").WebpackError***REMOVED*** WebpackError */
/** @typedef {import("webpack").AssetInfo***REMOVED*** AssetInfo */
/** @typedef {import("./loader.js").Dependency***REMOVED*** LoaderDependency */

/**
 * @typedef {Object***REMOVED*** LoaderOptions
 * @property {string | ((resourcePath: string, rootContext: string) => string)***REMOVED*** [publicPath]
 * @property {boolean***REMOVED*** [emit]
 * @property {boolean***REMOVED*** [esModule]
 * @property {string***REMOVED*** [layer]
 * @property {boolean***REMOVED*** [defaultExport]
 */

/**
 * @typedef {Object***REMOVED*** PluginOptions
 * @property {Required<Configuration>['output']['filename']***REMOVED*** [filename]
 * @property {Required<Configuration>['output']['chunkFilename']***REMOVED*** [chunkFilename]
 * @property {boolean***REMOVED*** [ignoreOrder]
 * @property {string | ((linkTag: HTMLLinkElement) => void)***REMOVED*** [insert]
 * @property {Record<string, string>***REMOVED*** [attributes]
 * @property {string | false | 'text/css'***REMOVED*** [linkType]
 * @property {boolean***REMOVED*** [runtime]
 * @property {boolean***REMOVED*** [experimentalUseImportModule]
 */

/**
 * @typedef {Object***REMOVED*** NormalizedPluginOptions
 * @property {Required<Configuration>['output']['filename']***REMOVED*** filename
 * @property {Required<Configuration>['output']['chunkFilename']***REMOVED*** [chunkFilename]
 * @property {boolean***REMOVED*** ignoreOrder
 * @property {string | ((linkTag: HTMLLinkElement) => void)***REMOVED*** [insert]
 * @property {Record<string, string>***REMOVED*** [attributes]
 * @property {string | false | 'text/css'***REMOVED*** [linkType]
 * @property {boolean***REMOVED*** runtime
 * @property {boolean***REMOVED*** [experimentalUseImportModule]
 */

/**
 * @typedef {Object***REMOVED*** RuntimeOptions
 * @property {string | ((linkTag: HTMLLinkElement) => void) | undefined***REMOVED*** insert
 * @property {string | false | 'text/css'***REMOVED*** linkType
 * @property {Record<string, string> | undefined***REMOVED*** attributes
 */

/** @typedef {any***REMOVED*** TODO */

const pluginName = "mini-css-extract-plugin";
const pluginSymbol = Symbol(pluginName);
const DEFAULT_FILENAME = "[name].css";
/**
 * @type {Set<string>***REMOVED***
 */
const TYPES = new Set([MODULE_TYPE]);
/**
 * @type {ReturnType<Module["codeGeneration"]>***REMOVED***
 */
const CODE_GENERATION_RESULT = {
  sources: new Map(),
  runtimeRequirements: new Set()
***REMOVED***;

/** @typedef {Module & { content: Buffer, media?: string, sourceMap?: Buffer, supports?: string, layer?: string, assets?: { [key: string]: TODO ***REMOVED***, assetsInfo?: Map<string, AssetInfo> ***REMOVED******REMOVED*** CssModule */
/** @typedef {{ context: string | null, identifier: string, identifierIndex: number, content: Buffer, sourceMap?: Buffer, media?: string, supports?: string, layer?: TODO, assetsInfo?: Map<string, AssetInfo>, assets?: { [key: string]: TODO ***REMOVED******REMOVED******REMOVED*** CssModuleDependency */
/** @typedef {{ new(dependency: CssModuleDependency): CssModule ***REMOVED******REMOVED*** CssModuleConstructor */
/** @typedef {Dependency & CssModuleDependency***REMOVED*** CssDependency */
/** @typedef {Omit<LoaderDependency, "context">***REMOVED*** CssDependencyOptions */
/** @typedef {{ new(loaderDependency: CssDependencyOptions, context: string | null, identifierIndex: number): CssDependency ***REMOVED******REMOVED*** CssDependencyConstructor */
/**
 * @typedef {Object***REMOVED*** VarNames
 * @property {string***REMOVED*** tag
 * @property {string***REMOVED*** chunkId
 * @property {string***REMOVED*** href
 * @property {string***REMOVED*** resolve
 * @property {string***REMOVED*** reject
 */
/**
 * @typedef {Object***REMOVED*** MiniCssExtractPluginCompilationHooks
 * @property {import("tapable").SyncWaterfallHook<[string, VarNames], string>***REMOVED*** beforeTagInsert
 * @property {SyncWaterfallHook<[string, Chunk]>***REMOVED*** linkPreload
 * @property {SyncWaterfallHook<[string, Chunk]>***REMOVED*** linkPrefetch
 */

/**
 *
 * @type {WeakMap<Compiler["webpack"], CssModuleConstructor>***REMOVED***
 */
const cssModuleCache = new WeakMap();
/**
 * @type {WeakMap<Compiler["webpack"], CssDependencyConstructor>***REMOVED***
 */
const cssDependencyCache = new WeakMap();
/**
 * @type {WeakSet<Compiler["webpack"]>***REMOVED***
 */
const registered = new WeakSet();

/** @type {WeakMap<Compilation, MiniCssExtractPluginCompilationHooks>***REMOVED*** */
const compilationHooksMap = new WeakMap();
class MiniCssExtractPlugin {
  /**
   * @param {Compiler["webpack"]***REMOVED*** webpack
   * @returns {CssModuleConstructor***REMOVED***
   */
  static getCssModule(webpack) {
    /**
     * Prevent creation of multiple CssModule classes to allow other integrations to get the current CssModule.
     */
    if (cssModuleCache.has(webpack)) {
      return /** @type {CssModuleConstructor***REMOVED*** */cssModuleCache.get(webpack);
    ***REMOVED***
    class CssModule extends webpack.Module {
      /**
       * @param {CssModuleDependency***REMOVED*** dependency
       */
      constructor({
        context,
        identifier,
        identifierIndex,
        content,
        layer,
        supports,
        media,
        sourceMap,
        assets,
        assetsInfo
      ***REMOVED***) {
        // @ts-ignore
        super(MODULE_TYPE, /** @type {string | undefined***REMOVED*** */context);
        this.id = "";
        this._context = context;
        this._identifier = identifier;
        this._identifierIndex = identifierIndex;
        this.content = content;
        this.layer = layer;
        this.supports = supports;
        this.media = media;
        this.sourceMap = sourceMap;
        this.assets = assets;
        this.assetsInfo = assetsInfo;
        this._needBuild = true;
      ***REMOVED***

      // no source() so webpack 4 doesn't do add stuff to the bundle

      size() {
        return this.content.length;
      ***REMOVED***
      identifier() {
        return `css|${this._identifier***REMOVED***|${this._identifierIndex***REMOVED***|${this.layer || ""***REMOVED***|${this.supports || ""***REMOVED***|${this.media***REMOVED******REMOVED******REMOVED***`;
      ***REMOVED***

      /**
       * @param {Parameters<Module["readableIdentifier"]>[0]***REMOVED*** requestShortener
       * @returns {ReturnType<Module["readableIdentifier"]>***REMOVED***
       */
      readableIdentifier(requestShortener) {
        return `css ${requestShortener.shorten(this._identifier)***REMOVED***${this._identifierIndex ? ` (${this._identifierIndex***REMOVED***)` : ""***REMOVED***${this.layer ? ` (layer ${this.layer***REMOVED***)` : ""***REMOVED***${this.supports ? ` (supports ${this.supports***REMOVED***)` : ""***REMOVED***${this.media ? ` (media ${this.media***REMOVED***)` : ""***REMOVED***`;
      ***REMOVED***

      // eslint-disable-next-line class-methods-use-this
      getSourceTypes() {
        return TYPES;
      ***REMOVED***

      // eslint-disable-next-line class-methods-use-this
      codeGeneration() {
        return CODE_GENERATION_RESULT;
      ***REMOVED***
      nameForCondition() {
        const resource = /** @type {string***REMOVED*** */
        this._identifier.split("!").pop();
        const idx = resource.indexOf("?");
        if (idx >= 0) {
          return resource.substring(0, idx);
        ***REMOVED***
        return resource;
      ***REMOVED***

      /**
       * @param {Module***REMOVED*** module
       */
      updateCacheModule(module) {
        if (!this.content.equals( /** @type {CssModule***REMOVED*** */module.content) || this.layer !== /** @type {CssModule***REMOVED*** */module.layer || this.supports !== /** @type {CssModule***REMOVED*** */module.supports || this.media !== /** @type {CssModule***REMOVED*** */module.media || (this.sourceMap ? !this.sourceMap.equals( /** @type {Uint8Array***REMOVED*** **/
        /** @type {CssModule***REMOVED*** */module.sourceMap) : false) || this.assets !== /** @type {CssModule***REMOVED*** */module.assets || this.assetsInfo !== /** @type {CssModule***REMOVED*** */module.assetsInfo) {
          this._needBuild = true;
          this.content = /** @type {CssModule***REMOVED*** */module.content;
          this.layer = /** @type {CssModule***REMOVED*** */module.layer;
          this.supports = /** @type {CssModule***REMOVED*** */module.supports;
          this.media = /** @type {CssModule***REMOVED*** */module.media;
          this.sourceMap = /** @type {CssModule***REMOVED*** */module.sourceMap;
          this.assets = /** @type {CssModule***REMOVED*** */module.assets;
          this.assetsInfo = /** @type {CssModule***REMOVED*** */module.assetsInfo;
        ***REMOVED***
      ***REMOVED***

      // eslint-disable-next-line class-methods-use-this
      needRebuild() {
        return this._needBuild;
      ***REMOVED***

      // eslint-disable-next-line class-methods-use-this
      /**
       * @param {Parameters<Module["needBuild"]>[0]***REMOVED*** context context info
       * @param {Parameters<Module["needBuild"]>[1]***REMOVED*** callback callback function, returns true, if the module needs a rebuild
       */
      needBuild(context, callback) {
        // eslint-disable-next-line no-undefined
        callback(undefined, this._needBuild);
      ***REMOVED***

      /**
       * @param {Parameters<Module["build"]>[0]***REMOVED*** options
       * @param {Parameters<Module["build"]>[1]***REMOVED*** compilation
       * @param {Parameters<Module["build"]>[2]***REMOVED*** resolver
       * @param {Parameters<Module["build"]>[3]***REMOVED*** fileSystem
       * @param {Parameters<Module["build"]>[4]***REMOVED*** callback
       */
      build(options, compilation, resolver, fileSystem, callback) {
        this.buildInfo = {
          assets: this.assets,
          assetsInfo: this.assetsInfo,
          cacheable: true,
          hash: this._computeHash( /** @type {string***REMOVED*** */compilation.outputOptions.hashFunction)
        ***REMOVED***;
        this.buildMeta = {***REMOVED***;
        this._needBuild = false;
        callback();
      ***REMOVED***

      /**
       * @private
       * @param {string***REMOVED*** hashFunction
       * @returns {string | Buffer***REMOVED***
       */
      _computeHash(hashFunction) {
        const hash = webpack.util.createHash(hashFunction);
        hash.update(this.content);
        if (this.layer) {
          hash.update(this.layer);
        ***REMOVED***
        hash.update(this.supports || "");
        hash.update(this.media || "");
        hash.update(this.sourceMap || "");
        return hash.digest("hex");
      ***REMOVED***

      /**
       * @param {Parameters<Module["updateHash"]>[0]***REMOVED*** hash
       * @param {Parameters<Module["updateHash"]>[1]***REMOVED*** context
       */
      updateHash(hash, context) {
        super.updateHash(hash, context);
        hash.update( /** @type {NonNullable<Module["buildInfo"]>***REMOVED*** */this.buildInfo.hash);
      ***REMOVED***

      /**
       * @param {Parameters<Module["serialize"]>[0]***REMOVED*** context
       */
      serialize(context) {
        const {
          write
        ***REMOVED*** = context;
        write(this._context);
        write(this._identifier);
        write(this._identifierIndex);
        write(this.content);
        write(this.layer);
        write(this.supports);
        write(this.media);
        write(this.sourceMap);
        write(this.assets);
        write(this.assetsInfo);
        write(this._needBuild);
        super.serialize(context);
      ***REMOVED***

      /**
       * @param {Parameters<Module["deserialize"]>[0]***REMOVED*** context
       */
      deserialize(context) {
        this._needBuild = context.read();
        super.deserialize(context);
      ***REMOVED***
    ***REMOVED***
    cssModuleCache.set(webpack, CssModule);
    webpack.util.serialization.register(CssModule, path.resolve(__dirname, "CssModule"),
    // @ts-ignore
    null, {
      serialize(instance, context) {
        instance.serialize(context);
      ***REMOVED***,
      deserialize(context) {
        const {
          read
        ***REMOVED*** = context;
        const contextModule = read();
        const identifier = read();
        const identifierIndex = read();
        const content = read();
        const layer = read();
        const supports = read();
        const media = read();
        const sourceMap = read();
        const assets = read();
        const assetsInfo = read();
        const dep = new CssModule({
          context: contextModule,
          identifier,
          identifierIndex,
          content,
          layer,
          supports,
          media,
          sourceMap,
          assets,
          assetsInfo
        ***REMOVED***);
        dep.deserialize(context);
        return dep;
      ***REMOVED***
    ***REMOVED***);
    return CssModule;
  ***REMOVED***

  /**
   * @param {Compiler["webpack"]***REMOVED*** webpack
   * @returns {CssDependencyConstructor***REMOVED***
   */
  static getCssDependency(webpack) {
    /**
     * Prevent creation of multiple CssDependency classes to allow other integrations to get the current CssDependency.
     */
    if (cssDependencyCache.has(webpack)) {
      return /** @type {CssDependencyConstructor***REMOVED*** */(
        cssDependencyCache.get(webpack)
      );
    ***REMOVED***
    class CssDependency extends webpack.Dependency {
      /**
       * @param {CssDependencyOptions***REMOVED*** loaderDependency
       * @param {string | null***REMOVED*** context
       * @param {number***REMOVED*** identifierIndex
       */
      constructor({
        identifier,
        content,
        layer,
        supports,
        media,
        sourceMap
      ***REMOVED***, context, identifierIndex) {
        super();
        this.identifier = identifier;
        this.identifierIndex = identifierIndex;
        this.content = content;
        this.layer = layer;
        this.supports = supports;
        this.media = media;
        this.sourceMap = sourceMap;
        this.context = context;
        /** @type {{ [key: string]: Source ***REMOVED*** | undefined***REMOVED******REMOVED*** */
        // eslint-disable-next-line no-undefined
        this.assets = undefined;
        /** @type {Map<string, AssetInfo> | undefined***REMOVED*** */
        // eslint-disable-next-line no-undefined
        this.assetsInfo = undefined;
      ***REMOVED***

      /**
       * @returns {ReturnType<Dependency["getResourceIdentifier"]>***REMOVED***
       */
      getResourceIdentifier() {
        return `css-module-${this.identifier***REMOVED***-${this.identifierIndex***REMOVED***`;
      ***REMOVED***

      /**
       * @returns {ReturnType<Dependency["getModuleEvaluationSideEffectsState"]>***REMOVED***
       */
      // eslint-disable-next-line class-methods-use-this
      getModuleEvaluationSideEffectsState() {
        return webpack.ModuleGraphConnection.TRANSITIVE_ONLY;
      ***REMOVED***

      /**
       * @param {Parameters<Dependency["serialize"]>[0]***REMOVED*** context
       */
      serialize(context) {
        const {
          write
        ***REMOVED*** = context;
        write(this.identifier);
        write(this.content);
        write(this.layer);
        write(this.supports);
        write(this.media);
        write(this.sourceMap);
        write(this.context);
        write(this.identifierIndex);
        write(this.assets);
        write(this.assetsInfo);
        super.serialize(context);
      ***REMOVED***

      /**
       * @param {Parameters<Dependency["deserialize"]>[0]***REMOVED*** context
       */
      deserialize(context) {
        super.deserialize(context);
      ***REMOVED***
    ***REMOVED***
    cssDependencyCache.set(webpack, CssDependency);
    webpack.util.serialization.register(CssDependency, path.resolve(__dirname, "CssDependency"),
    // @ts-ignore
    null, {
      serialize(instance, context) {
        instance.serialize(context);
      ***REMOVED***,
      deserialize(context) {
        const {
          read
        ***REMOVED*** = context;
        const dep = new CssDependency({
          identifier: read(),
          content: read(),
          layer: read(),
          supports: read(),
          media: read(),
          sourceMap: read()
        ***REMOVED***, read(), read());
        const assets = read();
        const assetsInfo = read();
        dep.assets = assets;
        dep.assetsInfo = assetsInfo;
        dep.deserialize(context);
        return dep;
      ***REMOVED***
    ***REMOVED***);
    return CssDependency;
  ***REMOVED***

  /**
   * Returns all hooks for the given compilation
   * @param {Compilation***REMOVED*** compilation the compilation
   * @returns {MiniCssExtractPluginCompilationHooks***REMOVED*** hooks
   */
  static getCompilationHooks(compilation) {
    let hooks = compilationHooksMap.get(compilation);
    if (!hooks) {
      hooks = {
        beforeTagInsert: new SyncWaterfallHook(["source", "varNames"], "string"),
        linkPreload: new SyncWaterfallHook(["source", "chunk"]),
        linkPrefetch: new SyncWaterfallHook(["source", "chunk"])
      ***REMOVED***;
      compilationHooksMap.set(compilation, hooks);
    ***REMOVED***
    return hooks;
  ***REMOVED***

  /**
   * @param {PluginOptions***REMOVED*** [options]
   */
  constructor(options = {***REMOVED***) {
    validate( /** @type {Schema***REMOVED*** */schema, options, {
      baseDataPath: "options"
    ***REMOVED***);

    /**
     * @private
     * @type {WeakMap<Chunk, Set<CssModule>>***REMOVED***
     * @private
     */
    this._sortedModulesCache = new WeakMap();

    /**
     * @private
     * @type {NormalizedPluginOptions***REMOVED***
     */
    this.options = Object.assign({
      filename: DEFAULT_FILENAME,
      ignoreOrder: false,
      // TODO remove in the next major release
      // eslint-disable-next-line no-undefined
      experimentalUseImportModule: undefined,
      runtime: true
    ***REMOVED***, options);

    /**
     * @private
     * @type {RuntimeOptions***REMOVED***
     */
    this.runtimeOptions = {
      insert: options.insert,
      linkType:
      // Todo in next major release set default to "false"
      typeof options.linkType === "boolean" && /** @type {boolean***REMOVED*** */options.linkType === true || typeof options.linkType === "undefined" ? "text/css" : options.linkType,
      attributes: options.attributes
    ***REMOVED***;
    if (!this.options.chunkFilename) {
      const {
        filename
      ***REMOVED*** = this.options;
      if (typeof filename !== "function") {
        const hasName = /** @type {string***REMOVED*** */filename.includes("[name]");
        const hasId = /** @type {string***REMOVED*** */filename.includes("[id]");
        const hasChunkHash = /** @type {string***REMOVED*** */
        filename.includes("[chunkhash]");
        const hasContentHash = /** @type {string***REMOVED*** */
        filename.includes("[contenthash]");

        // Anything changing depending on chunk is fine
        if (hasChunkHash || hasContentHash || hasName || hasId) {
          this.options.chunkFilename = filename;
        ***REMOVED*** else {
          // Otherwise prefix "[id]." in front of the basename to make it changing
          this.options.chunkFilename = /** @type {string***REMOVED*** */
          filename.replace(/(^|\/)([^/]*(?:\?|$))/, "$1[id].$2");
        ***REMOVED***
      ***REMOVED*** else {
        this.options.chunkFilename = "[id].css";
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  /**
   * @param {Compiler***REMOVED*** compiler
   */
  apply(compiler) {
    const {
      webpack
    ***REMOVED*** = compiler;
    if (this.options.experimentalUseImportModule) {
      if (typeof ( /** @type {Compiler["options"]["experiments"] & { executeModule?: boolean ***REMOVED******REMOVED*** */
      compiler.options.experiments.executeModule) === "undefined") {
        /** @type {Compiler["options"]["experiments"] & { executeModule?: boolean ***REMOVED******REMOVED*** */
        // eslint-disable-next-line no-param-reassign
        compiler.options.experiments.executeModule = true;
      ***REMOVED***
    ***REMOVED***

    // TODO bug in webpack, remove it after it will be fixed
    // webpack tries to `require` loader firstly when serializer doesn't found
    if (!registered.has(webpack)) {
      registered.add(webpack);
      webpack.util.serialization.registerLoader(/^mini-css-extract-plugin\//, trueFn);
    ***REMOVED***
    const {
      splitChunks
    ***REMOVED*** = compiler.options.optimization;
    if (splitChunks) {
      if ( /** @type {string[]***REMOVED*** */splitChunks.defaultSizeTypes.includes("...")) {
        /** @type {string[]***REMOVED*** */
        splitChunks.defaultSizeTypes.push(MODULE_TYPE);
      ***REMOVED***
    ***REMOVED***
    const CssModule = MiniCssExtractPlugin.getCssModule(webpack);
    const CssDependency = MiniCssExtractPlugin.getCssDependency(webpack);
    const {
      NormalModule
    ***REMOVED*** = compiler.webpack;
    compiler.hooks.compilation.tap(pluginName, compilation => {
      const {
        loader: normalModuleHook
      ***REMOVED*** = NormalModule.getCompilationHooks(compilation);
      normalModuleHook.tap(pluginName,
      /**
       * @param {object***REMOVED*** loaderContext
       */
      loaderContext => {
        /** @type {object & { [pluginSymbol]: { experimentalUseImportModule: boolean | undefined ***REMOVED*** ***REMOVED******REMOVED*** */
        // eslint-disable-next-line no-param-reassign
        loaderContext[pluginSymbol] = {
          experimentalUseImportModule: this.options.experimentalUseImportModule
        ***REMOVED***;
      ***REMOVED***);
    ***REMOVED***);
    compiler.hooks.thisCompilation.tap(pluginName, compilation => {
      class CssModuleFactory {
        /**
         * @param {{ dependencies: Dependency[] ***REMOVED******REMOVED*** dependencies
         * @param {(arg0?: Error, arg1?: TODO) => void***REMOVED*** callback
         */
        // eslint-disable-next-line class-methods-use-this
        create({
          dependencies: [dependency]
        ***REMOVED***, callback) {
          callback(
          // eslint-disable-next-line no-undefined
          undefined, new CssModule( /** @type {CssDependency***REMOVED*** */dependency));
        ***REMOVED***
      ***REMOVED***
      compilation.dependencyFactories.set(CssDependency, new CssModuleFactory());
      class CssDependencyTemplate {
        // eslint-disable-next-line class-methods-use-this
        apply() {***REMOVED***
      ***REMOVED***
      compilation.dependencyTemplates.set(CssDependency, new CssDependencyTemplate());
      compilation.hooks.renderManifest.tap(pluginName,
      /**
       * @param {ReturnType<Compilation["getRenderManifest"]>***REMOVED*** result
       * @param {Parameters<Compilation["getRenderManifest"]>[0]***REMOVED*** chunk
       * @returns {TODO***REMOVED***
       */
      (result, {
        chunk
      ***REMOVED***) => {
        const {
          chunkGraph
        ***REMOVED*** = compilation;
        const {
          HotUpdateChunk
        ***REMOVED*** = webpack;

        // We don't need hot update chunks for css
        // We will use the real asset instead to update
        if (chunk instanceof HotUpdateChunk) {
          return;
        ***REMOVED***

        /** @type {CssModule[]***REMOVED*** */
        const renderedModules = Array.from( /** @type {CssModule[]***REMOVED*** */
        this.getChunkModules(chunk, chunkGraph)).filter(module =>
        // @ts-ignore
        module.type === MODULE_TYPE);
        const filenameTemplate = /** @type {string***REMOVED*** */

        chunk.canBeInitial() ? this.options.filename : this.options.chunkFilename;
        if (renderedModules.length > 0) {
          result.push({
            render: () => this.renderContentAsset(compiler, compilation, chunk, renderedModules, compilation.runtimeTemplate.requestShortener, filenameTemplate, {
              contentHashType: MODULE_TYPE,
              chunk
            ***REMOVED***),
            filenameTemplate,
            pathOptions: {
              chunk,
              contentHashType: MODULE_TYPE
            ***REMOVED***,
            identifier: `${pluginName***REMOVED***.${chunk.id***REMOVED***`,
            hash: chunk.contentHash[MODULE_TYPE]
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***);
      compilation.hooks.contentHash.tap(pluginName, chunk => {
        const {
          outputOptions,
          chunkGraph
        ***REMOVED*** = compilation;
        const modules = this.sortModules(compilation, chunk, /** @type {CssModule[]***REMOVED*** */
        chunkGraph.getChunkModulesIterableBySourceType(chunk, MODULE_TYPE), compilation.runtimeTemplate.requestShortener);
        if (modules) {
          const {
            hashFunction,
            hashDigest,
            hashDigestLength
          ***REMOVED*** = outputOptions;
          const {
            createHash
          ***REMOVED*** = compiler.webpack.util;
          const hash = createHash( /** @type {string***REMOVED*** */hashFunction);
          for (const m of modules) {
            hash.update(chunkGraph.getModuleHash(m, chunk.runtime));
          ***REMOVED***

          // eslint-disable-next-line no-param-reassign
          chunk.contentHash[MODULE_TYPE] = /** @type {string***REMOVED*** */
          hash.digest(hashDigest).substring(0, hashDigestLength);
        ***REMOVED***
      ***REMOVED***);

      // All the code below is dedicated to the runtime and can be skipped when the `runtime` option is `false`
      if (!this.options.runtime) {
        return;
      ***REMOVED***
      const {
        Template,
        RuntimeGlobals,
        RuntimeModule,
        runtime
      ***REMOVED*** = webpack;

      /**
       * @param {Chunk***REMOVED*** mainChunk
       * @param {Compilation***REMOVED*** compilation
       * @returns {Record<string, number>***REMOVED***
       */
      // eslint-disable-next-line no-shadow
      const getCssChunkObject = (mainChunk, compilation) => {
        /** @type {Record<string, number>***REMOVED*** */
        const obj = {***REMOVED***;
        const {
          chunkGraph
        ***REMOVED*** = compilation;
        for (const chunk of mainChunk.getAllAsyncChunks()) {
          const modules = chunkGraph.getOrderedChunkModulesIterable(chunk, compareModulesByIdentifier);
          for (const module of modules) {
            // @ts-ignore
            if (module.type === MODULE_TYPE) {
              obj[( /** @type {string***REMOVED*** */chunk.id)] = 1;
              break;
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***
        return obj;
      ***REMOVED***;

      /**
       * @param {Chunk***REMOVED*** chunk chunk
       * @param {ChunkGraph***REMOVED*** chunkGraph chunk graph
       * @returns {boolean***REMOVED*** true, when the chunk has css
       */
      function chunkHasCss(chunk, chunkGraph) {
        // this function replace:
        // const chunkHasCss = require("webpack/lib/css/CssModulesPlugin").chunkHasCss;
        return !!chunkGraph.getChunkModulesIterableBySourceType(chunk, "css/mini-extract");
      ***REMOVED***
      class CssLoadingRuntimeModule extends RuntimeModule {
        /**
         * @param {Set<string>***REMOVED*** runtimeRequirements
         * @param {RuntimeOptions***REMOVED*** runtimeOptions
         */
        constructor(runtimeRequirements, runtimeOptions) {
          super("css loading", 10);
          this.runtimeRequirements = runtimeRequirements;
          this.runtimeOptions = runtimeOptions;
        ***REMOVED***
        generate() {
          const {
            chunkGraph,
            chunk,
            runtimeRequirements
          ***REMOVED*** = this;
          const {
            runtimeTemplate,
            outputOptions: {
              crossOriginLoading
            ***REMOVED***
          ***REMOVED*** = /** @type {Compilation***REMOVED*** */this.compilation;
          const chunkMap = getCssChunkObject( /** @type {Chunk***REMOVED*** */chunk, /** @type {Compilation***REMOVED*** */this.compilation);
          const withLoading = runtimeRequirements.has(RuntimeGlobals.ensureChunkHandlers) && Object.keys(chunkMap).length > 0;
          const withHmr = runtimeRequirements.has(RuntimeGlobals.hmrDownloadUpdateHandlers);
          if (!withLoading && !withHmr) {
            return "";
          ***REMOVED***
          const conditionMap = /** @type {ChunkGraph***REMOVED*** */chunkGraph.getChunkConditionMap( /** @type {Chunk***REMOVED*** */chunk, chunkHasCss);
          const hasCssMatcher = compileBooleanMatcher(conditionMap);
          const withPrefetch = runtimeRequirements.has(RuntimeGlobals.prefetchChunkHandlers);
          const withPreload = runtimeRequirements.has(RuntimeGlobals.preloadChunkHandlers);
          const {
            linkPreload,
            linkPrefetch
          ***REMOVED*** = MiniCssExtractPlugin.getCompilationHooks(compilation);
          return Template.asString(['if (typeof document === "undefined") return;', `var createStylesheet = ${runtimeTemplate.basicFunction("chunkId, fullhref, oldTag, resolve, reject", ['var linkTag = document.createElement("link");', this.runtimeOptions.attributes ? Template.asString(Object.entries(this.runtimeOptions.attributes).map(entry => {
            const [key, value] = entry;
            return `linkTag.setAttribute(${JSON.stringify(key)***REMOVED***, ${JSON.stringify(value)***REMOVED***);`;
          ***REMOVED***)) : "", 'linkTag.rel = "stylesheet";', this.runtimeOptions.linkType ? `linkTag.type = ${JSON.stringify(this.runtimeOptions.linkType)***REMOVED***;` : "", `if (${RuntimeGlobals.scriptNonce***REMOVED***) {`, Template.indent(`linkTag.nonce = ${RuntimeGlobals.scriptNonce***REMOVED***;`), "***REMOVED***", `var onLinkComplete = ${runtimeTemplate.basicFunction("event", ["// avoid mem leaks.", "linkTag.onerror = linkTag.onload = null;", "if (event.type === 'load') {", Template.indent(["resolve();"]), "***REMOVED*** else {", Template.indent(["var errorType = event && event.type;", "var realHref = event && event.target && event.target.href || fullhref;", 'var err = new Error("Loading CSS chunk " + chunkId + " failed.\\n(" + errorType + ": " + realHref + ")");', 'err.name = "ChunkLoadError";',
          // TODO remove `code` in the future major release to align with webpack
          'err.code = "CSS_CHUNK_LOAD_FAILED";', "err.type = errorType;", "err.request = realHref;", "if (linkTag.parentNode) linkTag.parentNode.removeChild(linkTag)", "reject(err);"]), "***REMOVED***"])***REMOVED***`, "linkTag.onerror = linkTag.onload = onLinkComplete;", "linkTag.href = fullhref;", crossOriginLoading ? Template.asString([`if (linkTag.href.indexOf(window.location.origin + '/') !== 0) {`, Template.indent(`linkTag.crossOrigin = ${JSON.stringify(crossOriginLoading)***REMOVED***;`), "***REMOVED***"]) : "", MiniCssExtractPlugin.getCompilationHooks(compilation).beforeTagInsert.call("", {
            tag: "linkTag",
            chunkId: "chunkId",
            href: "fullhref",
            resolve: "resolve",
            reject: "reject"
          ***REMOVED***) || "", typeof this.runtimeOptions.insert !== "undefined" ? typeof this.runtimeOptions.insert === "function" ? `(${this.runtimeOptions.insert.toString()***REMOVED***)(linkTag)` : Template.asString([`var target = document.querySelector("${this.runtimeOptions.insert***REMOVED***");`, `target.parentNode.insertBefore(linkTag, target.nextSibling);`]) : Template.asString(["if (oldTag) {", Template.indent(["oldTag.parentNode.insertBefore(linkTag, oldTag.nextSibling);"]), "***REMOVED*** else {", Template.indent(["document.head.appendChild(linkTag);"]), "***REMOVED***"]), "return linkTag;"])***REMOVED***;`, `var findStylesheet = ${runtimeTemplate.basicFunction("href, fullhref", ['var existingLinkTags = document.getElementsByTagName("link");', "for(var i = 0; i < existingLinkTags.length; i++) {", Template.indent(["var tag = existingLinkTags[i];", 'var dataHref = tag.getAttribute("data-href") || tag.getAttribute("href");', 'if(tag.rel === "stylesheet" && (dataHref === href || dataHref === fullhref)) return tag;']), "***REMOVED***", 'var existingStyleTags = document.getElementsByTagName("style");', "for(var i = 0; i < existingStyleTags.length; i++) {", Template.indent(["var tag = existingStyleTags[i];", 'var dataHref = tag.getAttribute("data-href");', "if(dataHref === href || dataHref === fullhref) return tag;"]), "***REMOVED***"])***REMOVED***;`, `var loadStylesheet = ${runtimeTemplate.basicFunction("chunkId", `return new Promise(${runtimeTemplate.basicFunction("resolve, reject", [`var href = ${RuntimeGlobals.require***REMOVED***.miniCssF(chunkId);`, `var fullhref = ${RuntimeGlobals.publicPath***REMOVED*** + href;`, "if(findStylesheet(href, fullhref)) return resolve();", "createStylesheet(chunkId, fullhref, null, resolve, reject);"])***REMOVED***);`)***REMOVED***`, withLoading ? Template.asString(["// object to store loaded CSS chunks", "var installedCssChunks = {", Template.indent( /** @type {string[]***REMOVED*** */
          ( /** @type {Chunk***REMOVED*** */chunk.ids).map(id => `${JSON.stringify(id)***REMOVED***: 0`).join(",\n")), "***REMOVED***;", "", `${RuntimeGlobals.ensureChunkHandlers***REMOVED***.miniCss = ${runtimeTemplate.basicFunction("chunkId, promises", [`var cssChunks = ${JSON.stringify(chunkMap)***REMOVED***;`, "if(installedCssChunks[chunkId]) promises.push(installedCssChunks[chunkId]);", "else if(installedCssChunks[chunkId] !== 0 && cssChunks[chunkId]) {", Template.indent([`promises.push(installedCssChunks[chunkId] = loadStylesheet(chunkId).then(${runtimeTemplate.basicFunction("", "installedCssChunks[chunkId] = 0;")***REMOVED***, ${runtimeTemplate.basicFunction("e", ["delete installedCssChunks[chunkId];", "throw e;"])***REMOVED***));`]), "***REMOVED***"])***REMOVED***;`]) : "// no chunk loading", "", withHmr ? Template.asString(["var oldTags = [];", "var newTags = [];", `var applyHandler = ${runtimeTemplate.basicFunction("options", [`return { dispose: ${runtimeTemplate.basicFunction("", ["for(var i = 0; i < oldTags.length; i++) {", Template.indent(["var oldTag = oldTags[i];", "if(oldTag.parentNode) oldTag.parentNode.removeChild(oldTag);"]), "***REMOVED***", "oldTags.length = 0;"])***REMOVED***, apply: ${runtimeTemplate.basicFunction("", ['for(var i = 0; i < newTags.length; i++) newTags[i].rel = "stylesheet";', "newTags.length = 0;"])***REMOVED*** ***REMOVED***;`])***REMOVED***`, `${RuntimeGlobals.hmrDownloadUpdateHandlers***REMOVED***.miniCss = ${runtimeTemplate.basicFunction("chunkIds, removedChunks, removedModules, promises, applyHandlers, updatedModulesList", ["applyHandlers.push(applyHandler);", `chunkIds.forEach(${runtimeTemplate.basicFunction("chunkId", [`var href = ${RuntimeGlobals.require***REMOVED***.miniCssF(chunkId);`, `var fullhref = ${RuntimeGlobals.publicPath***REMOVED*** + href;`, "var oldTag = findStylesheet(href, fullhref);", "if(!oldTag) return;", `promises.push(new Promise(${runtimeTemplate.basicFunction("resolve, reject", [`var tag = createStylesheet(chunkId, fullhref, oldTag, ${runtimeTemplate.basicFunction("", ['tag.as = "style";', 'tag.rel = "preload";', "resolve();"])***REMOVED***, reject);`, "oldTags.push(oldTag);", "newTags.push(tag);"])***REMOVED***));`])***REMOVED***);`])***REMOVED***`]) : "// no hmr", "", withPrefetch && withLoading && hasCssMatcher !== false ? `${RuntimeGlobals.prefetchChunkHandlers***REMOVED***.miniCss = ${runtimeTemplate.basicFunction("chunkId", [`if((!${RuntimeGlobals.hasOwnProperty***REMOVED***(installedCssChunks, chunkId) || installedCssChunks[chunkId] === undefined) && ${hasCssMatcher === true ? "true" : hasCssMatcher("chunkId")***REMOVED***) {`, Template.indent(["installedCssChunks[chunkId] = null;", linkPrefetch.call(Template.asString(["var link = document.createElement('link');", crossOriginLoading ? `link.crossOrigin = ${JSON.stringify(crossOriginLoading)***REMOVED***;` : "", `if (${RuntimeGlobals.scriptNonce***REMOVED***) {`, Template.indent(`link.setAttribute("nonce", ${RuntimeGlobals.scriptNonce***REMOVED***);`), "***REMOVED***", 'link.rel = "prefetch";', 'link.as = "style";', `link.href = ${RuntimeGlobals.publicPath***REMOVED*** + ${RuntimeGlobals.require***REMOVED***.miniCssF(chunkId);`]), /** @type {Chunk***REMOVED*** */chunk), "document.head.appendChild(link);"]), "***REMOVED***"])***REMOVED***;` : "// no prefetching", "", withPreload && withLoading && hasCssMatcher !== false ? `${RuntimeGlobals.preloadChunkHandlers***REMOVED***.miniCss = ${runtimeTemplate.basicFunction("chunkId", [`if((!${RuntimeGlobals.hasOwnProperty***REMOVED***(installedCssChunks, chunkId) || installedCssChunks[chunkId] === undefined) && ${hasCssMatcher === true ? "true" : hasCssMatcher("chunkId")***REMOVED***) {`, Template.indent(["installedCssChunks[chunkId] = null;", linkPreload.call(Template.asString(["var link = document.createElement('link');", "link.charset = 'utf-8';", `if (${RuntimeGlobals.scriptNonce***REMOVED***) {`, Template.indent(`link.setAttribute("nonce", ${RuntimeGlobals.scriptNonce***REMOVED***);`), "***REMOVED***", 'link.rel = "preload";', 'link.as = "style";', `link.href = ${RuntimeGlobals.publicPath***REMOVED*** + ${RuntimeGlobals.require***REMOVED***.miniCssF(chunkId);`, crossOriginLoading ? crossOriginLoading === "use-credentials" ? 'link.crossOrigin = "use-credentials";' : Template.asString(["if (link.href.indexOf(window.location.origin + '/') !== 0) {", Template.indent(`link.crossOrigin = ${JSON.stringify(crossOriginLoading)***REMOVED***;`), "***REMOVED***"]) : ""]), /** @type {Chunk***REMOVED*** */chunk), "document.head.appendChild(link);"]), "***REMOVED***"])***REMOVED***;` : "// no preloaded"]);
        ***REMOVED***
      ***REMOVED***
      const enabledChunks = new WeakSet();

      /**
       * @param {Chunk***REMOVED*** chunk
       * @param {Set<string>***REMOVED*** set
       */
      const handler = (chunk, set) => {
        if (enabledChunks.has(chunk)) {
          return;
        ***REMOVED***
        enabledChunks.add(chunk);
        if (typeof this.options.chunkFilename === "string" && /\[(full)?hash(:\d+)?\]/.test(this.options.chunkFilename)) {
          set.add(RuntimeGlobals.getFullHash);
        ***REMOVED***
        set.add(RuntimeGlobals.publicPath);
        compilation.addRuntimeModule(chunk, new runtime.GetChunkFilenameRuntimeModule(MODULE_TYPE, "mini-css", `${RuntimeGlobals.require***REMOVED***.miniCssF`,
        /**
         * @param {Chunk***REMOVED*** referencedChunk
         * @returns {TODO***REMOVED***
         */
        referencedChunk => {
          if (!referencedChunk.contentHash[MODULE_TYPE]) {
            return false;
          ***REMOVED***
          return referencedChunk.canBeInitial() ? this.options.filename : this.options.chunkFilename;
        ***REMOVED***, false));
        compilation.addRuntimeModule(chunk, new CssLoadingRuntimeModule(set, this.runtimeOptions));
      ***REMOVED***;
      compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.ensureChunkHandlers).tap(pluginName, handler);
      compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.hmrDownloadUpdateHandlers).tap(pluginName, handler);
      compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.prefetchChunkHandlers).tap(pluginName, handler);
      compilation.hooks.runtimeRequirementInTree.for(RuntimeGlobals.preloadChunkHandlers).tap(pluginName, handler);
    ***REMOVED***);
  ***REMOVED***

  /**
   * @private
   * @param {Chunk***REMOVED*** chunk
   * @param {ChunkGraph***REMOVED*** chunkGraph
   * @returns {Iterable<Module>***REMOVED***
   */
  getChunkModules(chunk, chunkGraph) {
    return typeof chunkGraph !== "undefined" ? chunkGraph.getOrderedChunkModulesIterable(chunk, compareModulesByIdentifier) : chunk.modulesIterable;
  ***REMOVED***

  /**
   * @private
   * @param {Compilation***REMOVED*** compilation
   * @param {Chunk***REMOVED*** chunk
   * @param {CssModule[]***REMOVED*** modules
   * @param {Compilation["requestShortener"]***REMOVED*** requestShortener
   * @returns {Set<CssModule>***REMOVED***
   */
  sortModules(compilation, chunk, modules, requestShortener) {
    let usedModules = this._sortedModulesCache.get(chunk);
    if (usedModules || !modules) {
      return /** @type {Set<CssModule>***REMOVED*** */usedModules;
    ***REMOVED***

    /** @type {CssModule[]***REMOVED*** */
    const modulesList = [...modules];
    // Store dependencies for modules
    /** @type {Map<CssModule, Set<CssModule>>***REMOVED*** */
    const moduleDependencies = new Map(modulesList.map(m => [m, ( /** @type {Set<CssModule>***REMOVED*** */
    new Set())]));
    /** @type {Map<CssModule, Map<CssModule, Set<ChunkGroup>>>***REMOVED*** */
    const moduleDependenciesReasons = new Map(modulesList.map(m => [m, new Map()]));
    // Get ordered list of modules per chunk group
    // This loop also gathers dependencies from the ordered lists
    // Lists are in reverse order to allow to use Array.pop()
    /** @type {CssModule[][]***REMOVED*** */
    const modulesByChunkGroup = Array.from(chunk.groupsIterable, chunkGroup => {
      const sortedModules = modulesList.map(module => {
        return {
          module,
          index: chunkGroup.getModulePostOrderIndex(module)
        ***REMOVED***;
      ***REMOVED***)
      // eslint-disable-next-line no-undefined
      .filter(item => item.index !== undefined).sort((a, b) => /** @type {number***REMOVED*** */b.index - ( /** @type {number***REMOVED*** */a.index)).map(item => item.module);
      for (let i = 0; i < sortedModules.length; i++) {
        const set = moduleDependencies.get(sortedModules[i]);
        const reasons = /** @type {Map<CssModule, Set<ChunkGroup>>***REMOVED*** */
        moduleDependenciesReasons.get(sortedModules[i]);
        for (let j = i + 1; j < sortedModules.length; j++) {
          const module = sortedModules[j];

          /** @type {Set<CssModule>***REMOVED*** */
          set.add(module);
          const reason = reasons.get(module) || ( /** @type {Set<ChunkGroup>***REMOVED*** */new Set());
          reason.add(chunkGroup);
          reasons.set(module, reason);
        ***REMOVED***
      ***REMOVED***
      return sortedModules;
    ***REMOVED***);

    // set with already included modules in correct order
    usedModules = new Set();

    /**
     * @param {CssModule***REMOVED*** m
     * @returns {boolean***REMOVED***
     */
    const unusedModulesFilter = m => !( /** @type {Set<CssModule>***REMOVED*** */usedModules.has(m));
    while (usedModules.size < modulesList.length) {
      let success = false;
      let bestMatch;
      let bestMatchDeps;

      // get first module where dependencies are fulfilled
      for (const list of modulesByChunkGroup) {
        // skip and remove already added modules
        while (list.length > 0 && usedModules.has(list[list.length - 1])) {
          list.pop();
        ***REMOVED***

        // skip empty lists
        if (list.length !== 0) {
          const module = list[list.length - 1];
          const deps = moduleDependencies.get(module);
          // determine dependencies that are not yet included
          const failedDeps = Array.from( /** @type {Set<CssModule>***REMOVED*** */
          deps).filter(unusedModulesFilter);

          // store best match for fallback behavior
          if (!bestMatchDeps || bestMatchDeps.length > failedDeps.length) {
            bestMatch = list;
            bestMatchDeps = failedDeps;
          ***REMOVED***
          if (failedDeps.length === 0) {
            // use this module and remove it from list
            usedModules.add( /** @type {CssModule***REMOVED*** */list.pop());
            success = true;
            break;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
      if (!success) {
        // no module found => there is a conflict
        // use list with fewest failed deps
        // and emit a warning
        const fallbackModule = /** @type {CssModule[]***REMOVED*** */bestMatch.pop();
        if (!this.options.ignoreOrder) {
          const reasons = moduleDependenciesReasons.get( /** @type {CssModule***REMOVED*** */fallbackModule);
          compilation.warnings.push( /** @type {WebpackError***REMOVED*** */

          new Error([`chunk ${chunk.name || chunk.id***REMOVED*** [${pluginName***REMOVED***]`, "Conflicting order. Following module has been added:", ` * ${
          /** @type {CssModule***REMOVED*** */fallbackModule.readableIdentifier(requestShortener)***REMOVED***`, "despite it was not able to fulfill desired ordering with these modules:", ... /** @type {CssModule[]***REMOVED*** */bestMatchDeps.map(m => {
            const goodReasonsMap = moduleDependenciesReasons.get(m);
            const goodReasons = goodReasonsMap && goodReasonsMap.get( /** @type {CssModule***REMOVED*** */fallbackModule);
            const failedChunkGroups = Array.from( /** @type {Set<ChunkGroup>***REMOVED*** */

            /** @type {Map<CssModule, Set<ChunkGroup>>***REMOVED*** */
            reasons.get(m), cg => cg.name).join(", ");
            const goodChunkGroups = goodReasons && Array.from(goodReasons, cg => cg.name).join(", ");
            return [` * ${m.readableIdentifier(requestShortener)***REMOVED***`, `   - couldn't fulfill desired order of chunk group(s) ${failedChunkGroups***REMOVED***`, goodChunkGroups && `   - while fulfilling desired order of chunk group(s) ${goodChunkGroups***REMOVED***`].filter(Boolean).join("\n");
          ***REMOVED***)].join("\n")));
        ***REMOVED***
        usedModules.add( /** @type {CssModule***REMOVED*** */fallbackModule);
      ***REMOVED***
    ***REMOVED***
    this._sortedModulesCache.set(chunk, usedModules);
    return usedModules;
  ***REMOVED***

  /**
   * @private
   * @param {Compiler***REMOVED*** compiler
   * @param {Compilation***REMOVED*** compilation
   * @param {Chunk***REMOVED*** chunk
   * @param {CssModule[]***REMOVED*** modules
   * @param {Compiler["requestShortener"]***REMOVED*** requestShortener
   * @param {string***REMOVED*** filenameTemplate
   * @param {Parameters<Exclude<Required<Configuration>['output']['filename'], string | undefined>>[0]***REMOVED*** pathData
   * @returns {Source***REMOVED***
   */
  renderContentAsset(compiler, compilation, chunk, modules, requestShortener, filenameTemplate, pathData) {
    const usedModules = this.sortModules(compilation, chunk, modules, requestShortener);
    const {
      ConcatSource,
      SourceMapSource,
      RawSource
    ***REMOVED*** = compiler.webpack.sources;
    const source = new ConcatSource();
    const externalsSource = new ConcatSource();
    for (const module of usedModules) {
      let content = module.content.toString();
      const readableIdentifier = module.readableIdentifier(requestShortener);
      const startsWithAtRuleImport = /^@import url/.test(content);
      let header;
      if (compilation.outputOptions.pathinfo) {
        // From https://github.com/webpack/webpack/blob/29eff8a74ecc2f87517b627dee451c2af9ed3f3f/lib/ModuleInfoHeaderPlugin.js#L191-L194
        const reqStr = readableIdentifier.replace(/\*\//g, "*_/");
        const reqStrStar = "*".repeat(reqStr.length);
        const headerStr = `/*!****${reqStrStar***REMOVED*******!*\\\n  !*** ${reqStr***REMOVED*** ***!\n  \\****${reqStrStar***REMOVED*******/\n`;
        header = new RawSource(headerStr);
      ***REMOVED***
      if (startsWithAtRuleImport) {
        if (typeof header !== "undefined") {
          externalsSource.add(header);
        ***REMOVED***

        // HACK for IE
        // http://stackoverflow.com/a/14676665/1458162
        if (module.media || module.supports || typeof module.layer !== "undefined") {
          let atImportExtra = "";
          const needLayer = typeof module.layer !== "undefined";
          if (needLayer) {
            atImportExtra += module.layer.length > 0 ? ` layer(${module.layer***REMOVED***)` : " layer";
          ***REMOVED***
          if (module.supports) {
            atImportExtra += ` supports(${module.supports***REMOVED***)`;
          ***REMOVED***
          if (module.media) {
            atImportExtra += ` ${module.media***REMOVED***`;
          ***REMOVED***

          // insert media into the @import
          // this is rar
          // TODO improve this and parse the CSS to support multiple medias
          content = content.replace(/;|\s*$/, `${atImportExtra***REMOVED***;`);
        ***REMOVED***
        externalsSource.add(content);
        externalsSource.add("\n");
      ***REMOVED*** else {
        if (typeof header !== "undefined") {
          source.add(header);
        ***REMOVED***
        if (module.supports) {
          source.add(`@supports (${module.supports***REMOVED***) {\n`);
        ***REMOVED***
        if (module.media) {
          source.add(`@media ${module.media***REMOVED*** {\n`);
        ***REMOVED***
        const needLayer = typeof module.layer !== "undefined";
        if (needLayer) {
          source.add(`@layer${module.layer.length > 0 ? ` ${module.layer***REMOVED***` : ""***REMOVED*** {\n`);
        ***REMOVED***
        const {
          path: filename
        ***REMOVED*** = compilation.getPathWithInfo(filenameTemplate, pathData);
        const undoPath = getUndoPath(filename, compiler.outputPath, false);

        // replacements
        content = content.replace(new RegExp(ABSOLUTE_PUBLIC_PATH, "g"), "");
        content = content.replace(new RegExp(SINGLE_DOT_PATH_SEGMENT, "g"), ".");
        content = content.replace(new RegExp(AUTO_PUBLIC_PATH, "g"), undoPath);
        const entryOptions = chunk.getEntryOptions();
        const baseUriReplacement = entryOptions && entryOptions.baseUri || undoPath;
        content = content.replace(new RegExp(BASE_URI, "g"), baseUriReplacement);
        if (module.sourceMap) {
          source.add(new SourceMapSource(content, readableIdentifier, module.sourceMap.toString()));
        ***REMOVED*** else {
          source.add(new RawSource(content));
        ***REMOVED***
        source.add("\n");
        if (needLayer) {
          source.add("***REMOVED***\n");
        ***REMOVED***
        if (module.media) {
          source.add("***REMOVED***\n");
        ***REMOVED***
        if (module.supports) {
          source.add("***REMOVED***\n");
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    return new ConcatSource(externalsSource, source);
  ***REMOVED***
***REMOVED***
MiniCssExtractPlugin.pluginName = pluginName;
MiniCssExtractPlugin.pluginSymbol = pluginSymbol;
MiniCssExtractPlugin.loader = require.resolve("./loader");
module.exports = MiniCssExtractPlugin;