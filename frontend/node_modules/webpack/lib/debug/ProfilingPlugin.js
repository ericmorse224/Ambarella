/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/

"use strict";

const { Tracer ***REMOVED*** = require("chrome-trace-event");
const {
	JAVASCRIPT_MODULES,
	CSS_MODULES,
	WEBASSEMBLY_MODULES,
	JSON_MODULE_TYPE
***REMOVED*** = require("../ModuleTypeConstants");
const createSchemaValidation = require("../util/create-schema-validation");
const { dirname, mkdirpSync ***REMOVED*** = require("../util/fs");

/** @typedef {import("inspector").Session***REMOVED*** Session */
/** @typedef {import("tapable").FullTap***REMOVED*** FullTap */
/** @typedef {import("../../declarations/plugins/debug/ProfilingPlugin").ProfilingPluginOptions***REMOVED*** ProfilingPluginOptions */
/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../ContextModuleFactory")***REMOVED*** ContextModuleFactory */
/** @typedef {import("../ModuleFactory")***REMOVED*** ModuleFactory */
/** @typedef {import("../NormalModuleFactory")***REMOVED*** NormalModuleFactory */
/** @typedef {import("../Parser")***REMOVED*** Parser */
/** @typedef {import("../ResolverFactory")***REMOVED*** ResolverFactory */
/** @typedef {import("../util/fs").IntermediateFileSystem***REMOVED*** IntermediateFileSystem */

const validate = createSchemaValidation(
	require("../../schemas/plugins/debug/ProfilingPlugin.check.js"),
	() => require("../../schemas/plugins/debug/ProfilingPlugin.json"),
	{
		name: "Profiling Plugin",
		baseDataPath: "options"
	***REMOVED***
);

/** @typedef {{ Session: typeof import("inspector").Session ***REMOVED******REMOVED*** Inspector */

/** @type {Inspector | undefined***REMOVED*** */
let inspector;

try {
	// eslint-disable-next-line n/no-unsupported-features/node-builtins
	inspector = require("inspector");
***REMOVED*** catch (_err) {
	// eslint-disable-next-line no-console
	console.log("Unable to CPU profile in < node 8.0");
***REMOVED***

class Profiler {
	/**
	 * @param {Inspector***REMOVED*** inspector inspector
	 */
	constructor(inspector) {
		/** @type {undefined | Session***REMOVED*** */
		this.session = undefined;
		this.inspector = inspector;
		this._startTime = 0;
	***REMOVED***

	hasSession() {
		return this.session !== undefined;
	***REMOVED***

	startProfiling() {
		if (this.inspector === undefined) {
			return Promise.resolve();
		***REMOVED***

		try {
			this.session = new /** @type {Inspector***REMOVED*** */ (inspector).Session();
			/** @type {Session***REMOVED*** */
			(this.session).connect();
		***REMOVED*** catch (_) {
			this.session = undefined;
			return Promise.resolve();
		***REMOVED***

		const hrtime = process.hrtime();
		this._startTime = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);

		return Promise.all([
			this.sendCommand("Profiler.setSamplingInterval", {
				interval: 100
			***REMOVED***),
			this.sendCommand("Profiler.enable"),
			this.sendCommand("Profiler.start")
		]);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** method method name
	 * @param {EXPECTED_OBJECT=***REMOVED*** params params
	 * @returns {Promise<EXPECTED_ANY | void>***REMOVED*** Promise for the result
	 */
	sendCommand(method, params) {
		if (this.hasSession()) {
			return new Promise((res, rej) => {
				/** @type {Session***REMOVED*** */
				(this.session).post(method, params, (err, params) => {
					if (err !== null) {
						rej(err);
					***REMOVED*** else {
						res(params);
					***REMOVED***
				***REMOVED***);
			***REMOVED***);
		***REMOVED***
		return Promise.resolve();
	***REMOVED***

	destroy() {
		if (this.hasSession()) {
			/** @type {Session***REMOVED*** */
			(this.session).disconnect();
		***REMOVED***

		return Promise.resolve();
	***REMOVED***

	stopProfiling() {
		return this.sendCommand("Profiler.stop").then(({ profile ***REMOVED***) => {
			const hrtime = process.hrtime();
			const endTime = hrtime[0] * 1000000 + Math.round(hrtime[1] / 1000);
			// Avoid coverage problems due indirect changes
			/* istanbul ignore next */
			if (profile.startTime < this._startTime || profile.endTime > endTime) {
				// In some cases timestamps mismatch and we need to adjust them
				// Both process.hrtime and the inspector timestamps claim to be relative
				// to a unknown point in time. But they do not guarantee that this is the
				// same point in time.
				const duration = profile.endTime - profile.startTime;
				const ownDuration = endTime - this._startTime;
				const untracked = Math.max(0, ownDuration - duration);
				profile.startTime = this._startTime + untracked / 2;
				profile.endTime = endTime - untracked / 2;
			***REMOVED***
			return { profile ***REMOVED***;
		***REMOVED***);
	***REMOVED***
***REMOVED***

/**
 * an object that wraps Tracer and Profiler with a counter
 * @typedef {object***REMOVED*** Trace
 * @property {Tracer***REMOVED*** trace instance of Tracer
 * @property {number***REMOVED*** counter Counter
 * @property {Profiler***REMOVED*** profiler instance of Profiler
 * @property {(callback: (err?: null | Error) => void) => void***REMOVED*** end the end function
 */

/**
 * @param {IntermediateFileSystem***REMOVED*** fs filesystem used for output
 * @param {string***REMOVED*** outputPath The location where to write the log.
 * @returns {Trace***REMOVED*** The trace object
 */
const createTrace = (fs, outputPath) => {
	const trace = new Tracer();
	const profiler = new Profiler(/** @type {Inspector***REMOVED*** */ (inspector));
	if (/\/|\\/.test(outputPath)) {
		const dirPath = dirname(fs, outputPath);
		mkdirpSync(fs, dirPath);
	***REMOVED***
	const fsStream = fs.createWriteStream(outputPath);

	let counter = 0;

	trace.pipe(fsStream);
	// These are critical events that need to be inserted so that tools like
	// chrome dev tools can load the profile.
	trace.instantEvent({
		name: "TracingStartedInPage",
		id: ++counter,
		cat: ["disabled-by-default-devtools.timeline"],
		args: {
			data: {
				sessionId: "-1",
				page: "0xfff",
				frames: [
					{
						frame: "0xfff",
						url: "webpack",
						name: ""
					***REMOVED***
				]
			***REMOVED***
		***REMOVED***
	***REMOVED***);

	trace.instantEvent({
		name: "TracingStartedInBrowser",
		id: ++counter,
		cat: ["disabled-by-default-devtools.timeline"],
		args: {
			data: {
				sessionId: "-1"
			***REMOVED***
		***REMOVED***
	***REMOVED***);

	return {
		trace,
		counter,
		profiler,
		end: callback => {
			trace.push("]");
			// Wait until the write stream finishes.
			fsStream.on("close", () => {
				callback();
			***REMOVED***);
			// Tear down the readable trace stream.
			trace.push(null);
		***REMOVED***
	***REMOVED***;
***REMOVED***;

const PLUGIN_NAME = "ProfilingPlugin";

class ProfilingPlugin {
	/**
	 * @param {ProfilingPluginOptions=***REMOVED*** options options object
	 */
	constructor(options = {***REMOVED***) {
		validate(options);
		this.outputPath = options.outputPath || "events.json";
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		const tracer = createTrace(
			/** @type {IntermediateFileSystem***REMOVED*** */
			(compiler.intermediateFileSystem),
			this.outputPath
		);
		tracer.profiler.startProfiling();

		// Compiler Hooks
		for (const hookName of Object.keys(compiler.hooks)) {
			const hook =
				compiler.hooks[/** @type {keyof Compiler["hooks"]***REMOVED*** */ (hookName)];
			if (hook) {
				hook.intercept(makeInterceptorFor("Compiler", tracer)(hookName));
			***REMOVED***
		***REMOVED***

		for (const hookName of Object.keys(compiler.resolverFactory.hooks)) {
			const hook =
				compiler.resolverFactory.hooks[
					/** @type {keyof ResolverFactory["hooks"]***REMOVED*** */
					(hookName)
				];
			if (hook) {
				hook.intercept(makeInterceptorFor("Resolver", tracer)(hookName));
			***REMOVED***
		***REMOVED***

		compiler.hooks.compilation.tap(
			PLUGIN_NAME,
			(compilation, { normalModuleFactory, contextModuleFactory ***REMOVED***) => {
				interceptAllHooksFor(compilation, tracer, "Compilation");
				interceptAllHooksFor(
					normalModuleFactory,
					tracer,
					"Normal Module Factory"
				);
				interceptAllHooksFor(
					contextModuleFactory,
					tracer,
					"Context Module Factory"
				);
				interceptAllParserHooks(normalModuleFactory, tracer);
				interceptAllGeneratorHooks(normalModuleFactory, tracer);
				interceptAllJavascriptModulesPluginHooks(compilation, tracer);
				interceptAllCssModulesPluginHooks(compilation, tracer);
			***REMOVED***
		);

		// We need to write out the CPU profile when we are all done.
		compiler.hooks.done.tapAsync(
			{
				name: PLUGIN_NAME,
				stage: Infinity
			***REMOVED***,
			(stats, callback) => {
				if (compiler.watchMode) return callback();
				tracer.profiler.stopProfiling().then(parsedResults => {
					if (parsedResults === undefined) {
						tracer.profiler.destroy();
						tracer.end(callback);
						return;
					***REMOVED***

					const cpuStartTime = parsedResults.profile.startTime;
					const cpuEndTime = parsedResults.profile.endTime;

					tracer.trace.completeEvent({
						name: "TaskQueueManager::ProcessTaskFromWorkQueue",
						id: ++tracer.counter,
						cat: ["toplevel"],
						ts: cpuStartTime,
						args: {
							// eslint-disable-next-line camelcase
							src_file: "../../ipc/ipc_moji_bootstrap.cc",
							// eslint-disable-next-line camelcase
							src_func: "Accept"
						***REMOVED***
					***REMOVED***);

					tracer.trace.completeEvent({
						name: "EvaluateScript",
						id: ++tracer.counter,
						cat: ["devtools.timeline"],
						ts: cpuStartTime,
						dur: cpuEndTime - cpuStartTime,
						args: {
							data: {
								url: "webpack",
								lineNumber: 1,
								columnNumber: 1,
								frame: "0xFFF"
							***REMOVED***
						***REMOVED***
					***REMOVED***);

					tracer.trace.instantEvent({
						name: "CpuProfile",
						id: ++tracer.counter,
						cat: ["disabled-by-default-devtools.timeline"],
						ts: cpuEndTime,
						args: {
							data: {
								cpuProfile: parsedResults.profile
							***REMOVED***
						***REMOVED***
					***REMOVED***);

					tracer.profiler.destroy();
					tracer.end(callback);
				***REMOVED***);
			***REMOVED***
		);
	***REMOVED***
***REMOVED***

/**
 * @param {EXPECTED_ANY & { hooks: TODO ***REMOVED******REMOVED*** instance instance
 * @param {Trace***REMOVED*** tracer tracer
 * @param {string***REMOVED*** logLabel log label
 */
const interceptAllHooksFor = (instance, tracer, logLabel) => {
	if (Reflect.has(instance, "hooks")) {
		for (const hookName of Object.keys(instance.hooks)) {
			const hook = instance.hooks[hookName];
			if (hook && !hook._fakeHook) {
				hook.intercept(makeInterceptorFor(logLabel, tracer)(hookName));
			***REMOVED***
		***REMOVED***
	***REMOVED***
***REMOVED***;

/**
 * @param {NormalModuleFactory***REMOVED*** moduleFactory normal module factory
 * @param {Trace***REMOVED*** tracer tracer
 */
const interceptAllParserHooks = (moduleFactory, tracer) => {
	const moduleTypes = [
		...JAVASCRIPT_MODULES,
		JSON_MODULE_TYPE,
		...WEBASSEMBLY_MODULES,
		...CSS_MODULES
	];

	for (const moduleType of moduleTypes) {
		moduleFactory.hooks.parser
			.for(moduleType)
			.tap(PLUGIN_NAME, (parser, parserOpts) => {
				interceptAllHooksFor(parser, tracer, "Parser");
			***REMOVED***);
	***REMOVED***
***REMOVED***;

/**
 * @param {NormalModuleFactory***REMOVED*** moduleFactory normal module factory
 * @param {Trace***REMOVED*** tracer tracer
 */
const interceptAllGeneratorHooks = (moduleFactory, tracer) => {
	const moduleTypes = [
		...JAVASCRIPT_MODULES,
		JSON_MODULE_TYPE,
		...WEBASSEMBLY_MODULES,
		...CSS_MODULES
	];

	for (const moduleType of moduleTypes) {
		moduleFactory.hooks.generator
			.for(moduleType)
			.tap(PLUGIN_NAME, (parser, parserOpts) => {
				interceptAllHooksFor(parser, tracer, "Generator");
			***REMOVED***);
	***REMOVED***
***REMOVED***;

/**
 * @param {Compilation***REMOVED*** compilation compilation
 * @param {Trace***REMOVED*** tracer tracer
 */
const interceptAllJavascriptModulesPluginHooks = (compilation, tracer) => {
	interceptAllHooksFor(
		{
			hooks:
				require("../javascript/JavascriptModulesPlugin").getCompilationHooks(
					compilation
				)
		***REMOVED***,
		tracer,
		"JavascriptModulesPlugin"
	);
***REMOVED***;

/**
 * @param {Compilation***REMOVED*** compilation compilation
 * @param {Trace***REMOVED*** tracer tracer
 */
const interceptAllCssModulesPluginHooks = (compilation, tracer) => {
	interceptAllHooksFor(
		{
			hooks: require("../css/CssModulesPlugin").getCompilationHooks(compilation)
		***REMOVED***,
		tracer,
		"CssModulesPlugin"
	);
***REMOVED***;

/** @typedef {(...args: EXPECTED_ANY[]) => EXPECTED_ANY | Promise<(...args: EXPECTED_ANY[]) => EXPECTED_ANY>***REMOVED*** PluginFunction */

/**
 * @param {string***REMOVED*** instance instance
 * @param {Trace***REMOVED*** tracer tracer
 * @returns {(hookName: string) => TODO***REMOVED*** interceptor
 */
const makeInterceptorFor = (instance, tracer) => hookName => ({
	/**
	 * @param {FullTap***REMOVED*** tapInfo tap info
	 * @returns {FullTap***REMOVED*** modified full tap
	 */
	register: tapInfo => {
		const { name, type, fn: internalFn ***REMOVED*** = tapInfo;
		const newFn =
			// Don't tap our own hooks to ensure stream can close cleanly
			name === PLUGIN_NAME
				? internalFn
				: makeNewProfiledTapFn(hookName, tracer, {
						name,
						type,
						fn: /** @type {PluginFunction***REMOVED*** */ (internalFn)
					***REMOVED***);
		return { ...tapInfo, fn: newFn ***REMOVED***;
	***REMOVED***
***REMOVED***);

/**
 * @param {string***REMOVED*** hookName Name of the hook to profile.
 * @param {Trace***REMOVED*** tracer The trace object.
 * @param {object***REMOVED*** options Options for the profiled fn.
 * @param {string***REMOVED*** options.name Plugin name
 * @param {"sync" | "async" | "promise"***REMOVED*** options.type Plugin type (sync | async | promise)
 * @param {PluginFunction***REMOVED*** options.fn Plugin function
 * @returns {PluginFunction***REMOVED*** Chainable hooked function.
 */
const makeNewProfiledTapFn = (hookName, tracer, { name, type, fn ***REMOVED***) => {
	const defaultCategory = ["blink.user_timing"];

	switch (type) {
		case "promise":
			return (...args) => {
				const id = ++tracer.counter;
				tracer.trace.begin({
					name,
					id,
					cat: defaultCategory
				***REMOVED***);
				const promise =
					/** @type {Promise<(...args: EXPECTED_ANY[]) => EXPECTED_ANY>***REMOVED*** */
					(fn(...args));
				return promise.then(r => {
					tracer.trace.end({
						name,
						id,
						cat: defaultCategory
					***REMOVED***);
					return r;
				***REMOVED***);
			***REMOVED***;
		case "async":
			return (...args) => {
				const id = ++tracer.counter;
				tracer.trace.begin({
					name,
					id,
					cat: defaultCategory
				***REMOVED***);
				const callback = args.pop();
				fn(
					...args,
					/**
					 * @param {...EXPECTED_ANY[]***REMOVED*** r result
					 */
					(...r) => {
						tracer.trace.end({
							name,
							id,
							cat: defaultCategory
						***REMOVED***);
						callback(...r);
					***REMOVED***
				);
			***REMOVED***;
		case "sync":
			return (...args) => {
				const id = ++tracer.counter;
				// Do not instrument ourself due to the CPU
				// profile needing to be the last event in the trace.
				if (name === PLUGIN_NAME) {
					return fn(...args);
				***REMOVED***

				tracer.trace.begin({
					name,
					id,
					cat: defaultCategory
				***REMOVED***);
				let r;
				try {
					r = fn(...args);
				***REMOVED*** catch (err) {
					tracer.trace.end({
						name,
						id,
						cat: defaultCategory
					***REMOVED***);
					throw err;
				***REMOVED***
				tracer.trace.end({
					name,
					id,
					cat: defaultCategory
				***REMOVED***);
				return r;
			***REMOVED***;
		default:
			return fn;
	***REMOVED***
***REMOVED***;

module.exports = ProfilingPlugin;
module.exports.Profiler = Profiler;
