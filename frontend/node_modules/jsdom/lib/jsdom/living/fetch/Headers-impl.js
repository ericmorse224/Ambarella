"use strict";

const {
  isForbidden,
  isForbiddenResponse,
  isPrivilegedNoCORSRequest,
  isNoCORSSafelistedRequest,
  isCORSWhitelisted
***REMOVED*** = require("./header-types");
const HeaderList = require("./header-list");

function assertName(name) {
  if (!name.match(/^[!#$%&'*+\-.^`|~\w]+$/)) {
    throw new TypeError("name is invalid");
  ***REMOVED***
***REMOVED***

function assertValue(value) {
  if (value.match(/[\0\r\n]/)) {
    throw new TypeError("value is invalid");
  ***REMOVED***
***REMOVED***

class HeadersImpl {
  constructor(globalObject, args) {
    this.guard = "none";
    this.headersList = new HeaderList();

    if (args[0]) {
      this._fill(args[0]);
    ***REMOVED***
  ***REMOVED***

  _fill(init) {
    if (Array.isArray(init)) {
      for (const header of init) {
        if (header.length !== 2) {
          throw new TypeError("init is invalid");
        ***REMOVED***
        this.append(header[0], header[1]);
      ***REMOVED***
    ***REMOVED*** else {
      for (const key of Object.keys(init)) {
        this.append(key, init[key]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  has(name) {
    assertName(name);
    return this.headersList.contains(name);
  ***REMOVED***

  get(name) {
    assertName(name);
    return this.headersList.get(name);
  ***REMOVED***

  _removePrivilegedNoCORSHeaders() {
    this.headersList.delete("range");
  ***REMOVED***

  append(name, value) {
    value = value.trim();
    assertName(name);
    assertValue(value);

    switch (this.guard) {
      case "immutable":
        throw new TypeError("Headers is immutable");
      case "request":
        if (isForbidden(name)) {
          return;
        ***REMOVED***
        break;
      case "request-no-cors": {
        let temporaryValue = this.get(name);
        if (temporaryValue === null) {
          temporaryValue = value;
        ***REMOVED*** else {
          temporaryValue += `, ${value***REMOVED***`;
        ***REMOVED***
        if (!isCORSWhitelisted(name, value)) {
          return;
        ***REMOVED***
        break;
      ***REMOVED***
      case "response":
        if (isForbiddenResponse(name)) {
          return;
        ***REMOVED***
        break;
    ***REMOVED***

    this.headersList.append(name, value);
    this._removePrivilegedNoCORSHeaders();
  ***REMOVED***

  set(name, value) {
    value = value.trim();
    assertName(name);
    assertValue(value);

    switch (this.guard) {
      case "immutable":
        throw new TypeError("Headers is immutable");
      case "request":
        if (isForbidden(name)) {
          return;
        ***REMOVED***
        break;
      case "request-no-cors": {
        if (!isCORSWhitelisted(name, value)) {
          return;
        ***REMOVED***
        break;
      ***REMOVED***
      case "response":
        if (isForbiddenResponse(name)) {
          return;
        ***REMOVED***
        break;
    ***REMOVED***
    this.headersList.set(name, value);
    this._removePrivilegedNoCORSHeaders();
  ***REMOVED***

  delete(name) {
    assertName(name);

    switch (this.guard) {
      case "immutable":
        throw new TypeError("Headers is immutable");
      case "request":
        if (isForbidden(name)) {
          return;
        ***REMOVED***
        break;
      case "request-no-cors": {
        if (
          !isNoCORSSafelistedRequest(name) &&
          !isPrivilegedNoCORSRequest(name)
        ) {
          return;
        ***REMOVED***
        break;
      ***REMOVED***
      case "response":
        if (isForbiddenResponse(name)) {
          return;
        ***REMOVED***
        break;
    ***REMOVED***
    this.headersList.delete(name);
    this._removePrivilegedNoCORSHeaders();
  ***REMOVED***

  * [Symbol.iterator]() {
    for (const header of this.headersList.sortAndCombine()) {
      yield header;
    ***REMOVED***
  ***REMOVED***
***REMOVED***

exports.implementation = HeadersImpl;
