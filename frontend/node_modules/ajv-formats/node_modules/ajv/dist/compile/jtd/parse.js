"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const types_1 = require("./types");
const __1 = require("..");
const codegen_1 = require("../codegen");
const ref_error_1 = require("../ref_error");
const names_1 = require("../names");
const code_1 = require("../../vocabularies/code");
const ref_1 = require("../../vocabularies/jtd/ref");
const type_1 = require("../../vocabularies/jtd/type");
const parseJson_1 = require("../../runtime/parseJson");
const util_1 = require("../util");
const timestamp_1 = require("../../runtime/timestamp");
const genParse = {
    elements: parseElements,
    values: parseValues,
    discriminator: parseDiscriminator,
    properties: parseProperties,
    optionalProperties: parseProperties,
    enum: parseEnum,
    type: parseType,
    ref: parseRef,
***REMOVED***;
function compileParser(sch, definitions) {
    const _sch = __1.getCompilingSchema.call(this, sch);
    if (_sch)
        return _sch;
    const { es5, lines ***REMOVED*** = this.opts.code;
    const { ownProperties ***REMOVED*** = this.opts;
    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties ***REMOVED***);
    const parseName = gen.scopeName("parse");
    const cxt = {
        self: this,
        gen,
        schema: sch.schema,
        schemaEnv: sch,
        definitions,
        data: names_1.default.data,
        parseName,
        char: gen.name("c"),
    ***REMOVED***;
    let sourceCode;
    try {
        this._compilations.add(sch);
        sch.parseName = parseName;
        parserFunction(cxt);
        gen.optimize(this.opts.code.optimize);
        const parseFuncCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)***REMOVED***return ${parseFuncCode***REMOVED***`;
        const makeParse = new Function(`${names_1.default.scope***REMOVED***`, sourceCode);
        const parse = makeParse(this.scope.get());
        this.scope.value(parseName, { ref: parse ***REMOVED***);
        sch.parse = parse;
    ***REMOVED***
    catch (e) {
        if (sourceCode)
            this.logger.error("Error compiling parser, function code:", sourceCode);
        delete sch.parse;
        delete sch.parseName;
        throw e;
    ***REMOVED***
    finally {
        this._compilations.delete(sch);
    ***REMOVED***
    return sch;
***REMOVED***
exports.default = compileParser;
const undef = (0, codegen_1._) `undefined`;
function parserFunction(cxt) {
    const { gen, parseName, char ***REMOVED*** = cxt;
    gen.func(parseName, (0, codegen_1._) `${names_1.default.json***REMOVED***, ${names_1.default.jsonPos***REMOVED***, ${names_1.default.jsonPart***REMOVED***`, false, () => {
        gen.let(names_1.default.data);
        gen.let(char);
        gen.assign((0, codegen_1._) `${parseName***REMOVED***.message`, undef);
        gen.assign((0, codegen_1._) `${parseName***REMOVED***.position`, undef);
        gen.assign(names_1.default.jsonPos, (0, codegen_1._) `${names_1.default.jsonPos***REMOVED*** || 0`);
        gen.const(names_1.default.jsonLen, (0, codegen_1._) `${names_1.default.json***REMOVED***.length`);
        parseCode(cxt);
        skipWhitespace(cxt);
        gen.if(names_1.default.jsonPart, () => {
            gen.assign((0, codegen_1._) `${parseName***REMOVED***.position`, names_1.default.jsonPos);
            gen.return(names_1.default.data);
        ***REMOVED***);
        gen.if((0, codegen_1._) `${names_1.default.jsonPos***REMOVED*** === ${names_1.default.jsonLen***REMOVED***`, () => gen.return(names_1.default.data));
        jsonSyntaxError(cxt);
    ***REMOVED***);
***REMOVED***
function parseCode(cxt) {
    let form;
    for (const key of types_1.jtdForms) {
        if (key in cxt.schema) {
            form = key;
            break;
        ***REMOVED***
    ***REMOVED***
    if (form)
        parseNullable(cxt, genParse[form]);
    else
        parseEmpty(cxt);
***REMOVED***
const parseBoolean = parseBooleanToken(true, parseBooleanToken(false, jsonSyntaxError));
function parseNullable(cxt, parseForm) {
    const { gen, schema, data ***REMOVED*** = cxt;
    if (!schema.nullable)
        return parseForm(cxt);
    tryParseToken(cxt, "null", parseForm, () => gen.assign(data, null));
***REMOVED***
function parseElements(cxt) {
    const { gen, schema, data ***REMOVED*** = cxt;
    parseToken(cxt, "[");
    const ix = gen.let("i", 0);
    gen.assign(data, (0, codegen_1._) `[]`);
    parseItems(cxt, "]", () => {
        const el = gen.let("el");
        parseCode({ ...cxt, schema: schema.elements, data: el ***REMOVED***);
        gen.assign((0, codegen_1._) `${data***REMOVED***[${ix***REMOVED***++]`, el);
    ***REMOVED***);
***REMOVED***
function parseValues(cxt) {
    const { gen, schema, data ***REMOVED*** = cxt;
    parseToken(cxt, "{");
    gen.assign(data, (0, codegen_1._) `{***REMOVED***`);
    parseItems(cxt, "***REMOVED***", () => parseKeyValue(cxt, schema.values));
***REMOVED***
function parseItems(cxt, endToken, block) {
    tryParseItems(cxt, endToken, block);
    parseToken(cxt, endToken);
***REMOVED***
function tryParseItems(cxt, endToken, block) {
    const { gen ***REMOVED*** = cxt;
    gen.for((0, codegen_1._) `;${names_1.default.jsonPos***REMOVED***<${names_1.default.jsonLen***REMOVED*** && ${jsonSlice(1)***REMOVED***!==${endToken***REMOVED***;`, () => {
        block();
        tryParseToken(cxt, ",", () => gen.break(), hasItem);
    ***REMOVED***);
    function hasItem() {
        tryParseToken(cxt, endToken, () => { ***REMOVED***, jsonSyntaxError);
    ***REMOVED***
***REMOVED***
function parseKeyValue(cxt, schema) {
    const { gen ***REMOVED*** = cxt;
    const key = gen.let("key");
    parseString({ ...cxt, data: key ***REMOVED***);
    parseToken(cxt, ":");
    parsePropertyValue(cxt, key, schema);
***REMOVED***
function parseDiscriminator(cxt) {
    const { gen, data, schema ***REMOVED*** = cxt;
    const { discriminator, mapping ***REMOVED*** = schema;
    parseToken(cxt, "{");
    gen.assign(data, (0, codegen_1._) `{***REMOVED***`);
    const startPos = gen.const("pos", names_1.default.jsonPos);
    const value = gen.let("value");
    const tag = gen.let("tag");
    tryParseItems(cxt, "***REMOVED***", () => {
        const key = gen.let("key");
        parseString({ ...cxt, data: key ***REMOVED***);
        parseToken(cxt, ":");
        gen.if((0, codegen_1._) `${key***REMOVED*** === ${discriminator***REMOVED***`, () => {
            parseString({ ...cxt, data: tag ***REMOVED***);
            gen.assign((0, codegen_1._) `${data***REMOVED***[${key***REMOVED***]`, tag);
            gen.break();
        ***REMOVED***, () => parseEmpty({ ...cxt, data: value ***REMOVED***) // can be discarded/skipped
        );
    ***REMOVED***);
    gen.assign(names_1.default.jsonPos, startPos);
    gen.if((0, codegen_1._) `${tag***REMOVED*** === undefined`);
    parsingError(cxt, (0, codegen_1.str) `discriminator tag not found`);
    for (const tagValue in mapping) {
        gen.elseIf((0, codegen_1._) `${tag***REMOVED*** === ${tagValue***REMOVED***`);
        parseSchemaProperties({ ...cxt, schema: mapping[tagValue] ***REMOVED***, discriminator);
    ***REMOVED***
    gen.else();
    parsingError(cxt, (0, codegen_1.str) `discriminator value not in schema`);
    gen.endIf();
***REMOVED***
function parseProperties(cxt) {
    const { gen, data ***REMOVED*** = cxt;
    parseToken(cxt, "{");
    gen.assign(data, (0, codegen_1._) `{***REMOVED***`);
    parseSchemaProperties(cxt);
***REMOVED***
function parseSchemaProperties(cxt, discriminator) {
    const { gen, schema, data ***REMOVED*** = cxt;
    const { properties, optionalProperties, additionalProperties ***REMOVED*** = schema;
    parseItems(cxt, "***REMOVED***", () => {
        const key = gen.let("key");
        parseString({ ...cxt, data: key ***REMOVED***);
        parseToken(cxt, ":");
        gen.if(false);
        parseDefinedProperty(cxt, key, properties);
        parseDefinedProperty(cxt, key, optionalProperties);
        if (discriminator) {
            gen.elseIf((0, codegen_1._) `${key***REMOVED*** === ${discriminator***REMOVED***`);
            const tag = gen.let("tag");
            parseString({ ...cxt, data: tag ***REMOVED***); // can be discarded, it is already assigned
        ***REMOVED***
        gen.else();
        if (additionalProperties) {
            parseEmpty({ ...cxt, data: (0, codegen_1._) `${data***REMOVED***[${key***REMOVED***]` ***REMOVED***);
        ***REMOVED***
        else {
            parsingError(cxt, (0, codegen_1.str) `property ${key***REMOVED*** not allowed`);
        ***REMOVED***
        gen.endIf();
    ***REMOVED***);
    if (properties) {
        const hasProp = (0, code_1.hasPropFunc)(gen);
        const allProps = (0, codegen_1.and)(...Object.keys(properties).map((p) => (0, codegen_1._) `${hasProp***REMOVED***.call(${data***REMOVED***, ${p***REMOVED***)`));
        gen.if((0, codegen_1.not)(allProps), () => parsingError(cxt, (0, codegen_1.str) `missing required properties`));
    ***REMOVED***
***REMOVED***
function parseDefinedProperty(cxt, key, schemas = {***REMOVED***) {
    const { gen ***REMOVED*** = cxt;
    for (const prop in schemas) {
        gen.elseIf((0, codegen_1._) `${key***REMOVED*** === ${prop***REMOVED***`);
        parsePropertyValue(cxt, key, schemas[prop]);
    ***REMOVED***
***REMOVED***
function parsePropertyValue(cxt, key, schema) {
    parseCode({ ...cxt, schema, data: (0, codegen_1._) `${cxt.data***REMOVED***[${key***REMOVED***]` ***REMOVED***);
***REMOVED***
function parseType(cxt) {
    const { gen, schema, data, self ***REMOVED*** = cxt;
    switch (schema.type) {
        case "boolean":
            parseBoolean(cxt);
            break;
        case "string":
            parseString(cxt);
            break;
        case "timestamp": {
            parseString(cxt);
            const vts = (0, util_1.useFunc)(gen, timestamp_1.default);
            const { allowDate, parseDate ***REMOVED*** = self.opts;
            const notValid = allowDate ? (0, codegen_1._) `!${vts***REMOVED***(${data***REMOVED***, true)` : (0, codegen_1._) `!${vts***REMOVED***(${data***REMOVED***)`;
            const fail = parseDate
                ? (0, codegen_1.or)(notValid, (0, codegen_1._) `(${data***REMOVED*** = new Date(${data***REMOVED***), false)`, (0, codegen_1._) `isNaN(${data***REMOVED***.valueOf())`)
                : notValid;
            gen.if(fail, () => parsingError(cxt, (0, codegen_1.str) `invalid timestamp`));
            break;
        ***REMOVED***
        case "float32":
        case "float64":
            parseNumber(cxt);
            break;
        default: {
            const t = schema.type;
            if (!self.opts.int32range && (t === "int32" || t === "uint32")) {
                parseNumber(cxt, 16); // 2 ** 53 - max safe integer
                if (t === "uint32") {
                    gen.if((0, codegen_1._) `${data***REMOVED*** < 0`, () => parsingError(cxt, (0, codegen_1.str) `integer out of range`));
                ***REMOVED***
            ***REMOVED***
            else {
                const [min, max, maxDigits] = type_1.intRange[t];
                parseNumber(cxt, maxDigits);
                gen.if((0, codegen_1._) `${data***REMOVED*** < ${min***REMOVED*** || ${data***REMOVED*** > ${max***REMOVED***`, () => parsingError(cxt, (0, codegen_1.str) `integer out of range`));
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
***REMOVED***
function parseString(cxt) {
    parseToken(cxt, '"');
    parseWith(cxt, parseJson_1.parseJsonString);
***REMOVED***
function parseEnum(cxt) {
    const { gen, data, schema ***REMOVED*** = cxt;
    const enumSch = schema.enum;
    parseToken(cxt, '"');
    // TODO loopEnum
    gen.if(false);
    for (const value of enumSch) {
        const valueStr = JSON.stringify(value).slice(1); // remove starting quote
        gen.elseIf((0, codegen_1._) `${jsonSlice(valueStr.length)***REMOVED*** === ${valueStr***REMOVED***`);
        gen.assign(data, (0, codegen_1.str) `${value***REMOVED***`);
        gen.add(names_1.default.jsonPos, valueStr.length);
    ***REMOVED***
    gen.else();
    jsonSyntaxError(cxt);
    gen.endIf();
***REMOVED***
function parseNumber(cxt, maxDigits) {
    const { gen ***REMOVED*** = cxt;
    skipWhitespace(cxt);
    gen.if((0, codegen_1._) `"-0123456789".indexOf(${jsonSlice(1)***REMOVED***) < 0`, () => jsonSyntaxError(cxt), () => parseWith(cxt, parseJson_1.parseJsonNumber, maxDigits));
***REMOVED***
function parseBooleanToken(bool, fail) {
    return (cxt) => {
        const { gen, data ***REMOVED*** = cxt;
        tryParseToken(cxt, `${bool***REMOVED***`, () => fail(cxt), () => gen.assign(data, bool));
    ***REMOVED***;
***REMOVED***
function parseRef(cxt) {
    const { gen, self, definitions, schema, schemaEnv ***REMOVED*** = cxt;
    const { ref ***REMOVED*** = schema;
    const refSchema = definitions[ref];
    if (!refSchema)
        throw new ref_error_1.default(self.opts.uriResolver, "", ref, `No definition ${ref***REMOVED***`);
    if (!(0, ref_1.hasRef)(refSchema))
        return parseCode({ ...cxt, schema: refSchema ***REMOVED***);
    const { root ***REMOVED*** = schemaEnv;
    const sch = compileParser.call(self, new __1.SchemaEnv({ schema: refSchema, root ***REMOVED***), definitions);
    partialParse(cxt, getParser(gen, sch), true);
***REMOVED***
function getParser(gen, sch) {
    return sch.parse
        ? gen.scopeValue("parse", { ref: sch.parse ***REMOVED***)
        : (0, codegen_1._) `${gen.scopeValue("wrapper", { ref: sch ***REMOVED***)***REMOVED***.parse`;
***REMOVED***
function parseEmpty(cxt) {
    parseWith(cxt, parseJson_1.parseJson);
***REMOVED***
function parseWith(cxt, parseFunc, args) {
    partialParse(cxt, (0, util_1.useFunc)(cxt.gen, parseFunc), args);
***REMOVED***
function partialParse(cxt, parseFunc, args) {
    const { gen, data ***REMOVED*** = cxt;
    gen.assign(data, (0, codegen_1._) `${parseFunc***REMOVED***(${names_1.default.json***REMOVED***, ${names_1.default.jsonPos***REMOVED***${args ? (0, codegen_1._) `, ${args***REMOVED***` : codegen_1.nil***REMOVED***)`);
    gen.assign(names_1.default.jsonPos, (0, codegen_1._) `${parseFunc***REMOVED***.position`);
    gen.if((0, codegen_1._) `${data***REMOVED*** === undefined`, () => parsingError(cxt, (0, codegen_1._) `${parseFunc***REMOVED***.message`));
***REMOVED***
function parseToken(cxt, tok) {
    tryParseToken(cxt, tok, jsonSyntaxError);
***REMOVED***
function tryParseToken(cxt, tok, fail, success) {
    const { gen ***REMOVED*** = cxt;
    const n = tok.length;
    skipWhitespace(cxt);
    gen.if((0, codegen_1._) `${jsonSlice(n)***REMOVED*** === ${tok***REMOVED***`, () => {
        gen.add(names_1.default.jsonPos, n);
        success === null || success === void 0 ? void 0 : success(cxt);
    ***REMOVED***, () => fail(cxt));
***REMOVED***
function skipWhitespace({ gen, char: c ***REMOVED***) {
    gen.code((0, codegen_1._) `while((${c***REMOVED***=${names_1.default.json***REMOVED***[${names_1.default.jsonPos***REMOVED***],${c***REMOVED***===" "||${c***REMOVED***==="\\n"||${c***REMOVED***==="\\r"||${c***REMOVED***==="\\t"))${names_1.default.jsonPos***REMOVED***++;`);
***REMOVED***
function jsonSlice(len) {
    return len === 1
        ? (0, codegen_1._) `${names_1.default.json***REMOVED***[${names_1.default.jsonPos***REMOVED***]`
        : (0, codegen_1._) `${names_1.default.json***REMOVED***.slice(${names_1.default.jsonPos***REMOVED***, ${names_1.default.jsonPos***REMOVED***+${len***REMOVED***)`;
***REMOVED***
function jsonSyntaxError(cxt) {
    parsingError(cxt, (0, codegen_1._) `"unexpected token " + ${names_1.default.json***REMOVED***[${names_1.default.jsonPos***REMOVED***]`);
***REMOVED***
function parsingError({ gen, parseName ***REMOVED***, msg) {
    gen.assign((0, codegen_1._) `${parseName***REMOVED***.message`, msg);
    gen.assign((0, codegen_1._) `${parseName***REMOVED***.position`, names_1.default.jsonPos);
    gen.return(undef);
***REMOVED***
//# sourceMappingURL=parse.js.map