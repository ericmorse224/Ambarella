"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.default = void 0;
function _gensync() {
  const data = require("gensync");
  _gensync = function () {
    return data;
  ***REMOVED***;
  return data;
***REMOVED***
var _async = require("../gensync-utils/async.js");
var _util = require("./util.js");
var context = require("../index.js");
var _plugin = require("./plugin.js");
var _item = require("./item.js");
var _configChain = require("./config-chain.js");
var _deepArray = require("./helpers/deep-array.js");
function _traverse() {
  const data = require("@babel/traverse");
  _traverse = function () {
    return data;
  ***REMOVED***;
  return data;
***REMOVED***
var _caching = require("./caching.js");
var _options = require("./validation/options.js");
var _plugins = require("./validation/plugins.js");
var _configApi = require("./helpers/config-api.js");
var _partial = require("./partial.js");
var _configError = require("../errors/config-error.js");
var _default = exports.default = _gensync()(function* loadFullConfig(inputOpts) {
  var _opts$assumptions;
  const result = yield* (0, _partial.default)(inputOpts);
  if (!result) {
    return null;
  ***REMOVED***
  const {
    options,
    context,
    fileHandling
  ***REMOVED*** = result;
  if (fileHandling === "ignored") {
    return null;
  ***REMOVED***
  const optionDefaults = {***REMOVED***;
  const {
    plugins,
    presets
  ***REMOVED*** = options;
  if (!plugins || !presets) {
    throw new Error("Assertion failure - plugins and presets exist");
  ***REMOVED***
  const presetContext = Object.assign({***REMOVED***, context, {
    targets: options.targets
  ***REMOVED***);
  const toDescriptor = item => {
    const desc = (0, _item.getItemDescriptor)(item);
    if (!desc) {
      throw new Error("Assertion failure - must be config item");
    ***REMOVED***
    return desc;
  ***REMOVED***;
  const presetsDescriptors = presets.map(toDescriptor);
  const initialPluginsDescriptors = plugins.map(toDescriptor);
  const pluginDescriptorsByPass = [[]];
  const passes = [];
  const externalDependencies = [];
  const ignored = yield* enhanceError(context, function* recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {
    const presets = [];
    for (let i = 0; i < rawPresets.length; i++) {
      const descriptor = rawPresets[i];
      if (descriptor.options !== false) {
        try {
          var preset = yield* loadPresetDescriptor(descriptor, presetContext);
        ***REMOVED*** catch (e) {
          if (e.code === "BABEL_UNKNOWN_OPTION") {
            (0, _options.checkNoUnwrappedItemOptionPairs)(rawPresets, i, "preset", e);
          ***REMOVED***
          throw e;
        ***REMOVED***
        externalDependencies.push(preset.externalDependencies);
        if (descriptor.ownPass) {
          presets.push({
            preset: preset.chain,
            pass: []
          ***REMOVED***);
        ***REMOVED*** else {
          presets.unshift({
            preset: preset.chain,
            pass: pluginDescriptorsPass
          ***REMOVED***);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    if (presets.length > 0) {
      pluginDescriptorsByPass.splice(1, 0, ...presets.map(o => o.pass).filter(p => p !== pluginDescriptorsPass));
      for (const {
        preset,
        pass
      ***REMOVED*** of presets) {
        if (!preset) return true;
        pass.push(...preset.plugins);
        const ignored = yield* recursePresetDescriptors(preset.presets, pass);
        if (ignored) return true;
        preset.options.forEach(opts => {
          (0, _util.mergeOptions)(optionDefaults, opts);
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***)(presetsDescriptors, pluginDescriptorsByPass[0]);
  if (ignored) return null;
  const opts = optionDefaults;
  (0, _util.mergeOptions)(opts, options);
  const pluginContext = Object.assign({***REMOVED***, presetContext, {
    assumptions: (_opts$assumptions = opts.assumptions) != null ? _opts$assumptions : {***REMOVED***
  ***REMOVED***);
  yield* enhanceError(context, function* loadPluginDescriptors() {
    pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);
    for (const descs of pluginDescriptorsByPass) {
      const pass = [];
      passes.push(pass);
      for (let i = 0; i < descs.length; i++) {
        const descriptor = descs[i];
        if (descriptor.options !== false) {
          try {
            var plugin = yield* loadPluginDescriptor(descriptor, pluginContext);
          ***REMOVED*** catch (e) {
            if (e.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY") {
              (0, _options.checkNoUnwrappedItemOptionPairs)(descs, i, "plugin", e);
            ***REMOVED***
            throw e;
          ***REMOVED***
          pass.push(plugin);
          externalDependencies.push(plugin.externalDependencies);
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***)();
  opts.plugins = passes[0];
  opts.presets = passes.slice(1).filter(plugins => plugins.length > 0).map(plugins => ({
    plugins
  ***REMOVED***));
  opts.passPerPreset = opts.presets.length > 0;
  return {
    options: opts,
    passes: passes,
    externalDependencies: (0, _deepArray.finalize)(externalDependencies)
  ***REMOVED***;
***REMOVED***);
function enhanceError(context, fn) {
  return function* (arg1, arg2) {
    try {
      return yield* fn(arg1, arg2);
    ***REMOVED*** catch (e) {
      if (!/^\[BABEL\]/.test(e.message)) {
        var _context$filename;
        e.message = `[BABEL] ${(_context$filename = context.filename) != null ? _context$filename : "unknown file"***REMOVED***: ${e.message***REMOVED***`;
      ***REMOVED***
      throw e;
    ***REMOVED***
  ***REMOVED***;
***REMOVED***
const makeDescriptorLoader = apiFactory => (0, _caching.makeWeakCache)(function* ({
  value,
  options,
  dirname,
  alias
***REMOVED***, cache) {
  if (options === false) throw new Error("Assertion failure");
  options = options || {***REMOVED***;
  const externalDependencies = [];
  let item = value;
  if (typeof value === "function") {
    const factory = (0, _async.maybeAsync)(value, `You appear to be using an async plugin/preset, but Babel has been called synchronously`);
    const api = Object.assign({***REMOVED***, context, apiFactory(cache, externalDependencies));
    try {
      item = yield* factory(api, options, dirname);
    ***REMOVED*** catch (e) {
      if (alias) {
        e.message += ` (While processing: ${JSON.stringify(alias)***REMOVED***)`;
      ***REMOVED***
      throw e;
    ***REMOVED***
  ***REMOVED***
  if (!item || typeof item !== "object") {
    throw new Error("Plugin/Preset did not return an object.");
  ***REMOVED***
  if ((0, _async.isThenable)(item)) {
    yield* [];
    throw new Error(`You appear to be using a promise as a plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, ` + `you may need to upgrade your @babel/core version. ` + `As an alternative, you can prefix the promise with "await". ` + `(While processing: ${JSON.stringify(alias)***REMOVED***)`);
  ***REMOVED***
  if (externalDependencies.length > 0 && (!cache.configured() || cache.mode() === "forever")) {
    let error = `A plugin/preset has external untracked dependencies ` + `(${externalDependencies[0]***REMOVED***), but the cache `;
    if (!cache.configured()) {
      error += `has not been configured to be invalidated when the external dependencies change. `;
    ***REMOVED*** else {
      error += ` has been configured to never be invalidated. `;
    ***REMOVED***
    error += `Plugins/presets should configure their cache to be invalidated when the external ` + `dependencies change, for example using \`api.cache.invalidate(() => ` + `statSync(filepath).mtimeMs)\` or \`api.cache.never()\`\n` + `(While processing: ${JSON.stringify(alias)***REMOVED***)`;
    throw new Error(error);
  ***REMOVED***
  return {
    value: item,
    options,
    dirname,
    alias,
    externalDependencies: (0, _deepArray.finalize)(externalDependencies)
  ***REMOVED***;
***REMOVED***);
const pluginDescriptorLoader = makeDescriptorLoader(_configApi.makePluginAPI);
const presetDescriptorLoader = makeDescriptorLoader(_configApi.makePresetAPI);
const instantiatePlugin = (0, _caching.makeWeakCache)(function* ({
  value,
  options,
  dirname,
  alias,
  externalDependencies
***REMOVED***, cache) {
  const pluginObj = (0, _plugins.validatePluginObject)(value);
  const plugin = Object.assign({***REMOVED***, pluginObj);
  if (plugin.visitor) {
    plugin.visitor = _traverse().default.explode(Object.assign({***REMOVED***, plugin.visitor));
  ***REMOVED***
  if (plugin.inherits) {
    const inheritsDescriptor = {
      name: undefined,
      alias: `${alias***REMOVED***$inherits`,
      value: plugin.inherits,
      options,
      dirname
    ***REMOVED***;
    const inherits = yield* (0, _async.forwardAsync)(loadPluginDescriptor, run => {
      return cache.invalidate(data => run(inheritsDescriptor, data));
    ***REMOVED***);
    plugin.pre = chainMaybeAsync(inherits.pre, plugin.pre);
    plugin.post = chainMaybeAsync(inherits.post, plugin.post);
    plugin.manipulateOptions = chainMaybeAsync(inherits.manipulateOptions, plugin.manipulateOptions);
    plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {***REMOVED***, plugin.visitor || {***REMOVED***]);
    if (inherits.externalDependencies.length > 0) {
      if (externalDependencies.length === 0) {
        externalDependencies = inherits.externalDependencies;
      ***REMOVED*** else {
        externalDependencies = (0, _deepArray.finalize)([externalDependencies, inherits.externalDependencies]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  return new _plugin.default(plugin, options, alias, externalDependencies);
***REMOVED***);
function* loadPluginDescriptor(descriptor, context) {
  if (descriptor.value instanceof _plugin.default) {
    if (descriptor.options) {
      throw new Error("Passed options to an existing Plugin instance will not work.");
    ***REMOVED***
    return descriptor.value;
  ***REMOVED***
  return yield* instantiatePlugin(yield* pluginDescriptorLoader(descriptor, context), context);
***REMOVED***
const needsFilename = val => val && typeof val !== "function";
const validateIfOptionNeedsFilename = (options, descriptor) => {
  if (needsFilename(options.test) || needsFilename(options.include) || needsFilename(options.exclude)) {
    const formattedPresetName = descriptor.name ? `"${descriptor.name***REMOVED***"` : "/* your preset */";
    throw new _configError.default([`Preset ${formattedPresetName***REMOVED*** requires a filename to be set when babel is called directly,`, `\`\`\``, `babel.transformSync(code, { filename: 'file.ts', presets: [${formattedPresetName***REMOVED***] ***REMOVED***);`, `\`\`\``, `See https://babeljs.io/docs/en/options#filename for more information.`].join("\n"));
  ***REMOVED***
***REMOVED***;
const validatePreset = (preset, context, descriptor) => {
  if (!context.filename) {
    var _options$overrides;
    const {
      options
    ***REMOVED*** = preset;
    validateIfOptionNeedsFilename(options, descriptor);
    (_options$overrides = options.overrides) == null || _options$overrides.forEach(overrideOptions => validateIfOptionNeedsFilename(overrideOptions, descriptor));
  ***REMOVED***
***REMOVED***;
const instantiatePreset = (0, _caching.makeWeakCacheSync)(({
  value,
  dirname,
  alias,
  externalDependencies
***REMOVED***) => {
  return {
    options: (0, _options.validate)("preset", value),
    alias,
    dirname,
    externalDependencies
  ***REMOVED***;
***REMOVED***);
function* loadPresetDescriptor(descriptor, context) {
  const preset = instantiatePreset(yield* presetDescriptorLoader(descriptor, context));
  validatePreset(preset, context, descriptor);
  return {
    chain: yield* (0, _configChain.buildPresetChain)(preset, context),
    externalDependencies: preset.externalDependencies
  ***REMOVED***;
***REMOVED***
function chainMaybeAsync(a, b) {
  if (!a) return b;
  if (!b) return a;
  return function (...args) {
    const res = a.apply(this, args);
    if (res && typeof res.then === "function") {
      return res.then(() => b.apply(this, args));
    ***REMOVED***
    return b.apply(this, args);
  ***REMOVED***;
***REMOVED***
0 && 0;

//# sourceMappingURL=full.js.map
