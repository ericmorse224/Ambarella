"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; ***REMOVED*** ***REMOVED***;
    ***REMOVED***
    Object.defineProperty(o, k2, desc);
***REMOVED***) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
***REMOVED***));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v ***REMOVED***);
***REMOVED***) : function(o, v) {
    o["default"] = v;
***REMOVED***);
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {***REMOVED***;
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
***REMOVED***;
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const utils_1 = require("@typescript-eslint/utils");
const util = __importStar(require("../util"));
const getESLintCoreRule_1 = require("../util/getESLintCoreRule");
const baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('lines-around-comment');
const COMMENTS_IGNORE_PATTERN = /^\s*(?:eslint|jshint\s+|jslint\s+|istanbul\s+|globals?\s+|exported\s+|jscs)/u;
/**
 * @returns an array with with any line numbers that are empty.
 */
function getEmptyLineNums(lines) {
    const emptyLines = lines
        .map((line, i) => ({
        code: line.trim(),
        num: i + 1,
    ***REMOVED***))
        .filter(line => !line.code)
        .map(line => line.num);
    return emptyLines;
***REMOVED***
/**
 * @returns an array with with any line numbers that contain comments.
 */
function getCommentLineNums(comments) {
    const lines = [];
    comments.forEach(token => {
        const start = token.loc.start.line;
        const end = token.loc.end.line;
        lines.push(start, end);
    ***REMOVED***);
    return lines;
***REMOVED***
exports.default = util.createRule({
    name: 'lines-around-comment',
    meta: {
        type: 'layout',
        docs: {
            description: 'Require empty lines around comments',
            recommended: false,
            extendsBaseRule: true,
        ***REMOVED***,
        schema: {
            type: 'array',
            items: [
                {
                    type: 'object',
                    properties: {
                        beforeBlockComment: {
                            type: 'boolean',
                            default: true,
                        ***REMOVED***,
                        afterBlockComment: {
                            type: 'boolean',
                            default: false,
                        ***REMOVED***,
                        beforeLineComment: {
                            type: 'boolean',
                            default: false,
                        ***REMOVED***,
                        afterLineComment: {
                            type: 'boolean',
                            default: false,
                        ***REMOVED***,
                        allowBlockStart: {
                            type: 'boolean',
                            default: false,
                        ***REMOVED***,
                        allowBlockEnd: {
                            type: 'boolean',
                            default: false,
                        ***REMOVED***,
                        allowClassStart: {
                            type: 'boolean',
                        ***REMOVED***,
                        allowClassEnd: {
                            type: 'boolean',
                        ***REMOVED***,
                        allowObjectStart: {
                            type: 'boolean',
                        ***REMOVED***,
                        allowObjectEnd: {
                            type: 'boolean',
                        ***REMOVED***,
                        allowArrayStart: {
                            type: 'boolean',
                        ***REMOVED***,
                        allowArrayEnd: {
                            type: 'boolean',
                        ***REMOVED***,
                        allowInterfaceStart: {
                            type: 'boolean',
                        ***REMOVED***,
                        allowInterfaceEnd: {
                            type: 'boolean',
                        ***REMOVED***,
                        allowTypeStart: {
                            type: 'boolean',
                        ***REMOVED***,
                        allowTypeEnd: {
                            type: 'boolean',
                        ***REMOVED***,
                        allowEnumStart: {
                            type: 'boolean',
                        ***REMOVED***,
                        allowEnumEnd: {
                            type: 'boolean',
                        ***REMOVED***,
                        allowModuleStart: {
                            type: 'boolean',
                        ***REMOVED***,
                        allowModuleEnd: {
                            type: 'boolean',
                        ***REMOVED***,
                        ignorePattern: {
                            type: 'string',
                        ***REMOVED***,
                        applyDefaultIgnorePatterns: {
                            type: 'boolean',
                        ***REMOVED***,
                    ***REMOVED***,
                    additionalProperties: false,
                ***REMOVED***,
            ],
        ***REMOVED***,
        fixable: baseRule.meta.fixable,
        hasSuggestions: baseRule.meta.hasSuggestions,
        messages: baseRule.meta.messages,
    ***REMOVED***,
    defaultOptions: [
        {
            beforeBlockComment: true,
        ***REMOVED***,
    ],
    create(context, [_options]) {
        var _a;
        const options = _options;
        const defaultIgnoreRegExp = COMMENTS_IGNORE_PATTERN;
        const customIgnoreRegExp = new RegExp((_a = options.ignorePattern) !== null && _a !== void 0 ? _a : '', 'u');
        const sourceCode = context.getSourceCode();
        const comments = sourceCode.getAllComments();
        const lines = sourceCode.lines;
        const commentLines = getCommentLineNums(comments);
        const emptyLines = getEmptyLineNums(lines);
        const commentAndEmptyLines = new Set(commentLines.concat(emptyLines));
        /**
         * @returns whether comments are on lines starting with or ending with code.
         */
        function codeAroundComment(token) {
            let currentToken = token;
            do {
                currentToken = sourceCode.getTokenBefore(currentToken, {
                    includeComments: true,
                ***REMOVED***);
            ***REMOVED*** while (currentToken && util.isCommentToken(currentToken));
            if (currentToken && util.isTokenOnSameLine(currentToken, token)) {
                return true;
            ***REMOVED***
            currentToken = token;
            do {
                currentToken = sourceCode.getTokenAfter(currentToken, {
                    includeComments: true,
                ***REMOVED***);
            ***REMOVED*** while (currentToken && util.isCommentToken(currentToken));
            if (currentToken && util.isTokenOnSameLine(token, currentToken)) {
                return true;
            ***REMOVED***
            return false;
        ***REMOVED***
        /**
         * @returns whether comments are inside a node type.
         */
        function isParentNodeType(parent, nodeType) {
            return parent.type === nodeType;
        ***REMOVED***
        /**
         * @returns the parent node that contains the given token.
         */
        function getParentNodeOfToken(token) {
            const node = sourceCode.getNodeByRangeIndex(token.range[0]);
            return node;
        ***REMOVED***
        /**
         * @returns whether comments are at the parent start.
         */
        function isCommentAtParentStart(token, nodeType) {
            const parent = getParentNodeOfToken(token);
            if (parent && isParentNodeType(parent, nodeType)) {
                const parentStartNodeOrToken = parent;
                return (token.loc.start.line - parentStartNodeOrToken.loc.start.line === 1);
            ***REMOVED***
            return false;
        ***REMOVED***
        /**
         * @returns whether comments are at the parent end.
         */
        function isCommentAtParentEnd(token, nodeType) {
            const parent = getParentNodeOfToken(token);
            return (!!parent &&
                isParentNodeType(parent, nodeType) &&
                parent.loc.end.line - token.loc.end.line === 1);
        ***REMOVED***
        function isCommentAtInterfaceStart(token) {
            return isCommentAtParentStart(token, utils_1.AST_NODE_TYPES.TSInterfaceBody);
        ***REMOVED***
        function isCommentAtInterfaceEnd(token) {
            return isCommentAtParentEnd(token, utils_1.AST_NODE_TYPES.TSInterfaceBody);
        ***REMOVED***
        function isCommentAtTypeStart(token) {
            return isCommentAtParentStart(token, utils_1.AST_NODE_TYPES.TSTypeLiteral);
        ***REMOVED***
        function isCommentAtTypeEnd(token) {
            return isCommentAtParentEnd(token, utils_1.AST_NODE_TYPES.TSTypeLiteral);
        ***REMOVED***
        function isCommentAtEnumStart(token) {
            return isCommentAtParentStart(token, utils_1.AST_NODE_TYPES.TSEnumDeclaration);
        ***REMOVED***
        function isCommentAtEnumEnd(token) {
            return isCommentAtParentEnd(token, utils_1.AST_NODE_TYPES.TSEnumDeclaration);
        ***REMOVED***
        function isCommentAtModuleStart(token) {
            return isCommentAtParentStart(token, utils_1.AST_NODE_TYPES.TSModuleBlock);
        ***REMOVED***
        function isCommentAtModuleEnd(token) {
            return isCommentAtParentEnd(token, utils_1.AST_NODE_TYPES.TSModuleBlock);
        ***REMOVED***
        function isCommentNearTSConstruct(token) {
            return (isCommentAtInterfaceStart(token) ||
                isCommentAtInterfaceEnd(token) ||
                isCommentAtTypeStart(token) ||
                isCommentAtTypeEnd(token) ||
                isCommentAtEnumStart(token) ||
                isCommentAtEnumEnd(token) ||
                isCommentAtModuleStart(token) ||
                isCommentAtModuleEnd(token));
        ***REMOVED***
        function checkForEmptyLine(token, { before, after ***REMOVED***) {
            // the base rule handles comments away from TS constructs blocks correctly, we skip those
            if (!isCommentNearTSConstruct(token)) {
                return;
            ***REMOVED***
            if (options.applyDefaultIgnorePatterns !== false &&
                defaultIgnoreRegExp.test(token.value)) {
                return;
            ***REMOVED***
            if (options.ignorePattern && customIgnoreRegExp.test(token.value)) {
                return;
            ***REMOVED***
            const prevLineNum = token.loc.start.line - 1;
            const nextLineNum = token.loc.end.line + 1;
            // we ignore all inline comments
            if (codeAroundComment(token)) {
                return;
            ***REMOVED***
            const interfaceStartAllowed = Boolean(options.allowInterfaceStart) &&
                isCommentAtInterfaceStart(token);
            const interfaceEndAllowed = Boolean(options.allowInterfaceEnd) && isCommentAtInterfaceEnd(token);
            const typeStartAllowed = Boolean(options.allowTypeStart) && isCommentAtTypeStart(token);
            const typeEndAllowed = Boolean(options.allowTypeEnd) && isCommentAtTypeEnd(token);
            const enumStartAllowed = Boolean(options.allowEnumStart) && isCommentAtEnumStart(token);
            const enumEndAllowed = Boolean(options.allowEnumEnd) && isCommentAtEnumEnd(token);
            const moduleStartAllowed = Boolean(options.allowModuleStart) && isCommentAtModuleStart(token);
            const moduleEndAllowed = Boolean(options.allowModuleEnd) && isCommentAtModuleEnd(token);
            const exceptionStartAllowed = interfaceStartAllowed ||
                typeStartAllowed ||
                enumStartAllowed ||
                moduleStartAllowed;
            const exceptionEndAllowed = interfaceEndAllowed ||
                typeEndAllowed ||
                enumEndAllowed ||
                moduleEndAllowed;
            const previousTokenOrComment = sourceCode.getTokenBefore(token, {
                includeComments: true,
            ***REMOVED***);
            const nextTokenOrComment = sourceCode.getTokenAfter(token, {
                includeComments: true,
            ***REMOVED***);
            // check for newline before
            if (!exceptionStartAllowed &&
                before &&
                !commentAndEmptyLines.has(prevLineNum) &&
                !(util.isCommentToken(previousTokenOrComment) &&
                    util.isTokenOnSameLine(previousTokenOrComment, token))) {
                const lineStart = token.range[0] - token.loc.start.column;
                const range = [lineStart, lineStart];
                context.report({
                    node: token,
                    messageId: 'before',
                    fix(fixer) {
                        return fixer.insertTextBeforeRange(range, '\n');
                    ***REMOVED***,
                ***REMOVED***);
            ***REMOVED***
            // check for newline after
            if (!exceptionEndAllowed &&
                after &&
                !commentAndEmptyLines.has(nextLineNum) &&
                !(util.isCommentToken(nextTokenOrComment) &&
                    util.isTokenOnSameLine(token, nextTokenOrComment))) {
                context.report({
                    node: token,
                    messageId: 'after',
                    fix(fixer) {
                        return fixer.insertTextAfter(token, '\n');
                    ***REMOVED***,
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***
        /**
         * A custom report function for the baseRule to ignore false positive errors
         * caused by TS-specific codes
         */
        const customReport = descriptor => {
            if ('node' in descriptor) {
                if (descriptor.node.type === utils_1.AST_TOKEN_TYPES.Line ||
                    descriptor.node.type === utils_1.AST_TOKEN_TYPES.Block) {
                    if (isCommentNearTSConstruct(descriptor.node)) {
                        return;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
            return context.report(descriptor);
        ***REMOVED***;
        const customContext = { report: customReport ***REMOVED***;
        // we can't directly proxy `context` because its `report` property is non-configurable
        // and non-writable. So we proxy `customContext` and redirect all
        // property access to the original context except for `report`
        const proxiedContext = new Proxy(customContext, {
            get(target, path, receiver) {
                if (path !== 'report') {
                    return Reflect.get(context, path, receiver);
                ***REMOVED***
                return Reflect.get(target, path, receiver);
            ***REMOVED***,
        ***REMOVED***);
        const rules = baseRule.create(proxiedContext);
        return {
            Program() {
                rules.Program();
                comments.forEach(token => {
                    if (token.type === utils_1.AST_TOKEN_TYPES.Line) {
                        if (options.beforeLineComment || options.afterLineComment) {
                            checkForEmptyLine(token, {
                                after: options.afterLineComment,
                                before: options.beforeLineComment,
                            ***REMOVED***);
                        ***REMOVED***
                    ***REMOVED***
                    else if (token.type === utils_1.AST_TOKEN_TYPES.Block) {
                        if (options.beforeBlockComment || options.afterBlockComment) {
                            checkForEmptyLine(token, {
                                after: options.afterBlockComment,
                                before: options.beforeBlockComment,
                            ***REMOVED***);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***,
        ***REMOVED***;
    ***REMOVED***,
***REMOVED***);
//# sourceMappingURL=lines-around-comment.js.map