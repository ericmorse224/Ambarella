const { humanReadableArgName ***REMOVED*** = require('./argument.js');

/**
 * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`
 * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types
 * @typedef { import("./argument.js").Argument ***REMOVED*** Argument
 * @typedef { import("./command.js").Command ***REMOVED*** Command
 * @typedef { import("./option.js").Option ***REMOVED*** Option
 */

// @ts-check

// Although this is a class, methods are static in style to allow override using subclass or just functions.
class Help {
  constructor() {
    this.helpWidth = undefined;
    this.sortSubcommands = false;
    this.sortOptions = false;
  ***REMOVED***

  /**
   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
   *
   * @param {Command***REMOVED*** cmd
   * @returns {Command[]***REMOVED***
   */

  visibleCommands(cmd) {
    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);
    if (cmd._hasImplicitHelpCommand()) {
      // Create a command matching the implicit help command.
      const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
      const helpCommand = cmd.createCommand(helpName)
        .helpOption(false);
      helpCommand.description(cmd._helpCommandDescription);
      if (helpArgs) helpCommand.arguments(helpArgs);
      visibleCommands.push(helpCommand);
    ***REMOVED***
    if (this.sortSubcommands) {
      visibleCommands.sort((a, b) => {
        // @ts-ignore: overloaded return type
        return a.name().localeCompare(b.name());
      ***REMOVED***);
    ***REMOVED***
    return visibleCommands;
  ***REMOVED***

  /**
   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
   *
   * @param {Command***REMOVED*** cmd
   * @returns {Option[]***REMOVED***
   */

  visibleOptions(cmd) {
    const visibleOptions = cmd.options.filter((option) => !option.hidden);
    // Implicit help
    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
    if (showShortHelpFlag || showLongHelpFlag) {
      let helpOption;
      if (!showShortHelpFlag) {
        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
      ***REMOVED*** else if (!showLongHelpFlag) {
        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
      ***REMOVED*** else {
        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
      ***REMOVED***
      visibleOptions.push(helpOption);
    ***REMOVED***
    if (this.sortOptions) {
      const getSortKey = (option) => {
        // WYSIWYG for order displayed in help with short before long, no special handling for negated.
        return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');
      ***REMOVED***;
      visibleOptions.sort((a, b) => {
        return getSortKey(a).localeCompare(getSortKey(b));
      ***REMOVED***);
    ***REMOVED***
    return visibleOptions;
  ***REMOVED***

  /**
   * Get an array of the arguments if any have a description.
   *
   * @param {Command***REMOVED*** cmd
   * @returns {Argument[]***REMOVED***
   */

  visibleArguments(cmd) {
    // Side effect! Apply the legacy descriptions before the arguments are displayed.
    if (cmd._argsDescription) {
      cmd._args.forEach(argument => {
        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';
      ***REMOVED***);
    ***REMOVED***

    // If there are any arguments with a description then return all the arguments.
    if (cmd._args.find(argument => argument.description)) {
      return cmd._args;
    ***REMOVED***;
    return [];
  ***REMOVED***

  /**
   * Get the command term to show in the list of subcommands.
   *
   * @param {Command***REMOVED*** cmd
   * @returns {string***REMOVED***
   */

  subcommandTerm(cmd) {
    // Legacy. Ignores custom usage string, and nested commands.
    const args = cmd._args.map(arg => humanReadableArgName(arg)).join(' ');
    return cmd._name +
      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +
      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option
      (args ? ' ' + args : '');
  ***REMOVED***

  /**
   * Get the option term to show in the list of options.
   *
   * @param {Option***REMOVED*** option
   * @returns {string***REMOVED***
   */

  optionTerm(option) {
    return option.flags;
  ***REMOVED***

  /**
   * Get the argument term to show in the list of arguments.
   *
   * @param {Argument***REMOVED*** argument
   * @returns {string***REMOVED***
   */

  argumentTerm(argument) {
    return argument.name();
  ***REMOVED***

  /**
   * Get the longest command term length.
   *
   * @param {Command***REMOVED*** cmd
   * @param {Help***REMOVED*** helper
   * @returns {number***REMOVED***
   */

  longestSubcommandTermLength(cmd, helper) {
    return helper.visibleCommands(cmd).reduce((max, command) => {
      return Math.max(max, helper.subcommandTerm(command).length);
    ***REMOVED***, 0);
  ***REMOVED***;

  /**
   * Get the longest option term length.
   *
   * @param {Command***REMOVED*** cmd
   * @param {Help***REMOVED*** helper
   * @returns {number***REMOVED***
   */

  longestOptionTermLength(cmd, helper) {
    return helper.visibleOptions(cmd).reduce((max, option) => {
      return Math.max(max, helper.optionTerm(option).length);
    ***REMOVED***, 0);
  ***REMOVED***;

  /**
   * Get the longest argument term length.
   *
   * @param {Command***REMOVED*** cmd
   * @param {Help***REMOVED*** helper
   * @returns {number***REMOVED***
   */

  longestArgumentTermLength(cmd, helper) {
    return helper.visibleArguments(cmd).reduce((max, argument) => {
      return Math.max(max, helper.argumentTerm(argument).length);
    ***REMOVED***, 0);
  ***REMOVED***;

  /**
   * Get the command usage to be displayed at the top of the built-in help.
   *
   * @param {Command***REMOVED*** cmd
   * @returns {string***REMOVED***
   */

  commandUsage(cmd) {
    // Usage
    let cmdName = cmd._name;
    if (cmd._aliases[0]) {
      cmdName = cmdName + '|' + cmd._aliases[0];
    ***REMOVED***
    let parentCmdNames = '';
    for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {
      parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;
    ***REMOVED***
    return parentCmdNames + cmdName + ' ' + cmd.usage();
  ***REMOVED***

  /**
   * Get the description for the command.
   *
   * @param {Command***REMOVED*** cmd
   * @returns {string***REMOVED***
   */

  commandDescription(cmd) {
    // @ts-ignore: overloaded return type
    return cmd.description();
  ***REMOVED***

  /**
   * Get the command description to show in the list of subcommands.
   *
   * @param {Command***REMOVED*** cmd
   * @returns {string***REMOVED***
   */

  subcommandDescription(cmd) {
    // @ts-ignore: overloaded return type
    return cmd.description();
  ***REMOVED***

  /**
   * Get the option description to show in the list of options.
   *
   * @param {Option***REMOVED*** option
   * @return {string***REMOVED***
   */

  optionDescription(option) {
    const extraInfo = [];
    // Some of these do not make sense for negated boolean and suppress for backwards compatibility.

    if (option.argChoices && !option.negate) {
      extraInfo.push(
        // use stringify to match the display of the default value
        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')***REMOVED***`);
    ***REMOVED***
    if (option.defaultValue !== undefined && !option.negate) {
      extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)***REMOVED***`);
    ***REMOVED***
    if (option.envVar !== undefined) {
      extraInfo.push(`env: ${option.envVar***REMOVED***`);
    ***REMOVED***
    if (extraInfo.length > 0) {
      return `${option.description***REMOVED*** (${extraInfo.join(', ')***REMOVED***)`;
    ***REMOVED***

    return option.description;
  ***REMOVED***;

  /**
   * Get the argument description to show in the list of arguments.
   *
   * @param {Argument***REMOVED*** argument
   * @return {string***REMOVED***
   */

  argumentDescription(argument) {
    const extraInfo = [];
    if (argument.argChoices) {
      extraInfo.push(
        // use stringify to match the display of the default value
        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')***REMOVED***`);
    ***REMOVED***
    if (argument.defaultValue !== undefined) {
      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)***REMOVED***`);
    ***REMOVED***
    if (extraInfo.length > 0) {
      const extraDescripton = `(${extraInfo.join(', ')***REMOVED***)`;
      if (argument.description) {
        return `${argument.description***REMOVED*** ${extraDescripton***REMOVED***`;
      ***REMOVED***
      return extraDescripton;
    ***REMOVED***
    return argument.description;
  ***REMOVED***

  /**
   * Generate the built-in help text.
   *
   * @param {Command***REMOVED*** cmd
   * @param {Help***REMOVED*** helper
   * @returns {string***REMOVED***
   */

  formatHelp(cmd, helper) {
    const termWidth = helper.padWidth(cmd, helper);
    const helpWidth = helper.helpWidth || 80;
    const itemIndentWidth = 2;
    const itemSeparatorWidth = 2; // between term and description
    function formatItem(term, description) {
      if (description) {
        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)***REMOVED***${description***REMOVED***`;
        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
      ***REMOVED***
      return term;
    ***REMOVED***;
    function formatList(textArray) {
      return textArray.join('\n').replace(/^/gm, ' '.repeat(itemIndentWidth));
    ***REMOVED***

    // Usage
    let output = [`Usage: ${helper.commandUsage(cmd)***REMOVED***`, ''];

    // Description
    const commandDescription = helper.commandDescription(cmd);
    if (commandDescription.length > 0) {
      output = output.concat([commandDescription, '']);
    ***REMOVED***

    // Arguments
    const argumentList = helper.visibleArguments(cmd).map((argument) => {
      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
    ***REMOVED***);
    if (argumentList.length > 0) {
      output = output.concat(['Arguments:', formatList(argumentList), '']);
    ***REMOVED***

    // Options
    const optionList = helper.visibleOptions(cmd).map((option) => {
      return formatItem(helper.optionTerm(option), helper.optionDescription(option));
    ***REMOVED***);
    if (optionList.length > 0) {
      output = output.concat(['Options:', formatList(optionList), '']);
    ***REMOVED***

    // Commands
    const commandList = helper.visibleCommands(cmd).map((cmd) => {
      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));
    ***REMOVED***);
    if (commandList.length > 0) {
      output = output.concat(['Commands:', formatList(commandList), '']);
    ***REMOVED***

    return output.join('\n');
  ***REMOVED***

  /**
   * Calculate the pad width from the maximum term length.
   *
   * @param {Command***REMOVED*** cmd
   * @param {Help***REMOVED*** helper
   * @returns {number***REMOVED***
   */

  padWidth(cmd, helper) {
    return Math.max(
      helper.longestOptionTermLength(cmd, helper),
      helper.longestSubcommandTermLength(cmd, helper),
      helper.longestArgumentTermLength(cmd, helper)
    );
  ***REMOVED***;

  /**
   * Wrap the given string to width characters per line, with lines after the first indented.
   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
   *
   * @param {string***REMOVED*** str
   * @param {number***REMOVED*** width
   * @param {number***REMOVED*** indent
   * @param {number***REMOVED*** [minColumnWidth=40]
   * @return {string***REMOVED***
   *
   */

  wrap(str, width, indent, minColumnWidth = 40) {
    // Detect manually wrapped and indented strings by searching for line breaks
    // followed by multiple spaces/tabs.
    if (str.match(/[\n]\s+/)) return str;
    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).
    const columnWidth = width - indent;
    if (columnWidth < minColumnWidth) return str;

    const leadingStr = str.substr(0, indent);
    const columnText = str.substr(indent);

    const indentString = ' '.repeat(indent);
    const regex = new RegExp('.{1,' + (columnWidth - 1) + '***REMOVED***([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)', 'g');
    const lines = columnText.match(regex) || [];
    return leadingStr + lines.map((line, i) => {
      if (line.slice(-1) === '\n') {
        line = line.slice(0, line.length - 1);
      ***REMOVED***
      return ((i > 0) ? indentString : '') + line.trimRight();
    ***REMOVED***).join('\n');
  ***REMOVED***
***REMOVED***

exports.Help = Help;
