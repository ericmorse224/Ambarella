'use strict';
const normalizeArgs = (file, args = []) => {
	if (!Array.isArray(args)) {
		return [file];
	***REMOVED***

	return [file, ...args];
***REMOVED***;

const NO_ESCAPE_REGEXP = /^[\w.-]+$/;
const DOUBLE_QUOTES_REGEXP = /"/g;

const escapeArg = arg => {
	if (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {
		return arg;
	***REMOVED***

	return `"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\"')***REMOVED***"`;
***REMOVED***;

const joinCommand = (file, args) => {
	return normalizeArgs(file, args).join(' ');
***REMOVED***;

const getEscapedCommand = (file, args) => {
	return normalizeArgs(file, args).map(arg => escapeArg(arg)).join(' ');
***REMOVED***;

const SPACES_REGEXP = / +/g;

// Handle `execa.command()`
const parseCommand = command => {
	const tokens = [];
	for (const token of command.trim().split(SPACES_REGEXP)) {
		// Allow spaces to be escaped by a backslash if not meant as a delimiter
		const previousToken = tokens[tokens.length - 1];
		if (previousToken && previousToken.endsWith('\\')) {
			// Merge previous token with current one
			tokens[tokens.length - 1] = `${previousToken.slice(0, -1)***REMOVED*** ${token***REMOVED***`;
		***REMOVED*** else {
			tokens.push(token);
		***REMOVED***
	***REMOVED***

	return tokens;
***REMOVED***;

module.exports = {
	joinCommand,
	getEscapedCommand,
	parseCommand
***REMOVED***;
