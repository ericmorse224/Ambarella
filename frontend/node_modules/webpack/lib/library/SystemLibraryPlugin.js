/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Joel Denning @joeldenning
*/

"use strict";

const { ConcatSource ***REMOVED*** = require("webpack-sources");
const { UsageState ***REMOVED*** = require("../ExportsInfo");
const ExternalModule = require("../ExternalModule");
const Template = require("../Template");
const propertyAccess = require("../util/propertyAccess");
const AbstractLibraryPlugin = require("./AbstractLibraryPlugin");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../../declarations/WebpackOptions").LibraryOptions***REMOVED*** LibraryOptions */
/** @typedef {import("../../declarations/WebpackOptions").LibraryType***REMOVED*** LibraryType */
/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../Compilation").ChunkHashContext***REMOVED*** ChunkHashContext */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../javascript/JavascriptModulesPlugin").RenderContext***REMOVED*** RenderContext */
/** @typedef {import("../util/Hash")***REMOVED*** Hash */
/** @template T @typedef {import("./AbstractLibraryPlugin").LibraryContext<T>***REMOVED*** LibraryContext<T> */

/**
 * @typedef {object***REMOVED*** SystemLibraryPluginOptions
 * @property {LibraryType***REMOVED*** type
 */

/**
 * @typedef {object***REMOVED*** SystemLibraryPluginParsed
 * @property {string***REMOVED*** name
 */

/**
 * @typedef {SystemLibraryPluginParsed***REMOVED*** T
 * @extends {AbstractLibraryPlugin<SystemLibraryPluginParsed>***REMOVED***
 */
class SystemLibraryPlugin extends AbstractLibraryPlugin {
	/**
	 * @param {SystemLibraryPluginOptions***REMOVED*** options the plugin options
	 */
	constructor(options) {
		super({
			pluginName: "SystemLibraryPlugin",
			type: options.type
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {LibraryOptions***REMOVED*** library normalized library option
	 * @returns {T | false***REMOVED*** preprocess as needed by overriding
	 */
	parseOptions(library) {
		const { name ***REMOVED*** = library;
		if (name && typeof name !== "string") {
			throw new Error(
				`System.js library name must be a simple string or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE***REMOVED***`
			);
		***REMOVED***
		const _name = /** @type {string***REMOVED*** */ (name);
		return {
			name: _name
		***REMOVED***;
	***REMOVED***

	/**
	 * @param {Source***REMOVED*** source source
	 * @param {RenderContext***REMOVED*** renderContext render context
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {Source***REMOVED*** source with library export
	 */
	render(source, { chunkGraph, moduleGraph, chunk ***REMOVED***, { options, compilation ***REMOVED***) {
		const modules = chunkGraph
			.getChunkModules(chunk)
			.filter(m => m instanceof ExternalModule && m.externalType === "system");
		const externals = /** @type {ExternalModule[]***REMOVED*** */ (modules);

		// The name this bundle should be registered as with System
		const name = options.name
			? `${JSON.stringify(compilation.getPath(options.name, { chunk ***REMOVED***))***REMOVED***, `
			: "";

		// The array of dependencies that are external to webpack and will be provided by System
		const systemDependencies = JSON.stringify(
			externals.map(m =>
				typeof m.request === "object" && !Array.isArray(m.request)
					? m.request.amd
					: m.request
			)
		);

		// The name of the variable provided by System for exporting
		const dynamicExport = "__WEBPACK_DYNAMIC_EXPORT__";

		// An array of the internal variable names for the webpack externals
		const externalWebpackNames = externals.map(
			m =>
				`__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(
					`${chunkGraph.getModuleId(m)***REMOVED***`
				)***REMOVED***__`
		);

		// Declaring variables for the internal variable names for the webpack externals
		const externalVarDeclarations = externalWebpackNames
			.map(name => `var ${name***REMOVED*** = {***REMOVED***;`)
			.join("\n");

		// Define __esModule flag on all internal variables and helpers
		/** @type {string[]***REMOVED*** */
		const externalVarInitialization = [];

		// The system.register format requires an array of setter functions for externals.
		const setters =
			externalWebpackNames.length === 0
				? ""
				: Template.asString([
						"setters: [",
						Template.indent(
							externals
								.map((module, i) => {
									const external = externalWebpackNames[i];
									const exportsInfo = moduleGraph.getExportsInfo(module);
									const otherUnused =
										exportsInfo.otherExportsInfo.getUsed(chunk.runtime) ===
										UsageState.Unused;
									const instructions = [];
									const handledNames = [];
									for (const exportInfo of exportsInfo.orderedExports) {
										const used = exportInfo.getUsedName(
											undefined,
											chunk.runtime
										);
										if (used) {
											if (otherUnused || used !== exportInfo.name) {
												instructions.push(
													`${external***REMOVED***${propertyAccess([
														used
													])***REMOVED*** = module${propertyAccess([exportInfo.name])***REMOVED***;`
												);
												handledNames.push(exportInfo.name);
											***REMOVED***
										***REMOVED*** else {
											handledNames.push(exportInfo.name);
										***REMOVED***
									***REMOVED***
									if (!otherUnused) {
										if (
											!Array.isArray(module.request) ||
											module.request.length === 1
										) {
											externalVarInitialization.push(
												`Object.defineProperty(${external***REMOVED***, "__esModule", { value: true ***REMOVED***);`
											);
										***REMOVED***
										if (handledNames.length > 0) {
											const name = `${external***REMOVED***handledNames`;
											externalVarInitialization.push(
												`var ${name***REMOVED*** = ${JSON.stringify(handledNames)***REMOVED***;`
											);
											instructions.push(
												Template.asString([
													"Object.keys(module).forEach(function(key) {",
													Template.indent([
														`if(${name***REMOVED***.indexOf(key) >= 0)`,
														Template.indent(`${external***REMOVED***[key] = module[key];`)
													]),
													"***REMOVED***);"
												])
											);
										***REMOVED*** else {
											instructions.push(
												Template.asString([
													"Object.keys(module).forEach(function(key) {",
													Template.indent([`${external***REMOVED***[key] = module[key];`]),
													"***REMOVED***);"
												])
											);
										***REMOVED***
									***REMOVED***
									if (instructions.length === 0) return "function() {***REMOVED***";
									return Template.asString([
										"function(module) {",
										Template.indent(instructions),
										"***REMOVED***"
									]);
								***REMOVED***)
								.join(",\n")
						),
						"],"
					]);

		return new ConcatSource(
			Template.asString([
				`System.register(${name***REMOVED***${systemDependencies***REMOVED***, function(${dynamicExport***REMOVED***, __system_context__) {`,
				Template.indent([
					externalVarDeclarations,
					Template.asString(externalVarInitialization),
					"return {",
					Template.indent([
						setters,
						"execute: function() {",
						Template.indent(`${dynamicExport***REMOVED***(`)
					])
				]),
				""
			]),
			source,
			Template.asString([
				"",
				Template.indent([
					Template.indent([Template.indent([");"]), "***REMOVED***"]),
					"***REMOVED***;"
				]),
				"***REMOVED***)"
			])
		);
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk the chunk
	 * @param {Hash***REMOVED*** hash hash
	 * @param {ChunkHashContext***REMOVED*** chunkHashContext chunk hash context
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {void***REMOVED***
	 */
	chunkHash(chunk, hash, chunkHashContext, { options, compilation ***REMOVED***) {
		hash.update("SystemLibraryPlugin");
		if (options.name) {
			hash.update(compilation.getPath(options.name, { chunk ***REMOVED***));
		***REMOVED***
	***REMOVED***
***REMOVED***

module.exports = SystemLibraryPlugin;
