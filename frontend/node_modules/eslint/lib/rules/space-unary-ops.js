/**
 * @fileoverview This rule should require or disallow spaces before or after unary operations.
 * @author Marcin Kumorek
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
    meta: {
        type: "layout",

        docs: {
            description: "enforce consistent spacing before or after unary operators",
            category: "Stylistic Issues",
            recommended: false,
            url: "https://eslint.org/docs/rules/space-unary-ops"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [
            {
                type: "object",
                properties: {
                    words: {
                        type: "boolean",
                        default: true
                    ***REMOVED***,
                    nonwords: {
                        type: "boolean",
                        default: false
                    ***REMOVED***,
                    overrides: {
                        type: "object",
                        additionalProperties: {
                            type: "boolean"
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false
            ***REMOVED***
        ],
        messages: {
            unexpectedBefore: "Unexpected space before unary operator '{{operator***REMOVED******REMOVED***'.",
            unexpectedAfter: "Unexpected space after unary operator '{{operator***REMOVED******REMOVED***'.",
            unexpectedAfterWord: "Unexpected space after unary word operator '{{word***REMOVED******REMOVED***'.",
            wordOperator: "Unary word operator '{{word***REMOVED******REMOVED***' must be followed by whitespace.",
            operator: "Unary operator '{{operator***REMOVED******REMOVED***' must be followed by whitespace.",
            beforeUnaryExpressions: "Space is required before unary expressions '{{token***REMOVED******REMOVED***'."
        ***REMOVED***
    ***REMOVED***,

    create(context) {
        const options = context.options[0] || { words: true, nonwords: false ***REMOVED***;

        const sourceCode = context.getSourceCode();

        //--------------------------------------------------------------------------
        // Helpers
        //--------------------------------------------------------------------------

        /**
         * Check if the node is the first "!" in a "!!" convert to Boolean expression
         * @param {ASTnode***REMOVED*** node AST node
         * @returns {boolean***REMOVED*** Whether or not the node is first "!" in "!!"
         */
        function isFirstBangInBangBangExpression(node) {
            return node && node.type === "UnaryExpression" && node.argument.operator === "!" &&
                node.argument && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
        ***REMOVED***

        /**
         * Checks if an override exists for a given operator.
         * @param {string***REMOVED*** operator Operator
         * @returns {boolean***REMOVED*** Whether or not an override has been provided for the operator
         */
        function overrideExistsForOperator(operator) {
            return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);
        ***REMOVED***

        /**
         * Gets the value that the override was set to for this operator
         * @param {string***REMOVED*** operator Operator
         * @returns {boolean***REMOVED*** Whether or not an override enforces a space with this operator
         */
        function overrideEnforcesSpaces(operator) {
            return options.overrides[operator];
        ***REMOVED***

        /**
         * Verify Unary Word Operator has spaces after the word operator
         * @param {ASTnode***REMOVED*** node AST node
         * @param {Object***REMOVED*** firstToken first token from the AST node
         * @param {Object***REMOVED*** secondToken second token from the AST node
         * @param {string***REMOVED*** word The word to be used for reporting
         * @returns {void***REMOVED***
         */
        function verifyWordHasSpaces(node, firstToken, secondToken, word) {
            if (secondToken.range[0] === firstToken.range[1]) {
                context.report({
                    node,
                    messageId: "wordOperator",
                    data: {
                        word
                    ***REMOVED***,
                    fix(fixer) {
                        return fixer.insertTextAfter(firstToken, " ");
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Verify Unary Word Operator doesn't have spaces after the word operator
         * @param {ASTnode***REMOVED*** node AST node
         * @param {Object***REMOVED*** firstToken first token from the AST node
         * @param {Object***REMOVED*** secondToken second token from the AST node
         * @param {string***REMOVED*** word The word to be used for reporting
         * @returns {void***REMOVED***
         */
        function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {
            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {
                if (secondToken.range[0] > firstToken.range[1]) {
                    context.report({
                        node,
                        messageId: "unexpectedAfterWord",
                        data: {
                            word
                        ***REMOVED***,
                        fix(fixer) {
                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Check Unary Word Operators for spaces after the word operator
         * @param {ASTnode***REMOVED*** node AST node
         * @param {Object***REMOVED*** firstToken first token from the AST node
         * @param {Object***REMOVED*** secondToken second token from the AST node
         * @param {string***REMOVED*** word The word to be used for reporting
         * @returns {void***REMOVED***
         */
        function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {
            if (overrideExistsForOperator(word)) {
                if (overrideEnforcesSpaces(word)) {
                    verifyWordHasSpaces(node, firstToken, secondToken, word);
                ***REMOVED*** else {
                    verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
                ***REMOVED***
            ***REMOVED*** else if (options.words) {
                verifyWordHasSpaces(node, firstToken, secondToken, word);
            ***REMOVED*** else {
                verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
            ***REMOVED***
        ***REMOVED***

        /**
         * Verifies YieldExpressions satisfy spacing requirements
         * @param {ASTnode***REMOVED*** node AST node
         * @returns {void***REMOVED***
         */
        function checkForSpacesAfterYield(node) {
            const tokens = sourceCode.getFirstTokens(node, 3),
                word = "yield";

            if (!node.argument || node.delegate) {
                return;
            ***REMOVED***

            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);
        ***REMOVED***

        /**
         * Verifies AwaitExpressions satisfy spacing requirements
         * @param {ASTNode***REMOVED*** node AwaitExpression AST node
         * @returns {void***REMOVED***
         */
        function checkForSpacesAfterAwait(node) {
            const tokens = sourceCode.getFirstTokens(node, 3);

            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], "await");
        ***REMOVED***

        /**
         * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator
         * @param {ASTnode***REMOVED*** node AST node
         * @param {Object***REMOVED*** firstToken First token in the expression
         * @param {Object***REMOVED*** secondToken Second token in the expression
         * @returns {void***REMOVED***
         */
        function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {
            if (node.prefix) {
                if (isFirstBangInBangBangExpression(node)) {
                    return;
                ***REMOVED***
                if (firstToken.range[1] === secondToken.range[0]) {
                    context.report({
                        node,
                        messageId: "operator",
                        data: {
                            operator: firstToken.value
                        ***REMOVED***,
                        fix(fixer) {
                            return fixer.insertTextAfter(firstToken, " ");
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED*** else {
                if (firstToken.range[1] === secondToken.range[0]) {
                    context.report({
                        node,
                        messageId: "beforeUnaryExpressions",
                        data: {
                            token: secondToken.value
                        ***REMOVED***,
                        fix(fixer) {
                            return fixer.insertTextBefore(secondToken, " ");
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator
         * @param {ASTnode***REMOVED*** node AST node
         * @param {Object***REMOVED*** firstToken First token in the expression
         * @param {Object***REMOVED*** secondToken Second token in the expression
         * @returns {void***REMOVED***
         */
        function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {
            if (node.prefix) {
                if (secondToken.range[0] > firstToken.range[1]) {
                    context.report({
                        node,
                        messageId: "unexpectedAfter",
                        data: {
                            operator: firstToken.value
                        ***REMOVED***,
                        fix(fixer) {
                            if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {
                                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
                            ***REMOVED***
                            return null;
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED*** else {
                if (secondToken.range[0] > firstToken.range[1]) {
                    context.report({
                        node,
                        messageId: "unexpectedBefore",
                        data: {
                            operator: secondToken.value
                        ***REMOVED***,
                        fix(fixer) {
                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements
         * @param {ASTnode***REMOVED*** node AST node
         * @returns {void***REMOVED***
         */
        function checkForSpaces(node) {
            const tokens = node.type === "UpdateExpression" && !node.prefix
                ? sourceCode.getLastTokens(node, 2)
                : sourceCode.getFirstTokens(node, 2);
            const firstToken = tokens[0];
            const secondToken = tokens[1];

            if ((node.type === "NewExpression" || node.prefix) && firstToken.type === "Keyword") {
                checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);
                return;
            ***REMOVED***

            const operator = node.prefix ? tokens[0].value : tokens[1].value;

            if (overrideExistsForOperator(operator)) {
                if (overrideEnforcesSpaces(operator)) {
                    verifyNonWordsHaveSpaces(node, firstToken, secondToken);
                ***REMOVED*** else {
                    verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
                ***REMOVED***
            ***REMOVED*** else if (options.nonwords) {
                verifyNonWordsHaveSpaces(node, firstToken, secondToken);
            ***REMOVED*** else {
                verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
            ***REMOVED***
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        return {
            UnaryExpression: checkForSpaces,
            UpdateExpression: checkForSpaces,
            NewExpression: checkForSpaces,
            YieldExpression: checkForSpacesAfterYield,
            AwaitExpression: checkForSpacesAfterAwait
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
