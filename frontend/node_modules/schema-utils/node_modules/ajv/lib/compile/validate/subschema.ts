import type {AnySchema***REMOVED*** from "../../types"
import type {SchemaObjCxt***REMOVED*** from ".."
import {_, str, getProperty, Code, Name***REMOVED*** from "../codegen"
import {escapeFragment, getErrorPath, Type***REMOVED*** from "../util"
import type {JSONType***REMOVED*** from "../rules"

export interface SubschemaContext {
  // TODO use Optional? align with SchemCxt property types
  schema: AnySchema
  schemaPath: Code
  errSchemaPath: string
  topSchemaRef?: Code
  errorPath?: Code
  dataLevel?: number
  dataTypes?: JSONType[]
  data?: Name
  parentData?: Name
  parentDataProperty?: Code | number
  dataNames?: Name[]
  dataPathArr?: (Code | number)[]
  propertyName?: Name
  jtdDiscriminator?: string
  jtdMetadata?: boolean
  compositeRule?: true
  createErrors?: boolean
  allErrors?: boolean
***REMOVED***

export type SubschemaArgs = Partial<{
  keyword: string
  schemaProp: string | number
  schema: AnySchema
  schemaPath: Code
  errSchemaPath: string
  topSchemaRef: Code
  data: Name | Code
  dataProp: Code | string | number
  dataTypes: JSONType[]
  definedProperties: Set<string>
  propertyName: Name
  dataPropType: Type
  jtdDiscriminator: string
  jtdMetadata: boolean
  compositeRule: true
  createErrors: boolean
  allErrors: boolean
***REMOVED***>

export function getSubschema(
  it: SchemaObjCxt,
  {keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef***REMOVED***: SubschemaArgs
): SubschemaContext {
  if (keyword !== undefined && schema !== undefined) {
    throw new Error('both "keyword" and "schema" passed, only one allowed')
  ***REMOVED***

  if (keyword !== undefined) {
    const sch = it.schema[keyword]
    return schemaProp === undefined
      ? {
          schema: sch,
          schemaPath: _`${it.schemaPath***REMOVED***${getProperty(keyword)***REMOVED***`,
          errSchemaPath: `${it.errSchemaPath***REMOVED***/${keyword***REMOVED***`,
        ***REMOVED***
      : {
          schema: sch[schemaProp],
          schemaPath: _`${it.schemaPath***REMOVED***${getProperty(keyword)***REMOVED***${getProperty(schemaProp)***REMOVED***`,
          errSchemaPath: `${it.errSchemaPath***REMOVED***/${keyword***REMOVED***/${escapeFragment(schemaProp)***REMOVED***`,
        ***REMOVED***
  ***REMOVED***

  if (schema !== undefined) {
    if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
      throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"')
    ***REMOVED***
    return {
      schema,
      schemaPath,
      topSchemaRef,
      errSchemaPath,
    ***REMOVED***
  ***REMOVED***

  throw new Error('either "keyword" or "schema" must be passed')
***REMOVED***

export function extendSubschemaData(
  subschema: SubschemaContext,
  it: SchemaObjCxt,
  {dataProp, dataPropType: dpType, data, dataTypes, propertyName***REMOVED***: SubschemaArgs
): void {
  if (data !== undefined && dataProp !== undefined) {
    throw new Error('both "data" and "dataProp" passed, only one allowed')
  ***REMOVED***

  const {gen***REMOVED*** = it

  if (dataProp !== undefined) {
    const {errorPath, dataPathArr, opts***REMOVED*** = it
    const nextData = gen.let("data", _`${it.data***REMOVED***${getProperty(dataProp)***REMOVED***`, true)
    dataContextProps(nextData)
    subschema.errorPath = str`${errorPath***REMOVED***${getErrorPath(dataProp, dpType, opts.jsPropertySyntax)***REMOVED***`
    subschema.parentDataProperty = _`${dataProp***REMOVED***`
    subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty]
  ***REMOVED***

  if (data !== undefined) {
    const nextData = data instanceof Name ? data : gen.let("data", data, true) // replaceable if used once?
    dataContextProps(nextData)
    if (propertyName !== undefined) subschema.propertyName = propertyName
    // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
  ***REMOVED***

  if (dataTypes) subschema.dataTypes = dataTypes

  function dataContextProps(_nextData: Name): void {
    subschema.data = _nextData
    subschema.dataLevel = it.dataLevel + 1
    subschema.dataTypes = []
    it.definedProperties = new Set<string>()
    subschema.parentData = it.data
    subschema.dataNames = [...it.dataNames, _nextData]
  ***REMOVED***
***REMOVED***

export function extendSubschemaMode(
  subschema: SubschemaContext,
  {jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors***REMOVED***: SubschemaArgs
): void {
  if (compositeRule !== undefined) subschema.compositeRule = compositeRule
  if (createErrors !== undefined) subschema.createErrors = createErrors
  if (allErrors !== undefined) subschema.allErrors = allErrors
  subschema.jtdDiscriminator = jtdDiscriminator // not inherited
  subschema.jtdMetadata = jtdMetadata // not inherited
***REMOVED***
