/**
 * @fileoverview Main Linter Class
 * @author Gyandeep Singh
 * @author aladdin-add
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const path = require("node:path"),
	eslintScope = require("eslint-scope"),
	evk = require("eslint-visitor-keys"),
	espree = require("espree"),
	merge = require("lodash.merge"),
	pkg = require("../../package.json"),
	{
		Legacy: {
			ConfigOps,
			ConfigValidator,
			environments: BuiltInEnvironments,
		***REMOVED***,
	***REMOVED*** = require("@eslint/eslintrc/universal"),
	Traverser = require("../shared/traverser"),
	{ SourceCode ***REMOVED*** = require("../languages/js/source-code"),
	applyDisableDirectives = require("./apply-disable-directives"),
	{ ConfigCommentParser ***REMOVED*** = require("@eslint/plugin-kit"),
	NodeEventGenerator = require("./node-event-generator"),
	createReportTranslator = require("./report-translator"),
	Rules = require("./rules"),
	createEmitter = require("./safe-emitter"),
	SourceCodeFixer = require("./source-code-fixer"),
	timing = require("./timing"),
	ruleReplacements = require("../../conf/replacements.json");
const { getRuleFromConfig ***REMOVED*** = require("../config/flat-config-helpers");
const { FlatConfigArray ***REMOVED*** = require("../config/flat-config-array");
const { startTime, endTime ***REMOVED*** = require("../shared/stats");
const { RuleValidator ***REMOVED*** = require("../config/rule-validator");
const { assertIsRuleSeverity ***REMOVED*** = require("../config/flat-config-schema");
const {
	normalizeSeverityToString,
	normalizeSeverityToNumber,
***REMOVED*** = require("../shared/severity");
const { deepMergeArrays ***REMOVED*** = require("../shared/deep-merge-arrays");
const jslang = require("../languages/js");
const {
	activeFlags,
	inactiveFlags,
	getInactivityReasonMessage,
***REMOVED*** = require("../shared/flags");
const debug = require("debug")("eslint:linter");
const MAX_AUTOFIX_PASSES = 10;
const DEFAULT_PARSER_NAME = "espree";
const DEFAULT_ECMA_VERSION = 5;
const commentParser = new ConfigCommentParser();
const DEFAULT_ERROR_LOC = {
	start: { line: 1, column: 0 ***REMOVED***,
	end: { line: 1, column: 1 ***REMOVED***,
***REMOVED***;
const parserSymbol = Symbol.for("eslint.RuleTester.parser");
const { LATEST_ECMA_VERSION ***REMOVED*** = require("../../conf/ecma-version");
const { VFile ***REMOVED*** = require("./vfile");
const { ParserService ***REMOVED*** = require("../services/parser-service");
const { FileContext ***REMOVED*** = require("./file-context");
const { ProcessorService ***REMOVED*** = require("../services/processor-service");
const { containsDifferentProperty ***REMOVED*** = require("../shared/option-utils");
const STEP_KIND_VISIT = 1;
const STEP_KIND_CALL = 2;

//------------------------------------------------------------------------------
// Typedefs
//------------------------------------------------------------------------------

/** @import { Language, LanguageOptions, RuleConfig, RuleDefinition, RuleSeverity ***REMOVED*** from "@eslint/core" */

/** @typedef {import("../shared/types").ConfigData***REMOVED*** ConfigData */
/** @typedef {import("../shared/types").Environment***REMOVED*** Environment */
/** @typedef {import("../shared/types").GlobalConf***REMOVED*** GlobalConf */
/** @typedef {import("../shared/types").LintMessage***REMOVED*** LintMessage */
/** @typedef {import("../shared/types").SuppressedLintMessage***REMOVED*** SuppressedLintMessage */
/** @typedef {import("../shared/types").ParserOptions***REMOVED*** ParserOptions */
/** @typedef {import("../shared/types").Processor***REMOVED*** Processor */
/** @typedef {import("../shared/types").Times***REMOVED*** Times */
/** @typedef {import("../types").Linter.LanguageOptions***REMOVED*** JSLanguageOptions */
/** @typedef {import("../types").Linter.StringSeverity***REMOVED*** StringSeverity */
/** @typedef {import("../types").Rule.RuleModule***REMOVED*** Rule */

/* eslint-disable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */
/**
 * @template T
 * @typedef {{ [P in keyof T]-?: T[P] ***REMOVED******REMOVED*** Required
 */
/* eslint-enable jsdoc/valid-types -- https://github.com/jsdoc-type-pratt-parser/jsdoc-type-pratt-parser/issues/4#issuecomment-778805577 */

/**
 * @typedef {Object***REMOVED*** DisableDirective
 * @property {("disable"|"enable"|"disable-line"|"disable-next-line")***REMOVED*** type Type of directive
 * @property {number***REMOVED*** line The line number
 * @property {number***REMOVED*** column The column number
 * @property {(string|null)***REMOVED*** ruleId The rule ID
 * @property {string***REMOVED*** justification The justification of directive
 */

/**
 * The private data for `Linter` instance.
 * @typedef {Object***REMOVED*** LinterInternalSlots
 * @property {ConfigArray|null***REMOVED*** lastConfigArray The `ConfigArray` instance that the last `verify()` call used.
 * @property {SourceCode|null***REMOVED*** lastSourceCode The `SourceCode` instance that the last `verify()` call used.
 * @property {SuppressedLintMessage[]***REMOVED*** lastSuppressedMessages The `SuppressedLintMessage[]` instance that the last `verify()` call produced.
 * @property {Map<string, Parser>***REMOVED*** parserMap The loaded parsers.
 * @property {Times***REMOVED*** times The times spent on applying a rule to a file (see `stats` option).
 * @property {Rules***REMOVED*** ruleMap The loaded rules.
 */

/**
 * @typedef {Object***REMOVED*** VerifyOptions
 * @property {boolean***REMOVED*** [allowInlineConfig] Allow/disallow inline comments' ability
 *      to change config once it is set. Defaults to true if not supplied.
 *      Useful if you want to validate JS without comments overriding rules.
 * @property {boolean***REMOVED*** [disableFixes] if `true` then the linter doesn't make `fix`
 *      properties into the lint result.
 * @property {string***REMOVED*** [filename] the filename of the source code.
 * @property {boolean | "off" | "warn" | "error"***REMOVED*** [reportUnusedDisableDirectives] Adds reported errors for
 *      unused `eslint-disable` directives.
 * @property {Function***REMOVED*** [ruleFilter] A predicate function that determines whether a given rule should run.
 */

/**
 * @typedef {Object***REMOVED*** ProcessorOptions
 * @property {(filename:string, text:string) => boolean***REMOVED*** [filterCodeBlock] the
 *      predicate function that selects adopt code blocks.
 * @property {Processor.postprocess***REMOVED*** [postprocess] postprocessor for report
 *      messages. If provided, this should accept an array of the message lists
 *      for each code block returned from the preprocessor, apply a mapping to
 *      the messages as appropriate, and return a one-dimensional array of
 *      messages.
 * @property {Processor.preprocess***REMOVED*** [preprocess] preprocessor for source text.
 *      If provided, this should accept a string of source text, and return an
 *      array of code blocks to lint.
 */

/**
 * @typedef {Object***REMOVED*** FixOptions
 * @property {boolean | ((message: LintMessage) => boolean)***REMOVED*** [fix] Determines
 *      whether fixes should be applied.
 */

/**
 * @typedef {Object***REMOVED*** InternalOptions
 * @property {string | null***REMOVED*** warnInlineConfig The config name what `noInlineConfig` setting came from. If `noInlineConfig` setting didn't exist, this is null. If this is a config name, then the linter warns directive comments.
 * @property {StringSeverity***REMOVED*** reportUnusedDisableDirectives Severity to report unused disable directives, if not "off" (boolean values were normalized).
 * @property {StringSeverity***REMOVED*** reportUnusedInlineConfigs Severity to report unused inline configs, if not "off".
 */

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Determines if a given object is Espree.
 * @param {Object***REMOVED*** parser The parser to check.
 * @returns {boolean***REMOVED*** True if the parser is Espree or false if not.
 */
function isEspree(parser) {
	return !!(parser === espree || parser[parserSymbol] === espree);
***REMOVED***

/**
 * Ensures that variables representing built-in properties of the Global Object,
 * and any globals declared by special block comments, are present in the global
 * scope.
 * @param {Scope***REMOVED*** globalScope The global scope.
 * @param {Object***REMOVED*** configGlobals The globals declared in configuration
 * @param {{exportedVariables: Object, enabledGlobals: Object***REMOVED******REMOVED*** commentDirectives Directives from comment configuration
 * @returns {void***REMOVED***
 */
function addDeclaredGlobals(
	globalScope,
	configGlobals,
	{ exportedVariables, enabledGlobals ***REMOVED***,
) {
	// Define configured global variables.
	for (const id of new Set([
		...Object.keys(configGlobals),
		...Object.keys(enabledGlobals),
	])) {
		/*
		 * `ConfigOps.normalizeConfigGlobal` will throw an error if a configured global value is invalid. However, these errors would
		 * typically be caught when validating a config anyway (validity for inline global comments is checked separately).
		 */
		const configValue =
			configGlobals[id] === void 0
				? void 0
				: ConfigOps.normalizeConfigGlobal(configGlobals[id]);
		const commentValue = enabledGlobals[id] && enabledGlobals[id].value;
		const value = commentValue || configValue;
		const sourceComments =
			enabledGlobals[id] && enabledGlobals[id].comments;

		if (value === "off") {
			continue;
		***REMOVED***

		let variable = globalScope.set.get(id);

		if (!variable) {
			variable = new eslintScope.Variable(id, globalScope);

			globalScope.variables.push(variable);
			globalScope.set.set(id, variable);
		***REMOVED***

		variable.eslintImplicitGlobalSetting = configValue;
		variable.eslintExplicitGlobal = sourceComments !== void 0;
		variable.eslintExplicitGlobalComments = sourceComments;
		variable.writeable = value === "writable";
	***REMOVED***

	// mark all exported variables as such
	Object.keys(exportedVariables).forEach(name => {
		const variable = globalScope.set.get(name);

		if (variable) {
			variable.eslintUsed = true;
			variable.eslintExported = true;
		***REMOVED***
	***REMOVED***);

	/*
	 * "through" contains all references which definitions cannot be found.
	 * Since we augment the global scope using configuration, we need to update
	 * references and remove the ones that were added by configuration.
	 */
	globalScope.through = globalScope.through.filter(reference => {
		const name = reference.identifier.name;
		const variable = globalScope.set.get(name);

		if (variable) {
			/*
			 * Links the variable and the reference.
			 * And this reference is removed from `Scope#through`.
			 */
			reference.resolved = variable;
			variable.references.push(reference);

			return false;
		***REMOVED***

		return true;
	***REMOVED***);
***REMOVED***

/**
 * creates a missing-rule message.
 * @param {string***REMOVED*** ruleId the ruleId to create
 * @returns {string***REMOVED*** created error message
 * @private
 */
function createMissingRuleMessage(ruleId) {
	return Object.hasOwn(ruleReplacements.rules, ruleId)
		? `Rule '${ruleId***REMOVED***' was removed and replaced by: ${ruleReplacements.rules[ruleId].join(", ")***REMOVED***`
		: `Definition for rule '${ruleId***REMOVED***' was not found.`;
***REMOVED***

/**
 * Updates a given location based on the language offsets. This allows us to
 * change 0-based locations to 1-based locations. We always want ESLint
 * reporting lines and columns starting from 1.
 * @param {Object***REMOVED*** location The location to update.
 * @param {number***REMOVED*** location.line The starting line number.
 * @param {number***REMOVED*** location.column The starting column number.
 * @param {number***REMOVED*** [location.endLine] The ending line number.
 * @param {number***REMOVED*** [location.endColumn] The ending column number.
 * @param {Language***REMOVED*** language The language to use to adjust the location information.
 * @returns {Object***REMOVED*** The updated location.
 */
function updateLocationInformation(
	{ line, column, endLine, endColumn ***REMOVED***,
	language,
) {
	const columnOffset = language.columnStart === 1 ? 0 : 1;
	const lineOffset = language.lineStart === 1 ? 0 : 1;

	// calculate separately to account for undefined
	const finalEndLine = endLine === void 0 ? endLine : endLine + lineOffset;
	const finalEndColumn =
		endColumn === void 0 ? endColumn : endColumn + columnOffset;

	return {
		line: line + lineOffset,
		column: column + columnOffset,
		endLine: finalEndLine,
		endColumn: finalEndColumn,
	***REMOVED***;
***REMOVED***

/**
 * creates a linting problem
 * @param {Object***REMOVED*** options to create linting error
 * @param {string***REMOVED*** [options.ruleId] the ruleId to report
 * @param {Object***REMOVED*** [options.loc] the loc to report
 * @param {string***REMOVED*** [options.message] the error message to report
 * @param {RuleSeverity***REMOVED*** [options.severity] the error message to report
 * @param {Language***REMOVED*** [options.language] the language to use to adjust the location information
 * @returns {LintMessage***REMOVED*** created problem, returns a missing-rule problem if only provided ruleId.
 * @private
 */
function createLintingProblem(options) {
	const {
		ruleId = null,
		loc = DEFAULT_ERROR_LOC,
		message = createMissingRuleMessage(options.ruleId),
		severity = 2,

		// fallback for eslintrc mode
		language = {
			columnStart: 0,
			lineStart: 1,
		***REMOVED***,
	***REMOVED*** = options;

	return {
		ruleId,
		message,
		...updateLocationInformation(
			{
				line: loc.start.line,
				column: loc.start.column,
				endLine: loc.end.line,
				endColumn: loc.end.column,
			***REMOVED***,
			language,
		),
		severity,
		nodeType: null,
	***REMOVED***;
***REMOVED***

/**
 * Wraps the value in an Array if it isn't already one.
 * @template T
 * @param {T|T[]***REMOVED*** value Value to be wrapped.
 * @returns {Array***REMOVED*** The value as an array.
 */
function asArray(value) {
	return Array.isArray(value) ? value : [value];
***REMOVED***

/**
 * Pushes a problem to inlineConfigProblems if ruleOptions are redundant.
 * @param {ConfigData***REMOVED*** config Provided config.
 * @param {Object***REMOVED*** loc A line/column location
 * @param {Array***REMOVED*** problems Problems that may be added to.
 * @param {string***REMOVED*** ruleId The rule ID.
 * @param {Array***REMOVED*** ruleOptions The rule options, merged with the config's.
 * @param {Array***REMOVED*** ruleOptionsInline The rule options from the comment.
 * @param {"error"|"warn"***REMOVED*** severity The severity to report.
 * @returns {void***REMOVED***
 */
function addProblemIfSameSeverityAndOptions(
	config,
	loc,
	problems,
	ruleId,
	ruleOptions,
	ruleOptionsInline,
	severity,
) {
	const existingConfigRaw = config.rules?.[ruleId];
	const existingConfig = existingConfigRaw
		? asArray(existingConfigRaw)
		: ["off"];
	const existingSeverity = normalizeSeverityToString(existingConfig[0]);
	const inlineSeverity = normalizeSeverityToString(ruleOptions[0]);
	const sameSeverity = existingSeverity === inlineSeverity;

	if (!sameSeverity) {
		return;
	***REMOVED***

	const alreadyConfigured = existingConfigRaw
		? `is already configured to '${existingSeverity***REMOVED***'`
		: "is not enabled so can't be turned off";
	let message;

	if (
		(existingConfig.length === 1 && ruleOptions.length === 1) ||
		existingSeverity === "off"
	) {
		message = `Unused inline config ('${ruleId***REMOVED***' ${alreadyConfigured***REMOVED***).`;
	***REMOVED*** else if (
		!containsDifferentProperty(
			ruleOptions.slice(1),
			existingConfig.slice(1),
		)
	) {
		message =
			ruleOptionsInline.length === 1
				? `Unused inline config ('${ruleId***REMOVED***' ${alreadyConfigured***REMOVED***).`
				: `Unused inline config ('${ruleId***REMOVED***' ${alreadyConfigured***REMOVED*** with the same options).`;
	***REMOVED***

	if (message) {
		problems.push(
			createLintingProblem({
				ruleId: null,
				message,
				loc,
				language: config.language,
				severity: normalizeSeverityToNumber(severity),
			***REMOVED***),
		);
	***REMOVED***
***REMOVED***

/**
 * Creates a collection of disable directives from a comment
 * @param {Object***REMOVED*** options to create disable directives
 * @param {("disable"|"enable"|"disable-line"|"disable-next-line")***REMOVED*** options.type The type of directive comment
 * @param {string***REMOVED*** options.value The value after the directive in the comment
 * comment specified no specific rules, so it applies to all rules (e.g. `eslint-disable`)
 * @param {string***REMOVED*** options.justification The justification of the directive
 * @param {ASTNode|token***REMOVED*** options.node The Comment node/token.
 * @param {function(string): {create: Function***REMOVED******REMOVED*** ruleMapper A map from rule IDs to defined rules
 * @param {Language***REMOVED*** language The language to use to adjust the location information.
 * @param {SourceCode***REMOVED*** sourceCode The SourceCode object to get comments from.
 * @returns {Object***REMOVED*** Directives and problems from the comment
 */
function createDisableDirectives(
	{ type, value, justification, node ***REMOVED***,
	ruleMapper,
	language,
	sourceCode,
) {
	const ruleIds = Object.keys(commentParser.parseListConfig(value));
	const directiveRules = ruleIds.length ? ruleIds : [null];
	const result = {
		directives: [], // valid disable directives
		directiveProblems: [], // problems in directives
	***REMOVED***;
	const parentDirective = { node, value, ruleIds ***REMOVED***;

	for (const ruleId of directiveRules) {
		const loc = sourceCode.getLoc(node);

		// push to directives, if the rule is defined(including null, e.g. /*eslint enable*/)
		if (ruleId === null || !!ruleMapper(ruleId)) {
			if (type === "disable-next-line") {
				const { line, column ***REMOVED*** = updateLocationInformation(
					loc.end,
					language,
				);

				result.directives.push({
					parentDirective,
					type,
					line,
					column,
					ruleId,
					justification,
				***REMOVED***);
			***REMOVED*** else {
				const { line, column ***REMOVED*** = updateLocationInformation(
					loc.start,
					language,
				);

				result.directives.push({
					parentDirective,
					type,
					line,
					column,
					ruleId,
					justification,
				***REMOVED***);
			***REMOVED***
		***REMOVED*** else {
			result.directiveProblems.push(
				createLintingProblem({ ruleId, loc, language ***REMOVED***),
			);
		***REMOVED***
	***REMOVED***
	return result;
***REMOVED***

/**
 * Parses comments in file to extract file-specific config of rules, globals
 * and environments and merges them with global config; also code blocks
 * where reporting is disabled or enabled and merges them with reporting config.
 * @param {SourceCode***REMOVED*** sourceCode The SourceCode object to get comments from.
 * @param {function(string): {create: Function***REMOVED******REMOVED*** ruleMapper A map from rule IDs to defined rules
 * @param {string|null***REMOVED*** warnInlineConfig If a string then it should warn directive comments as disabled. The string value is the config name what the setting came from.
 * @param {ConfigData***REMOVED*** config Provided config.
 * @returns {{configuredRules: Object, enabledGlobals: {value:string,comment:Token***REMOVED***[], exportedVariables: Object, problems: LintMessage[], disableDirectives: DisableDirective[]***REMOVED******REMOVED***
 * A collection of the directive comments that were found, along with any problems that occurred when parsing
 */
function getDirectiveComments(
	sourceCode,
	ruleMapper,
	warnInlineConfig,
	config,
) {
	const configuredRules = {***REMOVED***;
	const enabledGlobals = Object.create(null);
	const exportedVariables = {***REMOVED***;
	const problems = [];
	const disableDirectives = [];
	const validator = new ConfigValidator({
		builtInRules: Rules,
	***REMOVED***);

	sourceCode
		.getInlineConfigNodes()
		.filter(token => token.type !== "Shebang")
		.forEach(comment => {
			const directive = commentParser.parseDirective(comment.value);

			if (!directive) {
				return;
			***REMOVED***

			const {
				label,
				value,
				justification: justificationPart,
			***REMOVED*** = directive;

			const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(
				label,
			);

			if (comment.type === "Line" && !lineCommentSupported) {
				return;
			***REMOVED***

			const loc = sourceCode.getLoc(comment);

			if (warnInlineConfig) {
				const kind =
					comment.type === "Block" ? `/*${label***REMOVED****/` : `//${label***REMOVED***`;

				problems.push(
					createLintingProblem({
						ruleId: null,
						message: `'${kind***REMOVED***' has no effect because you have 'noInlineConfig' setting in ${warnInlineConfig***REMOVED***.`,
						loc,
						severity: 1,
					***REMOVED***),
				);
				return;
			***REMOVED***

			if (
				label === "eslint-disable-line" &&
				loc.start.line !== loc.end.line
			) {
				const message = `${label***REMOVED*** comment should not span multiple lines.`;

				problems.push(
					createLintingProblem({
						ruleId: null,
						message,
						loc,
					***REMOVED***),
				);
				return;
			***REMOVED***

			switch (label) {
				case "eslint-disable":
				case "eslint-enable":
				case "eslint-disable-next-line":
				case "eslint-disable-line": {
					const directiveType = label.slice("eslint-".length);
					const { directives, directiveProblems ***REMOVED*** =
						createDisableDirectives(
							{
								type: directiveType,
								value,
								justification: justificationPart,
								node: comment,
							***REMOVED***,
							ruleMapper,
							jslang,
							sourceCode,
						);

					disableDirectives.push(...directives);
					problems.push(...directiveProblems);
					break;
				***REMOVED***

				case "exported":
					Object.assign(
						exportedVariables,
						commentParser.parseListConfig(value),
					);
					break;

				case "globals":
				case "global":
					for (const [id, idSetting] of Object.entries(
						commentParser.parseStringConfig(value),
					)) {
						let normalizedValue;

						try {
							normalizedValue =
								ConfigOps.normalizeConfigGlobal(idSetting);
						***REMOVED*** catch (err) {
							problems.push(
								createLintingProblem({
									ruleId: null,
									loc,
									message: err.message,
								***REMOVED***),
							);
							continue;
						***REMOVED***

						if (enabledGlobals[id]) {
							enabledGlobals[id].comments.push(comment);
							enabledGlobals[id].value = normalizedValue;
						***REMOVED*** else {
							enabledGlobals[id] = {
								comments: [comment],
								value: normalizedValue,
							***REMOVED***;
						***REMOVED***
					***REMOVED***
					break;

				case "eslint": {
					const parseResult =
						commentParser.parseJSONLikeConfig(value);

					if (parseResult.ok) {
						Object.keys(parseResult.config).forEach(name => {
							const rule = ruleMapper(name);
							const ruleValue = parseResult.config[name];

							if (!rule) {
								problems.push(
									createLintingProblem({ ruleId: name, loc ***REMOVED***),
								);
								return;
							***REMOVED***

							if (Object.hasOwn(configuredRules, name)) {
								problems.push(
									createLintingProblem({
										message: `Rule "${name***REMOVED***" is already configured by another configuration comment in the preceding code. This configuration is ignored.`,
										loc,
									***REMOVED***),
								);
								return;
							***REMOVED***

							let ruleOptions = asArray(ruleValue);

							/*
							 * If the rule was already configured, inline rule configuration that
							 * only has severity should retain options from the config and just override the severity.
							 *
							 * Example:
							 *
							 *   {
							 *       rules: {
							 *           curly: ["error", "multi"]
							 *       ***REMOVED***
							 *   ***REMOVED***
							 *
							 *   /* eslint curly: ["warn"] * /
							 *
							 *   Results in:
							 *
							 *   curly: ["warn", "multi"]
							 */
							if (
								/*
								 * If inline config for the rule has only severity
								 */
								ruleOptions.length === 1 &&
								/*
								 * And the rule was already configured
								 */
								config.rules &&
								Object.hasOwn(config.rules, name)
							) {
								/*
								 * Then use severity from the inline config and options from the provided config
								 */
								ruleOptions = [
									ruleOptions[0], // severity from the inline config
									...asArray(config.rules[name]).slice(1), // options from the provided config
								];
							***REMOVED***

							try {
								validator.validateRuleOptions(
									rule,
									name,
									ruleOptions,
								);
							***REMOVED*** catch (err) {
								/*
								 * If the rule has invalid `meta.schema`, throw the error because
								 * this is not an invalid inline configuration but an invalid rule.
								 */
								if (
									err.code ===
									"ESLINT_INVALID_RULE_OPTIONS_SCHEMA"
								) {
									throw err;
								***REMOVED***

								problems.push(
									createLintingProblem({
										ruleId: name,
										message: err.message,
										loc,
									***REMOVED***),
								);

								// do not apply the config, if found invalid options.
								return;
							***REMOVED***

							configuredRules[name] = ruleOptions;
						***REMOVED***);
					***REMOVED*** else {
						const problem = createLintingProblem({
							ruleId: null,
							loc,
							message: parseResult.error.message,
						***REMOVED***);

						problem.fatal = true;
						problems.push(problem);
					***REMOVED***

					break;
				***REMOVED***

				// no default
			***REMOVED***
		***REMOVED***);

	return {
		configuredRules,
		enabledGlobals,
		exportedVariables,
		problems,
		disableDirectives,
	***REMOVED***;
***REMOVED***

/**
 * Parses comments in file to extract disable directives.
 * @param {SourceCode***REMOVED*** sourceCode The SourceCode object to get comments from.
 * @param {function(string): {create: Function***REMOVED******REMOVED*** ruleMapper A map from rule IDs to defined rules
 * @param {Language***REMOVED*** language The language to use to adjust the location information
 * @returns {{problems: LintMessage[], disableDirectives: DisableDirective[]***REMOVED******REMOVED***
 * A collection of the directive comments that were found, along with any problems that occurred when parsing
 */
function getDirectiveCommentsForFlatConfig(sourceCode, ruleMapper, language) {
	const disableDirectives = [];
	const problems = [];

	if (sourceCode.getDisableDirectives) {
		const { directives: directivesSources, problems: directivesProblems ***REMOVED*** =
			sourceCode.getDisableDirectives();

		problems.push(
			...directivesProblems.map(directiveProblem =>
				createLintingProblem({
					...directiveProblem,
					language,
				***REMOVED***),
			),
		);

		directivesSources.forEach(directive => {
			const { directives, directiveProblems ***REMOVED*** = createDisableDirectives(
				directive,
				ruleMapper,
				language,
				sourceCode,
			);

			disableDirectives.push(...directives);
			problems.push(...directiveProblems);
		***REMOVED***);
	***REMOVED***

	return {
		problems,
		disableDirectives,
	***REMOVED***;
***REMOVED***

/**
 * Normalize ECMAScript version from the initial config
 * @param {Parser***REMOVED*** parser The parser which uses this options.
 * @param {number***REMOVED*** ecmaVersion ECMAScript version from the initial config
 * @returns {number***REMOVED*** normalized ECMAScript version
 */
function normalizeEcmaVersion(parser, ecmaVersion) {
	if (isEspree(parser)) {
		if (ecmaVersion === "latest") {
			return espree.latestEcmaVersion;
		***REMOVED***
	***REMOVED***

	/*
	 * Calculate ECMAScript edition number from official year version starting with
	 * ES2015, which corresponds with ES6 (or a difference of 2009).
	 */
	return ecmaVersion >= 2015 ? ecmaVersion - 2009 : ecmaVersion;
***REMOVED***

/**
 * Normalize ECMAScript version from the initial config into languageOptions (year)
 * format.
 * @param {any***REMOVED*** [ecmaVersion] ECMAScript version from the initial config
 * @returns {number***REMOVED*** normalized ECMAScript version
 */
function normalizeEcmaVersionForLanguageOptions(ecmaVersion) {
	switch (ecmaVersion) {
		case 3:
			return 3;

		// void 0 = no ecmaVersion specified so use the default
		case 5:
		case void 0:
			return 5;

		default:
			if (typeof ecmaVersion === "number") {
				return ecmaVersion >= 2015 ? ecmaVersion : ecmaVersion + 2009;
			***REMOVED***
	***REMOVED***

	/*
	 * We default to the latest supported ecmaVersion for everything else.
	 * Remember, this is for languageOptions.ecmaVersion, which sets the version
	 * that is used for a number of processes inside of ESLint. It's normally
	 * safe to assume people want the latest unless otherwise specified.
	 */
	return LATEST_ECMA_VERSION;
***REMOVED***

const eslintEnvPattern = /\/\*\s*eslint-env\s(.+?)(?:\*\/|$)/gsu;

/**
 * Checks whether or not there is a comment which has "eslint-env *" in a given text.
 * @param {string***REMOVED*** text A source code text to check.
 * @returns {Object|null***REMOVED*** A result of parseListConfig() with "eslint-env *" comment.
 */
function findEslintEnv(text) {
	let match, retv;

	eslintEnvPattern.lastIndex = 0;

	while ((match = eslintEnvPattern.exec(text)) !== null) {
		if (match[0].endsWith("*/")) {
			retv = Object.assign(
				retv || {***REMOVED***,
				commentParser.parseListConfig(
					commentParser.parseDirective(match[0].slice(2, -2)).value,
				),
			);
		***REMOVED***
	***REMOVED***

	return retv;
***REMOVED***

/**
 * Convert "/path/to/<text>" to "<text>".
 * `CLIEngine#executeOnText()` method gives "/path/to/<text>" if the filename
 * was omitted because `configArray.extractConfig()` requires an absolute path.
 * But the linter should pass `<text>` to `RuleContext#filename` in that
 * case.
 * Also, code blocks can have their virtual filename. If the parent filename was
 * `<text>`, the virtual filename is `<text>/0_foo.js` or something like (i.e.,
 * it's not an absolute path).
 * @param {string***REMOVED*** filename The filename to normalize.
 * @returns {string***REMOVED*** The normalized filename.
 */
function normalizeFilename(filename) {
	const parts = filename.split(path.sep);
	const index = parts.lastIndexOf("<text>");

	return index === -1 ? filename : parts.slice(index).join(path.sep);
***REMOVED***

/**
 * Normalizes the possible options for `linter.verify` and `linter.verifyAndFix` to a
 * consistent shape.
 * @param {VerifyOptions***REMOVED*** providedOptions Options
 * @param {ConfigData***REMOVED*** config Config.
 * @returns {Required<VerifyOptions> & InternalOptions***REMOVED*** Normalized options
 */
function normalizeVerifyOptions(providedOptions, config) {
	const linterOptions = config.linterOptions || config;

	// .noInlineConfig for eslintrc, .linterOptions.noInlineConfig for flat
	const disableInlineConfig = linterOptions.noInlineConfig === true;
	const ignoreInlineConfig = providedOptions.allowInlineConfig === false;
	const configNameOfNoInlineConfig = config.configNameOfNoInlineConfig
		? ` (${config.configNameOfNoInlineConfig***REMOVED***)`
		: "";

	let reportUnusedDisableDirectives =
		providedOptions.reportUnusedDisableDirectives;

	if (typeof reportUnusedDisableDirectives === "boolean") {
		reportUnusedDisableDirectives = reportUnusedDisableDirectives
			? "error"
			: "off";
	***REMOVED***
	if (typeof reportUnusedDisableDirectives !== "string") {
		if (typeof linterOptions.reportUnusedDisableDirectives === "boolean") {
			reportUnusedDisableDirectives =
				linterOptions.reportUnusedDisableDirectives ? "warn" : "off";
		***REMOVED*** else {
			reportUnusedDisableDirectives =
				linterOptions.reportUnusedDisableDirectives === void 0
					? "off"
					: normalizeSeverityToString(
							linterOptions.reportUnusedDisableDirectives,
						);
		***REMOVED***
	***REMOVED***

	const reportUnusedInlineConfigs =
		linterOptions.reportUnusedInlineConfigs === void 0
			? "off"
			: normalizeSeverityToString(
					linterOptions.reportUnusedInlineConfigs,
				);

	let ruleFilter = providedOptions.ruleFilter;

	if (typeof ruleFilter !== "function") {
		ruleFilter = () => true;
	***REMOVED***

	return {
		filename: normalizeFilename(providedOptions.filename || "<input>"),
		allowInlineConfig: !ignoreInlineConfig,
		warnInlineConfig:
			disableInlineConfig && !ignoreInlineConfig
				? `your config${configNameOfNoInlineConfig***REMOVED***`
				: null,
		reportUnusedDisableDirectives,
		reportUnusedInlineConfigs,
		disableFixes: Boolean(providedOptions.disableFixes),
		stats: providedOptions.stats,
		ruleFilter,
	***REMOVED***;
***REMOVED***

/**
 * Combines the provided parserOptions with the options from environments
 * @param {Parser***REMOVED*** parser The parser which uses this options.
 * @param {ParserOptions***REMOVED*** providedOptions The provided 'parserOptions' key in a config
 * @param {Environment[]***REMOVED*** enabledEnvironments The environments enabled in configuration and with inline comments
 * @returns {ParserOptions***REMOVED*** Resulting parser options after merge
 */
function resolveParserOptions(parser, providedOptions, enabledEnvironments) {
	const parserOptionsFromEnv = enabledEnvironments
		.filter(env => env.parserOptions)
		.reduce(
			(parserOptions, env) => merge(parserOptions, env.parserOptions),
			{***REMOVED***,
		);
	const mergedParserOptions = merge(
		parserOptionsFromEnv,
		providedOptions || {***REMOVED***,
	);
	const isModule = mergedParserOptions.sourceType === "module";

	if (isModule) {
		/*
		 * can't have global return inside of modules
		 * TODO: espree validate parserOptions.globalReturn when sourceType is setting to module.(@aladdin-add)
		 */
		mergedParserOptions.ecmaFeatures = Object.assign(
			{***REMOVED***,
			mergedParserOptions.ecmaFeatures,
			{ globalReturn: false ***REMOVED***,
		);
	***REMOVED***

	mergedParserOptions.ecmaVersion = normalizeEcmaVersion(
		parser,
		mergedParserOptions.ecmaVersion,
	);

	return mergedParserOptions;
***REMOVED***

/**
 * Converts parserOptions to languageOptions for backwards compatibility with eslintrc.
 * @param {ConfigData***REMOVED*** config Config object.
 * @param {Object***REMOVED*** config.globals Global variable definitions.
 * @param {Parser***REMOVED*** config.parser The parser to use.
 * @param {ParserOptions***REMOVED*** config.parserOptions The parserOptions to use.
 * @returns {JSLanguageOptions***REMOVED*** The languageOptions equivalent.
 */
function createLanguageOptions({
	globals: configuredGlobals,
	parser,
	parserOptions,
***REMOVED***) {
	const { ecmaVersion, sourceType ***REMOVED*** = parserOptions;

	return {
		globals: configuredGlobals,
		ecmaVersion: normalizeEcmaVersionForLanguageOptions(ecmaVersion),
		sourceType,
		parser,
		parserOptions,
	***REMOVED***;
***REMOVED***

/**
 * Combines the provided globals object with the globals from environments
 * @param {Record<string, GlobalConf>***REMOVED*** providedGlobals The 'globals' key in a config
 * @param {Environment[]***REMOVED*** enabledEnvironments The environments enabled in configuration and with inline comments
 * @returns {Record<string, GlobalConf>***REMOVED*** The resolved globals object
 */
function resolveGlobals(providedGlobals, enabledEnvironments) {
	return Object.assign(
		Object.create(null),
		...enabledEnvironments
			.filter(env => env.globals)
			.map(env => env.globals),
		providedGlobals,
	);
***REMOVED***

/**
 * Store time measurements in map
 * @param {number***REMOVED*** time Time measurement
 * @param {Object***REMOVED*** timeOpts Options relating which time was measured
 * @param {WeakMap<Linter, LinterInternalSlots>***REMOVED*** slots Linter internal slots map
 * @returns {void***REMOVED***
 */
function storeTime(time, timeOpts, slots) {
	const { type, key ***REMOVED*** = timeOpts;

	if (!slots.times) {
		slots.times = { passes: [{***REMOVED***] ***REMOVED***;
	***REMOVED***

	const passIndex = slots.fixPasses;

	if (passIndex > slots.times.passes.length - 1) {
		slots.times.passes.push({***REMOVED***);
	***REMOVED***

	if (key) {
		slots.times.passes[passIndex][type] ??= {***REMOVED***;
		slots.times.passes[passIndex][type][key] ??= { total: 0 ***REMOVED***;
		slots.times.passes[passIndex][type][key].total += time;
	***REMOVED*** else {
		slots.times.passes[passIndex][type] ??= { total: 0 ***REMOVED***;
		slots.times.passes[passIndex][type].total += time;
	***REMOVED***
***REMOVED***

/**
 * Get the options for a rule (not including severity), if any
 * @param {RuleConfig***REMOVED*** ruleConfig rule configuration
 * @param {Object|undefined***REMOVED*** defaultOptions rule.meta.defaultOptions
 * @returns {Array***REMOVED*** of rule options, empty Array if none
 */
function getRuleOptions(ruleConfig, defaultOptions) {
	if (Array.isArray(ruleConfig)) {
		return deepMergeArrays(defaultOptions, ruleConfig.slice(1));
	***REMOVED***
	return defaultOptions ?? [];
***REMOVED***

/**
 * Analyze scope of the given AST.
 * @param {ASTNode***REMOVED*** ast The `Program` node to analyze.
 * @param {JSLanguageOptions***REMOVED*** languageOptions The language options.
 * @param {Record<string, string[]>***REMOVED*** visitorKeys The visitor keys.
 * @returns {ScopeManager***REMOVED*** The analysis result.
 */
function analyzeScope(ast, languageOptions, visitorKeys) {
	const parserOptions = languageOptions.parserOptions;
	const ecmaFeatures = parserOptions.ecmaFeatures || {***REMOVED***;
	const ecmaVersion = languageOptions.ecmaVersion || DEFAULT_ECMA_VERSION;

	return eslintScope.analyze(ast, {
		ignoreEval: true,
		nodejsScope: ecmaFeatures.globalReturn,
		impliedStrict: ecmaFeatures.impliedStrict,
		ecmaVersion: typeof ecmaVersion === "number" ? ecmaVersion : 6,
		sourceType: languageOptions.sourceType || "script",
		childVisitorKeys: visitorKeys || evk.KEYS,
		fallback: Traverser.getKeys,
	***REMOVED***);
***REMOVED***

/**
 * Runs a rule, and gets its listeners
 * @param {RuleDefinition***REMOVED*** rule A rule object
 * @param {Context***REMOVED*** ruleContext The context that should be passed to the rule
 * @throws {TypeError***REMOVED*** If `rule` is not an object with a `create` method
 * @throws {any***REMOVED*** Any error during the rule's `create`
 * @returns {Object***REMOVED*** A map of selector listeners provided by the rule
 */
function createRuleListeners(rule, ruleContext) {
	if (
		!rule ||
		typeof rule !== "object" ||
		typeof rule.create !== "function"
	) {
		throw new TypeError(
			`Error while loading rule '${ruleContext.id***REMOVED***': Rule must be an object with a \`create\` method`,
		);
	***REMOVED***

	try {
		return rule.create(ruleContext);
	***REMOVED*** catch (ex) {
		ex.message = `Error while loading rule '${ruleContext.id***REMOVED***': ${ex.message***REMOVED***`;
		throw ex;
	***REMOVED***
***REMOVED***

/**
 * Runs the given rules on the given SourceCode object
 * @param {SourceCode***REMOVED*** sourceCode A SourceCode object for the given text
 * @param {Object***REMOVED*** configuredRules The rules configuration
 * @param {function(string): RuleDefinition***REMOVED*** ruleMapper A mapper function from rule names to rules
 * @param {string | undefined***REMOVED*** parserName The name of the parser in the config
 * @param {Language***REMOVED*** language The language object used for parsing.
 * @param {LanguageOptions***REMOVED*** languageOptions The options for parsing the code.
 * @param {Object***REMOVED*** settings The settings that were enabled in the config
 * @param {string***REMOVED*** filename The reported filename of the code
 * @param {boolean***REMOVED*** applyDefaultOptions If true, apply rules' meta.defaultOptions in computing their config options.
 * @param {boolean***REMOVED*** disableFixes If true, it doesn't make `fix` properties.
 * @param {string | undefined***REMOVED*** cwd cwd of the cli
 * @param {string***REMOVED*** physicalFilename The full path of the file on disk without any code block information
 * @param {Function***REMOVED*** ruleFilter A predicate function to filter which rules should be executed.
 * @param {boolean***REMOVED*** stats If true, stats are collected appended to the result
 * @param {WeakMap<Linter, LinterInternalSlots>***REMOVED*** slots InternalSlotsMap of linter
 * @returns {LintMessage[]***REMOVED*** An array of reported problems
 * @throws {Error***REMOVED*** If traversal into a node fails.
 */
function runRules(
	sourceCode,
	configuredRules,
	ruleMapper,
	parserName,
	language,
	languageOptions,
	settings,
	filename,
	applyDefaultOptions,
	disableFixes,
	cwd,
	physicalFilename,
	ruleFilter,
	stats,
	slots,
) {
	const emitter = createEmitter();

	// must happen first to assign all node.parent properties
	const eventQueue = sourceCode.traverse();

	/*
	 * Create a frozen object with the ruleContext properties and methods that are shared by all rules.
	 * All rule contexts will inherit from this object. This avoids the performance penalty of copying all the
	 * properties once for each rule.
	 */
	const sharedTraversalContext = new FileContext({
		cwd,
		filename,
		physicalFilename: physicalFilename || filename,
		sourceCode,
		parserOptions: {
			...languageOptions.parserOptions,
		***REMOVED***,
		parserPath: parserName,
		languageOptions,
		settings,
	***REMOVED***);

	const lintingProblems = [];

	Object.keys(configuredRules).forEach(ruleId => {
		const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);

		// not load disabled rules
		if (severity === 0) {
			return;
		***REMOVED***

		if (ruleFilter && !ruleFilter({ ruleId, severity ***REMOVED***)) {
			return;
		***REMOVED***

		const rule = ruleMapper(ruleId);

		if (!rule) {
			lintingProblems.push(createLintingProblem({ ruleId, language ***REMOVED***));
			return;
		***REMOVED***

		const messageIds = rule.meta && rule.meta.messages;
		let reportTranslator = null;
		const ruleContext = Object.freeze(
			Object.assign(Object.create(sharedTraversalContext), {
				id: ruleId,
				options: getRuleOptions(
					configuredRules[ruleId],
					applyDefaultOptions ? rule.meta?.defaultOptions : void 0,
				),
				report(...args) {
					/*
					 * Create a report translator lazily.
					 * In a vast majority of cases, any given rule reports zero errors on a given
					 * piece of code. Creating a translator lazily avoids the performance cost of
					 * creating a new translator function for each rule that usually doesn't get
					 * called.
					 *
					 * Using lazy report translators improves end-to-end performance by about 3%
					 * with Node 8.4.0.
					 */
					if (reportTranslator === null) {
						reportTranslator = createReportTranslator({
							ruleId,
							severity,
							sourceCode,
							messageIds,
							disableFixes,
							language,
						***REMOVED***);
					***REMOVED***
					const problem = reportTranslator(...args);

					if (problem.fix && !(rule.meta && rule.meta.fixable)) {
						throw new Error(
							'Fixable rules must set the `meta.fixable` property to "code" or "whitespace".',
						);
					***REMOVED***
					if (
						problem.suggestions &&
						!(rule.meta && rule.meta.hasSuggestions === true)
					) {
						if (
							rule.meta &&
							rule.meta.docs &&
							typeof rule.meta.docs.suggestion !== "undefined"
						) {
							// Encourage migration from the former property name.
							throw new Error(
								"Rules with suggestions must set the `meta.hasSuggestions` property to `true`. `meta.docs.suggestion` is ignored by ESLint.",
							);
						***REMOVED***
						throw new Error(
							"Rules with suggestions must set the `meta.hasSuggestions` property to `true`.",
						);
					***REMOVED***
					lintingProblems.push(problem);
				***REMOVED***,
			***REMOVED***),
		);

		const ruleListenersReturn =
			timing.enabled || stats
				? timing.time(
						ruleId,
						createRuleListeners,
						stats,
					)(rule, ruleContext)
				: createRuleListeners(rule, ruleContext);

		const ruleListeners = stats
			? ruleListenersReturn.result
			: ruleListenersReturn;

		if (stats) {
			storeTime(
				ruleListenersReturn.tdiff,
				{ type: "rules", key: ruleId ***REMOVED***,
				slots,
			);
		***REMOVED***

		/**
		 * Include `ruleId` in error logs
		 * @param {Function***REMOVED*** ruleListener A rule method that listens for a node.
		 * @returns {Function***REMOVED*** ruleListener wrapped in error handler
		 */
		function addRuleErrorHandler(ruleListener) {
			return function ruleErrorHandler(...listenerArgs) {
				try {
					const ruleListenerReturn = ruleListener(...listenerArgs);

					const ruleListenerResult = stats
						? ruleListenerReturn.result
						: ruleListenerReturn;

					if (stats) {
						storeTime(
							ruleListenerReturn.tdiff,
							{ type: "rules", key: ruleId ***REMOVED***,
							slots,
						);
					***REMOVED***

					return ruleListenerResult;
				***REMOVED*** catch (e) {
					e.ruleId = ruleId;
					throw e;
				***REMOVED***
			***REMOVED***;
		***REMOVED***

		if (typeof ruleListeners === "undefined" || ruleListeners === null) {
			throw new Error(
				`The create() function for rule '${ruleId***REMOVED***' did not return an object.`,
			);
		***REMOVED***

		// add all the selectors from the rule as listeners
		Object.keys(ruleListeners).forEach(selector => {
			const ruleListener =
				timing.enabled || stats
					? timing.time(ruleId, ruleListeners[selector], stats)
					: ruleListeners[selector];

			emitter.on(selector, addRuleErrorHandler(ruleListener));
		***REMOVED***);
	***REMOVED***);

	const eventGenerator = new NodeEventGenerator(emitter, {
		visitorKeys: sourceCode.visitorKeys ?? language.visitorKeys,
		fallback: Traverser.getKeys,
		matchClass: language.matchesSelectorClass ?? (() => false),
		nodeTypeKey: language.nodeTypeKey,
	***REMOVED***);

	for (const step of eventQueue) {
		switch (step.kind) {
			case STEP_KIND_VISIT: {
				try {
					if (step.phase === 1) {
						eventGenerator.enterNode(step.target);
					***REMOVED*** else {
						eventGenerator.leaveNode(step.target);
					***REMOVED***
				***REMOVED*** catch (err) {
					err.currentNode = step.target;
					throw err;
				***REMOVED***
				break;
			***REMOVED***

			case STEP_KIND_CALL: {
				emitter.emit(step.target, ...step.args);
				break;
			***REMOVED***

			default:
				throw new Error(
					`Invalid traversal step found: "${step.type***REMOVED***".`,
				);
		***REMOVED***
	***REMOVED***

	return lintingProblems;
***REMOVED***

/**
 * Ensure the source code to be a string.
 * @param {string|SourceCode***REMOVED*** textOrSourceCode The text or source code object.
 * @returns {string***REMOVED*** The source code text.
 */
function ensureText(textOrSourceCode) {
	if (typeof textOrSourceCode === "object") {
		const { hasBOM, text ***REMOVED*** = textOrSourceCode;
		const bom = hasBOM ? "\uFEFF" : "";

		return bom + text;
	***REMOVED***

	return String(textOrSourceCode);
***REMOVED***

/**
 * Get an environment.
 * @param {LinterInternalSlots***REMOVED*** slots The internal slots of Linter.
 * @param {string***REMOVED*** envId The environment ID to get.
 * @returns {Environment|null***REMOVED*** The environment.
 */
function getEnv(slots, envId) {
	return (
		(slots.lastConfigArray &&
			slots.lastConfigArray.pluginEnvironments.get(envId)) ||
		BuiltInEnvironments.get(envId) ||
		null
	);
***REMOVED***

/**
 * Get a rule.
 * @param {LinterInternalSlots***REMOVED*** slots The internal slots of Linter.
 * @param {string***REMOVED*** ruleId The rule ID to get.
 * @returns {Rule|null***REMOVED*** The rule.
 */
function getRule(slots, ruleId) {
	return (
		(slots.lastConfigArray &&
			slots.lastConfigArray.pluginRules.get(ruleId)) ||
		slots.ruleMap.get(ruleId)
	);
***REMOVED***

/**
 * Normalize the value of the cwd
 * @param {string | undefined***REMOVED*** cwd raw value of the cwd, path to a directory that should be considered as the current working directory, can be undefined.
 * @returns {string | undefined***REMOVED*** normalized cwd
 */
function normalizeCwd(cwd) {
	if (cwd) {
		return cwd;
	***REMOVED***
	if (typeof process === "object") {
		return process.cwd();
	***REMOVED***

	// It's more explicit to assign the undefined
	// eslint-disable-next-line no-undefined -- Consistently returning a value
	return undefined;
***REMOVED***

/**
 * The map to store private data.
 * @type {WeakMap<Linter, LinterInternalSlots>***REMOVED***
 */
const internalSlotsMap = new WeakMap();

/**
 * Throws an error when the given linter is in flat config mode.
 * @param {Linter***REMOVED*** linter The linter to check.
 * @returns {void***REMOVED***
 * @throws {Error***REMOVED*** If the linter is in flat config mode.
 */
function assertEslintrcConfig(linter) {
	const { configType ***REMOVED*** = internalSlotsMap.get(linter);

	if (configType === "flat") {
		throw new Error(
			"This method cannot be used with flat config. Add your entries directly into the config array.",
		);
	***REMOVED***
***REMOVED***

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * Object that is responsible for verifying JavaScript text
 * @name Linter
 */
class Linter {
	/**
	 * Initialize the Linter.
	 * @param {Object***REMOVED*** [config] the config object
	 * @param {string***REMOVED*** [config.cwd] path to a directory that should be considered as the current working directory, can be undefined.
	 * @param {Array<string>***REMOVED*** [config.flags] the feature flags to enable.
	 * @param {"flat"|"eslintrc"***REMOVED*** [config.configType="flat"] the type of config used.
	 */
	constructor({ cwd, configType = "flat", flags = [] ***REMOVED*** = {***REMOVED***) {
		const processedFlags = [];

		flags.forEach(flag => {
			if (inactiveFlags.has(flag)) {
				const inactiveFlagData = inactiveFlags.get(flag);
				const inactivityReason =
					getInactivityReasonMessage(inactiveFlagData);

				if (typeof inactiveFlagData.replacedBy === "undefined") {
					throw new Error(
						`The flag '${flag***REMOVED***' is inactive: ${inactivityReason***REMOVED***`,
					);
				***REMOVED***

				// if there's a replacement, enable it instead of original
				if (typeof inactiveFlagData.replacedBy === "string") {
					processedFlags.push(inactiveFlagData.replacedBy);
				***REMOVED***

				globalThis.process?.emitWarning?.(
					`The flag '${flag***REMOVED***' is inactive: ${inactivityReason***REMOVED***`,
					`ESLintInactiveFlag_${flag***REMOVED***`,
				);

				return;
			***REMOVED***

			if (!activeFlags.has(flag)) {
				throw new Error(`Unknown flag '${flag***REMOVED***'.`);
			***REMOVED***

			processedFlags.push(flag);
		***REMOVED***);

		internalSlotsMap.set(this, {
			cwd: normalizeCwd(cwd),
			flags: processedFlags,
			lastConfigArray: null,
			lastSourceCode: null,
			lastSuppressedMessages: [],
			configType, // TODO: Remove after flat config conversion
			parserMap: new Map([["espree", espree]]),
			ruleMap: new Rules(),
		***REMOVED***);

		this.version = pkg.version;
	***REMOVED***

	/**
	 * Getter for package version.
	 * @static
	 * @returns {string***REMOVED*** The version from package.json.
	 */
	static get version() {
		return pkg.version;
	***REMOVED***

	/**
	 * Indicates if the given feature flag is enabled for this instance.
	 * @param {string***REMOVED*** flag The feature flag to check.
	 * @returns {boolean***REMOVED*** `true` if the feature flag is enabled, `false` if not.
	 */
	hasFlag(flag) {
		return internalSlotsMap.get(this).flags.includes(flag);
	***REMOVED***

	/**
	 * Lint using eslintrc and without processors.
	 * @param {VFile***REMOVED*** file The file to lint.
	 * @param {ConfigData***REMOVED*** providedConfig An ESLintConfig instance to configure everything.
	 * @param {VerifyOptions***REMOVED*** [providedOptions] The optional filename of the file being checked.
	 * @throws {Error***REMOVED*** If during rule execution.
	 * @returns {(LintMessage|SuppressedLintMessage)[]***REMOVED*** The results as an array of messages or an empty array if no messages.
	 */
	#eslintrcVerifyWithoutProcessors(file, providedConfig, providedOptions) {
		const slots = internalSlotsMap.get(this);
		const config = providedConfig || {***REMOVED***;
		const options = normalizeVerifyOptions(providedOptions, config);

		// Resolve parser.
		let parserName = DEFAULT_PARSER_NAME;
		let parser = espree;

		if (typeof config.parser === "object" && config.parser !== null) {
			parserName = config.parser.filePath;
			parser = config.parser.definition;
		***REMOVED*** else if (typeof config.parser === "string") {
			if (!slots.parserMap.has(config.parser)) {
				return [
					{
						ruleId: null,
						fatal: true,
						severity: 2,
						message: `Configured parser '${config.parser***REMOVED***' was not found.`,
						line: 0,
						column: 0,
						nodeType: null,
					***REMOVED***,
				];
			***REMOVED***
			parserName = config.parser;
			parser = slots.parserMap.get(config.parser);
		***REMOVED***

		// search and apply "eslint-env *".
		const envInFile =
			options.allowInlineConfig && !options.warnInlineConfig
				? findEslintEnv(file.body)
				: {***REMOVED***;
		const resolvedEnvConfig = Object.assign(
			{ builtin: true ***REMOVED***,
			config.env,
			envInFile,
		);
		const enabledEnvs = Object.keys(resolvedEnvConfig)
			.filter(envName => resolvedEnvConfig[envName])
			.map(envName => getEnv(slots, envName))
			.filter(env => env);

		const parserOptions = resolveParserOptions(
			parser,
			config.parserOptions || {***REMOVED***,
			enabledEnvs,
		);
		const configuredGlobals = resolveGlobals(
			config.globals || {***REMOVED***,
			enabledEnvs,
		);
		const settings = config.settings || {***REMOVED***;
		const languageOptions = createLanguageOptions({
			globals: config.globals,
			parser,
			parserOptions,
		***REMOVED***);

		if (!slots.lastSourceCode) {
			let t;

			if (options.stats) {
				t = startTime();
			***REMOVED***

			const parserService = new ParserService();
			const parseResult = parserService.parseSync(file, {
				language: jslang,
				languageOptions,
			***REMOVED***);

			if (options.stats) {
				const time = endTime(t);
				const timeOpts = { type: "parse" ***REMOVED***;

				storeTime(time, timeOpts, slots);
			***REMOVED***

			if (!parseResult.ok) {
				return parseResult.errors;
			***REMOVED***

			slots.lastSourceCode = parseResult.sourceCode;
		***REMOVED*** else {
			/*
			 * If the given source code object as the first argument does not have scopeManager, analyze the scope.
			 * This is for backward compatibility (SourceCode is frozen so it cannot rebind).
			 */
			if (!slots.lastSourceCode.scopeManager) {
				slots.lastSourceCode = new SourceCode({
					text: slots.lastSourceCode.text,
					ast: slots.lastSourceCode.ast,
					hasBOM: slots.lastSourceCode.hasBOM,
					parserServices: slots.lastSourceCode.parserServices,
					visitorKeys: slots.lastSourceCode.visitorKeys,
					scopeManager: analyzeScope(
						slots.lastSourceCode.ast,
						languageOptions,
					),
				***REMOVED***);
			***REMOVED***
		***REMOVED***

		const sourceCode = slots.lastSourceCode;
		const commentDirectives = options.allowInlineConfig
			? getDirectiveComments(
					sourceCode,
					ruleId => getRule(slots, ruleId),
					options.warnInlineConfig,
					config,
				)
			: {
					configuredRules: {***REMOVED***,
					enabledGlobals: {***REMOVED***,
					exportedVariables: {***REMOVED***,
					problems: [],
					disableDirectives: [],
				***REMOVED***;

		addDeclaredGlobals(
			sourceCode.scopeManager.scopes[0],
			configuredGlobals,
			{
				exportedVariables: commentDirectives.exportedVariables,
				enabledGlobals: commentDirectives.enabledGlobals,
			***REMOVED***,
		);

		const configuredRules = Object.assign(
			{***REMOVED***,
			config.rules,
			commentDirectives.configuredRules,
		);

		let lintingProblems;

		try {
			lintingProblems = runRules(
				sourceCode,
				configuredRules,
				ruleId => getRule(slots, ruleId),
				parserName,
				jslang,
				languageOptions,
				settings,
				options.filename,
				true,
				options.disableFixes,
				slots.cwd,
				providedOptions.physicalFilename,
				null,
				options.stats,
				slots,
			);
		***REMOVED*** catch (err) {
			err.message += `\nOccurred while linting ${options.filename***REMOVED***`;
			debug("An error occurred while traversing");
			debug("Filename:", options.filename);
			if (err.currentNode) {
				const { line ***REMOVED*** = sourceCode.getLoc(err.currentNode).start;

				debug("Line:", line);
				err.message += `:${line***REMOVED***`;
			***REMOVED***
			debug("Parser Options:", parserOptions);
			debug("Parser Path:", parserName);
			debug("Settings:", settings);

			if (err.ruleId) {
				err.message += `\nRule: "${err.ruleId***REMOVED***"`;
			***REMOVED***

			throw err;
		***REMOVED***

		return applyDisableDirectives({
			language: jslang,
			sourceCode,
			directives: commentDirectives.disableDirectives,
			disableFixes: options.disableFixes,
			problems: lintingProblems
				.concat(commentDirectives.problems)
				.sort(
					(problemA, problemB) =>
						problemA.line - problemB.line ||
						problemA.column - problemB.column,
				),
			reportUnusedDisableDirectives:
				options.reportUnusedDisableDirectives,
		***REMOVED***);
	***REMOVED***

	/**
	 * Same as linter.verify, except without support for processors.
	 * @param {string|SourceCode***REMOVED*** textOrSourceCode The text to parse or a SourceCode object.
	 * @param {ConfigData***REMOVED*** providedConfig An ESLintConfig instance to configure everything.
	 * @param {VerifyOptions***REMOVED*** [providedOptions] The optional filename of the file being checked.
	 * @throws {Error***REMOVED*** If during rule execution.
	 * @returns {(LintMessage|SuppressedLintMessage)[]***REMOVED*** The results as an array of messages or an empty array if no messages.
	 */
	_verifyWithoutProcessors(
		textOrSourceCode,
		providedConfig,
		providedOptions,
	) {
		const slots = internalSlotsMap.get(this);
		const filename = normalizeFilename(
			providedOptions.filename || "<input>",
		);
		let text;

		// evaluate arguments
		if (typeof textOrSourceCode === "string") {
			slots.lastSourceCode = null;
			text = textOrSourceCode;
		***REMOVED*** else {
			slots.lastSourceCode = textOrSourceCode;
			text = textOrSourceCode.text;
		***REMOVED***

		const file = new VFile(filename, text, {
			physicalPath: providedOptions.physicalFilename,
		***REMOVED***);

		return this.#eslintrcVerifyWithoutProcessors(
			file,
			providedConfig,
			providedOptions,
		);
	***REMOVED***

	/**
	 * Verifies the text against the rules specified by the second argument.
	 * @param {string|SourceCode***REMOVED*** textOrSourceCode The text to parse or a SourceCode object.
	 * @param {ConfigData|ConfigArray***REMOVED*** config An ESLintConfig instance to configure everything.
	 * @param {(string|(VerifyOptions&ProcessorOptions))***REMOVED*** [filenameOrOptions] The optional filename of the file being checked.
	 *      If this is not set, the filename will default to '<input>' in the rule context. If
	 *      an object, then it has "filename", "allowInlineConfig", and some properties.
	 * @returns {LintMessage[]***REMOVED*** The results as an array of messages or an empty array if no messages.
	 */
	verify(textOrSourceCode, config, filenameOrOptions) {
		debug("Verify");

		const { configType, cwd ***REMOVED*** = internalSlotsMap.get(this);

		const options =
			typeof filenameOrOptions === "string"
				? { filename: filenameOrOptions ***REMOVED***
				: filenameOrOptions || {***REMOVED***;

		const configToUse = config ?? {***REMOVED***;

		if (configType !== "eslintrc") {
			/*
			 * Because of how Webpack packages up the files, we can't
			 * compare directly to `FlatConfigArray` using `instanceof`
			 * because it's not the same `FlatConfigArray` as in the tests.
			 * So, we work around it by assuming an array is, in fact, a
			 * `FlatConfigArray` if it has a `getConfig()` method.
			 */
			let configArray = configToUse;

			if (
				!Array.isArray(configToUse) ||
				typeof configToUse.getConfig !== "function"
			) {
				configArray = new FlatConfigArray(configToUse, {
					basePath: cwd,
				***REMOVED***);
				configArray.normalizeSync();
			***REMOVED***

			return this._distinguishSuppressedMessages(
				this._verifyWithFlatConfigArray(
					textOrSourceCode,
					configArray,
					options,
					true,
				),
			);
		***REMOVED***

		if (typeof configToUse.extractConfig === "function") {
			return this._distinguishSuppressedMessages(
				this._verifyWithConfigArray(
					textOrSourceCode,
					configToUse,
					options,
				),
			);
		***REMOVED***

		/*
		 * If we get to here, it means `config` is just an object rather
		 * than a config array so we can go right into linting.
		 */

		/*
		 * `Linter` doesn't support `overrides` property in configuration.
		 * So we cannot apply multiple processors.
		 */
		if (options.preprocess || options.postprocess) {
			return this._distinguishSuppressedMessages(
				this._verifyWithProcessor(
					textOrSourceCode,
					configToUse,
					options,
				),
			);
		***REMOVED***
		return this._distinguishSuppressedMessages(
			this._verifyWithoutProcessors(
				textOrSourceCode,
				configToUse,
				options,
			),
		);
	***REMOVED***

	/**
	 * Verify with a processor.
	 * @param {string|SourceCode***REMOVED*** textOrSourceCode The source code.
	 * @param {FlatConfig***REMOVED*** config The config array.
	 * @param {VerifyOptions&ProcessorOptions***REMOVED*** options The options.
	 * @param {FlatConfigArray***REMOVED*** [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.
	 * @returns {(LintMessage|SuppressedLintMessage)[]***REMOVED*** The found problems.
	 */
	_verifyWithFlatConfigArrayAndProcessor(
		textOrSourceCode,
		config,
		options,
		configForRecursive,
	) {
		const slots = internalSlotsMap.get(this);
		const filename = options.filename || "<input>";
		const filenameToExpose = normalizeFilename(filename);
		const physicalFilename = options.physicalFilename || filenameToExpose;
		const text = ensureText(textOrSourceCode);
		const file = new VFile(filenameToExpose, text, {
			physicalPath: physicalFilename,
		***REMOVED***);

		const preprocess = options.preprocess || (rawText => [rawText]);
		const postprocess =
			options.postprocess || (messagesList => messagesList.flat());

		const processorService = new ProcessorService();
		const preprocessResult = processorService.preprocessSync(file, {
			processor: {
				preprocess,
				postprocess,
			***REMOVED***,
		***REMOVED***);

		if (!preprocessResult.ok) {
			return preprocessResult.errors;
		***REMOVED***

		const filterCodeBlock =
			options.filterCodeBlock ||
			(blockFilename => blockFilename.endsWith(".js"));
		const originalExtname = path.extname(filename);
		const { files ***REMOVED*** = preprocessResult;

		const messageLists = files.map(block => {
			debug("A code block was found: %o", block.path || "(unnamed)");

			// Keep the legacy behavior.
			if (typeof block === "string") {
				return this._verifyWithFlatConfigArrayAndWithoutProcessors(
					block,
					config,
					options,
				);
			***REMOVED***

			// Skip this block if filtered.
			if (!filterCodeBlock(block.path, block.body)) {
				debug("This code block was skipped.");
				return [];
			***REMOVED***

			// Resolve configuration again if the file content or extension was changed.
			if (
				configForRecursive &&
				(text !== block.rawBody ||
					path.extname(block.path) !== originalExtname)
			) {
				debug(
					"Resolving configuration again because the file content or extension was changed.",
				);
				return this._verifyWithFlatConfigArray(
					block.rawBody,
					configForRecursive,
					{
						...options,
						filename: block.path,
						physicalFilename: block.physicalPath,
					***REMOVED***,
				);
			***REMOVED***

			slots.lastSourceCode = null;

			// Does lint.
			return this.#flatVerifyWithoutProcessors(block, config, {
				...options,
				filename: block.path,
				physicalFilename: block.physicalPath,
			***REMOVED***);
		***REMOVED***);

		return processorService.postprocessSync(file, messageLists, {
			processor: {
				preprocess,
				postprocess,
			***REMOVED***,
		***REMOVED***);
	***REMOVED***

	/**
	 * Verify using flat config and without any processors.
	 * @param {VFile***REMOVED*** file The file to lint.
	 * @param {FlatConfig***REMOVED*** providedConfig An ESLintConfig instance to configure everything.
	 * @param {VerifyOptions***REMOVED*** [providedOptions] The optional filename of the file being checked.
	 * @throws {Error***REMOVED*** If during rule execution.
	 * @returns {(LintMessage|SuppressedLintMessage)[]***REMOVED*** The results as an array of messages or an empty array if no messages.
	 */
	#flatVerifyWithoutProcessors(file, providedConfig, providedOptions) {
		const slots = internalSlotsMap.get(this);
		const config = providedConfig || {***REMOVED***;
		const { settings = {***REMOVED***, languageOptions ***REMOVED*** = config;
		const options = normalizeVerifyOptions(providedOptions, config);

		if (!slots.lastSourceCode) {
			let t;

			if (options.stats) {
				t = startTime();
			***REMOVED***

			const parserService = new ParserService();
			const parseResult = parserService.parseSync(file, config);

			if (options.stats) {
				const time = endTime(t);

				storeTime(time, { type: "parse" ***REMOVED***, slots);
			***REMOVED***

			if (!parseResult.ok) {
				return parseResult.errors;
			***REMOVED***

			slots.lastSourceCode = parseResult.sourceCode;
		***REMOVED*** else {
			/*
			 * If the given source code object as the first argument does not have scopeManager, analyze the scope.
			 * This is for backward compatibility (SourceCode is frozen so it cannot rebind).
			 *
			 * We check explicitly for `null` to ensure that this is a JS-flavored language.
			 * For non-JS languages we don't want to do this.
			 *
			 * TODO: Remove this check when we stop exporting the `SourceCode` object.
			 */
			if (slots.lastSourceCode.scopeManager === null) {
				slots.lastSourceCode = new SourceCode({
					text: slots.lastSourceCode.text,
					ast: slots.lastSourceCode.ast,
					hasBOM: slots.lastSourceCode.hasBOM,
					parserServices: slots.lastSourceCode.parserServices,
					visitorKeys: slots.lastSourceCode.visitorKeys,
					scopeManager: analyzeScope(
						slots.lastSourceCode.ast,
						languageOptions,
					),
				***REMOVED***);
			***REMOVED***
		***REMOVED***

		const sourceCode = slots.lastSourceCode;

		/*
		 * Make adjustments based on the language options. For JavaScript,
		 * this is primarily about adding variables into the global scope
		 * to account for ecmaVersion and configured globals.
		 */
		sourceCode.applyLanguageOptions?.(languageOptions);

		const mergedInlineConfig = {
			rules: {***REMOVED***,
		***REMOVED***;
		const inlineConfigProblems = [];

		/*
		 * Inline config can be either enabled or disabled. If disabled, it's possible
		 * to detect the inline config and emit a warning (though this is not required).
		 * So we first check to see if inline config is allowed at all, and if so, we
		 * need to check if it's a warning or not.
		 */
		if (options.allowInlineConfig) {
			// if inline config should warn then add the warnings
			if (options.warnInlineConfig) {
				if (sourceCode.getInlineConfigNodes) {
					sourceCode.getInlineConfigNodes().forEach(node => {
						const loc = sourceCode.getLoc(node);
						const range = sourceCode.getRange(node);

						inlineConfigProblems.push(
							createLintingProblem({
								ruleId: null,
								message: `'${sourceCode.text.slice(range[0], range[1])***REMOVED***' has no effect because you have 'noInlineConfig' setting in ${options.warnInlineConfig***REMOVED***.`,
								loc,
								severity: 1,
								language: config.language,
							***REMOVED***),
						);
					***REMOVED***);
				***REMOVED***
			***REMOVED*** else {
				const inlineConfigResult = sourceCode.applyInlineConfig?.();

				if (inlineConfigResult) {
					inlineConfigProblems.push(
						...inlineConfigResult.problems
							.map(problem =>
								createLintingProblem({
									...problem,
									language: config.language,
								***REMOVED***),
							)
							.map(problem => {
								problem.fatal = true;
								return problem;
							***REMOVED***),
					);

					// next we need to verify information about the specified rules
					const ruleValidator = new RuleValidator();

					for (const {
						config: inlineConfig,
						loc,
					***REMOVED*** of inlineConfigResult.configs) {
						Object.keys(inlineConfig.rules).forEach(ruleId => {
							const rule = getRuleFromConfig(ruleId, config);
							const ruleValue = inlineConfig.rules[ruleId];

							if (!rule) {
								inlineConfigProblems.push(
									createLintingProblem({
										ruleId,
										loc,
										language: config.language,
									***REMOVED***),
								);
								return;
							***REMOVED***

							if (
								Object.hasOwn(mergedInlineConfig.rules, ruleId)
							) {
								inlineConfigProblems.push(
									createLintingProblem({
										message: `Rule "${ruleId***REMOVED***" is already configured by another configuration comment in the preceding code. This configuration is ignored.`,
										loc,
										language: config.language,
									***REMOVED***),
								);
								return;
							***REMOVED***

							try {
								const ruleOptionsInline = asArray(ruleValue);
								let ruleOptions = ruleOptionsInline;

								assertIsRuleSeverity(ruleId, ruleOptions[0]);

								/*
								 * If the rule was already configured, inline rule configuration that
								 * only has severity should retain options from the config and just override the severity.
								 *
								 * Example:
								 *
								 *   {
								 *       rules: {
								 *           curly: ["error", "multi"]
								 *       ***REMOVED***
								 *   ***REMOVED***
								 *
								 *   /* eslint curly: ["warn"] * /
								 *
								 *   Results in:
								 *
								 *   curly: ["warn", "multi"]
								 */

								let shouldValidateOptions = true;

								if (
									/*
									 * If inline config for the rule has only severity
									 */
									ruleOptions.length === 1 &&
									/*
									 * And the rule was already configured
									 */
									config.rules &&
									Object.hasOwn(config.rules, ruleId)
								) {
									/*
									 * Then use severity from the inline config and options from the provided config
									 */
									ruleOptions = [
										ruleOptions[0], // severity from the inline config
										...config.rules[ruleId].slice(1), // options from the provided config
									];

									// if the rule was enabled, the options have already been validated
									if (config.rules[ruleId][0] > 0) {
										shouldValidateOptions = false;
									***REMOVED***
								***REMOVED*** else {
									/**
									 * Since we know the user provided options, apply defaults on top of them
									 */
									const slicedOptions = ruleOptions.slice(1);
									const mergedOptions = deepMergeArrays(
										rule.meta?.defaultOptions,
										slicedOptions,
									);

									if (mergedOptions.length) {
										ruleOptions = [
											ruleOptions[0],
											...mergedOptions,
										];
									***REMOVED***
								***REMOVED***

								if (
									options.reportUnusedInlineConfigs !== "off"
								) {
									addProblemIfSameSeverityAndOptions(
										config,
										loc,
										inlineConfigProblems,
										ruleId,
										ruleOptions,
										ruleOptionsInline,
										options.reportUnusedInlineConfigs,
									);
								***REMOVED***

								if (shouldValidateOptions) {
									ruleValidator.validate({
										plugins: config.plugins,
										rules: {
											[ruleId]: ruleOptions,
										***REMOVED***,
									***REMOVED***);
								***REMOVED***

								mergedInlineConfig.rules[ruleId] = ruleOptions;
							***REMOVED*** catch (err) {
								/*
								 * If the rule has invalid `meta.schema`, throw the error because
								 * this is not an invalid inline configuration but an invalid rule.
								 */
								if (
									err.code ===
									"ESLINT_INVALID_RULE_OPTIONS_SCHEMA"
								) {
									throw err;
								***REMOVED***

								let baseMessage = err.message
									.slice(
										err.message.startsWith('Key "rules":')
											? err.message.indexOf(":", 12) + 1
											: err.message.indexOf(":") + 1,
									)
									.trim();

								if (err.messageTemplate) {
									baseMessage += ` You passed "${ruleValue***REMOVED***".`;
								***REMOVED***

								inlineConfigProblems.push(
									createLintingProblem({
										ruleId,
										message: `Inline configuration for rule "${ruleId***REMOVED***" is invalid:\n\t${baseMessage***REMOVED***\n`,
										loc,
										language: config.language,
									***REMOVED***),
								);
							***REMOVED***
						***REMOVED***);
					***REMOVED***
				***REMOVED***
			***REMOVED***
		***REMOVED***

		const commentDirectives =
			options.allowInlineConfig && !options.warnInlineConfig
				? getDirectiveCommentsForFlatConfig(
						sourceCode,
						ruleId => getRuleFromConfig(ruleId, config),
						config.language,
					)
				: { problems: [], disableDirectives: [] ***REMOVED***;

		const configuredRules = Object.assign(
			{***REMOVED***,
			config.rules,
			mergedInlineConfig.rules,
		);

		let lintingProblems;

		sourceCode.finalize?.();

		try {
			lintingProblems = runRules(
				sourceCode,
				configuredRules,
				ruleId => getRuleFromConfig(ruleId, config),
				void 0,
				config.language,
				languageOptions,
				settings,
				options.filename,
				false,
				options.disableFixes,
				slots.cwd,
				providedOptions.physicalFilename,
				options.ruleFilter,
				options.stats,
				slots,
			);
		***REMOVED*** catch (err) {
			err.message += `\nOccurred while linting ${options.filename***REMOVED***`;
			debug("An error occurred while traversing");
			debug("Filename:", options.filename);
			if (err.currentNode) {
				const { line ***REMOVED*** = sourceCode.getLoc(err.currentNode).start;

				debug("Line:", line);
				err.message += `:${line***REMOVED***`;
			***REMOVED***
			debug("Parser Options:", languageOptions.parserOptions);

			// debug("Parser Path:", parserName);
			debug("Settings:", settings);

			if (err.ruleId) {
				err.message += `\nRule: "${err.ruleId***REMOVED***"`;
			***REMOVED***

			throw err;
		***REMOVED***

		return applyDisableDirectives({
			language: config.language,
			sourceCode,
			directives: commentDirectives.disableDirectives,
			disableFixes: options.disableFixes,
			problems: lintingProblems
				.concat(commentDirectives.problems)
				.concat(inlineConfigProblems)
				.sort(
					(problemA, problemB) =>
						problemA.line - problemB.line ||
						problemA.column - problemB.column,
				),
			reportUnusedDisableDirectives:
				options.reportUnusedDisableDirectives,
			ruleFilter: options.ruleFilter,
			configuredRules,
		***REMOVED***);
	***REMOVED***

	/**
	 * Same as linter.verify, except without support for processors.
	 * @param {string|SourceCode***REMOVED*** textOrSourceCode The text to parse or a SourceCode object.
	 * @param {FlatConfig***REMOVED*** providedConfig An ESLintConfig instance to configure everything.
	 * @param {VerifyOptions***REMOVED*** [providedOptions] The optional filename of the file being checked.
	 * @throws {Error***REMOVED*** If during rule execution.
	 * @returns {(LintMessage|SuppressedLintMessage)[]***REMOVED*** The results as an array of messages or an empty array if no messages.
	 */
	_verifyWithFlatConfigArrayAndWithoutProcessors(
		textOrSourceCode,
		providedConfig,
		providedOptions,
	) {
		const slots = internalSlotsMap.get(this);
		const filename = normalizeFilename(
			providedOptions.filename || "<input>",
		);
		let text;

		// evaluate arguments
		if (typeof textOrSourceCode === "string") {
			slots.lastSourceCode = null;
			text = textOrSourceCode;
		***REMOVED*** else {
			slots.lastSourceCode = textOrSourceCode;
			text = textOrSourceCode.text;
		***REMOVED***

		const file = new VFile(filename, text, {
			physicalPath: providedOptions.physicalFilename,
		***REMOVED***);

		return this.#flatVerifyWithoutProcessors(
			file,
			providedConfig,
			providedOptions,
		);
	***REMOVED***

	/**
	 * Verify a given code with `ConfigArray`.
	 * @param {string|SourceCode***REMOVED*** textOrSourceCode The source code.
	 * @param {ConfigArray***REMOVED*** configArray The config array.
	 * @param {VerifyOptions&ProcessorOptions***REMOVED*** options The options.
	 * @returns {(LintMessage|SuppressedLintMessage)[]***REMOVED*** The found problems.
	 */
	_verifyWithConfigArray(textOrSourceCode, configArray, options) {
		debug("With ConfigArray: %s", options.filename);

		// Store the config array in order to get plugin envs and rules later.
		internalSlotsMap.get(this).lastConfigArray = configArray;

		// Extract the final config for this file.
		const config = configArray.extractConfig(options.filename);
		const processor =
			config.processor &&
			configArray.pluginProcessors.get(config.processor);

		// Verify.
		if (processor) {
			debug("Apply the processor: %o", config.processor);
			const { preprocess, postprocess, supportsAutofix ***REMOVED*** = processor;
			const disableFixes = options.disableFixes || !supportsAutofix;

			return this._verifyWithProcessor(
				textOrSourceCode,
				config,
				{ ...options, disableFixes, postprocess, preprocess ***REMOVED***,
				configArray,
			);
		***REMOVED***
		return this._verifyWithoutProcessors(textOrSourceCode, config, options);
	***REMOVED***

	/**
	 * Verify a given code with a flat config.
	 * @param {string|SourceCode***REMOVED*** textOrSourceCode The source code.
	 * @param {FlatConfigArray***REMOVED*** configArray The config array.
	 * @param {VerifyOptions&ProcessorOptions***REMOVED*** options The options.
	 * @param {boolean***REMOVED*** [firstCall=false] Indicates if this is being called directly
	 *      from verify(). (TODO: Remove once eslintrc is removed.)
	 * @returns {(LintMessage|SuppressedLintMessage)[]***REMOVED*** The found problems.
	 */
	_verifyWithFlatConfigArray(
		textOrSourceCode,
		configArray,
		options,
		firstCall = false,
	) {
		debug("With flat config: %s", options.filename);

		// we need a filename to match configs against
		const filename = options.filename || "__placeholder__.js";

		// Store the config array in order to get plugin envs and rules later.
		internalSlotsMap.get(this).lastConfigArray = configArray;
		const config = configArray.getConfig(filename);

		if (!config) {
			return [
				{
					ruleId: null,
					severity: 1,
					message: `No matching configuration found for ${filename***REMOVED***.`,
					line: 0,
					column: 0,
					nodeType: null,
				***REMOVED***,
			];
		***REMOVED***

		// Verify.
		if (config.processor) {
			debug("Apply the processor: %o", config.processor);
			const { preprocess, postprocess, supportsAutofix ***REMOVED*** =
				config.processor;
			const disableFixes = options.disableFixes || !supportsAutofix;

			return this._verifyWithFlatConfigArrayAndProcessor(
				textOrSourceCode,
				config,
				{ ...options, filename, disableFixes, postprocess, preprocess ***REMOVED***,
				configArray,
			);
		***REMOVED***

		// check for options-based processing
		if (firstCall && (options.preprocess || options.postprocess)) {
			return this._verifyWithFlatConfigArrayAndProcessor(
				textOrSourceCode,
				config,
				options,
			);
		***REMOVED***

		return this._verifyWithFlatConfigArrayAndWithoutProcessors(
			textOrSourceCode,
			config,
			options,
		);
	***REMOVED***

	/**
	 * Verify with a processor.
	 * @param {string|SourceCode***REMOVED*** textOrSourceCode The source code.
	 * @param {ConfigData|ExtractedConfig***REMOVED*** config The config array.
	 * @param {VerifyOptions&ProcessorOptions***REMOVED*** options The options.
	 * @param {ConfigArray***REMOVED*** [configForRecursive] The `ConfigArray` object to apply multiple processors recursively.
	 * @returns {(LintMessage|SuppressedLintMessage)[]***REMOVED*** The found problems.
	 */
	_verifyWithProcessor(
		textOrSourceCode,
		config,
		options,
		configForRecursive,
	) {
		const slots = internalSlotsMap.get(this);
		const filename = options.filename || "<input>";
		const filenameToExpose = normalizeFilename(filename);
		const physicalFilename = options.physicalFilename || filenameToExpose;
		const text = ensureText(textOrSourceCode);
		const file = new VFile(filenameToExpose, text, {
			physicalPath: physicalFilename,
		***REMOVED***);

		const preprocess = options.preprocess || (rawText => [rawText]);
		const postprocess =
			options.postprocess || (messagesList => messagesList.flat());

		const processorService = new ProcessorService();
		const preprocessResult = processorService.preprocessSync(file, {
			processor: {
				preprocess,
				postprocess,
			***REMOVED***,
		***REMOVED***);

		if (!preprocessResult.ok) {
			return preprocessResult.errors;
		***REMOVED***

		const filterCodeBlock =
			options.filterCodeBlock ||
			(blockFilePath => blockFilePath.endsWith(".js"));
		const originalExtname = path.extname(filename);

		const { files ***REMOVED*** = preprocessResult;

		const messageLists = files.map(block => {
			debug("A code block was found: %o", block.path ?? "(unnamed)");

			// Keep the legacy behavior.
			if (typeof block === "string") {
				return this._verifyWithoutProcessors(block, config, options);
			***REMOVED***

			// Skip this block if filtered.
			if (!filterCodeBlock(block.path, block.body)) {
				debug("This code block was skipped.");
				return [];
			***REMOVED***

			// Resolve configuration again if the file content or extension was changed.
			if (
				configForRecursive &&
				(text !== block.rawBody ||
					path.extname(block.path) !== originalExtname)
			) {
				debug(
					"Resolving configuration again because the file content or extension was changed.",
				);
				return this._verifyWithConfigArray(
					block.rawBody,
					configForRecursive,
					{
						...options,
						filename: block.path,
						physicalFilename: block.physicalPath,
					***REMOVED***,
				);
			***REMOVED***

			slots.lastSourceCode = null;

			// Does lint.
			return this.#eslintrcVerifyWithoutProcessors(block, config, {
				...options,
				filename: block.path,
				physicalFilename: block.physicalPath,
			***REMOVED***);
		***REMOVED***);

		return processorService.postprocessSync(file, messageLists, {
			processor: {
				preprocess,
				postprocess,
			***REMOVED***,
		***REMOVED***);
	***REMOVED***

	/**
	 * Given a list of reported problems, distinguish problems between normal messages and suppressed messages.
	 * The normal messages will be returned and the suppressed messages will be stored as lastSuppressedMessages.
	 * @param {Array<LintMessage|SuppressedLintMessage>***REMOVED*** problems A list of reported problems.
	 * @returns {LintMessage[]***REMOVED*** A list of LintMessage.
	 */
	_distinguishSuppressedMessages(problems) {
		const messages = [];
		const suppressedMessages = [];
		const slots = internalSlotsMap.get(this);

		for (const problem of problems) {
			if (problem.suppressions) {
				suppressedMessages.push(problem);
			***REMOVED*** else {
				messages.push(problem);
			***REMOVED***
		***REMOVED***

		slots.lastSuppressedMessages = suppressedMessages;

		return messages;
	***REMOVED***

	/**
	 * Gets the SourceCode object representing the parsed source.
	 * @returns {SourceCode***REMOVED*** The SourceCode object.
	 */
	getSourceCode() {
		return internalSlotsMap.get(this).lastSourceCode;
	***REMOVED***

	/**
	 * Gets the times spent on (parsing, fixing, linting) a file.
	 * @returns {LintTimes***REMOVED*** The times.
	 */
	getTimes() {
		return internalSlotsMap.get(this).times ?? { passes: [] ***REMOVED***;
	***REMOVED***

	/**
	 * Gets the number of autofix passes that were made in the last run.
	 * @returns {number***REMOVED*** The number of autofix passes.
	 */
	getFixPassCount() {
		return internalSlotsMap.get(this).fixPasses ?? 0;
	***REMOVED***

	/**
	 * Gets the list of SuppressedLintMessage produced in the last running.
	 * @returns {SuppressedLintMessage[]***REMOVED*** The list of SuppressedLintMessage
	 */
	getSuppressedMessages() {
		return internalSlotsMap.get(this).lastSuppressedMessages;
	***REMOVED***

	/**
	 * Defines a new linting rule.
	 * @param {string***REMOVED*** ruleId A unique rule identifier
	 * @param {Rule***REMOVED*** rule A rule object
	 * @returns {void***REMOVED***
	 */
	defineRule(ruleId, rule) {
		assertEslintrcConfig(this);
		internalSlotsMap.get(this).ruleMap.define(ruleId, rule);
	***REMOVED***

	/**
	 * Defines many new linting rules.
	 * @param {Record<string, Rule>***REMOVED*** rulesToDefine map from unique rule identifier to rule
	 * @returns {void***REMOVED***
	 */
	defineRules(rulesToDefine) {
		assertEslintrcConfig(this);
		Object.getOwnPropertyNames(rulesToDefine).forEach(ruleId => {
			this.defineRule(ruleId, rulesToDefine[ruleId]);
		***REMOVED***);
	***REMOVED***

	/**
	 * Gets an object with all loaded rules.
	 * @returns {Map<string, Rule>***REMOVED*** All loaded rules
	 */
	getRules() {
		assertEslintrcConfig(this);
		const { lastConfigArray, ruleMap ***REMOVED*** = internalSlotsMap.get(this);

		return new Map(
			(function* () {
				yield* ruleMap;

				if (lastConfigArray) {
					yield* lastConfigArray.pluginRules;
				***REMOVED***
			***REMOVED***)(),
		);
	***REMOVED***

	/**
	 * Define a new parser module
	 * @param {string***REMOVED*** parserId Name of the parser
	 * @param {Parser***REMOVED*** parserModule The parser object
	 * @returns {void***REMOVED***
	 */
	defineParser(parserId, parserModule) {
		assertEslintrcConfig(this);
		internalSlotsMap.get(this).parserMap.set(parserId, parserModule);
	***REMOVED***

	/**
	 * Performs multiple autofix passes over the text until as many fixes as possible
	 * have been applied.
	 * @param {string***REMOVED*** text The source text to apply fixes to.
	 * @param {ConfigData|ConfigArray|FlatConfigArray***REMOVED*** config The ESLint config object to use.
	 * @param {VerifyOptions&ProcessorOptions&FixOptions***REMOVED*** options The ESLint options object to use.
	 * @returns {{fixed:boolean,messages:LintMessage[],output:string***REMOVED******REMOVED*** The result of the fix operation as returned from the
	 *      SourceCodeFixer.
	 */
	verifyAndFix(text, config, options) {
		let messages,
			fixedResult,
			fixed = false,
			passNumber = 0,
			currentText = text,
			secondPreviousText,
			previousText;
		const debugTextDescription =
			(options && options.filename) || `${text.slice(0, 10)***REMOVED***...`;
		const shouldFix =
			options && typeof options.fix !== "undefined" ? options.fix : true;
		const stats = options?.stats;

		/**
		 * This loop continues until one of the following is true:
		 *
		 * 1. No more fixes have been applied.
		 * 2. Ten passes have been made.
		 *
		 * That means anytime a fix is successfully applied, there will be another pass.
		 * Essentially, guaranteeing a minimum of two passes.
		 */
		const slots = internalSlotsMap.get(this);

		// Remove lint times from the last run.
		if (stats) {
			delete slots.times;
			slots.fixPasses = 0;
		***REMOVED***

		do {
			passNumber++;
			let tTotal;

			if (stats) {
				tTotal = startTime();
			***REMOVED***

			debug(
				`Linting code for ${debugTextDescription***REMOVED*** (pass ${passNumber***REMOVED***)`,
			);
			messages = this.verify(currentText, config, options);

			debug(
				`Generating fixed text for ${debugTextDescription***REMOVED*** (pass ${passNumber***REMOVED***)`,
			);
			let t;

			if (stats) {
				t = startTime();
			***REMOVED***

			fixedResult = SourceCodeFixer.applyFixes(
				currentText,
				messages,
				shouldFix,
			);

			if (stats) {
				if (fixedResult.fixed) {
					const time = endTime(t);

					storeTime(time, { type: "fix" ***REMOVED***, slots);
					slots.fixPasses++;
				***REMOVED*** else {
					storeTime(0, { type: "fix" ***REMOVED***, slots);
				***REMOVED***
			***REMOVED***

			/*
			 * stop if there are any syntax errors.
			 * 'fixedResult.output' is a empty string.
			 */
			if (messages.length === 1 && messages[0].fatal) {
				break;
			***REMOVED***

			// keep track if any fixes were ever applied - important for return value
			fixed = fixed || fixedResult.fixed;

			// update to use the fixed output instead of the original text
			secondPreviousText = previousText;
			previousText = currentText;
			currentText = fixedResult.output;

			if (stats) {
				tTotal = endTime(tTotal);
				const passIndex = slots.times.passes.length - 1;

				slots.times.passes[passIndex].total = tTotal;
			***REMOVED***

			// Stop if we've made a circular fix
			if (
				passNumber > 1 &&
				currentText.length === secondPreviousText.length &&
				currentText === secondPreviousText
			) {
				debug(
					`Circular fixes detected after pass ${passNumber***REMOVED***. Exiting fix loop.`,
				);
				globalThis?.process?.emitWarning?.(
					`Circular fixes detected while fixing ${options?.filename ?? "text"***REMOVED***. It is likely that you have conflicting rules in your configuration.`,
					"ESLintCircularFixesWarning",
				);
				break;
			***REMOVED***
		***REMOVED*** while (fixedResult.fixed && passNumber < MAX_AUTOFIX_PASSES);

		/*
		 * If the last result had fixes, we need to lint again to be sure we have
		 * the most up-to-date information.
		 */
		if (fixedResult.fixed) {
			let tTotal;

			if (stats) {
				tTotal = startTime();
			***REMOVED***

			fixedResult.messages = this.verify(currentText, config, options);

			if (stats) {
				storeTime(0, { type: "fix" ***REMOVED***, slots);
				slots.times.passes.at(-1).total = endTime(tTotal);
			***REMOVED***
		***REMOVED***

		// ensure the last result properly reflects if fixes were done
		fixedResult.fixed = fixed;
		fixedResult.output = currentText;

		return fixedResult;
	***REMOVED***
***REMOVED***

module.exports = {
	Linter,

	/**
	 * Get the internal slots of a given Linter instance for tests.
	 * @param {Linter***REMOVED*** instance The Linter instance to get.
	 * @returns {LinterInternalSlots***REMOVED*** The internal slots.
	 */
	getLinterInternalSlots(instance) {
		return internalSlotsMap.get(instance);
	***REMOVED***,
***REMOVED***;
