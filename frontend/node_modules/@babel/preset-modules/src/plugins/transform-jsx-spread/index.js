import esutils from "esutils";

/**
 * Converts JSX Spread arguments into Object Spread, avoiding Babel's helper or Object.assign injection.
 * Input:
 * 	 <div a="1" {...b***REMOVED*** />
 * Output:
 *   <div {...{ a: "1", ...b ***REMOVED******REMOVED*** />
 * ...which Babel converts to:
 *   h("div", { a: "1", ...b ***REMOVED***)
 */
export default ({ types: t ***REMOVED***) => {
  // converts a set of JSXAttributes to an Object.assign() call
  function convertAttributesAssign(attributes) {
    const args = [];
    for (let i = 0, current; i < attributes.length; i++) {
      const node = attributes[i];
      if (t.isJSXSpreadAttribute(node)) {
        // the first attribute is a spread, avoid copying all other attributes onto it
        if (i === 0) {
          args.push(t.objectExpression([]));
        ***REMOVED***
        current = null;
        args.push(node.argument);
      ***REMOVED*** else {
        const name = getAttributeName(node);
        const value = getAttributeValue(node);
        if (!current) {
          current = t.objectExpression([]);
          args.push(current);
        ***REMOVED***
        current.properties.push(t.objectProperty(name, value));
      ***REMOVED***
    ***REMOVED***
    return t.callExpression(
      t.memberExpression(t.identifier("Object"), t.identifier("assign")),
      args
    );
  ***REMOVED***

  // Converts a JSXAttribute to the equivalent ObjectExpression property
  function convertAttributeSpread(node) {
    if (t.isJSXSpreadAttribute(node)) {
      return t.spreadElement(node.argument);
    ***REMOVED***

    const name = getAttributeName(node);
    const value = getAttributeValue(node);
    return t.inherits(t.objectProperty(name, value), node);
  ***REMOVED***

  // Convert a JSX attribute name to an Object expression property name
  function getAttributeName(node) {
    if (t.isJSXNamespacedName(node.name)) {
      return t.stringLiteral(
        node.name.namespace.name + ":" + node.name.name.name
      );
    ***REMOVED***
    if (esutils.keyword.isIdentifierNameES6(node.name.name)) {
      return t.identifier(node.name.name);
    ***REMOVED***
    return t.stringLiteral(node.name.name);
  ***REMOVED***

  // Convert a JSX attribute value to a JavaScript expression value
  function getAttributeValue(node) {
    let value = node.value || t.booleanLiteral(true);

    if (t.isJSXExpressionContainer(value)) {
      value = value.expression;
    ***REMOVED*** else if (t.isStringLiteral(value)) {
      value.value = value.value.replace(/\n\s+/g, " ");

      // "raw" JSXText should not be used from a StringLiteral because it needs to be escaped.
      if (value.extra && value.extra.raw) {
        delete value.extra.raw;
      ***REMOVED***
    ***REMOVED***

    return value;
  ***REMOVED***

  return {
    name: "transform-jsx-spread",
    visitor: {
      JSXOpeningElement(path, state) {
        const useSpread = state.opts.useSpread === true;
        const hasSpread = path.node.attributes.some(attr =>
          t.isJSXSpreadAttribute(attr)
        );

        // ignore JSX Elements without spread or with lone spread:
        if (!hasSpread || path.node.attributes.length === 1) return;

        if (useSpread) {
          path.node.attributes = [
            t.jsxSpreadAttribute(
              t.objectExpression(
                path.node.attributes.map(convertAttributeSpread)
              )
            ),
          ];
        ***REMOVED*** else {
          path.node.attributes = [
            t.jsxSpreadAttribute(convertAttributesAssign(path.node.attributes)),
          ];
        ***REMOVED***
      ***REMOVED***,
    ***REMOVED***,
  ***REMOVED***;
***REMOVED***;
