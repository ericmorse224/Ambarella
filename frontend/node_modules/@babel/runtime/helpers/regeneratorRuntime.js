var _typeof = require("./typeof.js")["default"];
function _regeneratorRuntime() {
  "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */
  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
    return r;
  ***REMOVED***, module.exports.__esModule = true, module.exports["default"] = module.exports;
  var t,
    r = {***REMOVED***,
    e = Object.prototype,
    n = e.hasOwnProperty,
    o = "function" == typeof Symbol ? Symbol : {***REMOVED***,
    i = o.iterator || "@@iterator",
    a = o.asyncIterator || "@@asyncIterator",
    u = o.toStringTag || "@@toStringTag";
  function c(t, r, e, n) {
    return Object.defineProperty(t, r, {
      value: e,
      enumerable: !n,
      configurable: !n,
      writable: !n
    ***REMOVED***);
  ***REMOVED***
  try {
    c({***REMOVED***, "");
  ***REMOVED*** catch (t) {
    c = function c(t, r, e) {
      return t[r] = e;
    ***REMOVED***;
  ***REMOVED***
  function h(r, e, n, o) {
    var i = e && e.prototype instanceof Generator ? e : Generator,
      a = Object.create(i.prototype);
    return c(a, "_invoke", function (r, e, n) {
      var o = 1;
      return function (i, a) {
        if (3 === o) throw Error("Generator is already running");
        if (4 === o) {
          if ("throw" === i) throw a;
          return {
            value: t,
            done: !0
          ***REMOVED***;
        ***REMOVED***
        for (n.method = i, n.arg = a;;) {
          var u = n.delegate;
          if (u) {
            var c = d(u, n);
            if (c) {
              if (c === f) continue;
              return c;
            ***REMOVED***
          ***REMOVED***
          if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
            if (1 === o) throw o = 4, n.arg;
            n.dispatchException(n.arg);
          ***REMOVED*** else "return" === n.method && n.abrupt("return", n.arg);
          o = 3;
          var h = s(r, e, n);
          if ("normal" === h.type) {
            if (o = n.done ? 4 : 2, h.arg === f) continue;
            return {
              value: h.arg,
              done: n.done
            ***REMOVED***;
          ***REMOVED***
          "throw" === h.type && (o = 4, n.method = "throw", n.arg = h.arg);
        ***REMOVED***
      ***REMOVED***;
    ***REMOVED***(r, n, new Context(o || [])), !0), a;
  ***REMOVED***
  function s(t, r, e) {
    try {
      return {
        type: "normal",
        arg: t.call(r, e)
      ***REMOVED***;
    ***REMOVED*** catch (t) {
      return {
        type: "throw",
        arg: t
      ***REMOVED***;
    ***REMOVED***
  ***REMOVED***
  r.wrap = h;
  var f = {***REMOVED***;
  function Generator() {***REMOVED***
  function GeneratorFunction() {***REMOVED***
  function GeneratorFunctionPrototype() {***REMOVED***
  var l = {***REMOVED***;
  c(l, i, function () {
    return this;
  ***REMOVED***);
  var p = Object.getPrototypeOf,
    y = p && p(p(x([])));
  y && y !== e && n.call(y, i) && (l = y);
  var v = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(l);
  function g(t) {
    ["next", "throw", "return"].forEach(function (r) {
      c(t, r, function (t) {
        return this._invoke(r, t);
      ***REMOVED***);
    ***REMOVED***);
  ***REMOVED***
  function AsyncIterator(t, r) {
    function e(o, i, a, u) {
      var c = s(t[o], t, i);
      if ("throw" !== c.type) {
        var h = c.arg,
          f = h.value;
        return f && "object" == _typeof(f) && n.call(f, "__await") ? r.resolve(f.__await).then(function (t) {
          e("next", t, a, u);
        ***REMOVED***, function (t) {
          e("throw", t, a, u);
        ***REMOVED***) : r.resolve(f).then(function (t) {
          h.value = t, a(h);
        ***REMOVED***, function (t) {
          return e("throw", t, a, u);
        ***REMOVED***);
      ***REMOVED***
      u(c.arg);
    ***REMOVED***
    var o;
    c(this, "_invoke", function (t, n) {
      function i() {
        return new r(function (r, o) {
          e(t, n, r, o);
        ***REMOVED***);
      ***REMOVED***
      return o = o ? o.then(i, i) : i();
    ***REMOVED***, !0);
  ***REMOVED***
  function d(r, e) {
    var n = e.method,
      o = r.i[n];
    if (o === t) return e.delegate = null, "throw" === n && r.i["return"] && (e.method = "return", e.arg = t, d(r, e), "throw" === e.method) || "return" !== n && (e.method = "throw", e.arg = new TypeError("The iterator does not provide a '" + n + "' method")), f;
    var i = s(o, r.i, e.arg);
    if ("throw" === i.type) return e.method = "throw", e.arg = i.arg, e.delegate = null, f;
    var a = i.arg;
    return a ? a.done ? (e[r.r] = a.value, e.next = r.n, "return" !== e.method && (e.method = "next", e.arg = t), e.delegate = null, f) : a : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, f);
  ***REMOVED***
  function w(t) {
    this.tryEntries.push(t);
  ***REMOVED***
  function m(r) {
    var e = r[4] || {***REMOVED***;
    e.type = "normal", e.arg = t, r[4] = e;
  ***REMOVED***
  function Context(t) {
    this.tryEntries = [[-1]], t.forEach(w, this), this.reset(!0);
  ***REMOVED***
  function x(r) {
    if (null != r) {
      var e = r[i];
      if (e) return e.call(r);
      if ("function" == typeof r.next) return r;
      if (!isNaN(r.length)) {
        var o = -1,
          a = function e() {
            for (; ++o < r.length;) if (n.call(r, o)) return e.value = r[o], e.done = !1, e;
            return e.value = t, e.done = !0, e;
          ***REMOVED***;
        return a.next = a;
      ***REMOVED***
    ***REMOVED***
    throw new TypeError(_typeof(r) + " is not iterable");
  ***REMOVED***
  return GeneratorFunction.prototype = GeneratorFunctionPrototype, c(v, "constructor", GeneratorFunctionPrototype), c(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = c(GeneratorFunctionPrototype, u, "GeneratorFunction"), r.isGeneratorFunction = function (t) {
    var r = "function" == typeof t && t.constructor;
    return !!r && (r === GeneratorFunction || "GeneratorFunction" === (r.displayName || r.name));
  ***REMOVED***, r.mark = function (t) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, c(t, u, "GeneratorFunction")), t.prototype = Object.create(v), t;
  ***REMOVED***, r.awrap = function (t) {
    return {
      __await: t
    ***REMOVED***;
  ***REMOVED***, g(AsyncIterator.prototype), c(AsyncIterator.prototype, a, function () {
    return this;
  ***REMOVED***), r.AsyncIterator = AsyncIterator, r.async = function (t, e, n, o, i) {
    void 0 === i && (i = Promise);
    var a = new AsyncIterator(h(t, e, n, o), i);
    return r.isGeneratorFunction(e) ? a : a.next().then(function (t) {
      return t.done ? t.value : a.next();
    ***REMOVED***);
  ***REMOVED***, g(v), c(v, u, "Generator"), c(v, i, function () {
    return this;
  ***REMOVED***), c(v, "toString", function () {
    return "[object Generator]";
  ***REMOVED***), r.keys = function (t) {
    var r = Object(t),
      e = [];
    for (var n in r) e.unshift(n);
    return function t() {
      for (; e.length;) if ((n = e.pop()) in r) return t.value = n, t.done = !1, t;
      return t.done = !0, t;
    ***REMOVED***;
  ***REMOVED***, r.values = x, Context.prototype = {
    constructor: Context,
    reset: function reset(r) {
      if (this.prev = this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(m), !r) for (var e in this) "t" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = t);
    ***REMOVED***,
    stop: function stop() {
      this.done = !0;
      var t = this.tryEntries[0][4];
      if ("throw" === t.type) throw t.arg;
      return this.rval;
    ***REMOVED***,
    dispatchException: function dispatchException(r) {
      if (this.done) throw r;
      var e = this;
      function n(t) {
        a.type = "throw", a.arg = r, e.next = t;
      ***REMOVED***
      for (var o = e.tryEntries.length - 1; o >= 0; --o) {
        var i = this.tryEntries[o],
          a = i[4],
          u = this.prev,
          c = i[1],
          h = i[2];
        if (-1 === i[0]) return n("end"), !1;
        if (!c && !h) throw Error("try statement without catch or finally");
        if (null != i[0] && i[0] <= u) {
          if (u < c) return this.method = "next", this.arg = t, n(c), !0;
          if (u < h) return n(h), !1;
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***,
    abrupt: function abrupt(t, r) {
      for (var e = this.tryEntries.length - 1; e >= 0; --e) {
        var n = this.tryEntries[e];
        if (n[0] > -1 && n[0] <= this.prev && this.prev < n[2]) {
          var o = n;
          break;
        ***REMOVED***
      ***REMOVED***
      o && ("break" === t || "continue" === t) && o[0] <= r && r <= o[2] && (o = null);
      var i = o ? o[4] : {***REMOVED***;
      return i.type = t, i.arg = r, o ? (this.method = "next", this.next = o[2], f) : this.complete(i);
    ***REMOVED***,
    complete: function complete(t, r) {
      if ("throw" === t.type) throw t.arg;
      return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && r && (this.next = r), f;
    ***REMOVED***,
    finish: function finish(t) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var e = this.tryEntries[r];
        if (e[2] === t) return this.complete(e[4], e[3]), m(e), f;
      ***REMOVED***
    ***REMOVED***,
    "catch": function _catch(t) {
      for (var r = this.tryEntries.length - 1; r >= 0; --r) {
        var e = this.tryEntries[r];
        if (e[0] === t) {
          var n = e[4];
          if ("throw" === n.type) {
            var o = n.arg;
            m(e);
          ***REMOVED***
          return o;
        ***REMOVED***
      ***REMOVED***
      throw Error("illegal catch attempt");
    ***REMOVED***,
    delegateYield: function delegateYield(r, e, n) {
      return this.delegate = {
        i: x(r),
        r: e,
        n: n
      ***REMOVED***, "next" === this.method && (this.arg = t), f;
    ***REMOVED***
  ***REMOVED***, r;
***REMOVED***
module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;