"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports._getTypeAnnotation = _getTypeAnnotation;
exports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
exports.couldBeBaseType = couldBeBaseType;
exports.getTypeAnnotation = getTypeAnnotation;
exports.isBaseType = isBaseType;
exports.isGenericType = isGenericType;
var inferers = require("./inferers.js");
var _t = require("@babel/types");
const {
  anyTypeAnnotation,
  isAnyTypeAnnotation,
  isArrayTypeAnnotation,
  isBooleanTypeAnnotation,
  isEmptyTypeAnnotation,
  isFlowBaseAnnotation,
  isGenericTypeAnnotation,
  isIdentifier,
  isMixedTypeAnnotation,
  isNumberTypeAnnotation,
  isStringTypeAnnotation,
  isTSArrayType,
  isTSTypeAnnotation,
  isTSTypeReference,
  isTupleTypeAnnotation,
  isTypeAnnotation,
  isUnionTypeAnnotation,
  isVoidTypeAnnotation,
  stringTypeAnnotation,
  voidTypeAnnotation
***REMOVED*** = _t;
function getTypeAnnotation() {
  let type = this.getData("typeAnnotation");
  if (type != null) {
    return type;
  ***REMOVED***
  type = _getTypeAnnotation.call(this) || anyTypeAnnotation();
  if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {
    type = type.typeAnnotation;
  ***REMOVED***
  this.setData("typeAnnotation", type);
  return type;
***REMOVED***
const typeAnnotationInferringNodes = new WeakSet();
function _getTypeAnnotation() {
  const node = this.node;
  if (!node) {
    if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
      const declar = this.parentPath.parentPath;
      const declarParent = declar.parentPath;
      if (declar.key === "left" && declarParent.isForInStatement()) {
        return stringTypeAnnotation();
      ***REMOVED***
      if (declar.key === "left" && declarParent.isForOfStatement()) {
        return anyTypeAnnotation();
      ***REMOVED***
      return voidTypeAnnotation();
    ***REMOVED*** else {
      return;
    ***REMOVED***
  ***REMOVED***
  if (node.typeAnnotation) {
    return node.typeAnnotation;
  ***REMOVED***
  if (typeAnnotationInferringNodes.has(node)) {
    return;
  ***REMOVED***
  typeAnnotationInferringNodes.add(node);
  try {
    var _inferer;
    let inferer = inferers[node.type];
    if (inferer) {
      return inferer.call(this, node);
    ***REMOVED***
    inferer = inferers[this.parentPath.type];
    if ((_inferer = inferer) != null && _inferer.validParent) {
      return this.parentPath.getTypeAnnotation();
    ***REMOVED***
  ***REMOVED*** finally {
    typeAnnotationInferringNodes.delete(node);
  ***REMOVED***
***REMOVED***
function isBaseType(baseName, soft) {
  return _isBaseType(baseName, this.getTypeAnnotation(), soft);
***REMOVED***
function _isBaseType(baseName, type, soft) {
  if (baseName === "string") {
    return isStringTypeAnnotation(type);
  ***REMOVED*** else if (baseName === "number") {
    return isNumberTypeAnnotation(type);
  ***REMOVED*** else if (baseName === "boolean") {
    return isBooleanTypeAnnotation(type);
  ***REMOVED*** else if (baseName === "any") {
    return isAnyTypeAnnotation(type);
  ***REMOVED*** else if (baseName === "mixed") {
    return isMixedTypeAnnotation(type);
  ***REMOVED*** else if (baseName === "empty") {
    return isEmptyTypeAnnotation(type);
  ***REMOVED*** else if (baseName === "void") {
    return isVoidTypeAnnotation(type);
  ***REMOVED*** else {
    if (soft) {
      return false;
    ***REMOVED*** else {
      throw new Error(`Unknown base type ${baseName***REMOVED***`);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
function couldBeBaseType(name) {
  const type = this.getTypeAnnotation();
  if (isAnyTypeAnnotation(type)) return true;
  if (isUnionTypeAnnotation(type)) {
    for (const type2 of type.types) {
      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {
        return true;
      ***REMOVED***
    ***REMOVED***
    return false;
  ***REMOVED*** else {
    return _isBaseType(name, type, true);
  ***REMOVED***
***REMOVED***
function baseTypeStrictlyMatches(rightArg) {
  const left = this.getTypeAnnotation();
  const right = rightArg.getTypeAnnotation();
  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
    return right.type === left.type;
  ***REMOVED***
  return false;
***REMOVED***
function isGenericType(genericName) {
  const type = this.getTypeAnnotation();
  if (genericName === "Array") {
    if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {
      return true;
    ***REMOVED***
  ***REMOVED***
  return isGenericTypeAnnotation(type) && isIdentifier(type.id, {
    name: genericName
  ***REMOVED***) || isTSTypeReference(type) && isIdentifier(type.typeName, {
    name: genericName
  ***REMOVED***);
***REMOVED***

//# sourceMappingURL=index.js.map
