/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { UsageState ***REMOVED*** = require("../ExportsInfo");
const {
	numberToIdentifier,
	NUMBER_OF_IDENTIFIER_START_CHARS,
	NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS
***REMOVED*** = require("../Template");
const { assignDeterministicIds ***REMOVED*** = require("../ids/IdHelpers");
const { compareSelect, compareStringsNumeric ***REMOVED*** = require("../util/comparators");

/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../ExportsInfo")***REMOVED*** ExportsInfo */
/** @typedef {import("../ExportsInfo").ExportInfo***REMOVED*** ExportInfo */

/**
 * @param {ExportsInfo***REMOVED*** exportsInfo exports info
 * @returns {boolean***REMOVED*** mangle is possible
 */
const canMangle = exportsInfo => {
	if (exportsInfo.otherExportsInfo.getUsed(undefined) !== UsageState.Unused)
		return false;
	let hasSomethingToMangle = false;
	for (const exportInfo of exportsInfo.exports) {
		if (exportInfo.canMangle === true) {
			hasSomethingToMangle = true;
		***REMOVED***
	***REMOVED***
	return hasSomethingToMangle;
***REMOVED***;

// Sort by name
const comparator = compareSelect(e => e.name, compareStringsNumeric);
/**
 * @param {boolean***REMOVED*** deterministic use deterministic names
 * @param {ExportsInfo***REMOVED*** exportsInfo exports info
 * @param {boolean | undefined***REMOVED*** isNamespace is namespace object
 * @returns {void***REMOVED***
 */
const mangleExportsInfo = (deterministic, exportsInfo, isNamespace) => {
	if (!canMangle(exportsInfo)) return;
	const usedNames = new Set();
	/** @type {ExportInfo[]***REMOVED*** */
	const mangleableExports = [];

	// Avoid to renamed exports that are not provided when
	// 1. it's not a namespace export: non-provided exports can be found in prototype chain
	// 2. there are other provided exports and deterministic mode is chosen:
	//    non-provided exports would break the determinism
	let avoidMangleNonProvided = !isNamespace;
	if (!avoidMangleNonProvided && deterministic) {
		for (const exportInfo of exportsInfo.ownedExports) {
			if (exportInfo.provided !== false) {
				avoidMangleNonProvided = true;
				break;
			***REMOVED***
		***REMOVED***
	***REMOVED***
	for (const exportInfo of exportsInfo.ownedExports) {
		const name = exportInfo.name;
		if (!exportInfo.hasUsedName()) {
			if (
				// Can the export be mangled?
				exportInfo.canMangle !== true ||
				// Never rename 1 char exports
				(name.length === 1 && /^[a-zA-Z0-9_$]/.test(name)) ||
				// Don't rename 2 char exports in deterministic mode
				(deterministic &&
					name.length === 2 &&
					/^[a-zA-Z_$][a-zA-Z0-9_$]|^[1-9][0-9]/.test(name)) ||
				// Don't rename exports that are not provided
				(avoidMangleNonProvided && exportInfo.provided !== true)
			) {
				exportInfo.setUsedName(name);
				usedNames.add(name);
			***REMOVED*** else {
				mangleableExports.push(exportInfo);
			***REMOVED***
		***REMOVED***
		if (exportInfo.exportsInfoOwned) {
			const used = exportInfo.getUsed(undefined);
			if (
				used === UsageState.OnlyPropertiesUsed ||
				used === UsageState.Unused
			) {
				mangleExportsInfo(
					deterministic,
					/** @type {ExportsInfo***REMOVED*** */ (exportInfo.exportsInfo),
					false
				);
			***REMOVED***
		***REMOVED***
	***REMOVED***
	if (deterministic) {
		assignDeterministicIds(
			mangleableExports,
			e => e.name,
			comparator,
			(e, id) => {
				const name = numberToIdentifier(id);
				const size = usedNames.size;
				usedNames.add(name);
				if (size === usedNames.size) return false;
				e.setUsedName(name);
				return true;
			***REMOVED***,
			[
				NUMBER_OF_IDENTIFIER_START_CHARS,
				NUMBER_OF_IDENTIFIER_START_CHARS *
					NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS
			],
			NUMBER_OF_IDENTIFIER_CONTINUATION_CHARS,
			usedNames.size
		);
	***REMOVED*** else {
		const usedExports = [];
		const unusedExports = [];
		for (const exportInfo of mangleableExports) {
			if (exportInfo.getUsed(undefined) === UsageState.Unused) {
				unusedExports.push(exportInfo);
			***REMOVED*** else {
				usedExports.push(exportInfo);
			***REMOVED***
		***REMOVED***
		usedExports.sort(comparator);
		unusedExports.sort(comparator);
		let i = 0;
		for (const list of [usedExports, unusedExports]) {
			for (const exportInfo of list) {
				let name;
				do {
					name = numberToIdentifier(i++);
				***REMOVED*** while (usedNames.has(name));
				exportInfo.setUsedName(name);
			***REMOVED***
		***REMOVED***
	***REMOVED***
***REMOVED***;

const PLUGIN_NAME = "MangleExportsPlugin";

class MangleExportsPlugin {
	/**
	 * @param {boolean***REMOVED*** deterministic use deterministic names
	 */
	constructor(deterministic) {
		this._deterministic = deterministic;
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		const { _deterministic: deterministic ***REMOVED*** = this;
		compiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {
			const moduleGraph = compilation.moduleGraph;
			compilation.hooks.optimizeCodeGeneration.tap(PLUGIN_NAME, modules => {
				if (compilation.moduleMemCaches) {
					throw new Error(
						"optimization.mangleExports can't be used with cacheUnaffected as export mangling is a global effect"
					);
				***REMOVED***
				for (const module of modules) {
					const isNamespace =
						module.buildMeta && module.buildMeta.exportsType === "namespace";
					const exportsInfo = moduleGraph.getExportsInfo(module);
					mangleExportsInfo(deterministic, exportsInfo, isNamespace);
				***REMOVED***
			***REMOVED***);
		***REMOVED***);
	***REMOVED***
***REMOVED***

module.exports = MangleExportsPlugin;
