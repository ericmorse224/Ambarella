function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; ***REMOVED***)), keys.push.apply(keys, symbols); ***REMOVED*** return keys; ***REMOVED***
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {***REMOVED***; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); ***REMOVED***) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); ***REMOVED***); ***REMOVED*** return target; ***REMOVED***
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true ***REMOVED***); ***REMOVED*** else { obj[key] = value; ***REMOVED*** return obj; ***REMOVED***
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); ***REMOVED***
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); ***REMOVED*** return (hint === "string" ? String : Number)(input); ***REMOVED***
// The error overlay is inspired (and mostly copied) from Create React App (https://github.com/facebookincubator/create-react-app)
// They, in turn, got inspired by webpack-hot-middleware (https://github.com/glenjamin/webpack-hot-middleware).

import ansiHTML from "ansi-html-community";
import { encode ***REMOVED*** from "html-entities";
import { listenToRuntimeError, listenToUnhandledRejection, parseErrorToStacks ***REMOVED*** from "./overlay/runtime-error.js";
import createOverlayMachine from "./overlay/state-machine.js";
import { containerStyle, dismissButtonStyle, headerStyle, iframeStyle, msgStyles, msgTextStyle, msgTypeStyle ***REMOVED*** from "./overlay/styles.js";
var colors = {
  reset: ["transparent", "transparent"],
  black: "181818",
  red: "E36049",
  green: "B3CB74",
  yellow: "FFD080",
  blue: "7CAFC2",
  magenta: "7FACCA",
  cyan: "C3C2EF",
  lightgrey: "EBE7E3",
  darkgrey: "6D7891"
***REMOVED***;
ansiHTML.setColors(colors);

/**
 * @param {string***REMOVED*** type
 * @param {string  | { file?: string, moduleName?: string, loc?: string, message?: string; stack?: string[] ***REMOVED******REMOVED*** item
 * @returns {{ header: string, body: string ***REMOVED******REMOVED***
 */
function formatProblem(type, item) {
  var header = type === "warning" ? "WARNING" : "ERROR";
  var body = "";
  if (typeof item === "string") {
    body += item;
  ***REMOVED*** else {
    var file = item.file || "";
    // eslint-disable-next-line no-nested-ternary
    var moduleName = item.moduleName ? item.moduleName.indexOf("!") !== -1 ? "".concat(item.moduleName.replace(/^(\s|\S)*!/, ""), " (").concat(item.moduleName, ")") : "".concat(item.moduleName) : "";
    var loc = item.loc;
    header += "".concat(moduleName || file ? " in ".concat(moduleName ? "".concat(moduleName).concat(file ? " (".concat(file, ")") : "") : file).concat(loc ? " ".concat(loc) : "") : "");
    body += item.message || "";
  ***REMOVED***
  if (Array.isArray(item.stack)) {
    item.stack.forEach(function (stack) {
      if (typeof stack === "string") {
        body += "\r\n".concat(stack);
      ***REMOVED***
    ***REMOVED***);
  ***REMOVED***
  return {
    header: header,
    body: body
  ***REMOVED***;
***REMOVED***

/**
 * @typedef {Object***REMOVED*** CreateOverlayOptions
 * @property {string | null***REMOVED*** trustedTypesPolicyName
 * @property {boolean | (error: Error) => void***REMOVED*** [catchRuntimeError]
 */

/**
 *
 * @param {CreateOverlayOptions***REMOVED*** options
 */
var createOverlay = function createOverlay(options) {
  /** @type {HTMLIFrameElement | null | undefined***REMOVED*** */
  var iframeContainerElement;
  /** @type {HTMLDivElement | null | undefined***REMOVED*** */
  var containerElement;
  /** @type {HTMLDivElement | null | undefined***REMOVED*** */
  var headerElement;
  /** @type {Array<(element: HTMLDivElement) => void>***REMOVED*** */
  var onLoadQueue = [];
  /** @type {TrustedTypePolicy | undefined***REMOVED*** */
  var overlayTrustedTypesPolicy;

  /**
   *
   * @param {HTMLElement***REMOVED*** element
   * @param {CSSStyleDeclaration***REMOVED*** style
   */
  function applyStyle(element, style) {
    Object.keys(style).forEach(function (prop) {
      element.style[prop] = style[prop];
    ***REMOVED***);
  ***REMOVED***

  /**
   * @param {string | null***REMOVED*** trustedTypesPolicyName
   */
  function createContainer(trustedTypesPolicyName) {
    // Enable Trusted Types if they are available in the current browser.
    if (window.trustedTypes) {
      overlayTrustedTypesPolicy = window.trustedTypes.createPolicy(trustedTypesPolicyName || "webpack-dev-server#overlay", {
        createHTML: function createHTML(value) {
          return value;
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***
    iframeContainerElement = document.createElement("iframe");
    iframeContainerElement.id = "webpack-dev-server-client-overlay";
    iframeContainerElement.src = "about:blank";
    applyStyle(iframeContainerElement, iframeStyle);
    iframeContainerElement.onload = function () {
      var contentElement = /** @type {Document***REMOVED*** */
      /** @type {HTMLIFrameElement***REMOVED*** */
      iframeContainerElement.contentDocument.createElement("div");
      containerElement = /** @type {Document***REMOVED*** */
      /** @type {HTMLIFrameElement***REMOVED*** */
      iframeContainerElement.contentDocument.createElement("div");
      contentElement.id = "webpack-dev-server-client-overlay-div";
      applyStyle(contentElement, containerStyle);
      headerElement = document.createElement("div");
      headerElement.innerText = "Compiled with problems:";
      applyStyle(headerElement, headerStyle);
      var closeButtonElement = document.createElement("button");
      applyStyle(closeButtonElement, dismissButtonStyle);
      closeButtonElement.innerText = "Ã—";
      closeButtonElement.ariaLabel = "Dismiss";
      closeButtonElement.addEventListener("click", function () {
        // eslint-disable-next-line no-use-before-define
        overlayService.send({
          type: "DISMISS"
        ***REMOVED***);
      ***REMOVED***);
      contentElement.appendChild(headerElement);
      contentElement.appendChild(closeButtonElement);
      contentElement.appendChild(containerElement);

      /** @type {Document***REMOVED*** */
      /** @type {HTMLIFrameElement***REMOVED*** */
      iframeContainerElement.contentDocument.body.appendChild(contentElement);
      onLoadQueue.forEach(function (onLoad) {
        onLoad( /** @type {HTMLDivElement***REMOVED*** */contentElement);
      ***REMOVED***);
      onLoadQueue = [];

      /** @type {HTMLIFrameElement***REMOVED*** */
      iframeContainerElement.onload = null;
    ***REMOVED***;
    document.body.appendChild(iframeContainerElement);
  ***REMOVED***

  /**
   * @param {(element: HTMLDivElement) => void***REMOVED*** callback
   * @param {string | null***REMOVED*** trustedTypesPolicyName
   */
  function ensureOverlayExists(callback, trustedTypesPolicyName) {
    if (containerElement) {
      containerElement.innerHTML = "";
      // Everything is ready, call the callback right away.
      callback(containerElement);
      return;
    ***REMOVED***
    onLoadQueue.push(callback);
    if (iframeContainerElement) {
      return;
    ***REMOVED***
    createContainer(trustedTypesPolicyName);
  ***REMOVED***

  // Successful compilation.
  function hide() {
    if (!iframeContainerElement) {
      return;
    ***REMOVED***

    // Clean up and reset internal state.
    document.body.removeChild(iframeContainerElement);
    iframeContainerElement = null;
    containerElement = null;
  ***REMOVED***

  // Compilation with errors (e.g. syntax error or missing modules).
  /**
   * @param {string***REMOVED*** type
   * @param {Array<string  | { moduleIdentifier?: string, moduleName?: string, loc?: string, message?: string ***REMOVED***>***REMOVED*** messages
   * @param {string | null***REMOVED*** trustedTypesPolicyName
   * @param {'build' | 'runtime'***REMOVED*** messageSource
   */
  function show(type, messages, trustedTypesPolicyName, messageSource) {
    ensureOverlayExists(function () {
      headerElement.innerText = messageSource === "runtime" ? "Uncaught runtime errors:" : "Compiled with problems:";
      messages.forEach(function (message) {
        var entryElement = document.createElement("div");
        var msgStyle = type === "warning" ? msgStyles.warning : msgStyles.error;
        applyStyle(entryElement, _objectSpread(_objectSpread({***REMOVED***, msgStyle), {***REMOVED***, {
          padding: "1rem 1rem 1.5rem 1rem"
        ***REMOVED***));
        var typeElement = document.createElement("div");
        var _formatProblem = formatProblem(type, message),
          header = _formatProblem.header,
          body = _formatProblem.body;
        typeElement.innerText = header;
        applyStyle(typeElement, msgTypeStyle);
        if (message.moduleIdentifier) {
          applyStyle(typeElement, {
            cursor: "pointer"
          ***REMOVED***);
          // element.dataset not supported in IE
          typeElement.setAttribute("data-can-open", true);
          typeElement.addEventListener("click", function () {
            fetch("/webpack-dev-server/open-editor?fileName=".concat(message.moduleIdentifier));
          ***REMOVED***);
        ***REMOVED***

        // Make it look similar to our terminal.
        var text = ansiHTML(encode(body));
        var messageTextNode = document.createElement("div");
        applyStyle(messageTextNode, msgTextStyle);
        messageTextNode.innerHTML = overlayTrustedTypesPolicy ? overlayTrustedTypesPolicy.createHTML(text) : text;
        entryElement.appendChild(typeElement);
        entryElement.appendChild(messageTextNode);

        /** @type {HTMLDivElement***REMOVED*** */
        containerElement.appendChild(entryElement);
      ***REMOVED***);
    ***REMOVED***, trustedTypesPolicyName);
  ***REMOVED***
  var overlayService = createOverlayMachine({
    showOverlay: function showOverlay(_ref) {
      var _ref$level = _ref.level,
        level = _ref$level === void 0 ? "error" : _ref$level,
        messages = _ref.messages,
        messageSource = _ref.messageSource;
      return show(level, messages, options.trustedTypesPolicyName, messageSource);
    ***REMOVED***,
    hideOverlay: hide
  ***REMOVED***);
  if (options.catchRuntimeError) {
    /**
     * @param {Error | undefined***REMOVED*** error
     * @param {string***REMOVED*** fallbackMessage
     */
    var handleError = function handleError(error, fallbackMessage) {
      var errorObject = error instanceof Error ? error : new Error(error || fallbackMessage);
      var shouldDisplay = typeof options.catchRuntimeError === "function" ? options.catchRuntimeError(errorObject) : true;
      if (shouldDisplay) {
        overlayService.send({
          type: "RUNTIME_ERROR",
          messages: [{
            message: errorObject.message,
            stack: parseErrorToStacks(errorObject)
          ***REMOVED***]
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***;
    listenToRuntimeError(function (errorEvent) {
      // error property may be empty in older browser like IE
      var error = errorEvent.error,
        message = errorEvent.message;
      if (!error && !message) {
        return;
      ***REMOVED***
      handleError(error, message);
    ***REMOVED***);
    listenToUnhandledRejection(function (promiseRejectionEvent) {
      var reason = promiseRejectionEvent.reason;
      handleError(reason, "Unknown promise rejection reason");
    ***REMOVED***);
  ***REMOVED***
  return overlayService;
***REMOVED***;
export { formatProblem, createOverlay ***REMOVED***;