/**
 * @fileoverview Comma style - enforces comma styles of two types: last and first
 * @author Vignesh Anand aka vegetableman
 * @deprecated in ESLint v8.53.0
 */

"use strict";

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		deprecated: {
			message: "Formatting rules are being moved out of ESLint core.",
			url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
			deprecatedSince: "8.53.0",
			availableUntil: "10.0.0",
			replacedBy: [
				{
					message:
						"ESLint Stylistic now maintains deprecated stylistic core rules.",
					url: "https://eslint.style/guide/migration",
					plugin: {
						name: "@stylistic/eslint-plugin-js",
						url: "https://eslint.style/packages/js",
					***REMOVED***,
					rule: {
						name: "comma-style",
						url: "https://eslint.style/rules/js/comma-style",
					***REMOVED***,
				***REMOVED***,
			],
		***REMOVED***,
		type: "layout",

		docs: {
			description: "Enforce consistent comma style",
			recommended: false,
			url: "https://eslint.org/docs/latest/rules/comma-style",
		***REMOVED***,

		fixable: "code",

		schema: [
			{
				enum: ["first", "last"],
			***REMOVED***,
			{
				type: "object",
				properties: {
					exceptions: {
						type: "object",
						additionalProperties: {
							type: "boolean",
						***REMOVED***,
					***REMOVED***,
				***REMOVED***,
				additionalProperties: false,
			***REMOVED***,
		],

		messages: {
			unexpectedLineBeforeAndAfterComma:
				"Bad line breaking before and after ','.",
			expectedCommaFirst: "',' should be placed first.",
			expectedCommaLast: "',' should be placed last.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const style = context.options[0] || "last",
			sourceCode = context.sourceCode;
		const exceptions = {
			ArrayPattern: true,
			ArrowFunctionExpression: true,
			CallExpression: true,
			FunctionDeclaration: true,
			FunctionExpression: true,
			ImportDeclaration: true,
			ObjectPattern: true,
			NewExpression: true,
		***REMOVED***;

		if (
			context.options.length === 2 &&
			Object.hasOwn(context.options[1], "exceptions")
		) {
			const keys = Object.keys(context.options[1].exceptions);

			for (let i = 0; i < keys.length; i++) {
				exceptions[keys[i]] = context.options[1].exceptions[keys[i]];
			***REMOVED***
		***REMOVED***

		//--------------------------------------------------------------------------
		// Helpers
		//--------------------------------------------------------------------------

		/**
		 * Modified text based on the style
		 * @param {string***REMOVED*** styleType Style type
		 * @param {string***REMOVED*** text Source code text
		 * @returns {string***REMOVED*** modified text
		 * @private
		 */
		function getReplacedText(styleType, text) {
			switch (styleType) {
				case "between":
					return `,${text.replace(astUtils.LINEBREAK_MATCHER, "")***REMOVED***`;

				case "first":
					return `${text***REMOVED***,`;

				case "last":
					return `,${text***REMOVED***`;

				default:
					return "";
			***REMOVED***
		***REMOVED***

		/**
		 * Determines the fixer function for a given style.
		 * @param {string***REMOVED*** styleType comma style
		 * @param {ASTNode***REMOVED*** previousItemToken The token to check.
		 * @param {ASTNode***REMOVED*** commaToken The token to check.
		 * @param {ASTNode***REMOVED*** currentItemToken The token to check.
		 * @returns {Function***REMOVED*** Fixer function
		 * @private
		 */
		function getFixerFunction(
			styleType,
			previousItemToken,
			commaToken,
			currentItemToken,
		) {
			const text =
				sourceCode.text.slice(
					previousItemToken.range[1],
					commaToken.range[0],
				) +
				sourceCode.text.slice(
					commaToken.range[1],
					currentItemToken.range[0],
				);
			const range = [
				previousItemToken.range[1],
				currentItemToken.range[0],
			];

			return function (fixer) {
				return fixer.replaceTextRange(
					range,
					getReplacedText(styleType, text),
				);
			***REMOVED***;
		***REMOVED***

		/**
		 * Validates the spacing around single items in lists.
		 * @param {Token***REMOVED*** previousItemToken The last token from the previous item.
		 * @param {Token***REMOVED*** commaToken The token representing the comma.
		 * @param {Token***REMOVED*** currentItemToken The first token of the current item.
		 * @param {Token***REMOVED*** reportItem The item to use when reporting an error.
		 * @returns {void***REMOVED***
		 * @private
		 */
		function validateCommaItemSpacing(
			previousItemToken,
			commaToken,
			currentItemToken,
			reportItem,
		) {
			// if single line
			if (
				astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&
				astUtils.isTokenOnSameLine(previousItemToken, commaToken)
			) {
				// do nothing.
			***REMOVED*** else if (
				!astUtils.isTokenOnSameLine(commaToken, currentItemToken) &&
				!astUtils.isTokenOnSameLine(previousItemToken, commaToken)
			) {
				const comment = sourceCode.getCommentsAfter(commaToken)[0];
				const styleType =
					comment &&
					comment.type === "Block" &&
					astUtils.isTokenOnSameLine(commaToken, comment)
						? style
						: "between";

				// lone comma
				context.report({
					node: reportItem,
					loc: commaToken.loc,
					messageId: "unexpectedLineBeforeAndAfterComma",
					fix: getFixerFunction(
						styleType,
						previousItemToken,
						commaToken,
						currentItemToken,
					),
				***REMOVED***);
			***REMOVED*** else if (
				style === "first" &&
				!astUtils.isTokenOnSameLine(commaToken, currentItemToken)
			) {
				context.report({
					node: reportItem,
					loc: commaToken.loc,
					messageId: "expectedCommaFirst",
					fix: getFixerFunction(
						style,
						previousItemToken,
						commaToken,
						currentItemToken,
					),
				***REMOVED***);
			***REMOVED*** else if (
				style === "last" &&
				astUtils.isTokenOnSameLine(commaToken, currentItemToken)
			) {
				context.report({
					node: reportItem,
					loc: commaToken.loc,
					messageId: "expectedCommaLast",
					fix: getFixerFunction(
						style,
						previousItemToken,
						commaToken,
						currentItemToken,
					),
				***REMOVED***);
			***REMOVED***
		***REMOVED***

		/**
		 * Checks the comma placement with regards to a declaration/property/element
		 * @param {ASTNode***REMOVED*** node The binary expression node to check
		 * @param {string***REMOVED*** property The property of the node containing child nodes.
		 * @private
		 * @returns {void***REMOVED***
		 */
		function validateComma(node, property) {
			const items = node[property],
				arrayLiteral =
					node.type === "ArrayExpression" ||
					node.type === "ArrayPattern";

			if (items.length > 1 || arrayLiteral) {
				// seed as opening [
				let previousItemToken = sourceCode.getFirstToken(node);

				items.forEach(item => {
					const commaToken = item
							? sourceCode.getTokenBefore(item)
							: previousItemToken,
						currentItemToken = item
							? sourceCode.getFirstToken(item)
							: sourceCode.getTokenAfter(commaToken),
						reportItem = item || currentItemToken;

					/*
					 * This works by comparing three token locations:
					 * - previousItemToken is the last token of the previous item
					 * - commaToken is the location of the comma before the current item
					 * - currentItemToken is the first token of the current item
					 *
					 * These values get switched around if item is undefined.
					 * previousItemToken will refer to the last token not belonging
					 * to the current item, which could be a comma or an opening
					 * square bracket. currentItemToken could be a comma.
					 *
					 * All comparisons are done based on these tokens directly, so
					 * they are always valid regardless of an undefined item.
					 */
					if (astUtils.isCommaToken(commaToken)) {
						validateCommaItemSpacing(
							previousItemToken,
							commaToken,
							currentItemToken,
							reportItem,
						);
					***REMOVED***

					if (item) {
						const tokenAfterItem = sourceCode.getTokenAfter(
							item,
							astUtils.isNotClosingParenToken,
						);

						previousItemToken = tokenAfterItem
							? sourceCode.getTokenBefore(tokenAfterItem)
							: sourceCode.ast.tokens.at(-1);
					***REMOVED*** else {
						previousItemToken = currentItemToken;
					***REMOVED***
				***REMOVED***);

				/*
				 * Special case for array literals that have empty last items, such
				 * as [ 1, 2, ]. These arrays only have two items show up in the
				 * AST, so we need to look at the token to verify that there's no
				 * dangling comma.
				 */
				if (arrayLiteral) {
					const lastToken = sourceCode.getLastToken(node),
						nextToLastToken = sourceCode.getTokenBefore(lastToken);

					if (astUtils.isCommaToken(nextToLastToken)) {
						validateCommaItemSpacing(
							sourceCode.getTokenBefore(nextToLastToken),
							nextToLastToken,
							lastToken,
							lastToken,
						);
					***REMOVED***
				***REMOVED***
			***REMOVED***
		***REMOVED***

		//--------------------------------------------------------------------------
		// Public
		//--------------------------------------------------------------------------

		const nodes = {***REMOVED***;

		if (!exceptions.VariableDeclaration) {
			nodes.VariableDeclaration = function (node) {
				validateComma(node, "declarations");
			***REMOVED***;
		***REMOVED***
		if (!exceptions.ObjectExpression) {
			nodes.ObjectExpression = function (node) {
				validateComma(node, "properties");
			***REMOVED***;
		***REMOVED***
		if (!exceptions.ObjectPattern) {
			nodes.ObjectPattern = function (node) {
				validateComma(node, "properties");
			***REMOVED***;
		***REMOVED***
		if (!exceptions.ArrayExpression) {
			nodes.ArrayExpression = function (node) {
				validateComma(node, "elements");
			***REMOVED***;
		***REMOVED***
		if (!exceptions.ArrayPattern) {
			nodes.ArrayPattern = function (node) {
				validateComma(node, "elements");
			***REMOVED***;
		***REMOVED***
		if (!exceptions.FunctionDeclaration) {
			nodes.FunctionDeclaration = function (node) {
				validateComma(node, "params");
			***REMOVED***;
		***REMOVED***
		if (!exceptions.FunctionExpression) {
			nodes.FunctionExpression = function (node) {
				validateComma(node, "params");
			***REMOVED***;
		***REMOVED***
		if (!exceptions.ArrowFunctionExpression) {
			nodes.ArrowFunctionExpression = function (node) {
				validateComma(node, "params");
			***REMOVED***;
		***REMOVED***
		if (!exceptions.CallExpression) {
			nodes.CallExpression = function (node) {
				validateComma(node, "arguments");
			***REMOVED***;
		***REMOVED***
		if (!exceptions.ImportDeclaration) {
			nodes.ImportDeclaration = function (node) {
				validateComma(node, "specifiers");
			***REMOVED***;
		***REMOVED***
		if (!exceptions.NewExpression) {
			nodes.NewExpression = function (node) {
				validateComma(node, "arguments");
			***REMOVED***;
		***REMOVED***

		return nodes;
	***REMOVED***,
***REMOVED***;
