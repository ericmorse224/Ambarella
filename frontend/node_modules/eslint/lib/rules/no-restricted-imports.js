/**
 * @fileoverview Restrict usage of specified node imports.
 * @author Guy Ellis
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

const ignore = require("ignore");

const arrayOfStringsOrObjects = {
    type: "array",
    items: {
        anyOf: [
            { type: "string" ***REMOVED***,
            {
                type: "object",
                properties: {
                    name: { type: "string" ***REMOVED***,
                    message: {
                        type: "string",
                        minLength: 1
                    ***REMOVED***,
                    importNames: {
                        type: "array",
                        items: {
                            type: "string"
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false,
                required: ["name"]
            ***REMOVED***
        ]
    ***REMOVED***,
    uniqueItems: true
***REMOVED***;

const arrayOfStringsOrObjectPatterns = {
    anyOf: [
        {
            type: "array",
            items: {
                type: "string"
            ***REMOVED***,
            uniqueItems: true
        ***REMOVED***,
        {
            type: "array",
            items: {
                type: "object",
                properties: {
                    group: {
                        type: "array",
                        items: {
                            type: "string"
                        ***REMOVED***,
                        minItems: 1,
                        uniqueItems: true
                    ***REMOVED***,
                    message: {
                        type: "string",
                        minLength: 1
                    ***REMOVED***
                ***REMOVED***,
                additionalProperties: false,
                required: ["group"]
            ***REMOVED***,
            uniqueItems: true
        ***REMOVED***
    ]
***REMOVED***;

module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "disallow specified modules when loaded by `import`",
            category: "ECMAScript 6",
            recommended: false,
            url: "https://eslint.org/docs/rules/no-restricted-imports"
        ***REMOVED***,

        messages: {
            path: "'{{importSource***REMOVED******REMOVED***' import is restricted from being used.",
            // eslint-disable-next-line eslint-plugin/report-message-format
            pathWithCustomMessage: "'{{importSource***REMOVED******REMOVED***' import is restricted from being used. {{customMessage***REMOVED******REMOVED***",

            patterns: "'{{importSource***REMOVED******REMOVED***' import is restricted from being used by a pattern.",
            // eslint-disable-next-line eslint-plugin/report-message-format
            patternWithCustomMessage: "'{{importSource***REMOVED******REMOVED***' import is restricted from being used by a pattern. {{customMessage***REMOVED******REMOVED***",

            everything: "* import is invalid because '{{importNames***REMOVED******REMOVED***' from '{{importSource***REMOVED******REMOVED***' is restricted.",
            // eslint-disable-next-line eslint-plugin/report-message-format
            everythingWithCustomMessage: "* import is invalid because '{{importNames***REMOVED******REMOVED***' from '{{importSource***REMOVED******REMOVED***' is restricted. {{customMessage***REMOVED******REMOVED***",

            importName: "'{{importName***REMOVED******REMOVED***' import from '{{importSource***REMOVED******REMOVED***' is restricted.",
            // eslint-disable-next-line eslint-plugin/report-message-format
            importNameWithCustomMessage: "'{{importName***REMOVED******REMOVED***' import from '{{importSource***REMOVED******REMOVED***' is restricted. {{customMessage***REMOVED******REMOVED***"
        ***REMOVED***,

        schema: {
            anyOf: [
                arrayOfStringsOrObjects,
                {
                    type: "array",
                    items: [{
                        type: "object",
                        properties: {
                            paths: arrayOfStringsOrObjects,
                            patterns: arrayOfStringsOrObjectPatterns
                        ***REMOVED***,
                        additionalProperties: false
                    ***REMOVED***],
                    additionalItems: false
                ***REMOVED***
            ]
        ***REMOVED***
    ***REMOVED***,

    create(context) {
        const sourceCode = context.getSourceCode();
        const options = Array.isArray(context.options) ? context.options : [];
        const isPathAndPatternsObject =
            typeof options[0] === "object" &&
            (Object.prototype.hasOwnProperty.call(options[0], "paths") || Object.prototype.hasOwnProperty.call(options[0], "patterns"));

        const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context.options) || [];
        const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {
            if (typeof importSource === "string") {
                memo[importSource] = { message: null ***REMOVED***;
            ***REMOVED*** else {
                memo[importSource.name] = {
                    message: importSource.message,
                    importNames: importSource.importNames
                ***REMOVED***;
            ***REMOVED***
            return memo;
        ***REMOVED***, {***REMOVED***);

        // Handle patterns too, either as strings or groups
        const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];
        const restrictedPatternGroups = restrictedPatterns.length > 0 && typeof restrictedPatterns[0] === "string"
            ? [{ matcher: ignore().add(restrictedPatterns) ***REMOVED***]
            : restrictedPatterns.map(({ group, message ***REMOVED***) => ({ matcher: ignore().add(group), customMessage: message ***REMOVED***));

        // if no imports are restricted we don"t need to check
        if (Object.keys(restrictedPaths).length === 0 && restrictedPatternGroups.length === 0) {
            return {***REMOVED***;
        ***REMOVED***

        /**
         * Report a restricted path.
         * @param {string***REMOVED*** importSource path of the import
         * @param {Map<string,Object[]>***REMOVED*** importNames Map of import names that are being imported
         * @param {node***REMOVED*** node representing the restricted path reference
         * @returns {void***REMOVED***
         * @private
         */
        function checkRestrictedPathAndReport(importSource, importNames, node) {
            if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {
                return;
            ***REMOVED***

            const customMessage = restrictedPathMessages[importSource].message;
            const restrictedImportNames = restrictedPathMessages[importSource].importNames;

            if (restrictedImportNames) {
                if (importNames.has("*")) {
                    const specifierData = importNames.get("*")[0];

                    context.report({
                        node,
                        messageId: customMessage ? "everythingWithCustomMessage" : "everything",
                        loc: specifierData.loc,
                        data: {
                            importSource,
                            importNames: restrictedImportNames,
                            customMessage
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***

                restrictedImportNames.forEach(importName => {
                    if (importNames.has(importName)) {
                        const specifiers = importNames.get(importName);

                        specifiers.forEach(specifier => {
                            context.report({
                                node,
                                messageId: customMessage ? "importNameWithCustomMessage" : "importName",
                                loc: specifier.loc,
                                data: {
                                    importSource,
                                    customMessage,
                                    importName
                                ***REMOVED***
                            ***REMOVED***);
                        ***REMOVED***);
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED*** else {
                context.report({
                    node,
                    messageId: customMessage ? "pathWithCustomMessage" : "path",
                    data: {
                        importSource,
                        customMessage
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Report a restricted path specifically for patterns.
         * @param {node***REMOVED*** node representing the restricted path reference
         * @param {Object***REMOVED*** group contains a Ignore instance for paths, and the customMessage to show if it fails
         * @returns {void***REMOVED***
         * @private
         */
        function reportPathForPatterns(node, group) {
            const importSource = node.source.value.trim();

            context.report({
                node,
                messageId: group.customMessage ? "patternWithCustomMessage" : "patterns",
                data: {
                    importSource,
                    customMessage: group.customMessage
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        /**
         * Check if the given importSource is restricted by a pattern.
         * @param {string***REMOVED*** importSource path of the import
         * @param {Object***REMOVED*** group contains a Ignore instance for paths, and the customMessage to show if it fails
         * @returns {boolean***REMOVED*** whether the variable is a restricted pattern or not
         * @private
         */
        function isRestrictedPattern(importSource, group) {
            return group.matcher.ignores(importSource);
        ***REMOVED***

        /**
         * Checks a node to see if any problems should be reported.
         * @param {ASTNode***REMOVED*** node The node to check.
         * @returns {void***REMOVED***
         * @private
         */
        function checkNode(node) {
            const importSource = node.source.value.trim();
            const importNames = new Map();

            if (node.type === "ExportAllDeclaration") {
                const starToken = sourceCode.getFirstToken(node, 1);

                importNames.set("*", [{ loc: starToken.loc ***REMOVED***]);
            ***REMOVED*** else if (node.specifiers) {
                for (const specifier of node.specifiers) {
                    let name;
                    const specifierData = { loc: specifier.loc ***REMOVED***;

                    if (specifier.type === "ImportDefaultSpecifier") {
                        name = "default";
                    ***REMOVED*** else if (specifier.type === "ImportNamespaceSpecifier") {
                        name = "*";
                    ***REMOVED*** else if (specifier.imported) {
                        name = specifier.imported.name;
                    ***REMOVED*** else if (specifier.local) {
                        name = specifier.local.name;
                    ***REMOVED***

                    if (name) {
                        if (importNames.has(name)) {
                            importNames.get(name).push(specifierData);
                        ***REMOVED*** else {
                            importNames.set(name, [specifierData]);
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***

            checkRestrictedPathAndReport(importSource, importNames, node);
            restrictedPatternGroups.forEach(group => {
                if (isRestrictedPattern(importSource, group)) {
                    reportPathForPatterns(node, group);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        return {
            ImportDeclaration: checkNode,
            ExportNamedDeclaration(node) {
                if (node.source) {
                    checkNode(node);
                ***REMOVED***
            ***REMOVED***,
            ExportAllDeclaration: checkNode
        ***REMOVED***;
    ***REMOVED***
***REMOVED***;
