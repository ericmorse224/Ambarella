const definitions = require("../src/definitions");
const flatMap = require("array.prototype.flatmap");
const {
  typeSignature,
  iterateProps,
  mapProps,
  filterProps,
  unique,
***REMOVED*** = require("./util");

const stdout = process.stdout;

const jsTypes = ["string", "number", "boolean"];

const quote = (value) => `"${value***REMOVED***"`;

function params(fields) {
  const optionalDefault = (field) =>
    field.default ? ` = ${field.default***REMOVED***` : "";
  return mapProps(fields)
    .map((field) => `${typeSignature(field)***REMOVED***${optionalDefault(field)***REMOVED***`)
    .join(",");
***REMOVED***

function assertParamType({ assertNodeType, array, name, type ***REMOVED***) {
  if (array) {
    // TODO - assert contents of array?
    return `assert(typeof ${name***REMOVED*** === "object" && typeof ${name***REMOVED***.length !== "undefined")\n`;
  ***REMOVED*** else {
    if (jsTypes.includes(type)) {
      return `assert(
          typeof ${name***REMOVED*** === "${type***REMOVED***",
          "Argument ${name***REMOVED*** must be of type ${type***REMOVED***, given: " + typeof ${name***REMOVED***
      )`;
    ***REMOVED***

    if (assertNodeType === true) {
      return `assert(
        ${name***REMOVED***.type === "${type***REMOVED***",
        "Argument ${name***REMOVED*** must be of type ${type***REMOVED***, given: " + ${name***REMOVED***.type
      )`;
    ***REMOVED***

    return "";
  ***REMOVED***
***REMOVED***

function assertParam(meta) {
  const paramAssertion = assertParamType(meta);

  if (paramAssertion === "") {
    return "";
  ***REMOVED***

  if (meta.maybe || meta.optional) {
    return `
      if (${meta.name***REMOVED*** !== null && ${meta.name***REMOVED*** !== undefined) {
        ${paramAssertion***REMOVED***;
      ***REMOVED***
    `;
  ***REMOVED*** else {
    return paramAssertion;
  ***REMOVED***
***REMOVED***

function assertParams(fields) {
  return mapProps(fields).map(assertParam).join("\n");
***REMOVED***

function buildObject(typeDef) {
  const optionalField = (meta) => {
    if (meta.array) {
      // omit optional array properties if the constructor function was supplied
      // with an empty array
      return `
        if (typeof ${meta.name***REMOVED*** !== "undefined" && ${meta.name***REMOVED***.length > 0) {
          node.${meta.name***REMOVED*** = ${meta.name***REMOVED***;
        ***REMOVED***
      `;
    ***REMOVED*** else if (meta.type === "Object") {
      // omit optional object properties if they have no keys
      return `
        if (typeof ${meta.name***REMOVED*** !== "undefined" && Object.keys(${meta.name***REMOVED***).length !== 0) {
          node.${meta.name***REMOVED*** = ${meta.name***REMOVED***;
        ***REMOVED***
      `;
    ***REMOVED*** else if (meta.type === "boolean") {
      // omit optional boolean properties if they are not true
      return `
        if (${meta.name***REMOVED*** === true) {
          node.${meta.name***REMOVED*** = true;
        ***REMOVED***
      `;
    ***REMOVED*** else {
      return `
        if (typeof ${meta.name***REMOVED*** !== "undefined") {
          node.${meta.name***REMOVED*** = ${meta.name***REMOVED***;
        ***REMOVED***
      `;
    ***REMOVED***
  ***REMOVED***;

  const fields = mapProps(typeDef.fields)
    .filter((f) => !f.optional && !f.constant)
    .map((f) => f.name);

  const constants = mapProps(typeDef.fields)
    .filter((f) => f.constant)
    .map((f) => `${f.name***REMOVED***: "${f.value***REMOVED***"`);

  return `
    const node: ${typeDef.flowTypeName || typeDef.name***REMOVED*** = {
      type: "${typeDef.name***REMOVED***",
      ${constants.concat(fields).join(",")***REMOVED***
    ***REMOVED***

    ${mapProps(typeDef.fields)
      .filter((f) => f.optional)
      .map(optionalField)
      .join("")***REMOVED***
  `;
***REMOVED***

function lowerCamelCase(name) {
  return name.substring(0, 1).toLowerCase() + name.substring(1);
***REMOVED***

function generate() {
  stdout.write(`
    // @flow

    // THIS FILE IS AUTOGENERATED
    // see scripts/generateNodeUtils.js

    import { assert ***REMOVED*** from "mamacro";

    function isTypeOf(t: string) {
      return (n: Node) => n.type === t;
    ***REMOVED***

    function assertTypeOf(t: string) {
      return (n: Node) => assert(n.type === t);
    ***REMOVED***
  `);

  // Node builders
  iterateProps(definitions, (typeDefinition) => {
    stdout.write(`
      export function ${lowerCamelCase(typeDefinition.name)***REMOVED*** (
        ${params(filterProps(typeDefinition.fields, (f) => !f.constant))***REMOVED***
      ): ${typeDefinition.name***REMOVED*** {

        ${assertParams(filterProps(typeDefinition.fields, (f) => !f.constant))***REMOVED***
        ${buildObject(typeDefinition)***REMOVED*** 

        return node;
      ***REMOVED***
    `);
  ***REMOVED***);

  // Node testers
  iterateProps(definitions, (typeDefinition) => {
    stdout.write(`
      export const is${typeDefinition.name***REMOVED***: ((n: Node) => boolean) =
        isTypeOf("${typeDefinition.name***REMOVED***");
    `);
  ***REMOVED***);

  // Node union type testers
  const unionTypes = unique(
    flatMap(
      mapProps(definitions).filter((d) => d.unionType),
      (d) => d.unionType
    )
  );
  unionTypes.forEach((unionType) => {
    stdout.write(
      `
      export const is${unionType***REMOVED*** = (node: Node): boolean => ` +
        mapProps(definitions)
          .filter((d) => d.unionType && d.unionType.includes(unionType))
          .map((d) => `is${d.name***REMOVED***(node) `)
          .join("||") +
        ";\n\n"
    );
  ***REMOVED***);

  // Node assertion
  iterateProps(definitions, (typeDefinition) => {
    stdout.write(`
      export const assert${typeDefinition.name***REMOVED***: ((n: Node) => void) =
        assertTypeOf("${typeDefinition.name***REMOVED***");
    `);
  ***REMOVED***);

  // a map from node type to its set of union types
  stdout.write(
    `
    export const unionTypesMap = {` +
      mapProps(definitions)
        .filter((d) => d.unionType)
        .map((t) => `"${t.name***REMOVED***": [${t.unionType.map(quote).join(",")***REMOVED***]\n`) +
      `***REMOVED***;
      `
  );

  // an array of all node and union types
  stdout.write(
    `
    export const nodeAndUnionTypes = [` +
      mapProps(definitions)
        .map((t) => `"${t.name***REMOVED***"`)
        .concat(unionTypes.map(quote))
        .join(",") +
      `];`
  );
***REMOVED***

generate();
