'use strict';

/**
 * Class representing an event.
 *
 * @private
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String***REMOVED*** type The name of the event
   * @param {Object***REMOVED*** target A reference to the target to which the event was
   *     dispatched
   */
  constructor(type, target) {
    this.target = target;
    this.type = type;
  ***REMOVED***
***REMOVED***

/**
 * Class representing a message event.
 *
 * @extends Event
 * @private
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {(String|Buffer|ArrayBuffer|Buffer[])***REMOVED*** data The received data
   * @param {WebSocket***REMOVED*** target A reference to the target to which the event was
   *     dispatched
   */
  constructor(data, target) {
    super('message', target);

    this.data = data;
  ***REMOVED***
***REMOVED***

/**
 * Class representing a close event.
 *
 * @extends Event
 * @private
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {Number***REMOVED*** code The status code explaining why the connection is being
   *     closed
   * @param {String***REMOVED*** reason A human-readable string explaining why the
   *     connection is closing
   * @param {WebSocket***REMOVED*** target A reference to the target to which the event was
   *     dispatched
   */
  constructor(code, reason, target) {
    super('close', target);

    this.wasClean = target._closeFrameReceived && target._closeFrameSent;
    this.reason = reason;
    this.code = code;
  ***REMOVED***
***REMOVED***

/**
 * Class representing an open event.
 *
 * @extends Event
 * @private
 */
class OpenEvent extends Event {
  /**
   * Create a new `OpenEvent`.
   *
   * @param {WebSocket***REMOVED*** target A reference to the target to which the event was
   *     dispatched
   */
  constructor(target) {
    super('open', target);
  ***REMOVED***
***REMOVED***

/**
 * Class representing an error event.
 *
 * @extends Event
 * @private
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {Object***REMOVED*** error The error that generated this event
   * @param {WebSocket***REMOVED*** target A reference to the target to which the event was
   *     dispatched
   */
  constructor(error, target) {
    super('error', target);

    this.message = error.message;
    this.error = error;
  ***REMOVED***
***REMOVED***

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String***REMOVED*** type A string representing the event type to listen for
   * @param {Function***REMOVED*** listener The listener to add
   * @param {Object***REMOVED*** [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean***REMOVED*** [options.once=false] A `Boolean`` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, listener, options) {
    if (typeof listener !== 'function') return;

    function onMessage(data) {
      listener.call(this, new MessageEvent(data, this));
    ***REMOVED***

    function onClose(code, message) {
      listener.call(this, new CloseEvent(code, message, this));
    ***REMOVED***

    function onError(error) {
      listener.call(this, new ErrorEvent(error, this));
    ***REMOVED***

    function onOpen() {
      listener.call(this, new OpenEvent(this));
    ***REMOVED***

    const method = options && options.once ? 'once' : 'on';

    if (type === 'message') {
      onMessage._listener = listener;
      this[method](type, onMessage);
    ***REMOVED*** else if (type === 'close') {
      onClose._listener = listener;
      this[method](type, onClose);
    ***REMOVED*** else if (type === 'error') {
      onError._listener = listener;
      this[method](type, onError);
    ***REMOVED*** else if (type === 'open') {
      onOpen._listener = listener;
      this[method](type, onOpen);
    ***REMOVED*** else {
      this[method](type, listener);
    ***REMOVED***
  ***REMOVED***,

  /**
   * Remove an event listener.
   *
   * @param {String***REMOVED*** type A string representing the event type to remove
   * @param {Function***REMOVED*** listener The listener to remove
   * @public
   */
  removeEventListener(type, listener) {
    const listeners = this.listeners(type);

    for (let i = 0; i < listeners.length; i++) {
      if (listeners[i] === listener || listeners[i]._listener === listener) {
        this.removeListener(type, listeners[i]);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***;

module.exports = EventTarget;
