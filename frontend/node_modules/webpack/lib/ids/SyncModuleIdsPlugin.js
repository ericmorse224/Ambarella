/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { WebpackError ***REMOVED*** = require("..");
const { getUsedModuleIdsAndModules ***REMOVED*** = require("./IdHelpers");

/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../util/fs").IntermediateFileSystem***REMOVED*** IntermediateFileSystem */

const plugin = "SyncModuleIdsPlugin";

/**
 * @typedef {object***REMOVED*** SyncModuleIdsPluginOptions
 * @property {string***REMOVED*** path path to file
 * @property {string=***REMOVED*** context context for module names
 * @property {((module: Module) => boolean)=***REMOVED*** test selector for modules
 * @property {"read" | "create" | "merge" | "update"=***REMOVED*** mode operation mode (defaults to merge)
 */

class SyncModuleIdsPlugin {
	/**
	 * @param {SyncModuleIdsPluginOptions***REMOVED*** options options
	 */
	constructor({ path, context, test, mode ***REMOVED***) {
		this._path = path;
		this._context = context;
		this._test = test || (() => true);
		const readAndWrite = !mode || mode === "merge" || mode === "update";
		this._read = readAndWrite || mode === "read";
		this._write = readAndWrite || mode === "create";
		this._prune = mode === "update";
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		/** @type {Map<string, string | number>***REMOVED*** */
		let data;
		let dataChanged = false;
		if (this._read) {
			compiler.hooks.readRecords.tapAsync(plugin, callback => {
				const fs =
					/** @type {IntermediateFileSystem***REMOVED*** */
					(compiler.intermediateFileSystem);
				fs.readFile(this._path, (err, buffer) => {
					if (err) {
						if (err.code !== "ENOENT") {
							return callback(err);
						***REMOVED***
						return callback();
					***REMOVED***
					const json = JSON.parse(/** @type {Buffer***REMOVED*** */ (buffer).toString());
					data = new Map();
					for (const key of Object.keys(json)) {
						data.set(key, json[key]);
					***REMOVED***
					dataChanged = false;
					return callback();
				***REMOVED***);
			***REMOVED***);
		***REMOVED***
		if (this._write) {
			compiler.hooks.emitRecords.tapAsync(plugin, callback => {
				if (!data || !dataChanged) return callback();
				/** @type {{[key: string]: string | number***REMOVED******REMOVED*** */
				const json = {***REMOVED***;
				const sorted = Array.from(data).sort(([a], [b]) => (a < b ? -1 : 1));
				for (const [key, value] of sorted) {
					json[key] = value;
				***REMOVED***
				const fs =
					/** @type {IntermediateFileSystem***REMOVED*** */
					(compiler.intermediateFileSystem);
				fs.writeFile(this._path, JSON.stringify(json), callback);
			***REMOVED***);
		***REMOVED***
		compiler.hooks.thisCompilation.tap(plugin, compilation => {
			const associatedObjectForCache = compiler.root;
			const context = this._context || compiler.context;
			if (this._read) {
				compilation.hooks.reviveModules.tap(plugin, (_1, _2) => {
					if (!data) return;
					const { chunkGraph ***REMOVED*** = compilation;
					const [usedIds, modules] = getUsedModuleIdsAndModules(
						compilation,
						this._test
					);
					for (const module of modules) {
						const name = module.libIdent({
							context,
							associatedObjectForCache
						***REMOVED***);
						if (!name) continue;
						const id = data.get(name);
						const idAsString = `${id***REMOVED***`;
						if (usedIds.has(idAsString)) {
							const err = new WebpackError(
								`SyncModuleIdsPlugin: Unable to restore id '${id***REMOVED***' from '${this._path***REMOVED***' as it's already used.`
							);
							err.module = module;
							compilation.errors.push(err);
						***REMOVED***
						chunkGraph.setModuleId(module, /** @type {string | number***REMOVED*** */ (id));
						usedIds.add(idAsString);
					***REMOVED***
				***REMOVED***);
			***REMOVED***
			if (this._write) {
				compilation.hooks.recordModules.tap(plugin, modules => {
					const { chunkGraph ***REMOVED*** = compilation;
					let oldData = data;
					if (!oldData) {
						oldData = data = new Map();
					***REMOVED*** else if (this._prune) {
						data = new Map();
					***REMOVED***
					for (const module of modules) {
						if (this._test(module)) {
							const name = module.libIdent({
								context,
								associatedObjectForCache
							***REMOVED***);
							if (!name) continue;
							const id = chunkGraph.getModuleId(module);
							if (id === null) continue;
							const oldId = oldData.get(name);
							if (oldId !== id) {
								dataChanged = true;
							***REMOVED*** else if (data === oldData) {
								continue;
							***REMOVED***
							data.set(name, id);
						***REMOVED***
					***REMOVED***
					if (data.size !== oldData.size) dataChanged = true;
				***REMOVED***);
			***REMOVED***
		***REMOVED***);
	***REMOVED***
***REMOVED***

module.exports = SyncModuleIdsPlugin;
