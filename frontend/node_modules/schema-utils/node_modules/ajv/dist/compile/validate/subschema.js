"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
const codegen_1 = require("../codegen");
const util_1 = require("../util");
function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef ***REMOVED***) {
    if (keyword !== undefined && schema !== undefined) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
    ***REMOVED***
    if (keyword !== undefined) {
        const sch = it.schema[keyword];
        return schemaProp === undefined
            ? {
                schema: sch,
                schemaPath: (0, codegen_1._) `${it.schemaPath***REMOVED***${(0, codegen_1.getProperty)(keyword)***REMOVED***`,
                errSchemaPath: `${it.errSchemaPath***REMOVED***/${keyword***REMOVED***`,
            ***REMOVED***
            : {
                schema: sch[schemaProp],
                schemaPath: (0, codegen_1._) `${it.schemaPath***REMOVED***${(0, codegen_1.getProperty)(keyword)***REMOVED***${(0, codegen_1.getProperty)(schemaProp)***REMOVED***`,
                errSchemaPath: `${it.errSchemaPath***REMOVED***/${keyword***REMOVED***/${(0, util_1.escapeFragment)(schemaProp)***REMOVED***`,
            ***REMOVED***;
    ***REMOVED***
    if (schema !== undefined) {
        if (schemaPath === undefined || errSchemaPath === undefined || topSchemaRef === undefined) {
            throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        ***REMOVED***
        return {
            schema,
            schemaPath,
            topSchemaRef,
            errSchemaPath,
        ***REMOVED***;
    ***REMOVED***
    throw new Error('either "keyword" or "schema" must be passed');
***REMOVED***
exports.getSubschema = getSubschema;
function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName ***REMOVED***) {
    if (data !== undefined && dataProp !== undefined) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
    ***REMOVED***
    const { gen ***REMOVED*** = it;
    if (dataProp !== undefined) {
        const { errorPath, dataPathArr, opts ***REMOVED*** = it;
        const nextData = gen.let("data", (0, codegen_1._) `${it.data***REMOVED***${(0, codegen_1.getProperty)(dataProp)***REMOVED***`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str) `${errorPath***REMOVED***${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)***REMOVED***`;
        subschema.parentDataProperty = (0, codegen_1._) `${dataProp***REMOVED***`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
    ***REMOVED***
    if (data !== undefined) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true); // replaceable if used once?
        dataContextProps(nextData);
        if (propertyName !== undefined)
            subschema.propertyName = propertyName;
        // TODO something is possibly wrong here with not changing parentDataProperty and not appending dataPathArr
    ***REMOVED***
    if (dataTypes)
        subschema.dataTypes = dataTypes;
    function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
    ***REMOVED***
***REMOVED***
exports.extendSubschemaData = extendSubschemaData;
function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors ***REMOVED***) {
    if (compositeRule !== undefined)
        subschema.compositeRule = compositeRule;
    if (createErrors !== undefined)
        subschema.createErrors = createErrors;
    if (allErrors !== undefined)
        subschema.allErrors = allErrors;
    subschema.jtdDiscriminator = jtdDiscriminator; // not inherited
    subschema.jtdMetadata = jtdMetadata; // not inherited
***REMOVED***
exports.extendSubschemaMode = extendSubschemaMode;
//# sourceMappingURL=subschema.js.map