"use strict";

class QueueItem {
  constructor(onLoad, onError, dependentItem) {
    this.onLoad = onLoad;
    this.onError = onError;
    this.data = null;
    this.error = null;
    this.dependentItem = dependentItem;
  ***REMOVED***
***REMOVED***

/**
 * AsyncResourceQueue is the queue in charge of run the async scripts
 * and notify when they finish.
 */
module.exports = class AsyncResourceQueue {
  constructor() {
    this.items = new Set();
    this.dependentItems = new Set();
  ***REMOVED***

  count() {
    return this.items.size + this.dependentItems.size;
  ***REMOVED***

  _notify() {
    if (this._listener) {
      this._listener();
    ***REMOVED***
  ***REMOVED***

  _check(item) {
    let promise;

    if (item.onError && item.error) {
      promise = item.onError(item.error);
    ***REMOVED*** else if (item.onLoad && item.data) {
      promise = item.onLoad(item.data);
    ***REMOVED***

    promise
      .then(() => {
        this.items.delete(item);
        this.dependentItems.delete(item);

        if (this.count() === 0) {
          this._notify();
        ***REMOVED***
      ***REMOVED***);
  ***REMOVED***

  setListener(listener) {
    this._listener = listener;
  ***REMOVED***

  push(request, onLoad, onError, dependentItem) {
    const q = this;

    const item = new QueueItem(onLoad, onError, dependentItem);

    q.items.add(item);

    return request
      .then(data => {
        item.data = data;

        if (dependentItem && !dependentItem.finished) {
          q.dependentItems.add(item);
          return q.items.delete(item);
        ***REMOVED***

        if (onLoad) {
          return q._check(item);
        ***REMOVED***

        q.items.delete(item);

        if (q.count() === 0) {
          q._notify();
        ***REMOVED***

        return null;
      ***REMOVED***)
      .catch(err => {
        item.error = err;

        if (dependentItem && !dependentItem.finished) {
          q.dependentItems.add(item);
          return q.items.delete(item);
        ***REMOVED***

        if (onError) {
          return q._check(item);
        ***REMOVED***

        q.items.delete(item);

        if (q.count() === 0) {
          q._notify();
        ***REMOVED***

        return null;
      ***REMOVED***);
  ***REMOVED***

  notifyItem(syncItem) {
    for (const item of this.dependentItems) {
      if (item.dependentItem === syncItem) {
        this._check(item);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
***REMOVED***;
