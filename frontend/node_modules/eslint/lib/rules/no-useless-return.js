/**
 * @fileoverview Disallow redundant return statements
 * @author Teddy Katz
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils"),
	FixTracker = require("./utils/fix-tracker");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Removes the given element from the array.
 * @param {Array***REMOVED*** array The source array to remove.
 * @param {any***REMOVED*** element The target item to remove.
 * @returns {void***REMOVED***
 */
function remove(array, element) {
	const index = array.indexOf(element);

	if (index !== -1) {
		array.splice(index, 1);
	***REMOVED***
***REMOVED***

/**
 * Checks whether it can remove the given return statement or not.
 * @param {ASTNode***REMOVED*** node The return statement node to check.
 * @returns {boolean***REMOVED*** `true` if the node is removable.
 */
function isRemovable(node) {
	return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);
***REMOVED***

/**
 * Checks whether the given return statement is in a `finally` block or not.
 * @param {ASTNode***REMOVED*** node The return statement node to check.
 * @returns {boolean***REMOVED*** `true` if the node is in a `finally` block.
 */
function isInFinally(node) {
	for (
		let currentNode = node;
		currentNode && currentNode.parent && !astUtils.isFunction(currentNode);
		currentNode = currentNode.parent
	) {
		if (
			currentNode.parent.type === "TryStatement" &&
			currentNode.parent.finalizer === currentNode
		) {
			return true;
		***REMOVED***
	***REMOVED***

	return false;
***REMOVED***

/**
 * Checks all segments in a set and returns true if any are reachable.
 * @param {Set<CodePathSegment>***REMOVED*** segments The segments to check.
 * @returns {boolean***REMOVED*** True if any segment is reachable; false otherwise.
 */
function isAnySegmentReachable(segments) {
	for (const segment of segments) {
		if (segment.reachable) {
			return true;
		***REMOVED***
	***REMOVED***

	return false;
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "suggestion",

		docs: {
			description: "Disallow redundant return statements",
			recommended: false,
			url: "https://eslint.org/docs/latest/rules/no-useless-return",
		***REMOVED***,

		fixable: "code",
		schema: [],

		messages: {
			unnecessaryReturn: "Unnecessary return statement.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const segmentInfoMap = new WeakMap();
		const sourceCode = context.sourceCode;
		let scopeInfo = null;

		/**
		 * Checks whether the given segment is terminated by a return statement or not.
		 * @param {CodePathSegment***REMOVED*** segment The segment to check.
		 * @returns {boolean***REMOVED*** `true` if the segment is terminated by a return statement, or if it's still a part of unreachable.
		 */
		function isReturned(segment) {
			const info = segmentInfoMap.get(segment);

			return !info || info.returned;
		***REMOVED***

		/**
		 * Collects useless return statements from the given previous segments.
		 *
		 * A previous segment may be an unreachable segment.
		 * In that case, the information object of the unreachable segment is not
		 * initialized because `onCodePathSegmentStart` event is not notified for
		 * unreachable segments.
		 * This goes to the previous segments of the unreachable segment recursively
		 * if the unreachable segment was generated by a return statement. Otherwise,
		 * this ignores the unreachable segment.
		 *
		 * This behavior would simulate code paths for the case that the return
		 * statement does not exist.
		 * @param {ASTNode[]***REMOVED*** uselessReturns The collected return statements.
		 * @param {CodePathSegment[]***REMOVED*** prevSegments The previous segments to traverse.
		 * @param {WeakSet<CodePathSegment>***REMOVED*** [providedTraversedSegments] A set of segments that have already been traversed in this call
		 * @returns {ASTNode[]***REMOVED*** `uselessReturns`.
		 */
		function getUselessReturns(
			uselessReturns,
			prevSegments,
			providedTraversedSegments,
		) {
			const traversedSegments =
				providedTraversedSegments || new WeakSet();

			for (const segment of prevSegments) {
				if (!segment.reachable) {
					if (!traversedSegments.has(segment)) {
						traversedSegments.add(segment);
						getUselessReturns(
							uselessReturns,
							segment.allPrevSegments.filter(isReturned),
							traversedSegments,
						);
					***REMOVED***
					continue;
				***REMOVED***

				if (segmentInfoMap.has(segment)) {
					uselessReturns.push(
						...segmentInfoMap.get(segment).uselessReturns,
					);
				***REMOVED***
			***REMOVED***

			return uselessReturns;
		***REMOVED***

		/**
		 * Removes the return statements on the given segment from the useless return
		 * statement list.
		 *
		 * This segment may be an unreachable segment.
		 * In that case, the information object of the unreachable segment is not
		 * initialized because `onCodePathSegmentStart` event is not notified for
		 * unreachable segments.
		 * This goes to the previous segments of the unreachable segment recursively
		 * if the unreachable segment was generated by a return statement. Otherwise,
		 * this ignores the unreachable segment.
		 *
		 * This behavior would simulate code paths for the case that the return
		 * statement does not exist.
		 * @param {CodePathSegment***REMOVED*** segment The segment to get return statements.
		 * @param {Set<CodePathSegment>***REMOVED*** usedUnreachableSegments A set of segments that have already been traversed in this call.
		 * @returns {void***REMOVED***
		 */
		function markReturnStatementsOnSegmentAsUsed(
			segment,
			usedUnreachableSegments,
		) {
			if (!segment.reachable) {
				usedUnreachableSegments.add(segment);
				segment.allPrevSegments
					.filter(isReturned)
					.filter(
						prevSegment =>
							!usedUnreachableSegments.has(prevSegment),
					)
					.forEach(prevSegment =>
						markReturnStatementsOnSegmentAsUsed(
							prevSegment,
							usedUnreachableSegments,
						),
					);
				return;
			***REMOVED***

			const info = segmentInfoMap.get(segment);

			if (!info) {
				return;
			***REMOVED***

			info.uselessReturns = info.uselessReturns.filter(node => {
				if (
					scopeInfo.traversedTryBlockStatements &&
					scopeInfo.traversedTryBlockStatements.length > 0
				) {
					const returnInitialRange = node.range[0];
					const returnFinalRange = node.range[1];

					const areBlocksInRange =
						scopeInfo.traversedTryBlockStatements.some(
							tryBlockStatement => {
								const blockInitialRange =
									tryBlockStatement.range[0];
								const blockFinalRange =
									tryBlockStatement.range[1];

								return (
									returnInitialRange >= blockInitialRange &&
									returnFinalRange <= blockFinalRange
								);
							***REMOVED***,
						);

					if (areBlocksInRange) {
						return true;
					***REMOVED***
				***REMOVED***

				remove(scopeInfo.uselessReturns, node);
				return false;
			***REMOVED***);
		***REMOVED***

		/**
		 * Removes the return statements on the current segments from the useless
		 * return statement list.
		 *
		 * This function will be called at every statement except FunctionDeclaration,
		 * BlockStatement, and BreakStatement.
		 *
		 * - FunctionDeclarations are always executed whether it's returned or not.
		 * - BlockStatements do nothing.
		 * - BreakStatements go the next merely.
		 * @returns {void***REMOVED***
		 */
		function markReturnStatementsOnCurrentSegmentsAsUsed() {
			scopeInfo.currentSegments.forEach(segment =>
				markReturnStatementsOnSegmentAsUsed(segment, new Set()),
			);
		***REMOVED***

		//----------------------------------------------------------------------
		// Public
		//----------------------------------------------------------------------

		return {
			// Makes and pushes a new scope information.
			onCodePathStart(codePath) {
				scopeInfo = {
					upper: scopeInfo,
					uselessReturns: [],
					traversedTryBlockStatements: [],
					codePath,
					currentSegments: new Set(),
				***REMOVED***;
			***REMOVED***,

			// Reports useless return statements if exist.
			onCodePathEnd() {
				for (const node of scopeInfo.uselessReturns) {
					context.report({
						node,
						loc: node.loc,
						messageId: "unnecessaryReturn",
						fix(fixer) {
							if (
								isRemovable(node) &&
								!sourceCode.getCommentsInside(node).length
							) {
								/*
								 * Extend the replacement range to include the
								 * entire function to avoid conflicting with
								 * no-else-return.
								 * https://github.com/eslint/eslint/issues/8026
								 */
								return new FixTracker(fixer, sourceCode)
									.retainEnclosingFunction(node)
									.remove(node);
							***REMOVED***
							return null;
						***REMOVED***,
					***REMOVED***);
				***REMOVED***

				scopeInfo = scopeInfo.upper;
			***REMOVED***,

			/*
			 * Initializes segments.
			 * NOTE: This event is notified for only reachable segments.
			 */
			onCodePathSegmentStart(segment) {
				scopeInfo.currentSegments.add(segment);

				const info = {
					uselessReturns: getUselessReturns(
						[],
						segment.allPrevSegments,
					),
					returned: false,
				***REMOVED***;

				// Stores the info.
				segmentInfoMap.set(segment, info);
			***REMOVED***,

			onUnreachableCodePathSegmentStart(segment) {
				scopeInfo.currentSegments.add(segment);
			***REMOVED***,

			onUnreachableCodePathSegmentEnd(segment) {
				scopeInfo.currentSegments.delete(segment);
			***REMOVED***,

			onCodePathSegmentEnd(segment) {
				scopeInfo.currentSegments.delete(segment);
			***REMOVED***,

			// Adds ReturnStatement node to check whether it's useless or not.
			ReturnStatement(node) {
				if (node.argument) {
					markReturnStatementsOnCurrentSegmentsAsUsed();
				***REMOVED***
				if (
					node.argument ||
					astUtils.isInLoop(node) ||
					isInFinally(node) ||
					// Ignore `return` statements in unreachable places (https://github.com/eslint/eslint/issues/11647).
					!isAnySegmentReachable(scopeInfo.currentSegments)
				) {
					return;
				***REMOVED***

				for (const segment of scopeInfo.currentSegments) {
					const info = segmentInfoMap.get(segment);

					if (info) {
						info.uselessReturns.push(node);
						info.returned = true;
					***REMOVED***
				***REMOVED***
				scopeInfo.uselessReturns.push(node);
			***REMOVED***,

			"TryStatement > BlockStatement.block:exit"(node) {
				scopeInfo.traversedTryBlockStatements.push(node);
			***REMOVED***,

			"TryStatement:exit"() {
				scopeInfo.traversedTryBlockStatements.pop();
			***REMOVED***,

			/*
			 * Registers for all statement nodes except FunctionDeclaration, BlockStatement, BreakStatement.
			 * Removes return statements of the current segments from the useless return statement list.
			 */
			ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
			ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
			ExportDefaultDeclaration:
				markReturnStatementsOnCurrentSegmentsAsUsed,
			ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
