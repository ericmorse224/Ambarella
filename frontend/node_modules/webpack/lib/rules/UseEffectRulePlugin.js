/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const util = require("util");

/** @typedef {import("../../declarations/WebpackOptions").Falsy***REMOVED*** Falsy */
/** @typedef {import("../../declarations/WebpackOptions").RuleSetLoader***REMOVED*** RuleSetLoader */
/** @typedef {import("../../declarations/WebpackOptions").RuleSetLoaderOptions***REMOVED*** RuleSetLoaderOptions */
/** @typedef {import("../../declarations/WebpackOptions").RuleSetRule***REMOVED*** RuleSetRule */
/** @typedef {import("../../declarations/WebpackOptions").RuleSetUse***REMOVED*** RuleSetUse */
/** @typedef {import("../../declarations/WebpackOptions").RuleSetUseItem***REMOVED*** RuleSetUseItem */
/** @typedef {import("./RuleSetCompiler")***REMOVED*** RuleSetCompiler */
/** @typedef {import("./RuleSetCompiler").Effect***REMOVED*** Effect */
/** @typedef {import("./RuleSetCompiler").EffectData***REMOVED*** EffectData */

class UseEffectRulePlugin {
	/**
	 * @param {RuleSetCompiler***REMOVED*** ruleSetCompiler the rule set compiler
	 * @returns {void***REMOVED***
	 */
	apply(ruleSetCompiler) {
		ruleSetCompiler.hooks.rule.tap(
			"UseEffectRulePlugin",
			(path, rule, unhandledProperties, result, references) => {
				/**
				 * @param {keyof RuleSetRule***REMOVED*** property property
				 * @param {string***REMOVED*** correctProperty correct property
				 */
				const conflictWith = (property, correctProperty) => {
					if (unhandledProperties.has(property)) {
						throw ruleSetCompiler.error(
							`${path***REMOVED***.${property***REMOVED***`,
							rule[property],
							`A Rule must not have a '${property***REMOVED***' property when it has a '${correctProperty***REMOVED***' property`
						);
					***REMOVED***
				***REMOVED***;

				if (unhandledProperties.has("use")) {
					unhandledProperties.delete("use");
					unhandledProperties.delete("enforce");

					conflictWith("loader", "use");
					conflictWith("options", "use");

					const use = /** @type {RuleSetUse***REMOVED*** */ (rule.use);
					const enforce = rule.enforce;

					const type = enforce ? `use-${enforce***REMOVED***` : "use";

					/**
					 * @param {string***REMOVED*** path options path
					 * @param {string***REMOVED*** defaultIdent default ident when none is provided
					 * @param {RuleSetUseItem***REMOVED*** item user provided use value
					 * @returns {(Effect | ((effectData: EffectData) => Effect[]))***REMOVED*** effect
					 */
					const useToEffect = (path, defaultIdent, item) => {
						if (typeof item === "function") {
							return data =>
								useToEffectsWithoutIdent(
									path,
									/** @type {RuleSetUseItem | RuleSetUseItem[]***REMOVED*** */
									(item(data))
								);
						***REMOVED***
						return useToEffectRaw(path, defaultIdent, item);
					***REMOVED***;

					/**
					 * @param {string***REMOVED*** path options path
					 * @param {string***REMOVED*** defaultIdent default ident when none is provided
					 * @param {Exclude<NonNullable<RuleSetUseItem>, EXPECTED_FUNCTION>***REMOVED*** item user provided use value
					 * @returns {Effect***REMOVED*** effect
					 */
					const useToEffectRaw = (path, defaultIdent, item) => {
						if (typeof item === "string") {
							return {
								type,
								value: {
									loader: item,
									options: undefined,
									ident: undefined
								***REMOVED***
							***REMOVED***;
						***REMOVED***
						const loader = item.loader;
						const options = item.options;
						let ident = item.ident;
						if (options && typeof options === "object") {
							if (!ident) ident = defaultIdent;
							references.set(ident, options);
						***REMOVED***
						if (typeof options === "string") {
							util.deprecate(
								() => {***REMOVED***,
								`Using a string as loader options is deprecated (${path***REMOVED***.options)`,
								"DEP_WEBPACK_RULE_LOADER_OPTIONS_STRING"
							)();
						***REMOVED***
						return {
							type: enforce ? `use-${enforce***REMOVED***` : "use",
							value: {
								loader,
								options,
								ident
							***REMOVED***
						***REMOVED***;
					***REMOVED***;

					/**
					 * @param {string***REMOVED*** path options path
					 * @param {RuleSetUseItem | (Falsy | RuleSetUseItem)[]***REMOVED*** items user provided use value
					 * @returns {Effect[]***REMOVED*** effects
					 */
					const useToEffectsWithoutIdent = (path, items) => {
						if (Array.isArray(items)) {
							return items.filter(Boolean).map((item, idx) =>
								useToEffectRaw(
									`${path***REMOVED***[${idx***REMOVED***]`,
									"[[missing ident]]",
									/** @type {Exclude<RuleSetUseItem, EXPECTED_FUNCTION>***REMOVED*** */
									(item)
								)
							);
						***REMOVED***
						return [
							useToEffectRaw(
								path,
								"[[missing ident]]",
								/** @type {Exclude<RuleSetUseItem, EXPECTED_FUNCTION>***REMOVED*** */
								(items)
							)
						];
					***REMOVED***;

					/**
					 * @param {string***REMOVED*** path current path
					 * @param {RuleSetUse***REMOVED*** items user provided use value
					 * @returns {(Effect | ((effectData: EffectData) => Effect[]))[]***REMOVED*** effects
					 */
					const useToEffects = (path, items) => {
						if (Array.isArray(items)) {
							return items.filter(Boolean).map((item, idx) => {
								const subPath = `${path***REMOVED***[${idx***REMOVED***]`;
								return useToEffect(
									subPath,
									subPath,
									/** @type {RuleSetUseItem***REMOVED*** */
									(item)
								);
							***REMOVED***);
						***REMOVED***
						return [
							useToEffect(path, path, /** @type {RuleSetUseItem***REMOVED*** */ (items))
						];
					***REMOVED***;

					if (typeof use === "function") {
						result.effects.push(data =>
							useToEffectsWithoutIdent(`${path***REMOVED***.use`, use(data))
						);
					***REMOVED*** else {
						for (const effect of useToEffects(`${path***REMOVED***.use`, use)) {
							result.effects.push(effect);
						***REMOVED***
					***REMOVED***
				***REMOVED***

				if (unhandledProperties.has("loader")) {
					unhandledProperties.delete("loader");
					unhandledProperties.delete("options");
					unhandledProperties.delete("enforce");

					const loader = /** @type {RuleSetLoader***REMOVED*** */ (rule.loader);
					const options = rule.options;
					const enforce = rule.enforce;

					if (loader.includes("!")) {
						throw ruleSetCompiler.error(
							`${path***REMOVED***.loader`,
							loader,
							"Exclamation mark separated loader lists has been removed in favor of the 'use' property with arrays"
						);
					***REMOVED***

					if (loader.includes("?")) {
						throw ruleSetCompiler.error(
							`${path***REMOVED***.loader`,
							loader,
							"Query arguments on 'loader' has been removed in favor of the 'options' property"
						);
					***REMOVED***

					if (typeof options === "string") {
						util.deprecate(
							() => {***REMOVED***,
							`Using a string as loader options is deprecated (${path***REMOVED***.options)`,
							"DEP_WEBPACK_RULE_LOADER_OPTIONS_STRING"
						)();
					***REMOVED***

					const ident =
						options && typeof options === "object" ? path : undefined;
					references.set(
						/** @type {TODO***REMOVED*** */
						(ident),
						/** @type {RuleSetLoaderOptions***REMOVED*** */
						(options)
					);
					result.effects.push({
						type: enforce ? `use-${enforce***REMOVED***` : "use",
						value: {
							loader,
							options,
							ident
						***REMOVED***
					***REMOVED***);
				***REMOVED***
			***REMOVED***
		);
	***REMOVED***
***REMOVED***

module.exports = UseEffectRulePlugin;
