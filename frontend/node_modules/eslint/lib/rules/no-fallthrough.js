/**
 * @fileoverview Rule to flag fall-through cases in switch statements.
 * @author Matt DuVall <http://mattduvall.com/>
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const { directivesPattern ***REMOVED*** = require("../shared/directives");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const DEFAULT_FALLTHROUGH_COMMENT = /falls?\s?through/iu;

/**
 * Checks all segments in a set and returns true if any are reachable.
 * @param {Set<CodePathSegment>***REMOVED*** segments The segments to check.
 * @returns {boolean***REMOVED*** True if any segment is reachable; false otherwise.
 */
function isAnySegmentReachable(segments) {
	for (const segment of segments) {
		if (segment.reachable) {
			return true;
		***REMOVED***
	***REMOVED***

	return false;
***REMOVED***

/**
 * Checks whether or not a given comment string is really a fallthrough comment and not an ESLint directive.
 * @param {string***REMOVED*** comment The comment string to check.
 * @param {RegExp***REMOVED*** fallthroughCommentPattern The regular expression used for checking for fallthrough comments.
 * @returns {boolean***REMOVED*** `true` if the comment string is truly a fallthrough comment.
 */
function isFallThroughComment(comment, fallthroughCommentPattern) {
	return (
		fallthroughCommentPattern.test(comment) &&
		!directivesPattern.test(comment.trim())
	);
***REMOVED***

/**
 * Checks whether or not a given case has a fallthrough comment.
 * @param {ASTNode***REMOVED*** caseWhichFallsThrough SwitchCase node which falls through.
 * @param {ASTNode***REMOVED*** subsequentCase The case after caseWhichFallsThrough.
 * @param {RuleContext***REMOVED*** context A rule context which stores comments.
 * @param {RegExp***REMOVED*** fallthroughCommentPattern A pattern to match comment to.
 * @returns {null | object***REMOVED*** the comment if the case has a valid fallthrough comment, otherwise null
 */
function getFallthroughComment(
	caseWhichFallsThrough,
	subsequentCase,
	context,
	fallthroughCommentPattern,
) {
	const sourceCode = context.sourceCode;

	if (
		caseWhichFallsThrough.consequent.length === 1 &&
		caseWhichFallsThrough.consequent[0].type === "BlockStatement"
	) {
		const trailingCloseBrace = sourceCode.getLastToken(
			caseWhichFallsThrough.consequent[0],
		);
		const commentInBlock = sourceCode
			.getCommentsBefore(trailingCloseBrace)
			.pop();

		if (
			commentInBlock &&
			isFallThroughComment(
				commentInBlock.value,
				fallthroughCommentPattern,
			)
		) {
			return commentInBlock;
		***REMOVED***
	***REMOVED***

	const comment = sourceCode.getCommentsBefore(subsequentCase).pop();

	if (
		comment &&
		isFallThroughComment(comment.value, fallthroughCommentPattern)
	) {
		return comment;
	***REMOVED***

	return null;
***REMOVED***

/**
 * Checks whether a node and a token are separated by blank lines
 * @param {ASTNode***REMOVED*** node The node to check
 * @param {Token***REMOVED*** token The token to compare against
 * @returns {boolean***REMOVED*** `true` if there are blank lines between node and token
 */
function hasBlankLinesBetween(node, token) {
	return token.loc.start.line > node.loc.end.line + 1;
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "problem",

		defaultOptions: [
			{
				allowEmptyCase: false,
				reportUnusedFallthroughComment: false,
			***REMOVED***,
		],

		docs: {
			description: "Disallow fallthrough of `case` statements",
			recommended: true,
			url: "https://eslint.org/docs/latest/rules/no-fallthrough",
		***REMOVED***,

		schema: [
			{
				type: "object",
				properties: {
					commentPattern: {
						type: "string",
					***REMOVED***,
					allowEmptyCase: {
						type: "boolean",
					***REMOVED***,
					reportUnusedFallthroughComment: {
						type: "boolean",
					***REMOVED***,
				***REMOVED***,
				additionalProperties: false,
			***REMOVED***,
		],
		messages: {
			unusedFallthroughComment:
				"Found a comment that would permit fallthrough, but case cannot fall through.",
			case: "Expected a 'break' statement before 'case'.",
			default: "Expected a 'break' statement before 'default'.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const codePathSegments = [];
		let currentCodePathSegments = new Set();
		const sourceCode = context.sourceCode;
		const [
			{ allowEmptyCase, commentPattern, reportUnusedFallthroughComment ***REMOVED***,
		] = context.options;
		const fallthroughCommentPattern = commentPattern
			? new RegExp(commentPattern, "u")
			: DEFAULT_FALLTHROUGH_COMMENT;

		/*
		 * We need to use leading comments of the next SwitchCase node because
		 * trailing comments is wrong if semicolons are omitted.
		 */
		let previousCase = null;

		return {
			onCodePathStart() {
				codePathSegments.push(currentCodePathSegments);
				currentCodePathSegments = new Set();
			***REMOVED***,

			onCodePathEnd() {
				currentCodePathSegments = codePathSegments.pop();
			***REMOVED***,

			onUnreachableCodePathSegmentStart(segment) {
				currentCodePathSegments.add(segment);
			***REMOVED***,

			onUnreachableCodePathSegmentEnd(segment) {
				currentCodePathSegments.delete(segment);
			***REMOVED***,

			onCodePathSegmentStart(segment) {
				currentCodePathSegments.add(segment);
			***REMOVED***,

			onCodePathSegmentEnd(segment) {
				currentCodePathSegments.delete(segment);
			***REMOVED***,

			SwitchCase(node) {
				/*
				 * Checks whether or not there is a fallthrough comment.
				 * And reports the previous fallthrough node if that does not exist.
				 */

				if (previousCase && previousCase.node.parent === node.parent) {
					const previousCaseFallthroughComment =
						getFallthroughComment(
							previousCase.node,
							node,
							context,
							fallthroughCommentPattern,
						);

					if (
						previousCase.isFallthrough &&
						!previousCaseFallthroughComment
					) {
						context.report({
							messageId: node.test ? "case" : "default",
							node,
						***REMOVED***);
					***REMOVED*** else if (
						reportUnusedFallthroughComment &&
						!previousCase.isSwitchExitReachable &&
						previousCaseFallthroughComment
					) {
						context.report({
							messageId: "unusedFallthroughComment",
							node: previousCaseFallthroughComment,
						***REMOVED***);
					***REMOVED***
				***REMOVED***
				previousCase = null;
			***REMOVED***,

			"SwitchCase:exit"(node) {
				const nextToken = sourceCode.getTokenAfter(node);

				/*
				 * `reachable` meant fall through because statements preceded by
				 * `break`, `return`, or `throw` are unreachable.
				 * And allows empty cases and the last case.
				 */
				const isSwitchExitReachable = isAnySegmentReachable(
					currentCodePathSegments,
				);
				const isFallthrough =
					isSwitchExitReachable &&
					(node.consequent.length > 0 ||
						(!allowEmptyCase &&
							hasBlankLinesBetween(node, nextToken))) &&
					node.parent.cases.at(-1) !== node;

				previousCase = {
					node,
					isSwitchExitReachable,
					isFallthrough,
				***REMOVED***;
			***REMOVED***,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
