/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { AsyncSeriesBailHook, AsyncSeriesHook, SyncHook ***REMOVED*** = require("tapable");
const createInnerContext = require("./createInnerContext");
const { parseIdentifier ***REMOVED*** = require("./util/identifier");
const {
	normalize,
	cachedJoin: join,
	getType,
	PathType
***REMOVED*** = require("./util/path");

/** @typedef {import("./ResolverFactory").ResolveOptions***REMOVED*** ResolveOptions */

/** @typedef {Error & { details?: string ***REMOVED******REMOVED*** ErrorWithDetail */

/** @typedef {(err: ErrorWithDetail | null, res?: string | false, req?: ResolveRequest) => void***REMOVED*** ResolveCallback */

/**
 * @typedef {Object***REMOVED*** PossibleFileSystemError
 * @property {string=***REMOVED*** code
 * @property {number=***REMOVED*** errno
 * @property {string=***REMOVED*** path
 * @property {string=***REMOVED*** syscall
 */

/**
 * @template T
 * @callback FileSystemCallback
 * @param {PossibleFileSystemError & Error | null***REMOVED*** err
 * @param {T=***REMOVED*** result
 */

/**
 * @typedef {string | Buffer | URL***REMOVED*** PathLike
 */

/**
 * @typedef {PathLike | number***REMOVED*** PathOrFileDescriptor
 */

/**
 * @typedef {Object***REMOVED*** ObjectEncodingOptions
 * @property {BufferEncoding | null | undefined***REMOVED*** [encoding]
 */

/** @typedef {function(NodeJS.ErrnoException | null, string=): void***REMOVED*** StringCallback */
/** @typedef {function(NodeJS.ErrnoException | null, Buffer=): void***REMOVED*** BufferCallback */
/** @typedef {function(NodeJS.ErrnoException | null, (string | Buffer)=): void***REMOVED*** StringOrBufferCallback */
/** @typedef {function(NodeJS.ErrnoException | null, IStats=): void***REMOVED*** StatsCallback */
/** @typedef {function(NodeJS.ErrnoException | null, IBigIntStats=): void***REMOVED*** BigIntStatsCallback */
/** @typedef {function(NodeJS.ErrnoException | null, (IStats | IBigIntStats)=): void***REMOVED*** StatsOrBigIntStatsCallback */
/** @typedef {function(NodeJS.ErrnoException | Error | null, JsonObject=): void***REMOVED*** ReadJsonCallback */
/** @typedef {function(NodeJS.ErrnoException | null, string[]=): void***REMOVED*** ReaddirStringCallback */
/** @typedef {function(NodeJS.ErrnoException | null, Buffer[]=): void***REMOVED*** ReaddirBufferCallback */
/** @typedef {function(NodeJS.ErrnoException | null, (string[] | Buffer[])=): void***REMOVED*** ReaddirStringOrBufferCallback */
/** @typedef {function(NodeJS.ErrnoException | null, Dirent[]=): void***REMOVED*** ReaddirDirentCallback */

/**
 * @template T
 * @typedef {Object***REMOVED*** IStatsBase
 * @property {() => boolean***REMOVED*** isFile
 * @property {() => boolean***REMOVED*** isDirectory
 * @property {() => boolean***REMOVED*** isBlockDevice
 * @property {() => boolean***REMOVED*** isCharacterDevice
 * @property {() => boolean***REMOVED*** isSymbolicLink
 * @property {() => boolean***REMOVED*** isFIFO
 * @property {() => boolean***REMOVED*** isSocket
 * @property {T***REMOVED*** dev
 * @property {T***REMOVED*** ino
 * @property {T***REMOVED*** mode
 * @property {T***REMOVED*** nlink
 * @property {T***REMOVED*** uid
 * @property {T***REMOVED*** gid
 * @property {T***REMOVED*** rdev
 * @property {T***REMOVED*** size
 * @property {T***REMOVED*** blksize
 * @property {T***REMOVED*** blocks
 * @property {T***REMOVED*** atimeMs
 * @property {T***REMOVED*** mtimeMs
 * @property {T***REMOVED*** ctimeMs
 * @property {T***REMOVED*** birthtimeMs
 * @property {Date***REMOVED*** atime
 * @property {Date***REMOVED*** mtime
 * @property {Date***REMOVED*** ctime
 * @property {Date***REMOVED*** birthtime
 */

/**
 * @typedef {IStatsBase<number>***REMOVED*** IStats
 */

/**
 * @typedef {IStatsBase<bigint> & { atimeNs: bigint, mtimeNs: bigint, ctimeNs: bigint, birthtimeNs: bigint  ***REMOVED******REMOVED*** IBigIntStats
 */

/**
 * @typedef {Object***REMOVED*** Dirent
 * @property {() => boolean***REMOVED*** isFile
 * @property {() => boolean***REMOVED*** isDirectory
 * @property {() => boolean***REMOVED*** isBlockDevice
 * @property {() => boolean***REMOVED*** isCharacterDevice
 * @property {() => boolean***REMOVED*** isSymbolicLink
 * @property {() => boolean***REMOVED*** isFIFO
 * @property {() => boolean***REMOVED*** isSocket
 * @property {string***REMOVED*** name
 * @property {string***REMOVED*** path
 */

/**
 * @typedef {Object***REMOVED*** StatOptions
 * @property {(boolean | undefined)=***REMOVED*** bigint
 */

/**
 * @typedef {Object***REMOVED*** StatSyncOptions
 * @property {(boolean | undefined)=***REMOVED*** bigint
 * @property {(boolean | undefined)=***REMOVED*** throwIfNoEntry
 */

/**
 * @typedef {{
 * (path: PathOrFileDescriptor, options: ({ encoding?: null | undefined, flag?: string | undefined ***REMOVED*** & import("events").Abortable) | undefined | null, callback: BufferCallback): void;
 * (path: PathOrFileDescriptor, options: ({ encoding: BufferEncoding, flag?: string | undefined ***REMOVED*** & import("events").Abortable) | BufferEncoding, callback: StringCallback): void;
 * (path: PathOrFileDescriptor, options: (ObjectEncodingOptions & { flag?: string | undefined ***REMOVED*** & import("events").Abortable) | BufferEncoding | undefined | null, callback: StringOrBufferCallback): void;
 * (path: PathOrFileDescriptor, callback: BufferCallback): void;
 * ***REMOVED******REMOVED*** ReadFile
 */

/**
 * @typedef {ObjectEncodingOptions | BufferEncoding | undefined | null***REMOVED*** EncodingOption
 */

/**
 * @typedef {'buffer'| { encoding: 'buffer' ***REMOVED******REMOVED*** BufferEncodingOption
 */

/**
 * @typedef {{
 * (path: PathOrFileDescriptor, options?: { encoding?: null | undefined, flag?: string | undefined ***REMOVED*** | null): Buffer;
 * (path: PathOrFileDescriptor, options: { encoding: BufferEncoding, flag?: string | undefined ***REMOVED*** | BufferEncoding): string;
 * (path: PathOrFileDescriptor, options?: (ObjectEncodingOptions & { flag?: string | undefined ***REMOVED***) | BufferEncoding | null): string | Buffer;
 * ***REMOVED******REMOVED*** ReadFileSync
 */

/**
 * @typedef {{
 * (path: PathLike, options: { encoding: BufferEncoding | null, withFileTypes?: false | undefined, recursive?: boolean | undefined ***REMOVED*** | BufferEncoding | undefined | null, callback: ReaddirStringCallback): void;
 * (path: PathLike, options: { encoding: 'buffer', withFileTypes?: false | undefined, recursive?: boolean | undefined ***REMOVED*** | 'buffer', callback: ReaddirBufferCallback): void;
 * (path: PathLike, callback: ReaddirStringCallback): void;
 * (path: PathLike, options: (ObjectEncodingOptions & { withFileTypes?: false | undefined, recursive?: boolean | undefined ***REMOVED***) | BufferEncoding | undefined | null, callback: ReaddirStringOrBufferCallback): void;
 * (path: PathLike, options: ObjectEncodingOptions & { withFileTypes: true, recursive?: boolean | undefined ***REMOVED***, callback: ReaddirDirentCallback): void;
 * ***REMOVED******REMOVED*** Readdir
 */

/**
 * @typedef {{
 * (path: PathLike, options?: { encoding: BufferEncoding | null, withFileTypes?: false | undefined, recursive?: boolean | undefined ***REMOVED*** | BufferEncoding | null): string[];
 * (path: PathLike, options: { encoding: 'buffer', withFileTypes?: false | undefined, recursive?: boolean | undefined ***REMOVED*** | 'buffer'): Buffer[];
 * (path: PathLike, options?: (ObjectEncodingOptions & { withFileTypes?: false | undefined, recursive?: boolean | undefined ***REMOVED***) | BufferEncoding | null): string[] | Buffer[];
 * (path: PathLike, options: ObjectEncodingOptions & { withFileTypes: true, recursive?: boolean | undefined ***REMOVED***): Dirent[];
 * ***REMOVED******REMOVED*** ReaddirSync

 /**
 * @typedef {function(PathOrFileDescriptor, ReadJsonCallback): void***REMOVED*** ReadJson
 */

/**
 * @typedef {function(PathOrFileDescriptor): JsonObject***REMOVED*** ReadJsonSync
 */

/**
 * @typedef {{
 * (path: PathLike, options: EncodingOption, callback: StringCallback): void;
 * (path: PathLike, options: BufferEncodingOption, callback: BufferCallback): void;
 * (path: PathLike, options: EncodingOption, callback: StringOrBufferCallback): void;
 * (path: PathLike, callback: StringCallback): void;
 * ***REMOVED******REMOVED*** Readlink
 */

/**
 * @typedef {{
 * (path: PathLike, options?: EncodingOption): string;
 * (path: PathLike, options: BufferEncodingOption): Buffer;
 * (path: PathLike, options?: EncodingOption): string | Buffer;
 * ***REMOVED******REMOVED*** ReadlinkSync
 */

/**
 * @typedef {{
 * (path: PathLike, callback: StatsCallback): void;
 * (path: PathLike, options: (StatOptions & { bigint?: false | undefined ***REMOVED***) | undefined, callback: StatsCallback): void;
 * (path: PathLike, options: StatOptions & { bigint: true ***REMOVED***, callback: BigIntStatsCallback): void;
 * (path: PathLike, options: StatOptions | undefined, callback: StatsOrBigIntStatsCallback): void;
 * ***REMOVED******REMOVED*** LStat
 */

/**
 * @typedef {{
 * (path: PathLike, options?: undefined): IStats;
 * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined, throwIfNoEntry: false ***REMOVED***): IStats | undefined;
 * (path: PathLike, options: StatSyncOptions & { bigint: true, throwIfNoEntry: false ***REMOVED***): IBigIntStats | undefined;
 * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined ***REMOVED***): IStats;
 * (path: PathLike, options: StatSyncOptions & { bigint: true ***REMOVED***): IBigIntStats;
 * (path: PathLike,  options: StatSyncOptions & { bigint: boolean, throwIfNoEntry?: false | undefined ***REMOVED***): IStats | IBigIntStats;
 * (path: PathLike,  options?: StatSyncOptions): IStats | IBigIntStats | undefined;
 * ***REMOVED******REMOVED*** LStatSync
 */

/**
 * @typedef {{
 * (path: PathLike, callback: StatsCallback): void;
 * (path: PathLike, options: (StatOptions & { bigint?: false | undefined ***REMOVED***) | undefined, callback: StatsCallback): void;
 * (path: PathLike, options: StatOptions & { bigint: true ***REMOVED***, callback: BigIntStatsCallback): void;
 * (path: PathLike, options: StatOptions | undefined, callback: StatsOrBigIntStatsCallback): void;
 * ***REMOVED******REMOVED*** Stat
 */

/**
 * @typedef {{
 * (path: PathLike, options?: undefined): IStats;
 * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined, throwIfNoEntry: false ***REMOVED***): IStats | undefined;
 * (path: PathLike, options: StatSyncOptions & { bigint: true, throwIfNoEntry: false ***REMOVED***): IBigIntStats | undefined;
 * (path: PathLike, options?: StatSyncOptions & { bigint?: false | undefined ***REMOVED***): IStats;
 * (path: PathLike, options: StatSyncOptions & { bigint: true ***REMOVED***): IBigIntStats;
 * (path: PathLike,  options: StatSyncOptions & { bigint: boolean, throwIfNoEntry?: false | undefined ***REMOVED***): IStats | IBigIntStats;
 * (path: PathLike,  options?: StatSyncOptions): IStats | IBigIntStats | undefined;
 * ***REMOVED******REMOVED*** StatSync
 */

/**
 * @typedef {{
 * (path: PathLike, options: EncodingOption, callback: StringCallback): void;
 * (path: PathLike, options: BufferEncodingOption, callback: BufferCallback): void;
 * (path: PathLike, options: EncodingOption, callback: StringOrBufferCallback): void;
 * (path: PathLike, callback: StringCallback): void;
 * ***REMOVED******REMOVED*** RealPath
 */

/**
 * @typedef {{
 * (path: PathLike, options?: EncodingOption): string;
 * (path: PathLike, options: BufferEncodingOption): Buffer;
 * (path: PathLike, options?: EncodingOption): string | Buffer;
 * ***REMOVED******REMOVED*** RealPathSync
 */

/**
 * @typedef {Object***REMOVED*** FileSystem
 * @property {ReadFile***REMOVED*** readFile
 * @property {Readdir***REMOVED*** readdir
 * @property {ReadJson=***REMOVED*** readJson
 * @property {Readlink***REMOVED*** readlink
 * @property {LStat=***REMOVED*** lstat
 * @property {Stat***REMOVED*** stat
 * @property {RealPath=***REMOVED*** realpath
 */

/**
 * @typedef {Object***REMOVED*** SyncFileSystem
 * @property {ReadFileSync***REMOVED*** readFileSync
 * @property {ReaddirSync***REMOVED*** readdirSync
 * @property {ReadJsonSync=***REMOVED*** readJsonSync
 * @property {ReadlinkSync***REMOVED*** readlinkSync
 * @property {LStatSync=***REMOVED*** lstatSync
 * @property {StatSync***REMOVED*** statSync
 * @property {RealPathSync=***REMOVED*** realpathSync
 */

/**
 * @typedef {Object***REMOVED*** ParsedIdentifier
 * @property {string***REMOVED*** request
 * @property {string***REMOVED*** query
 * @property {string***REMOVED*** fragment
 * @property {boolean***REMOVED*** directory
 * @property {boolean***REMOVED*** module
 * @property {boolean***REMOVED*** file
 * @property {boolean***REMOVED*** internal
 */

/** @typedef {string | number | boolean | null***REMOVED*** JsonPrimitive */
/** @typedef {JsonValue[]***REMOVED*** JsonArray */
/** @typedef {JsonPrimitive | JsonObject | JsonArray***REMOVED*** JsonValue */
/** @typedef {{[Key in string]: JsonValue***REMOVED*** & {[Key in string]?: JsonValue | undefined***REMOVED******REMOVED*** JsonObject */

/**
 * @typedef {Object***REMOVED*** BaseResolveRequest
 * @property {string | false***REMOVED*** path
 * @property {object=***REMOVED*** context
 * @property {string=***REMOVED*** descriptionFilePath
 * @property {string=***REMOVED*** descriptionFileRoot
 * @property {JsonObject=***REMOVED*** descriptionFileData
 * @property {string=***REMOVED*** relativePath
 * @property {boolean=***REMOVED*** ignoreSymlinks
 * @property {boolean=***REMOVED*** fullySpecified
 * @property {string=***REMOVED*** __innerRequest
 * @property {string=***REMOVED*** __innerRequest_request
 * @property {string=***REMOVED*** __innerRequest_relativePath
 */

/** @typedef {BaseResolveRequest & Partial<ParsedIdentifier>***REMOVED*** ResolveRequest */

/**
 * String with special formatting
 * @typedef {string***REMOVED*** StackEntry
 */

/**
 * @template T
 * @typedef {{ add: (item: T) => void ***REMOVED******REMOVED*** WriteOnlySet
 */

/** @typedef {(function (ResolveRequest): void)***REMOVED*** ResolveContextYield */

/**
 * Resolve context
 * @typedef {Object***REMOVED*** ResolveContext
 * @property {WriteOnlySet<string>=***REMOVED*** contextDependencies
 * @property {WriteOnlySet<string>=***REMOVED*** fileDependencies files that was found on file system
 * @property {WriteOnlySet<string>=***REMOVED*** missingDependencies dependencies that was not found on file system
 * @property {Set<StackEntry>=***REMOVED*** stack set of hooks' calls. For instance, `resolve → parsedResolve → describedResolve`,
 * @property {(function(string): void)=***REMOVED*** log log function
 * @property {ResolveContextYield=***REMOVED*** yield yield result, if provided plugins can return several results
 */

/** @typedef {AsyncSeriesBailHook<[ResolveRequest, ResolveContext], ResolveRequest | null>***REMOVED*** ResolveStepHook */

/**
 * @typedef {Object***REMOVED*** KnownHooks
 * @property {SyncHook<[ResolveStepHook, ResolveRequest], void>***REMOVED*** resolveStep
 * @property {SyncHook<[ResolveRequest, Error]>***REMOVED*** noResolve
 * @property {ResolveStepHook***REMOVED*** resolve
 * @property {AsyncSeriesHook<[ResolveRequest, ResolveContext]>***REMOVED*** result
 */

/**
 * @typedef {{[key: string]: ResolveStepHook***REMOVED******REMOVED*** EnsuredHooks
 */

/**
 * @param {string***REMOVED*** str input string
 * @returns {string***REMOVED*** in camel case
 */
function toCamelCase(str) {
	return str.replace(/-([a-z])/g, str => str.slice(1).toUpperCase());
***REMOVED***

class Resolver {
	/**
	 * @param {ResolveStepHook***REMOVED*** hook hook
	 * @param {ResolveRequest***REMOVED*** request request
	 * @returns {StackEntry***REMOVED*** stack entry
	 */
	static createStackEntry(hook, request) {
		return (
			hook.name +
			": (" +
			request.path +
			") " +
			(request.request || "") +
			(request.query || "") +
			(request.fragment || "") +
			(request.directory ? " directory" : "") +
			(request.module ? " module" : "")
		);
	***REMOVED***

	/**
	 * @param {FileSystem***REMOVED*** fileSystem a filesystem
	 * @param {ResolveOptions***REMOVED*** options options
	 */
	constructor(fileSystem, options) {
		this.fileSystem = fileSystem;
		this.options = options;
		/** @type {KnownHooks***REMOVED*** */
		this.hooks = {
			resolveStep: new SyncHook(["hook", "request"], "resolveStep"),
			noResolve: new SyncHook(["request", "error"], "noResolve"),
			resolve: new AsyncSeriesBailHook(
				["request", "resolveContext"],
				"resolve"
			),
			result: new AsyncSeriesHook(["result", "resolveContext"], "result")
		***REMOVED***;
	***REMOVED***

	/**
	 * @param {string | ResolveStepHook***REMOVED*** name hook name or hook itself
	 * @returns {ResolveStepHook***REMOVED*** the hook
	 */
	ensureHook(name) {
		if (typeof name !== "string") {
			return name;
		***REMOVED***
		name = toCamelCase(name);
		if (/^before/.test(name)) {
			return /** @type {ResolveStepHook***REMOVED*** */ (
				this.ensureHook(name[6].toLowerCase() + name.slice(7)).withOptions({
					stage: -10
				***REMOVED***)
			);
		***REMOVED***
		if (/^after/.test(name)) {
			return /** @type {ResolveStepHook***REMOVED*** */ (
				this.ensureHook(name[5].toLowerCase() + name.slice(6)).withOptions({
					stage: 10
				***REMOVED***)
			);
		***REMOVED***
		/** @type {ResolveStepHook***REMOVED*** */
		const hook = /** @type {KnownHooks & EnsuredHooks***REMOVED*** */ (this.hooks)[name];
		if (!hook) {
			/** @type {KnownHooks & EnsuredHooks***REMOVED*** */
			(this.hooks)[name] = new AsyncSeriesBailHook(
				["request", "resolveContext"],
				name
			);

			return /** @type {KnownHooks & EnsuredHooks***REMOVED*** */ (this.hooks)[name];
		***REMOVED***
		return hook;
	***REMOVED***

	/**
	 * @param {string | ResolveStepHook***REMOVED*** name hook name or hook itself
	 * @returns {ResolveStepHook***REMOVED*** the hook
	 */
	getHook(name) {
		if (typeof name !== "string") {
			return name;
		***REMOVED***
		name = toCamelCase(name);
		if (/^before/.test(name)) {
			return /** @type {ResolveStepHook***REMOVED*** */ (
				this.getHook(name[6].toLowerCase() + name.slice(7)).withOptions({
					stage: -10
				***REMOVED***)
			);
		***REMOVED***
		if (/^after/.test(name)) {
			return /** @type {ResolveStepHook***REMOVED*** */ (
				this.getHook(name[5].toLowerCase() + name.slice(6)).withOptions({
					stage: 10
				***REMOVED***)
			);
		***REMOVED***
		/** @type {ResolveStepHook***REMOVED*** */
		const hook = /** @type {KnownHooks & EnsuredHooks***REMOVED*** */ (this.hooks)[name];
		if (!hook) {
			throw new Error(`Hook ${name***REMOVED*** doesn't exist`);
		***REMOVED***
		return hook;
	***REMOVED***

	/**
	 * @param {object***REMOVED*** context context information object
	 * @param {string***REMOVED*** path context path
	 * @param {string***REMOVED*** request request string
	 * @returns {string | false***REMOVED*** result
	 */
	resolveSync(context, path, request) {
		/** @type {Error | null | undefined***REMOVED*** */
		let err = undefined;
		/** @type {string | false | undefined***REMOVED*** */
		let result = undefined;
		let sync = false;
		this.resolve(context, path, request, {***REMOVED***, (e, r) => {
			err = e;
			result = r;
			sync = true;
		***REMOVED***);
		if (!sync) {
			throw new Error(
				"Cannot 'resolveSync' because the fileSystem is not sync. Use 'resolve'!"
			);
		***REMOVED***
		if (err) throw err;
		if (result === undefined) throw new Error("No result");
		return result;
	***REMOVED***

	/**
	 * @param {object***REMOVED*** context context information object
	 * @param {string***REMOVED*** path context path
	 * @param {string***REMOVED*** request request string
	 * @param {ResolveContext***REMOVED*** resolveContext resolve context
	 * @param {ResolveCallback***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	resolve(context, path, request, resolveContext, callback) {
		if (!context || typeof context !== "object")
			return callback(new Error("context argument is not an object"));
		if (typeof path !== "string")
			return callback(new Error("path argument is not a string"));
		if (typeof request !== "string")
			return callback(new Error("request argument is not a string"));
		if (!resolveContext)
			return callback(new Error("resolveContext argument is not set"));

		/** @type {ResolveRequest***REMOVED*** */
		const obj = {
			context: context,
			path: path,
			request: request
		***REMOVED***;

		/** @type {ResolveContextYield | undefined***REMOVED*** */
		let yield_;
		let yieldCalled = false;
		/** @type {ResolveContextYield | undefined***REMOVED*** */
		let finishYield;
		if (typeof resolveContext.yield === "function") {
			const old = resolveContext.yield;
			/**
			 * @param {ResolveRequest***REMOVED*** obj object
			 */
			yield_ = obj => {
				old(obj);
				yieldCalled = true;
			***REMOVED***;
			/**
			 * @param {ResolveRequest***REMOVED*** result result
			 * @returns {void***REMOVED***
			 */
			finishYield = result => {
				if (result) {
					/** @type {ResolveContextYield***REMOVED*** */ (yield_)(result);
				***REMOVED***
				callback(null);
			***REMOVED***;
		***REMOVED***

		const message = `resolve '${request***REMOVED***' in '${path***REMOVED***'`;

		/**
		 * @param {ResolveRequest***REMOVED*** result result
		 * @returns {void***REMOVED***
		 */
		const finishResolved = result => {
			return callback(
				null,
				result.path === false
					? false
					: `${result.path.replace(/#/g, "\0#")***REMOVED***${
							result.query ? result.query.replace(/#/g, "\0#") : ""
					  ***REMOVED***${result.fragment || ""***REMOVED***`,
				result
			);
		***REMOVED***;

		/**
		 * @param {string[]***REMOVED*** log logs
		 * @returns {void***REMOVED***
		 */
		const finishWithoutResolve = log => {
			/**
			 * @type {ErrorWithDetail***REMOVED***
			 */
			const error = new Error("Can't " + message);
			error.details = log.join("\n");
			this.hooks.noResolve.call(obj, error);
			return callback(error);
		***REMOVED***;

		if (resolveContext.log) {
			// We need log anyway to capture it in case of an error
			const parentLog = resolveContext.log;
			/** @type {string[]***REMOVED*** */
			const log = [];
			return this.doResolve(
				this.hooks.resolve,
				obj,
				message,
				{
					log: msg => {
						parentLog(msg);
						log.push(msg);
					***REMOVED***,
					yield: yield_,
					fileDependencies: resolveContext.fileDependencies,
					contextDependencies: resolveContext.contextDependencies,
					missingDependencies: resolveContext.missingDependencies,
					stack: resolveContext.stack
				***REMOVED***,
				(err, result) => {
					if (err) return callback(err);

					if (yieldCalled || (result && yield_)) {
						return /** @type {ResolveContextYield***REMOVED*** */ (finishYield)(
							/** @type {ResolveRequest***REMOVED*** */ (result)
						);
					***REMOVED***

					if (result) return finishResolved(result);

					return finishWithoutResolve(log);
				***REMOVED***
			);
		***REMOVED*** else {
			// Try to resolve assuming there is no error
			// We don't log stuff in this case
			return this.doResolve(
				this.hooks.resolve,
				obj,
				message,
				{
					log: undefined,
					yield: yield_,
					fileDependencies: resolveContext.fileDependencies,
					contextDependencies: resolveContext.contextDependencies,
					missingDependencies: resolveContext.missingDependencies,
					stack: resolveContext.stack
				***REMOVED***,
				(err, result) => {
					if (err) return callback(err);

					if (yieldCalled || (result && yield_)) {
						return /** @type {ResolveContextYield***REMOVED*** */ (finishYield)(
							/** @type {ResolveRequest***REMOVED*** */ (result)
						);
					***REMOVED***

					if (result) return finishResolved(result);

					// log is missing for the error details
					// so we redo the resolving for the log info
					// this is more expensive to the success case
					// is assumed by default
					/** @type {string[]***REMOVED*** */
					const log = [];

					return this.doResolve(
						this.hooks.resolve,
						obj,
						message,
						{
							log: msg => log.push(msg),
							yield: yield_,
							stack: resolveContext.stack
						***REMOVED***,
						(err, result) => {
							if (err) return callback(err);

							// In a case that there is a race condition and yield will be called
							if (yieldCalled || (result && yield_)) {
								return /** @type {ResolveContextYield***REMOVED*** */ (finishYield)(
									/** @type {ResolveRequest***REMOVED*** */ (result)
								);
							***REMOVED***

							return finishWithoutResolve(log);
						***REMOVED***
					);
				***REMOVED***
			);
		***REMOVED***
	***REMOVED***

	/**
	 * @param {ResolveStepHook***REMOVED*** hook hook
	 * @param {ResolveRequest***REMOVED*** request request
	 * @param {null|string***REMOVED*** message string
	 * @param {ResolveContext***REMOVED*** resolveContext resolver context
	 * @param {(err?: null|Error, result?: ResolveRequest) => void***REMOVED*** callback callback
	 * @returns {void***REMOVED***
	 */
	doResolve(hook, request, message, resolveContext, callback) {
		const stackEntry = Resolver.createStackEntry(hook, request);

		/** @type {Set<string> | undefined***REMOVED*** */
		let newStack;
		if (resolveContext.stack) {
			newStack = new Set(resolveContext.stack);
			if (resolveContext.stack.has(stackEntry)) {
				/**
				 * Prevent recursion
				 * @type {Error & {recursion?: boolean***REMOVED******REMOVED***
				 */
				const recursionError = new Error(
					"Recursion in resolving\nStack:\n  " +
						Array.from(newStack).join("\n  ")
				);
				recursionError.recursion = true;
				if (resolveContext.log)
					resolveContext.log("abort resolving because of recursion");
				return callback(recursionError);
			***REMOVED***
			newStack.add(stackEntry);
		***REMOVED*** else {
			// creating a set with new Set([item])
			// allocates a new array that has to be garbage collected
			// this is an EXTREMELY hot path, so let's avoid it
			newStack = new Set();
			newStack.add(stackEntry);
		***REMOVED***
		this.hooks.resolveStep.call(hook, request);

		if (hook.isUsed()) {
			const innerContext = createInnerContext(
				{
					log: resolveContext.log,
					yield: resolveContext.yield,
					fileDependencies: resolveContext.fileDependencies,
					contextDependencies: resolveContext.contextDependencies,
					missingDependencies: resolveContext.missingDependencies,
					stack: newStack
				***REMOVED***,
				message
			);
			return hook.callAsync(request, innerContext, (err, result) => {
				if (err) return callback(err);
				if (result) return callback(null, result);
				callback();
			***REMOVED***);
		***REMOVED*** else {
			callback();
		***REMOVED***
	***REMOVED***

	/**
	 * @param {string***REMOVED*** identifier identifier
	 * @returns {ParsedIdentifier***REMOVED*** parsed identifier
	 */
	parse(identifier) {
		const part = {
			request: "",
			query: "",
			fragment: "",
			module: false,
			directory: false,
			file: false,
			internal: false
		***REMOVED***;

		const parsedIdentifier = parseIdentifier(identifier);

		if (!parsedIdentifier) return part;

		[part.request, part.query, part.fragment] = parsedIdentifier;

		if (part.request.length > 0) {
			part.internal = this.isPrivate(identifier);
			part.module = this.isModule(part.request);
			part.directory = this.isDirectory(part.request);
			if (part.directory) {
				part.request = part.request.slice(0, -1);
			***REMOVED***
		***REMOVED***

		return part;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** path path
	 * @returns {boolean***REMOVED*** true, if the path is a module
	 */
	isModule(path) {
		return getType(path) === PathType.Normal;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** path path
	 * @returns {boolean***REMOVED*** true, if the path is private
	 */
	isPrivate(path) {
		return getType(path) === PathType.Internal;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** path a path
	 * @returns {boolean***REMOVED*** true, if the path is a directory path
	 */
	isDirectory(path) {
		return path.endsWith("/");
	***REMOVED***

	/**
	 * @param {string***REMOVED*** path path
	 * @param {string***REMOVED*** request request
	 * @returns {string***REMOVED*** joined path
	 */
	join(path, request) {
		return join(path, request);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** path path
	 * @returns {string***REMOVED*** normalized path
	 */
	normalize(path) {
		return normalize(path);
	***REMOVED***
***REMOVED***

module.exports = Resolver;
