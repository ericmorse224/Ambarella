/**
 * @fileoverview Rule to check for "block scoped" variables by binding context
 * @author Matt DuVall <http://www.mattduvall.com>
 */
"use strict";

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

module.exports = {
    meta: {
        type: "suggestion",

        docs: {
            description: "enforce the use of variables within the scope they are defined",
            category: "Best Practices",
            recommended: false,
            url: "https://eslint.org/docs/rules/block-scoped-var"
        ***REMOVED***,

        schema: [],

        messages: {
            outOfScope: "'{{name***REMOVED******REMOVED***' used outside of binding context."
        ***REMOVED***
    ***REMOVED***,

    create(context) {
        let stack = [];

        /**
         * Makes a block scope.
         * @param {ASTNode***REMOVED*** node A node of a scope.
         * @returns {void***REMOVED***
         */
        function enterScope(node) {
            stack.push(node.range);
        ***REMOVED***

        /**
         * Pops the last block scope.
         * @returns {void***REMOVED***
         */
        function exitScope() {
            stack.pop();
        ***REMOVED***

        /**
         * Reports a given reference.
         * @param {eslint-scope.Reference***REMOVED*** reference A reference to report.
         * @returns {void***REMOVED***
         */
        function report(reference) {
            const identifier = reference.identifier;

            context.report({ node: identifier, messageId: "outOfScope", data: { name: identifier.name ***REMOVED*** ***REMOVED***);
        ***REMOVED***

        /**
         * Finds and reports references which are outside of valid scopes.
         * @param {ASTNode***REMOVED*** node A node to get variables.
         * @returns {void***REMOVED***
         */
        function checkForVariables(node) {
            if (node.kind !== "var") {
                return;
            ***REMOVED***

            // Defines a predicate to check whether or not a given reference is outside of valid scope.
            const scopeRange = stack[stack.length - 1];

            /**
             * Check if a reference is out of scope
             * @param {ASTNode***REMOVED*** reference node to examine
             * @returns {boolean***REMOVED*** True is its outside the scope
             * @private
             */
            function isOutsideOfScope(reference) {
                const idRange = reference.identifier.range;

                return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];
            ***REMOVED***

            // Gets declared variables, and checks its references.
            const variables = context.getDeclaredVariables(node);

            for (let i = 0; i < variables.length; ++i) {

                // Reports.
                variables[i]
                    .references
                    .filter(isOutsideOfScope)
                    .forEach(report);
            ***REMOVED***
        ***REMOVED***

        return {
            Program(node) {
                stack = [node.range];
            ***REMOVED***,

            // Manages scopes.
            BlockStatement: enterScope,
            "BlockStatement:exit": exitScope,
            ForStatement: enterScope,
            "ForStatement:exit": exitScope,
            ForInStatement: enterScope,
            "ForInStatement:exit": exitScope,
            ForOfStatement: enterScope,
            "ForOfStatement:exit": exitScope,
            SwitchStatement: enterScope,
            "SwitchStatement:exit": exitScope,
            CatchClause: enterScope,
            "CatchClause:exit": exitScope,

            // Finds and reports references which are outside of valid scope.
            VariableDeclaration: checkForVariables
        ***REMOVED***;

    ***REMOVED***
***REMOVED***;
