/**
 * @fileoverview Rule to disallow unused labels.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "suggestion",

		docs: {
			description: "Disallow unused labels",
			recommended: true,
			url: "https://eslint.org/docs/latest/rules/no-unused-labels",
		***REMOVED***,

		schema: [],

		fixable: "code",

		messages: {
			unused: "'{{name***REMOVED******REMOVED***:' is defined but never used.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const sourceCode = context.sourceCode;
		let scopeInfo = null;

		/**
		 * Adds a scope info to the stack.
		 * @param {ASTNode***REMOVED*** node A node to add. This is a LabeledStatement.
		 * @returns {void***REMOVED***
		 */
		function enterLabeledScope(node) {
			scopeInfo = {
				label: node.label.name,
				used: false,
				upper: scopeInfo,
			***REMOVED***;
		***REMOVED***

		/**
		 * Checks if a `LabeledStatement` node is fixable.
		 * For a node to be fixable, there must be no comments between the label and the body.
		 * Furthermore, is must be possible to remove the label without turning the body statement into a
		 * directive after other fixes are applied.
		 * @param {ASTNode***REMOVED*** node The node to evaluate.
		 * @returns {boolean***REMOVED*** Whether or not the node is fixable.
		 */
		function isFixable(node) {
			/*
			 * Only perform a fix if there are no comments between the label and the body. This will be the case
			 * when there is exactly one token/comment (the ":") between the label and the body.
			 */
			if (
				sourceCode.getTokenAfter(node.label, {
					includeComments: true,
				***REMOVED***) !==
				sourceCode.getTokenBefore(node.body, { includeComments: true ***REMOVED***)
			) {
				return false;
			***REMOVED***

			// Looking for the node's deepest ancestor which is not a `LabeledStatement`.
			let ancestor = node.parent;

			while (ancestor.type === "LabeledStatement") {
				ancestor = ancestor.parent;
			***REMOVED***

			if (
				ancestor.type === "Program" ||
				(ancestor.type === "BlockStatement" &&
					astUtils.isFunction(ancestor.parent))
			) {
				const { body ***REMOVED*** = node;

				if (
					body.type === "ExpressionStatement" &&
					((body.expression.type === "Literal" &&
						typeof body.expression.value === "string") ||
						astUtils.isStaticTemplateLiteral(body.expression))
				) {
					return false; // potential directive
				***REMOVED***
			***REMOVED***
			return true;
		***REMOVED***

		/**
		 * Removes the top of the stack.
		 * At the same time, this reports the label if it's never used.
		 * @param {ASTNode***REMOVED*** node A node to report. This is a LabeledStatement.
		 * @returns {void***REMOVED***
		 */
		function exitLabeledScope(node) {
			if (!scopeInfo.used) {
				context.report({
					node: node.label,
					messageId: "unused",
					data: node.label,
					fix: isFixable(node)
						? fixer =>
								fixer.removeRange([
									node.range[0],
									node.body.range[0],
								])
						: null,
				***REMOVED***);
			***REMOVED***

			scopeInfo = scopeInfo.upper;
		***REMOVED***

		/**
		 * Marks the label of a given node as used.
		 * @param {ASTNode***REMOVED*** node A node to mark. This is a BreakStatement or
		 *      ContinueStatement.
		 * @returns {void***REMOVED***
		 */
		function markAsUsed(node) {
			if (!node.label) {
				return;
			***REMOVED***

			const label = node.label.name;
			let info = scopeInfo;

			while (info) {
				if (info.label === label) {
					info.used = true;
					break;
				***REMOVED***
				info = info.upper;
			***REMOVED***
		***REMOVED***

		return {
			LabeledStatement: enterLabeledScope,
			"LabeledStatement:exit": exitLabeledScope,
			BreakStatement: markAsUsed,
			ContinueStatement: markAsUsed,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
