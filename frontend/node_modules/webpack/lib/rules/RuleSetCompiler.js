/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { SyncHook ***REMOVED*** = require("tapable");

/** @typedef {import("../../declarations/WebpackOptions").Falsy***REMOVED*** Falsy */
/** @typedef {import("../../declarations/WebpackOptions").RuleSetLoaderOptions***REMOVED*** RuleSetLoaderOptions */
/** @typedef {import("../../declarations/WebpackOptions").RuleSetRule***REMOVED*** RuleSetRule */

/** @typedef {(Falsy | RuleSetRule)[]***REMOVED*** RuleSetRules */

/**
 * @typedef {(value: EffectData[keyof EffectData]) => boolean***REMOVED*** RuleConditionFunction
 */

/**
 * @typedef {object***REMOVED*** RuleCondition
 * @property {string | string[]***REMOVED*** property
 * @property {boolean***REMOVED*** matchWhenEmpty
 * @property {RuleConditionFunction***REMOVED*** fn
 */

/**
 * @typedef {object***REMOVED*** Condition
 * @property {boolean***REMOVED*** matchWhenEmpty
 * @property {RuleConditionFunction***REMOVED*** fn
 */

/**
 * @typedef {object***REMOVED*** EffectData
 * @property {string=***REMOVED*** resource
 * @property {string=***REMOVED*** realResource
 * @property {string=***REMOVED*** resourceQuery
 * @property {string=***REMOVED*** resourceFragment
 * @property {string=***REMOVED*** scheme
 * @property {ImportAttributes=***REMOVED*** assertions
 * @property {string=***REMOVED*** mimetype
 * @property {string***REMOVED*** dependency
 * @property {Record<string, EXPECTED_ANY>***REMOVED*** descriptionData
 * @property {string=***REMOVED*** compiler
 * @property {string***REMOVED*** issuer
 * @property {string***REMOVED*** issuerLayer
 */

/**
 * @typedef {object***REMOVED*** CompiledRule
 * @property {RuleCondition[]***REMOVED*** conditions
 * @property {(Effect | ((effectData: EffectData) => Effect[]))[]***REMOVED*** effects
 * @property {CompiledRule[]=***REMOVED*** rules
 * @property {CompiledRule[]=***REMOVED*** oneOf
 */

/**
 * @typedef {object***REMOVED*** Effect
 * @property {string***REMOVED*** type
 * @property {TODO***REMOVED*** value
 */

/** @typedef {Map<string, RuleSetLoaderOptions>***REMOVED*** References */

/**
 * @typedef {object***REMOVED*** RuleSet
 * @property {References***REMOVED*** references map of references in the rule set (may grow over time)
 * @property {(effectData: EffectData) => Effect[]***REMOVED*** exec execute the rule set
 */

/**
 * @template T
 * @template {T[keyof T]***REMOVED*** V
 * @typedef {({ [P in keyof Required<T>]: Required<T>[P] extends V ? P : never ***REMOVED***)[keyof T]***REMOVED*** KeysOfTypes
 */

/** @typedef {{ apply: (ruleSetCompiler: RuleSetCompiler) => void ***REMOVED******REMOVED*** RuleSetPlugin */

class RuleSetCompiler {
	/**
	 * @param {RuleSetPlugin[]***REMOVED*** plugins plugins
	 */
	constructor(plugins) {
		this.hooks = Object.freeze({
			/** @type {SyncHook<[string, RuleSetRule, Set<string>, CompiledRule, References]>***REMOVED*** */
			rule: new SyncHook([
				"path",
				"rule",
				"unhandledProperties",
				"compiledRule",
				"references"
			])
		***REMOVED***);
		if (plugins) {
			for (const plugin of plugins) {
				plugin.apply(this);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	/**
	 * @param {RuleSetRules***REMOVED*** ruleSet raw user provided rules
	 * @returns {RuleSet***REMOVED*** compiled RuleSet
	 */
	compile(ruleSet) {
		const refs = new Map();
		const rules = this.compileRules("ruleSet", ruleSet, refs);

		/**
		 * @param {EffectData***REMOVED*** data data passed in
		 * @param {CompiledRule***REMOVED*** rule the compiled rule
		 * @param {Effect[]***REMOVED*** effects an array where effects are pushed to
		 * @returns {boolean***REMOVED*** true, if the rule has matched
		 */
		const execRule = (data, rule, effects) => {
			for (const condition of rule.conditions) {
				const p = condition.property;
				if (Array.isArray(p)) {
					/** @type {EffectData | EffectData[keyof EffectData] | undefined***REMOVED*** */
					let current = data;
					for (const subProperty of p) {
						if (
							current &&
							typeof current === "object" &&
							Object.prototype.hasOwnProperty.call(current, subProperty)
						) {
							current = current[/** @type {keyof EffectData***REMOVED*** */ (subProperty)];
						***REMOVED*** else {
							current = undefined;
							break;
						***REMOVED***
					***REMOVED***
					if (current !== undefined) {
						if (!condition.fn(current)) return false;
						continue;
					***REMOVED***
				***REMOVED*** else if (p in data) {
					const value = data[/** @type {keyof EffectData***REMOVED*** */ (p)];
					if (value !== undefined) {
						if (!condition.fn(value)) return false;
						continue;
					***REMOVED***
				***REMOVED***
				if (!condition.matchWhenEmpty) {
					return false;
				***REMOVED***
			***REMOVED***
			for (const effect of rule.effects) {
				if (typeof effect === "function") {
					const returnedEffects = effect(data);
					for (const effect of returnedEffects) {
						effects.push(effect);
					***REMOVED***
				***REMOVED*** else {
					effects.push(effect);
				***REMOVED***
			***REMOVED***
			if (rule.rules) {
				for (const childRule of rule.rules) {
					execRule(data, childRule, effects);
				***REMOVED***
			***REMOVED***
			if (rule.oneOf) {
				for (const childRule of rule.oneOf) {
					if (execRule(data, childRule, effects)) {
						break;
					***REMOVED***
				***REMOVED***
			***REMOVED***
			return true;
		***REMOVED***;

		return {
			references: refs,
			exec: data => {
				/** @type {Effect[]***REMOVED*** */
				const effects = [];
				for (const rule of rules) {
					execRule(data, rule, effects);
				***REMOVED***
				return effects;
			***REMOVED***
		***REMOVED***;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** path current path
	 * @param {RuleSetRules***REMOVED*** rules the raw rules provided by user
	 * @param {References***REMOVED*** refs references
	 * @returns {CompiledRule[]***REMOVED*** rules
	 */
	compileRules(path, rules, refs) {
		return rules
			.filter(Boolean)
			.map((rule, i) =>
				this.compileRule(
					`${path***REMOVED***[${i***REMOVED***]`,
					/** @type {RuleSetRule***REMOVED*** */ (rule),
					refs
				)
			);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** path current path
	 * @param {RuleSetRule***REMOVED*** rule the raw rule provided by user
	 * @param {References***REMOVED*** refs references
	 * @returns {CompiledRule***REMOVED*** normalized and compiled rule for processing
	 */
	compileRule(path, rule, refs) {
		const unhandledProperties = new Set(
			Object.keys(rule).filter(
				key => rule[/** @type {keyof RuleSetRule***REMOVED*** */ (key)] !== undefined
			)
		);

		/** @type {CompiledRule***REMOVED*** */
		const compiledRule = {
			conditions: [],
			effects: [],
			rules: undefined,
			oneOf: undefined
		***REMOVED***;

		this.hooks.rule.call(path, rule, unhandledProperties, compiledRule, refs);

		if (unhandledProperties.has("rules")) {
			unhandledProperties.delete("rules");
			const rules = rule.rules;
			if (!Array.isArray(rules))
				throw this.error(path, rules, "Rule.rules must be an array of rules");
			compiledRule.rules = this.compileRules(`${path***REMOVED***.rules`, rules, refs);
		***REMOVED***

		if (unhandledProperties.has("oneOf")) {
			unhandledProperties.delete("oneOf");
			const oneOf = rule.oneOf;
			if (!Array.isArray(oneOf))
				throw this.error(path, oneOf, "Rule.oneOf must be an array of rules");
			compiledRule.oneOf = this.compileRules(`${path***REMOVED***.oneOf`, oneOf, refs);
		***REMOVED***

		if (unhandledProperties.size > 0) {
			throw this.error(
				path,
				rule,
				`Properties ${Array.from(unhandledProperties).join(", ")***REMOVED*** are unknown`
			);
		***REMOVED***

		return compiledRule;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** path current path
	 * @param {RuleSetLoaderOptions***REMOVED*** condition user provided condition value
	 * @returns {Condition***REMOVED*** compiled condition
	 */
	compileCondition(path, condition) {
		if (condition === "") {
			return {
				matchWhenEmpty: true,
				fn: str => str === ""
			***REMOVED***;
		***REMOVED***
		if (!condition) {
			throw this.error(
				path,
				condition,
				"Expected condition but got falsy value"
			);
		***REMOVED***
		if (typeof condition === "string") {
			return {
				matchWhenEmpty: condition.length === 0,
				fn: str => typeof str === "string" && str.startsWith(condition)
			***REMOVED***;
		***REMOVED***
		if (typeof condition === "function") {
			try {
				return {
					matchWhenEmpty: condition(""),
					fn: /** @type {RuleConditionFunction***REMOVED*** */ (condition)
				***REMOVED***;
			***REMOVED*** catch (_err) {
				throw this.error(
					path,
					condition,
					"Evaluation of condition function threw error"
				);
			***REMOVED***
		***REMOVED***
		if (condition instanceof RegExp) {
			return {
				matchWhenEmpty: condition.test(""),
				fn: v => typeof v === "string" && condition.test(v)
			***REMOVED***;
		***REMOVED***
		if (Array.isArray(condition)) {
			const items = condition.map((c, i) =>
				this.compileCondition(`${path***REMOVED***[${i***REMOVED***]`, c)
			);
			return this.combineConditionsOr(items);
		***REMOVED***

		if (typeof condition !== "object") {
			throw this.error(
				path,
				condition,
				`Unexpected ${typeof condition***REMOVED*** when condition was expected`
			);
		***REMOVED***

		const conditions = [];
		for (const key of Object.keys(condition)) {
			const value = condition[key];
			switch (key) {
				case "or":
					if (value) {
						if (!Array.isArray(value)) {
							throw this.error(
								`${path***REMOVED***.or`,
								condition.or,
								"Expected array of conditions"
							);
						***REMOVED***
						conditions.push(this.compileCondition(`${path***REMOVED***.or`, value));
					***REMOVED***
					break;
				case "and":
					if (value) {
						if (!Array.isArray(value)) {
							throw this.error(
								`${path***REMOVED***.and`,
								condition.and,
								"Expected array of conditions"
							);
						***REMOVED***
						let i = 0;
						for (const item of value) {
							conditions.push(this.compileCondition(`${path***REMOVED***.and[${i***REMOVED***]`, item));
							i++;
						***REMOVED***
					***REMOVED***
					break;
				case "not":
					if (value) {
						const matcher = this.compileCondition(`${path***REMOVED***.not`, value);
						const fn = matcher.fn;
						conditions.push({
							matchWhenEmpty: !matcher.matchWhenEmpty,
							fn: /** @type {RuleConditionFunction***REMOVED*** */ (v => !fn(v))
						***REMOVED***);
					***REMOVED***
					break;
				default:
					throw this.error(
						`${path***REMOVED***.${key***REMOVED***`,
						condition[key],
						`Unexpected property ${key***REMOVED*** in condition`
					);
			***REMOVED***
		***REMOVED***
		if (conditions.length === 0) {
			throw this.error(
				path,
				condition,
				"Expected condition, but got empty thing"
			);
		***REMOVED***
		return this.combineConditionsAnd(conditions);
	***REMOVED***

	/**
	 * @param {Condition[]***REMOVED*** conditions some conditions
	 * @returns {Condition***REMOVED*** merged condition
	 */
	combineConditionsOr(conditions) {
		if (conditions.length === 0) {
			return {
				matchWhenEmpty: false,
				fn: () => false
			***REMOVED***;
		***REMOVED*** else if (conditions.length === 1) {
			return conditions[0];
		***REMOVED***
		return {
			matchWhenEmpty: conditions.some(c => c.matchWhenEmpty),
			fn: v => conditions.some(c => c.fn(v))
		***REMOVED***;
	***REMOVED***

	/**
	 * @param {Condition[]***REMOVED*** conditions some conditions
	 * @returns {Condition***REMOVED*** merged condition
	 */
	combineConditionsAnd(conditions) {
		if (conditions.length === 0) {
			return {
				matchWhenEmpty: false,
				fn: () => false
			***REMOVED***;
		***REMOVED*** else if (conditions.length === 1) {
			return conditions[0];
		***REMOVED***
		return {
			matchWhenEmpty: conditions.every(c => c.matchWhenEmpty),
			fn: v => conditions.every(c => c.fn(v))
		***REMOVED***;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** path current path
	 * @param {EXPECTED_ANY***REMOVED*** value value at the error location
	 * @param {string***REMOVED*** message message explaining the problem
	 * @returns {Error***REMOVED*** an error object
	 */
	error(path, value, message) {
		return new Error(
			`Compiling RuleSet failed: ${message***REMOVED*** (at ${path***REMOVED***: ${value***REMOVED***)`
		);
	***REMOVED***
***REMOVED***

module.exports = RuleSetCompiler;
