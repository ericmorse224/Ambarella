/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const Dependency = require("./Dependency");
const { UsageState ***REMOVED*** = require("./ExportsInfo");
const ModuleGraphConnection = require("./ModuleGraphConnection");
const { STAGE_DEFAULT ***REMOVED*** = require("./OptimizationStages");
const ArrayQueue = require("./util/ArrayQueue");
const TupleQueue = require("./util/TupleQueue");
const { getEntryRuntime, mergeRuntimeOwned ***REMOVED*** = require("./util/runtime");

/** @typedef {import("./Chunk")***REMOVED*** Chunk */
/** @typedef {import("./ChunkGroup")***REMOVED*** ChunkGroup */
/** @typedef {import("./Compiler")***REMOVED*** Compiler */
/** @typedef {import("./DependenciesBlock")***REMOVED*** DependenciesBlock */
/** @typedef {import("./Dependency").ReferencedExport***REMOVED*** ReferencedExport */
/** @typedef {import("./ExportsInfo")***REMOVED*** ExportsInfo */
/** @typedef {import("./Module")***REMOVED*** Module */
/** @typedef {import("./util/runtime").RuntimeSpec***REMOVED*** RuntimeSpec */

const { NO_EXPORTS_REFERENCED, EXPORTS_OBJECT_REFERENCED ***REMOVED*** = Dependency;

const PLUGIN_NAME = "FlagDependencyUsagePlugin";
const PLUGIN_LOGGER_NAME = `webpack.${PLUGIN_NAME***REMOVED***`;

class FlagDependencyUsagePlugin {
	/**
	 * @param {boolean***REMOVED*** global do a global analysis instead of per runtime
	 */
	constructor(global) {
		this.global = global;
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {
			const moduleGraph = compilation.moduleGraph;
			compilation.hooks.optimizeDependencies.tap(
				{ name: PLUGIN_NAME, stage: STAGE_DEFAULT ***REMOVED***,
				modules => {
					if (compilation.moduleMemCaches) {
						throw new Error(
							"optimization.usedExports can't be used with cacheUnaffected as export usage is a global effect"
						);
					***REMOVED***

					const logger = compilation.getLogger(PLUGIN_LOGGER_NAME);
					/** @type {Map<ExportsInfo, Module>***REMOVED*** */
					const exportInfoToModuleMap = new Map();

					/** @type {TupleQueue<Module, RuntimeSpec>***REMOVED*** */
					const queue = new TupleQueue();

					/**
					 * @param {Module***REMOVED*** module module to process
					 * @param {(string[] | ReferencedExport)[]***REMOVED*** usedExports list of used exports
					 * @param {RuntimeSpec***REMOVED*** runtime part of which runtime
					 * @param {boolean***REMOVED*** forceSideEffects always apply side effects
					 * @returns {void***REMOVED***
					 */
					const processReferencedModule = (
						module,
						usedExports,
						runtime,
						forceSideEffects
					) => {
						const exportsInfo = moduleGraph.getExportsInfo(module);
						if (usedExports.length > 0) {
							if (!module.buildMeta || !module.buildMeta.exportsType) {
								if (exportsInfo.setUsedWithoutInfo(runtime)) {
									queue.enqueue(module, runtime);
								***REMOVED***
								return;
							***REMOVED***
							for (const usedExportInfo of usedExports) {
								let usedExport;
								let canMangle = true;
								if (Array.isArray(usedExportInfo)) {
									usedExport = usedExportInfo;
								***REMOVED*** else {
									usedExport = usedExportInfo.name;
									canMangle = usedExportInfo.canMangle !== false;
								***REMOVED***
								if (usedExport.length === 0) {
									if (exportsInfo.setUsedInUnknownWay(runtime)) {
										queue.enqueue(module, runtime);
									***REMOVED***
								***REMOVED*** else {
									let currentExportsInfo = exportsInfo;
									for (let i = 0; i < usedExport.length; i++) {
										const exportInfo = currentExportsInfo.getExportInfo(
											usedExport[i]
										);
										if (canMangle === false) {
											exportInfo.canMangleUse = false;
										***REMOVED***
										const lastOne = i === usedExport.length - 1;
										if (!lastOne) {
											const nestedInfo = exportInfo.getNestedExportsInfo();
											if (nestedInfo) {
												if (
													exportInfo.setUsedConditionally(
														used => used === UsageState.Unused,
														UsageState.OnlyPropertiesUsed,
														runtime
													)
												) {
													const currentModule =
														currentExportsInfo === exportsInfo
															? module
															: exportInfoToModuleMap.get(currentExportsInfo);
													if (currentModule) {
														queue.enqueue(currentModule, runtime);
													***REMOVED***
												***REMOVED***
												currentExportsInfo = nestedInfo;
												continue;
											***REMOVED***
										***REMOVED***
										if (
											exportInfo.setUsedConditionally(
												v => v !== UsageState.Used,
												UsageState.Used,
												runtime
											)
										) {
											const currentModule =
												currentExportsInfo === exportsInfo
													? module
													: exportInfoToModuleMap.get(currentExportsInfo);
											if (currentModule) {
												queue.enqueue(currentModule, runtime);
											***REMOVED***
										***REMOVED***
										break;
									***REMOVED***
								***REMOVED***
							***REMOVED***
						***REMOVED*** else {
							// for a module without side effects we stop tracking usage here when no export is used
							// This module won't be evaluated in this case
							// TODO webpack 6 remove this check
							if (
								!forceSideEffects &&
								module.factoryMeta !== undefined &&
								module.factoryMeta.sideEffectFree
							) {
								return;
							***REMOVED***
							if (exportsInfo.setUsedForSideEffectsOnly(runtime)) {
								queue.enqueue(module, runtime);
							***REMOVED***
						***REMOVED***
					***REMOVED***;

					/**
					 * @param {DependenciesBlock***REMOVED*** module the module
					 * @param {RuntimeSpec***REMOVED*** runtime part of which runtime
					 * @param {boolean***REMOVED*** forceSideEffects always apply side effects
					 * @returns {void***REMOVED***
					 */
					const processModule = (module, runtime, forceSideEffects) => {
						/** @type {Map<Module, (string[] | ReferencedExport)[] | Map<string, string[] | ReferencedExport>>***REMOVED*** */
						const map = new Map();

						/** @type {ArrayQueue<DependenciesBlock>***REMOVED*** */
						const queue = new ArrayQueue();
						queue.enqueue(module);
						for (;;) {
							const block = queue.dequeue();
							if (block === undefined) break;
							for (const b of block.blocks) {
								if (
									!this.global &&
									b.groupOptions &&
									b.groupOptions.entryOptions
								) {
									processModule(
										b,
										b.groupOptions.entryOptions.runtime || undefined,
										true
									);
								***REMOVED*** else {
									queue.enqueue(b);
								***REMOVED***
							***REMOVED***
							for (const dep of block.dependencies) {
								const connection = moduleGraph.getConnection(dep);
								if (!connection || !connection.module) {
									continue;
								***REMOVED***
								const activeState = connection.getActiveState(runtime);
								if (activeState === false) continue;
								const { module ***REMOVED*** = connection;
								if (activeState === ModuleGraphConnection.TRANSITIVE_ONLY) {
									processModule(module, runtime, false);
									continue;
								***REMOVED***
								const oldReferencedExports = map.get(module);
								if (oldReferencedExports === EXPORTS_OBJECT_REFERENCED) {
									continue;
								***REMOVED***
								const referencedExports =
									compilation.getDependencyReferencedExports(dep, runtime);
								if (
									oldReferencedExports === undefined ||
									oldReferencedExports === NO_EXPORTS_REFERENCED ||
									referencedExports === EXPORTS_OBJECT_REFERENCED
								) {
									map.set(module, referencedExports);
								***REMOVED*** else if (
									oldReferencedExports !== undefined &&
									referencedExports === NO_EXPORTS_REFERENCED
								) {
									continue;
								***REMOVED*** else {
									let exportsMap;
									if (Array.isArray(oldReferencedExports)) {
										exportsMap = new Map();
										for (const item of oldReferencedExports) {
											if (Array.isArray(item)) {
												exportsMap.set(item.join("\n"), item);
											***REMOVED*** else {
												exportsMap.set(item.name.join("\n"), item);
											***REMOVED***
										***REMOVED***
										map.set(module, exportsMap);
									***REMOVED*** else {
										exportsMap = oldReferencedExports;
									***REMOVED***
									for (const item of referencedExports) {
										if (Array.isArray(item)) {
											const key = item.join("\n");
											const oldItem = exportsMap.get(key);
											if (oldItem === undefined) {
												exportsMap.set(key, item);
											***REMOVED***
											// if oldItem is already an array we have to do nothing
											// if oldItem is an ReferencedExport object, we don't have to do anything
											// as canMangle defaults to true for arrays
										***REMOVED*** else {
											const key = item.name.join("\n");
											const oldItem = exportsMap.get(key);
											if (oldItem === undefined || Array.isArray(oldItem)) {
												exportsMap.set(key, item);
											***REMOVED*** else {
												exportsMap.set(key, {
													name: item.name,
													canMangle: item.canMangle && oldItem.canMangle
												***REMOVED***);
											***REMOVED***
										***REMOVED***
									***REMOVED***
								***REMOVED***
							***REMOVED***
						***REMOVED***

						for (const [module, referencedExports] of map) {
							if (Array.isArray(referencedExports)) {
								processReferencedModule(
									module,
									referencedExports,
									runtime,
									forceSideEffects
								);
							***REMOVED*** else {
								processReferencedModule(
									module,
									Array.from(referencedExports.values()),
									runtime,
									forceSideEffects
								);
							***REMOVED***
						***REMOVED***
					***REMOVED***;

					logger.time("initialize exports usage");
					for (const module of modules) {
						const exportsInfo = moduleGraph.getExportsInfo(module);
						exportInfoToModuleMap.set(exportsInfo, module);
						exportsInfo.setHasUseInfo();
					***REMOVED***
					logger.timeEnd("initialize exports usage");

					logger.time("trace exports usage in graph");

					/**
					 * @param {Dependency***REMOVED*** dep dependency
					 * @param {RuntimeSpec***REMOVED*** runtime runtime
					 */
					const processEntryDependency = (dep, runtime) => {
						const module = moduleGraph.getModule(dep);
						if (module) {
							processReferencedModule(
								module,
								NO_EXPORTS_REFERENCED,
								runtime,
								true
							);
						***REMOVED***
					***REMOVED***;
					/** @type {RuntimeSpec***REMOVED*** */
					let globalRuntime;
					for (const [
						entryName,
						{ dependencies: deps, includeDependencies: includeDeps, options ***REMOVED***
					] of compilation.entries) {
						const runtime = this.global
							? undefined
							: getEntryRuntime(compilation, entryName, options);
						for (const dep of deps) {
							processEntryDependency(dep, runtime);
						***REMOVED***
						for (const dep of includeDeps) {
							processEntryDependency(dep, runtime);
						***REMOVED***
						globalRuntime = mergeRuntimeOwned(globalRuntime, runtime);
					***REMOVED***
					for (const dep of compilation.globalEntry.dependencies) {
						processEntryDependency(dep, globalRuntime);
					***REMOVED***
					for (const dep of compilation.globalEntry.includeDependencies) {
						processEntryDependency(dep, globalRuntime);
					***REMOVED***

					while (queue.length) {
						const [module, runtime] = /** @type {[Module, RuntimeSpec]***REMOVED*** */ (
							queue.dequeue()
						);
						processModule(module, runtime, false);
					***REMOVED***
					logger.timeEnd("trace exports usage in graph");
				***REMOVED***
			);
		***REMOVED***);
	***REMOVED***
***REMOVED***

module.exports = FlagDependencyUsagePlugin;
