/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./client-src/modules/logger/SyncBailHookFake.js":
/*!*******************************************************!*\
  !*** ./client-src/modules/logger/SyncBailHookFake.js ***!
  \*******************************************************/
/***/ (function(module) {



/**
 * Client stub for tapable SyncBailHook
 */
module.exports = function clientTapableSyncBailHook() {
  return {
    call: function call() {***REMOVED***
  ***REMOVED***;
***REMOVED***;

/***/ ***REMOVED***),

/***/ "./node_modules/webpack/lib/logging/Logger.js":
/*!****************************************************!*\
  !*** ./node_modules/webpack/lib/logging/Logger.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/



function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
***REMOVED***
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
***REMOVED***
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
***REMOVED***
function _iterableToArray(iter) {
  if (typeof (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; ***REMOVED***) !== "undefined" && iter[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; ***REMOVED***).iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
***REMOVED***
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
***REMOVED***
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
***REMOVED***
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  ***REMOVED***
***REMOVED***
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  ***REMOVED***
***REMOVED***
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  ***REMOVED***);
  return Constructor;
***REMOVED***
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
***REMOVED***
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; ***REMOVED***).toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  ***REMOVED***
  return (hint === "string" ? String : Number)(input);
***REMOVED***
var LogType = Object.freeze({
  error: /** @type {"error"***REMOVED*** */"error",
  // message, c style arguments
  warn: /** @type {"warn"***REMOVED*** */"warn",
  // message, c style arguments
  info: /** @type {"info"***REMOVED*** */"info",
  // message, c style arguments
  log: /** @type {"log"***REMOVED*** */"log",
  // message, c style arguments
  debug: /** @type {"debug"***REMOVED*** */"debug",
  // message, c style arguments

  trace: /** @type {"trace"***REMOVED*** */"trace",
  // no arguments

  group: /** @type {"group"***REMOVED*** */"group",
  // [label]
  groupCollapsed: /** @type {"groupCollapsed"***REMOVED*** */"groupCollapsed",
  // [label]
  groupEnd: /** @type {"groupEnd"***REMOVED*** */"groupEnd",
  // [label]

  profile: /** @type {"profile"***REMOVED*** */"profile",
  // [profileName]
  profileEnd: /** @type {"profileEnd"***REMOVED*** */"profileEnd",
  // [profileName]

  time: /** @type {"time"***REMOVED*** */"time",
  // name, time as [seconds, nanoseconds]

  clear: /** @type {"clear"***REMOVED*** */"clear",
  // no arguments
  status: /** @type {"status"***REMOVED*** */"status" // message, arguments
***REMOVED***);

exports.LogType = LogType;

/** @typedef {typeof LogType[keyof typeof LogType]***REMOVED*** LogTypeEnum */

var LOG_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; ***REMOVED***)("webpack logger raw log method");
var TIMERS_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; ***REMOVED***)("webpack logger times");
var TIMERS_AGGREGATES_SYMBOL = (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; ***REMOVED***)("webpack logger aggregated times");
var WebpackLogger = /*#__PURE__*/function () {
  /**
   * @param {function(LogTypeEnum, any[]=): void***REMOVED*** log log function
   * @param {function(string | function(): string): WebpackLogger***REMOVED*** getChildLogger function to create child logger
   */
  function WebpackLogger(log, getChildLogger) {
    _classCallCheck(this, WebpackLogger);
    this[LOG_SYMBOL] = log;
    this.getChildLogger = getChildLogger;
  ***REMOVED***
  _createClass(WebpackLogger, [{
    key: "error",
    value: function error() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      ***REMOVED***
      this[LOG_SYMBOL](LogType.error, args);
    ***REMOVED***
  ***REMOVED***, {
    key: "warn",
    value: function warn() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      ***REMOVED***
      this[LOG_SYMBOL](LogType.warn, args);
    ***REMOVED***
  ***REMOVED***, {
    key: "info",
    value: function info() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      ***REMOVED***
      this[LOG_SYMBOL](LogType.info, args);
    ***REMOVED***
  ***REMOVED***, {
    key: "log",
    value: function log() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      ***REMOVED***
      this[LOG_SYMBOL](LogType.log, args);
    ***REMOVED***
  ***REMOVED***, {
    key: "debug",
    value: function debug() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      ***REMOVED***
      this[LOG_SYMBOL](LogType.debug, args);
    ***REMOVED***
  ***REMOVED***, {
    key: "assert",
    value: function assert(assertion) {
      if (!assertion) {
        for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
          args[_key6 - 1] = arguments[_key6];
        ***REMOVED***
        this[LOG_SYMBOL](LogType.error, args);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***, {
    key: "trace",
    value: function trace() {
      this[LOG_SYMBOL](LogType.trace, ["Trace"]);
    ***REMOVED***
  ***REMOVED***, {
    key: "clear",
    value: function clear() {
      this[LOG_SYMBOL](LogType.clear);
    ***REMOVED***
  ***REMOVED***, {
    key: "status",
    value: function status() {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      ***REMOVED***
      this[LOG_SYMBOL](LogType.status, args);
    ***REMOVED***
  ***REMOVED***, {
    key: "group",
    value: function group() {
      for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      ***REMOVED***
      this[LOG_SYMBOL](LogType.group, args);
    ***REMOVED***
  ***REMOVED***, {
    key: "groupCollapsed",
    value: function groupCollapsed() {
      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      ***REMOVED***
      this[LOG_SYMBOL](LogType.groupCollapsed, args);
    ***REMOVED***
  ***REMOVED***, {
    key: "groupEnd",
    value: function groupEnd() {
      for (var _len10 = arguments.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        args[_key10] = arguments[_key10];
      ***REMOVED***
      this[LOG_SYMBOL](LogType.groupEnd, args);
    ***REMOVED***
  ***REMOVED***, {
    key: "profile",
    value: function profile(label) {
      this[LOG_SYMBOL](LogType.profile, [label]);
    ***REMOVED***
  ***REMOVED***, {
    key: "profileEnd",
    value: function profileEnd(label) {
      this[LOG_SYMBOL](LogType.profileEnd, [label]);
    ***REMOVED***
  ***REMOVED***, {
    key: "time",
    value: function time(label) {
      this[TIMERS_SYMBOL] = this[TIMERS_SYMBOL] || new Map();
      this[TIMERS_SYMBOL].set(label, process.hrtime());
    ***REMOVED***
  ***REMOVED***, {
    key: "timeLog",
    value: function timeLog(label) {
      var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
      if (!prev) {
        throw new Error("No such label '".concat(label, "' for WebpackLogger.timeLog()"));
      ***REMOVED***
      var time = process.hrtime(prev);
      this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));
    ***REMOVED***
  ***REMOVED***, {
    key: "timeEnd",
    value: function timeEnd(label) {
      var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
      if (!prev) {
        throw new Error("No such label '".concat(label, "' for WebpackLogger.timeEnd()"));
      ***REMOVED***
      var time = process.hrtime(prev);
      this[TIMERS_SYMBOL].delete(label);
      this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));
    ***REMOVED***
  ***REMOVED***, {
    key: "timeAggregate",
    value: function timeAggregate(label) {
      var prev = this[TIMERS_SYMBOL] && this[TIMERS_SYMBOL].get(label);
      if (!prev) {
        throw new Error("No such label '".concat(label, "' for WebpackLogger.timeAggregate()"));
      ***REMOVED***
      var time = process.hrtime(prev);
      this[TIMERS_SYMBOL].delete(label);
      this[TIMERS_AGGREGATES_SYMBOL] = this[TIMERS_AGGREGATES_SYMBOL] || new Map();
      var current = this[TIMERS_AGGREGATES_SYMBOL].get(label);
      if (current !== undefined) {
        if (time[1] + current[1] > 1e9) {
          time[0] += current[0] + 1;
          time[1] = time[1] - 1e9 + current[1];
        ***REMOVED*** else {
          time[0] += current[0];
          time[1] += current[1];
        ***REMOVED***
      ***REMOVED***
      this[TIMERS_AGGREGATES_SYMBOL].set(label, time);
    ***REMOVED***
  ***REMOVED***, {
    key: "timeAggregateEnd",
    value: function timeAggregateEnd(label) {
      if (this[TIMERS_AGGREGATES_SYMBOL] === undefined) return;
      var time = this[TIMERS_AGGREGATES_SYMBOL].get(label);
      if (time === undefined) return;
      this[TIMERS_AGGREGATES_SYMBOL].delete(label);
      this[LOG_SYMBOL](LogType.time, [label].concat(_toConsumableArray(time)));
    ***REMOVED***
  ***REMOVED***]);
  return WebpackLogger;
***REMOVED***();
exports.Logger = WebpackLogger;

/***/ ***REMOVED***),

/***/ "./node_modules/webpack/lib/logging/createConsoleLogger.js":
/*!*****************************************************************!*\
  !*** ./node_modules/webpack/lib/logging/createConsoleLogger.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/



function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
***REMOVED***
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
***REMOVED***
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
***REMOVED***
function _iterableToArray(iter) {
  if (typeof (typeof Symbol !== "undefined" ? Symbol : function (i) { return i; ***REMOVED***) !== "undefined" && iter[(typeof Symbol !== "undefined" ? Symbol : function (i) { return i; ***REMOVED***).iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
***REMOVED***
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
***REMOVED***
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
***REMOVED***
var _require = __webpack_require__(/*! ./Logger */ "./node_modules/webpack/lib/logging/Logger.js"),
  LogType = _require.LogType;

/** @typedef {import("../../declarations/WebpackOptions").FilterItemTypes***REMOVED*** FilterItemTypes */
/** @typedef {import("../../declarations/WebpackOptions").FilterTypes***REMOVED*** FilterTypes */
/** @typedef {import("./Logger").LogTypeEnum***REMOVED*** LogTypeEnum */

/** @typedef {function(string): boolean***REMOVED*** FilterFunction */

/**
 * @typedef {Object***REMOVED*** LoggerConsole
 * @property {function(): void***REMOVED*** clear
 * @property {function(): void***REMOVED*** trace
 * @property {(...args: any[]) => void***REMOVED*** info
 * @property {(...args: any[]) => void***REMOVED*** log
 * @property {(...args: any[]) => void***REMOVED*** warn
 * @property {(...args: any[]) => void***REMOVED*** error
 * @property {(...args: any[]) => void=***REMOVED*** debug
 * @property {(...args: any[]) => void=***REMOVED*** group
 * @property {(...args: any[]) => void=***REMOVED*** groupCollapsed
 * @property {(...args: any[]) => void=***REMOVED*** groupEnd
 * @property {(...args: any[]) => void=***REMOVED*** status
 * @property {(...args: any[]) => void=***REMOVED*** profile
 * @property {(...args: any[]) => void=***REMOVED*** profileEnd
 * @property {(...args: any[]) => void=***REMOVED*** logTime
 */

/**
 * @typedef {Object***REMOVED*** LoggerOptions
 * @property {false|true|"none"|"error"|"warn"|"info"|"log"|"verbose"***REMOVED*** level loglevel
 * @property {FilterTypes|boolean***REMOVED*** debug filter for debug logging
 * @property {LoggerConsole***REMOVED*** console the console to log to
 */

/**
 * @param {FilterItemTypes***REMOVED*** item an input item
 * @returns {FilterFunction***REMOVED*** filter function
 */
var filterToFunction = function filterToFunction(item) {
  if (typeof item === "string") {
    var regExp = new RegExp("[\\\\/]".concat(item.replace(
    // eslint-disable-next-line no-useless-escape
    /[-[\]{***REMOVED***()*+?.\\^$|]/g, "\\$&"), "([\\\\/]|$|!|\\?)"));
    return function (ident) {
      return regExp.test(ident);
    ***REMOVED***;
  ***REMOVED***
  if (item && typeof item === "object" && typeof item.test === "function") {
    return function (ident) {
      return item.test(ident);
    ***REMOVED***;
  ***REMOVED***
  if (typeof item === "function") {
    return item;
  ***REMOVED***
  if (typeof item === "boolean") {
    return function () {
      return item;
    ***REMOVED***;
  ***REMOVED***
***REMOVED***;

/**
 * @enum {number***REMOVED***
 */
var LogLevel = {
  none: 6,
  false: 6,
  error: 5,
  warn: 4,
  info: 3,
  log: 2,
  true: 2,
  verbose: 1
***REMOVED***;

/**
 * @param {LoggerOptions***REMOVED*** options options object
 * @returns {function(string, LogTypeEnum, any[]): void***REMOVED*** logging function
 */
module.exports = function (_ref) {
  var _ref$level = _ref.level,
    level = _ref$level === void 0 ? "info" : _ref$level,
    _ref$debug = _ref.debug,
    debug = _ref$debug === void 0 ? false : _ref$debug,
    console = _ref.console;
  var debugFilters = typeof debug === "boolean" ? [function () {
    return debug;
  ***REMOVED***] : /** @type {FilterItemTypes[]***REMOVED*** */[].concat(debug).map(filterToFunction);
  /** @type {number***REMOVED*** */
  var loglevel = LogLevel["".concat(level)] || 0;

  /**
   * @param {string***REMOVED*** name name of the logger
   * @param {LogTypeEnum***REMOVED*** type type of the log entry
   * @param {any[]***REMOVED*** args arguments of the log entry
   * @returns {void***REMOVED***
   */
  var logger = function logger(name, type, args) {
    var labeledArgs = function labeledArgs() {
      if (Array.isArray(args)) {
        if (args.length > 0 && typeof args[0] === "string") {
          return ["[".concat(name, "] ").concat(args[0])].concat(_toConsumableArray(args.slice(1)));
        ***REMOVED*** else {
          return ["[".concat(name, "]")].concat(_toConsumableArray(args));
        ***REMOVED***
      ***REMOVED*** else {
        return [];
      ***REMOVED***
    ***REMOVED***;
    var debug = debugFilters.some(function (f) {
      return f(name);
    ***REMOVED***);
    switch (type) {
      case LogType.debug:
        if (!debug) return;
        // eslint-disable-next-line node/no-unsupported-features/node-builtins
        if (typeof console.debug === "function") {
          // eslint-disable-next-line node/no-unsupported-features/node-builtins
          console.debug.apply(console, _toConsumableArray(labeledArgs()));
        ***REMOVED*** else {
          console.log.apply(console, _toConsumableArray(labeledArgs()));
        ***REMOVED***
        break;
      case LogType.log:
        if (!debug && loglevel > LogLevel.log) return;
        console.log.apply(console, _toConsumableArray(labeledArgs()));
        break;
      case LogType.info:
        if (!debug && loglevel > LogLevel.info) return;
        console.info.apply(console, _toConsumableArray(labeledArgs()));
        break;
      case LogType.warn:
        if (!debug && loglevel > LogLevel.warn) return;
        console.warn.apply(console, _toConsumableArray(labeledArgs()));
        break;
      case LogType.error:
        if (!debug && loglevel > LogLevel.error) return;
        console.error.apply(console, _toConsumableArray(labeledArgs()));
        break;
      case LogType.trace:
        if (!debug) return;
        console.trace();
        break;
      case LogType.groupCollapsed:
        if (!debug && loglevel > LogLevel.log) return;
        if (!debug && loglevel > LogLevel.verbose) {
          // eslint-disable-next-line node/no-unsupported-features/node-builtins
          if (typeof console.groupCollapsed === "function") {
            // eslint-disable-next-line node/no-unsupported-features/node-builtins
            console.groupCollapsed.apply(console, _toConsumableArray(labeledArgs()));
          ***REMOVED*** else {
            console.log.apply(console, _toConsumableArray(labeledArgs()));
          ***REMOVED***
          break;
        ***REMOVED***
      // falls through
      case LogType.group:
        if (!debug && loglevel > LogLevel.log) return;
        // eslint-disable-next-line node/no-unsupported-features/node-builtins
        if (typeof console.group === "function") {
          // eslint-disable-next-line node/no-unsupported-features/node-builtins
          console.group.apply(console, _toConsumableArray(labeledArgs()));
        ***REMOVED*** else {
          console.log.apply(console, _toConsumableArray(labeledArgs()));
        ***REMOVED***
        break;
      case LogType.groupEnd:
        if (!debug && loglevel > LogLevel.log) return;
        // eslint-disable-next-line node/no-unsupported-features/node-builtins
        if (typeof console.groupEnd === "function") {
          // eslint-disable-next-line node/no-unsupported-features/node-builtins
          console.groupEnd();
        ***REMOVED***
        break;
      case LogType.time:
        {
          if (!debug && loglevel > LogLevel.log) return;
          var ms = args[1] * 1000 + args[2] / 1000000;
          var msg = "[".concat(name, "] ").concat(args[0], ": ").concat(ms, " ms");
          if (typeof console.logTime === "function") {
            console.logTime(msg);
          ***REMOVED*** else {
            console.log(msg);
          ***REMOVED***
          break;
        ***REMOVED***
      case LogType.profile:
        // eslint-disable-next-line node/no-unsupported-features/node-builtins
        if (typeof console.profile === "function") {
          // eslint-disable-next-line node/no-unsupported-features/node-builtins
          console.profile.apply(console, _toConsumableArray(labeledArgs()));
        ***REMOVED***
        break;
      case LogType.profileEnd:
        // eslint-disable-next-line node/no-unsupported-features/node-builtins
        if (typeof console.profileEnd === "function") {
          // eslint-disable-next-line node/no-unsupported-features/node-builtins
          console.profileEnd.apply(console, _toConsumableArray(labeledArgs()));
        ***REMOVED***
        break;
      case LogType.clear:
        if (!debug && loglevel > LogLevel.log) return;
        // eslint-disable-next-line node/no-unsupported-features/node-builtins
        if (typeof console.clear === "function") {
          // eslint-disable-next-line node/no-unsupported-features/node-builtins
          console.clear();
        ***REMOVED***
        break;
      case LogType.status:
        if (!debug && loglevel > LogLevel.info) return;
        if (typeof console.status === "function") {
          if (args.length === 0) {
            console.status();
          ***REMOVED*** else {
            console.status.apply(console, _toConsumableArray(labeledArgs()));
          ***REMOVED***
        ***REMOVED*** else {
          if (args.length !== 0) {
            console.info.apply(console, _toConsumableArray(labeledArgs()));
          ***REMOVED***
        ***REMOVED***
        break;
      default:
        throw new Error("Unexpected LogType ".concat(type));
    ***REMOVED***
  ***REMOVED***;
  return logger;
***REMOVED***;

/***/ ***REMOVED***),

/***/ "./node_modules/webpack/lib/logging/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/webpack/lib/logging/runtime.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/



function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    return target;
  ***REMOVED***;
  return _extends.apply(this, arguments);
***REMOVED***
var SyncBailHook = __webpack_require__(/*! tapable/lib/SyncBailHook */ "./client-src/modules/logger/SyncBailHookFake.js");
var _require = __webpack_require__(/*! ./Logger */ "./node_modules/webpack/lib/logging/Logger.js"),
  Logger = _require.Logger;
var createConsoleLogger = __webpack_require__(/*! ./createConsoleLogger */ "./node_modules/webpack/lib/logging/createConsoleLogger.js");

/** @type {createConsoleLogger.LoggerOptions***REMOVED*** */
var currentDefaultLoggerOptions = {
  level: "info",
  debug: false,
  console: console
***REMOVED***;
var currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);

/**
 * @param {string***REMOVED*** name name of the logger
 * @returns {Logger***REMOVED*** a logger
 */
exports.getLogger = function (name) {
  return new Logger(function (type, args) {
    if (exports.hooks.log.call(name, type, args) === undefined) {
      currentDefaultLogger(name, type, args);
    ***REMOVED***
  ***REMOVED***, function (childName) {
    return exports.getLogger("".concat(name, "/").concat(childName));
  ***REMOVED***);
***REMOVED***;

/**
 * @param {createConsoleLogger.LoggerOptions***REMOVED*** options new options, merge with old options
 * @returns {void***REMOVED***
 */
exports.configureDefaultLogger = function (options) {
  _extends(currentDefaultLoggerOptions, options);
  currentDefaultLogger = createConsoleLogger(currentDefaultLoggerOptions);
***REMOVED***;
exports.hooks = {
  log: new SyncBailHook(["origin", "type", "args"])
***REMOVED***;

/***/ ***REMOVED***)

/******/ 	***REMOVED***);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {***REMOVED***;
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		***REMOVED***
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {***REMOVED***
/******/ 		***REMOVED***;
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	***REMOVED***
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] ***REMOVED***);
/******/ 				***REMOVED***
/******/ 			***REMOVED***
/******/ 		***REMOVED***;
/******/ 	***REMOVED***();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); ***REMOVED***
/******/ 	***REMOVED***();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' ***REMOVED***);
/******/ 			***REMOVED***
/******/ 			Object.defineProperty(exports, '__esModule', { value: true ***REMOVED***);
/******/ 		***REMOVED***;
/******/ 	***REMOVED***();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {***REMOVED***;
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
!function() {
/*!********************************************!*\
  !*** ./client-src/modules/logger/index.js ***!
  \********************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* reexport default export from named module */ webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__; ***REMOVED***
/* harmony export */ ***REMOVED***);
/* harmony import */ var webpack_lib_logging_runtime_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webpack/lib/logging/runtime.js */ "./node_modules/webpack/lib/logging/runtime.js");

***REMOVED***();
var __webpack_export_target__ = exports;
for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true ***REMOVED***);
/******/ ***REMOVED***)()
;