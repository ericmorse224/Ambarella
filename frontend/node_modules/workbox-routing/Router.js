/*
  Copyright 2018 Google LLC

  Use of this source code is governed by an MIT-style
  license that can be found in the LICENSE file or at
  https://opensource.org/licenses/MIT.
*/
import { assert ***REMOVED*** from 'workbox-core/_private/assert.js';
import { getFriendlyURL ***REMOVED*** from 'workbox-core/_private/getFriendlyURL.js';
import { defaultMethod ***REMOVED*** from './utils/constants.js';
import { logger ***REMOVED*** from 'workbox-core/_private/logger.js';
import { normalizeHandler ***REMOVED*** from './utils/normalizeHandler.js';
import { WorkboxError ***REMOVED*** from 'workbox-core/_private/WorkboxError.js';
import './_version.js';
/**
 * The Router can be used to process a `FetchEvent` using one or more
 * {@link workbox-routing.Route***REMOVED***, responding with a `Response` if
 * a matching route exists.
 *
 * If no route matches a given a request, the Router will use a "default"
 * handler if one is defined.
 *
 * Should the matching Route throw an error, the Router will use a "catch"
 * handler if one is defined to gracefully deal with issues and respond with a
 * Request.
 *
 * If a request matches multiple routes, the **earliest** registered route will
 * be used to respond to the request.
 *
 * @memberof workbox-routing
 */
class Router {
    /**
     * Initializes a new Router.
     */
    constructor() {
        this._routes = new Map();
        this._defaultHandlerMap = new Map();
    ***REMOVED***
    /**
     * @return {Map<string, Array<workbox-routing.Route>>***REMOVED*** routes A `Map` of HTTP
     * method name ('GET', etc.) to an array of all the corresponding `Route`
     * instances that are registered.
     */
    get routes() {
        return this._routes;
    ***REMOVED***
    /**
     * Adds a fetch event listener to respond to events when a route matches
     * the event's request.
     */
    addFetchListener() {
        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
        self.addEventListener('fetch', ((event) => {
            const { request ***REMOVED*** = event;
            const responsePromise = this.handleRequest({ request, event ***REMOVED***);
            if (responsePromise) {
                event.respondWith(responsePromise);
            ***REMOVED***
        ***REMOVED***));
    ***REMOVED***
    /**
     * Adds a message event listener for URLs to cache from the window.
     * This is useful to cache resources loaded on the page prior to when the
     * service worker started controlling it.
     *
     * The format of the message data sent from the window should be as follows.
     * Where the `urlsToCache` array may consist of URL strings or an array of
     * URL string + `requestInit` object (the same as you'd pass to `fetch()`).
     *
     * ```
     * {
     *   type: 'CACHE_URLS',
     *   payload: {
     *     urlsToCache: [
     *       './script1.js',
     *       './script2.js',
     *       ['./script3.js', {mode: 'no-cors'***REMOVED***],
     *     ],
     *   ***REMOVED***,
     * ***REMOVED***
     * ```
     */
    addCacheListener() {
        // See https://github.com/Microsoft/TypeScript/issues/28357#issuecomment-436484705
        self.addEventListener('message', ((event) => {
            // event.data is type 'any'
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            if (event.data && event.data.type === 'CACHE_URLS') {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                const { payload ***REMOVED*** = event.data;
                if (process.env.NODE_ENV !== 'production') {
                    logger.debug(`Caching URLs from the window`, payload.urlsToCache);
                ***REMOVED***
                const requestPromises = Promise.all(payload.urlsToCache.map((entry) => {
                    if (typeof entry === 'string') {
                        entry = [entry];
                    ***REMOVED***
                    const request = new Request(...entry);
                    return this.handleRequest({ request, event ***REMOVED***);
                    // TODO(philipwalton): TypeScript errors without this typecast for
                    // some reason (probably a bug). The real type here should work but
                    // doesn't: `Array<Promise<Response> | undefined>`.
                ***REMOVED***)); // TypeScript
                event.waitUntil(requestPromises);
                // If a MessageChannel was used, reply to the message on success.
                if (event.ports && event.ports[0]) {
                    void requestPromises.then(() => event.ports[0].postMessage(true));
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***));
    ***REMOVED***
    /**
     * Apply the routing rules to a FetchEvent object to get a Response from an
     * appropriate Route's handler.
     *
     * @param {Object***REMOVED*** options
     * @param {Request***REMOVED*** options.request The request to handle.
     * @param {ExtendableEvent***REMOVED*** options.event The event that triggered the
     *     request.
     * @return {Promise<Response>|undefined***REMOVED*** A promise is returned if a
     *     registered route can handle the request. If there is no matching
     *     route and there's no `defaultHandler`, `undefined` is returned.
     */
    handleRequest({ request, event, ***REMOVED***) {
        if (process.env.NODE_ENV !== 'production') {
            assert.isInstance(request, Request, {
                moduleName: 'workbox-routing',
                className: 'Router',
                funcName: 'handleRequest',
                paramName: 'options.request',
            ***REMOVED***);
        ***REMOVED***
        const url = new URL(request.url, location.href);
        if (!url.protocol.startsWith('http')) {
            if (process.env.NODE_ENV !== 'production') {
                logger.debug(`Workbox Router only supports URLs that start with 'http'.`);
            ***REMOVED***
            return;
        ***REMOVED***
        const sameOrigin = url.origin === location.origin;
        const { params, route ***REMOVED*** = this.findMatchingRoute({
            event,
            request,
            sameOrigin,
            url,
        ***REMOVED***);
        let handler = route && route.handler;
        const debugMessages = [];
        if (process.env.NODE_ENV !== 'production') {
            if (handler) {
                debugMessages.push([`Found a route to handle this request:`, route]);
                if (params) {
                    debugMessages.push([
                        `Passing the following params to the route's handler:`,
                        params,
                    ]);
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***
        // If we don't have a handler because there was no matching route, then
        // fall back to defaultHandler if that's defined.
        const method = request.method;
        if (!handler && this._defaultHandlerMap.has(method)) {
            if (process.env.NODE_ENV !== 'production') {
                debugMessages.push(`Failed to find a matching route. Falling ` +
                    `back to the default handler for ${method***REMOVED***.`);
            ***REMOVED***
            handler = this._defaultHandlerMap.get(method);
        ***REMOVED***
        if (!handler) {
            if (process.env.NODE_ENV !== 'production') {
                // No handler so Workbox will do nothing. If logs is set of debug
                // i.e. verbose, we should print out this information.
                logger.debug(`No route found for: ${getFriendlyURL(url)***REMOVED***`);
            ***REMOVED***
            return;
        ***REMOVED***
        if (process.env.NODE_ENV !== 'production') {
            // We have a handler, meaning Workbox is going to handle the route.
            // print the routing details to the console.
            logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)***REMOVED***`);
            debugMessages.forEach((msg) => {
                if (Array.isArray(msg)) {
                    logger.log(...msg);
                ***REMOVED***
                else {
                    logger.log(msg);
                ***REMOVED***
            ***REMOVED***);
            logger.groupEnd();
        ***REMOVED***
        // Wrap in try and catch in case the handle method throws a synchronous
        // error. It should still callback to the catch handler.
        let responsePromise;
        try {
            responsePromise = handler.handle({ url, request, event, params ***REMOVED***);
        ***REMOVED***
        catch (err) {
            responsePromise = Promise.reject(err);
        ***REMOVED***
        // Get route's catch handler, if it exists
        const catchHandler = route && route.catchHandler;
        if (responsePromise instanceof Promise &&
            (this._catchHandler || catchHandler)) {
            responsePromise = responsePromise.catch(async (err) => {
                // If there's a route catch handler, process that first
                if (catchHandler) {
                    if (process.env.NODE_ENV !== 'production') {
                        // Still include URL here as it will be async from the console group
                        // and may not make sense without the URL
                        logger.groupCollapsed(`Error thrown when responding to: ` +
                            ` ${getFriendlyURL(url)***REMOVED***. Falling back to route's Catch Handler.`);
                        logger.error(`Error thrown by:`, route);
                        logger.error(err);
                        logger.groupEnd();
                    ***REMOVED***
                    try {
                        return await catchHandler.handle({ url, request, event, params ***REMOVED***);
                    ***REMOVED***
                    catch (catchErr) {
                        if (catchErr instanceof Error) {
                            err = catchErr;
                        ***REMOVED***
                    ***REMOVED***
                ***REMOVED***
                if (this._catchHandler) {
                    if (process.env.NODE_ENV !== 'production') {
                        // Still include URL here as it will be async from the console group
                        // and may not make sense without the URL
                        logger.groupCollapsed(`Error thrown when responding to: ` +
                            ` ${getFriendlyURL(url)***REMOVED***. Falling back to global Catch Handler.`);
                        logger.error(`Error thrown by:`, route);
                        logger.error(err);
                        logger.groupEnd();
                    ***REMOVED***
                    return this._catchHandler.handle({ url, request, event ***REMOVED***);
                ***REMOVED***
                throw err;
            ***REMOVED***);
        ***REMOVED***
        return responsePromise;
    ***REMOVED***
    /**
     * Checks a request and URL (and optionally an event) against the list of
     * registered routes, and if there's a match, returns the corresponding
     * route along with any params generated by the match.
     *
     * @param {Object***REMOVED*** options
     * @param {URL***REMOVED*** options.url
     * @param {boolean***REMOVED*** options.sameOrigin The result of comparing `url.origin`
     *     against the current origin.
     * @param {Request***REMOVED*** options.request The request to match.
     * @param {Event***REMOVED*** options.event The corresponding event.
     * @return {Object***REMOVED*** An object with `route` and `params` properties.
     *     They are populated if a matching route was found or `undefined`
     *     otherwise.
     */
    findMatchingRoute({ url, sameOrigin, request, event, ***REMOVED***) {
        const routes = this._routes.get(request.method) || [];
        for (const route of routes) {
            let params;
            // route.match returns type any, not possible to change right now.
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            const matchResult = route.match({ url, sameOrigin, request, event ***REMOVED***);
            if (matchResult) {
                if (process.env.NODE_ENV !== 'production') {
                    // Warn developers that using an async matchCallback is almost always
                    // not the right thing to do.
                    if (matchResult instanceof Promise) {
                        logger.warn(`While routing ${getFriendlyURL(url)***REMOVED***, an async ` +
                            `matchCallback function was used. Please convert the ` +
                            `following route to use a synchronous matchCallback function:`, route);
                    ***REMOVED***
                ***REMOVED***
                // See https://github.com/GoogleChrome/workbox/issues/2079
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                params = matchResult;
                if (Array.isArray(params) && params.length === 0) {
                    // Instead of passing an empty array in as params, use undefined.
                    params = undefined;
                ***REMOVED***
                else if (matchResult.constructor === Object && // eslint-disable-line
                    Object.keys(matchResult).length === 0) {
                    // Instead of passing an empty object in as params, use undefined.
                    params = undefined;
                ***REMOVED***
                else if (typeof matchResult === 'boolean') {
                    // For the boolean value true (rather than just something truth-y),
                    // don't set params.
                    // See https://github.com/GoogleChrome/workbox/pull/2134#issuecomment-513924353
                    params = undefined;
                ***REMOVED***
                // Return early if have a match.
                return { route, params ***REMOVED***;
            ***REMOVED***
        ***REMOVED***
        // If no match was found above, return and empty object.
        return {***REMOVED***;
    ***REMOVED***
    /**
     * Define a default `handler` that's called when no routes explicitly
     * match the incoming request.
     *
     * Each HTTP method ('GET', 'POST', etc.) gets its own default handler.
     *
     * Without a default handler, unmatched requests will go against the
     * network as if there were no service worker present.
     *
     * @param {workbox-routing~handlerCallback***REMOVED*** handler A callback
     * function that returns a Promise resulting in a Response.
     * @param {string***REMOVED*** [method='GET'] The HTTP method to associate with this
     * default handler. Each method has its own default.
     */
    setDefaultHandler(handler, method = defaultMethod) {
        this._defaultHandlerMap.set(method, normalizeHandler(handler));
    ***REMOVED***
    /**
     * If a Route throws an error while handling a request, this `handler`
     * will be called and given a chance to provide a response.
     *
     * @param {workbox-routing~handlerCallback***REMOVED*** handler A callback
     * function that returns a Promise resulting in a Response.
     */
    setCatchHandler(handler) {
        this._catchHandler = normalizeHandler(handler);
    ***REMOVED***
    /**
     * Registers a route with the router.
     *
     * @param {workbox-routing.Route***REMOVED*** route The route to register.
     */
    registerRoute(route) {
        if (process.env.NODE_ENV !== 'production') {
            assert.isType(route, 'object', {
                moduleName: 'workbox-routing',
                className: 'Router',
                funcName: 'registerRoute',
                paramName: 'route',
            ***REMOVED***);
            assert.hasMethod(route, 'match', {
                moduleName: 'workbox-routing',
                className: 'Router',
                funcName: 'registerRoute',
                paramName: 'route',
            ***REMOVED***);
            assert.isType(route.handler, 'object', {
                moduleName: 'workbox-routing',
                className: 'Router',
                funcName: 'registerRoute',
                paramName: 'route',
            ***REMOVED***);
            assert.hasMethod(route.handler, 'handle', {
                moduleName: 'workbox-routing',
                className: 'Router',
                funcName: 'registerRoute',
                paramName: 'route.handler',
            ***REMOVED***);
            assert.isType(route.method, 'string', {
                moduleName: 'workbox-routing',
                className: 'Router',
                funcName: 'registerRoute',
                paramName: 'route.method',
            ***REMOVED***);
        ***REMOVED***
        if (!this._routes.has(route.method)) {
            this._routes.set(route.method, []);
        ***REMOVED***
        // Give precedence to all of the earlier routes by adding this additional
        // route to the end of the array.
        this._routes.get(route.method).push(route);
    ***REMOVED***
    /**
     * Unregisters a route with the router.
     *
     * @param {workbox-routing.Route***REMOVED*** route The route to unregister.
     */
    unregisterRoute(route) {
        if (!this._routes.has(route.method)) {
            throw new WorkboxError('unregister-route-but-not-found-with-method', {
                method: route.method,
            ***REMOVED***);
        ***REMOVED***
        const routeIndex = this._routes.get(route.method).indexOf(route);
        if (routeIndex > -1) {
            this._routes.get(route.method).splice(routeIndex, 1);
        ***REMOVED***
        else {
            throw new WorkboxError('unregister-route-route-not-registered');
        ***REMOVED***
    ***REMOVED***
***REMOVED***
export { Router ***REMOVED***;
