/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { LogType ***REMOVED*** = require("./Logger");

/** @typedef {import("../../declarations/WebpackOptions").FilterItemTypes***REMOVED*** FilterItemTypes */
/** @typedef {import("../../declarations/WebpackOptions").FilterTypes***REMOVED*** FilterTypes */
/** @typedef {import("./Logger").LogTypeEnum***REMOVED*** LogTypeEnum */

/** @typedef {(item: string) => boolean***REMOVED*** FilterFunction */
/** @typedef {(value: string, type: LogTypeEnum, args?: EXPECTED_ANY[]) => void***REMOVED*** LoggingFunction */

/**
 * @typedef {object***REMOVED*** LoggerConsole
 * @property {() => void***REMOVED*** clear
 * @property {() => void***REMOVED*** trace
 * @property {(...args: EXPECTED_ANY[]) => void***REMOVED*** info
 * @property {(...args: EXPECTED_ANY[]) => void***REMOVED*** log
 * @property {(...args: EXPECTED_ANY[]) => void***REMOVED*** warn
 * @property {(...args: EXPECTED_ANY[]) => void***REMOVED*** error
 * @property {(...args: EXPECTED_ANY[]) => void=***REMOVED*** debug
 * @property {(...args: EXPECTED_ANY[]) => void=***REMOVED*** group
 * @property {(...args: EXPECTED_ANY[]) => void=***REMOVED*** groupCollapsed
 * @property {(...args: EXPECTED_ANY[]) => void=***REMOVED*** groupEnd
 * @property {(...args: EXPECTED_ANY[]) => void=***REMOVED*** status
 * @property {(...args: EXPECTED_ANY[]) => void=***REMOVED*** profile
 * @property {(...args: EXPECTED_ANY[]) => void=***REMOVED*** profileEnd
 * @property {(...args: EXPECTED_ANY[]) => void=***REMOVED*** logTime
 */

/**
 * @typedef {object***REMOVED*** LoggerOptions
 * @property {false|true|"none"|"error"|"warn"|"info"|"log"|"verbose"***REMOVED*** level loglevel
 * @property {FilterTypes|boolean***REMOVED*** debug filter for debug logging
 * @property {LoggerConsole***REMOVED*** console the console to log to
 */

/**
 * @param {FilterItemTypes***REMOVED*** item an input item
 * @returns {FilterFunction | undefined***REMOVED*** filter function
 */
const filterToFunction = item => {
	if (typeof item === "string") {
		const regExp = new RegExp(
			`[\\\\/]${item.replace(/[-[\]{***REMOVED***()*+?.\\^$|]/g, "\\$&")***REMOVED***([\\\\/]|$|!|\\?)`
		);
		return ident => regExp.test(ident);
	***REMOVED***
	if (item && typeof item === "object" && typeof item.test === "function") {
		return ident => item.test(ident);
	***REMOVED***
	if (typeof item === "function") {
		return item;
	***REMOVED***
	if (typeof item === "boolean") {
		return () => item;
	***REMOVED***
***REMOVED***;

/**
 * @enum {number***REMOVED***
 */
const LogLevel = {
	none: 6,
	false: 6,
	error: 5,
	warn: 4,
	info: 3,
	log: 2,
	true: 2,
	verbose: 1
***REMOVED***;

/**
 * @param {LoggerOptions***REMOVED*** options options object
 * @returns {LoggingFunction***REMOVED*** logging function
 */
module.exports = ({ level = "info", debug = false, console ***REMOVED***) => {
	const debugFilters =
		/** @type {FilterFunction[]***REMOVED*** */
		(
			typeof debug === "boolean"
				? [() => debug]
				: /** @type {FilterItemTypes[]***REMOVED*** */ ([])
						.concat(debug)
						.map(filterToFunction)
		);
	const loglevel = LogLevel[`${level***REMOVED***`] || 0;

	/**
	 * @param {string***REMOVED*** name name of the logger
	 * @param {LogTypeEnum***REMOVED*** type type of the log entry
	 * @param {EXPECTED_ANY[]=***REMOVED*** args arguments of the log entry
	 * @returns {void***REMOVED***
	 */
	const logger = (name, type, args) => {
		const labeledArgs = () => {
			if (Array.isArray(args)) {
				if (args.length > 0 && typeof args[0] === "string") {
					return [`[${name***REMOVED***] ${args[0]***REMOVED***`, ...args.slice(1)];
				***REMOVED***
				return [`[${name***REMOVED***]`, ...args];
			***REMOVED***
			return [];
		***REMOVED***;
		const debug = debugFilters.some(f => f(name));
		switch (type) {
			case LogType.debug:
				if (!debug) return;
				if (typeof console.debug === "function") {
					console.debug(...labeledArgs());
				***REMOVED*** else {
					console.log(...labeledArgs());
				***REMOVED***
				break;
			case LogType.log:
				if (!debug && loglevel > LogLevel.log) return;
				console.log(...labeledArgs());
				break;
			case LogType.info:
				if (!debug && loglevel > LogLevel.info) return;
				console.info(...labeledArgs());
				break;
			case LogType.warn:
				if (!debug && loglevel > LogLevel.warn) return;
				console.warn(...labeledArgs());
				break;
			case LogType.error:
				if (!debug && loglevel > LogLevel.error) return;
				console.error(...labeledArgs());
				break;
			case LogType.trace:
				if (!debug) return;
				console.trace();
				break;
			case LogType.groupCollapsed:
				if (!debug && loglevel > LogLevel.log) return;
				if (!debug && loglevel > LogLevel.verbose) {
					if (typeof console.groupCollapsed === "function") {
						console.groupCollapsed(...labeledArgs());
					***REMOVED*** else {
						console.log(...labeledArgs());
					***REMOVED***
					break;
				***REMOVED***
			// falls through
			case LogType.group:
				if (!debug && loglevel > LogLevel.log) return;
				if (typeof console.group === "function") {
					console.group(...labeledArgs());
				***REMOVED*** else {
					console.log(...labeledArgs());
				***REMOVED***
				break;
			case LogType.groupEnd:
				if (!debug && loglevel > LogLevel.log) return;
				if (typeof console.groupEnd === "function") {
					console.groupEnd();
				***REMOVED***
				break;
			case LogType.time: {
				if (!debug && loglevel > LogLevel.log) return;
				const [label, start, end] =
					/** @type {[string, number, number]***REMOVED*** */
					(args);
				const ms = start * 1000 + end / 1000000;
				const msg = `[${name***REMOVED***] ${label***REMOVED***: ${ms***REMOVED*** ms`;
				if (typeof console.logTime === "function") {
					console.logTime(msg);
				***REMOVED*** else {
					console.log(msg);
				***REMOVED***
				break;
			***REMOVED***
			case LogType.profile:
				if (typeof console.profile === "function") {
					console.profile(...labeledArgs());
				***REMOVED***
				break;
			case LogType.profileEnd:
				if (typeof console.profileEnd === "function") {
					console.profileEnd(...labeledArgs());
				***REMOVED***
				break;
			case LogType.clear:
				if (!debug && loglevel > LogLevel.log) return;
				if (typeof console.clear === "function") {
					console.clear();
				***REMOVED***
				break;
			case LogType.status:
				if (!debug && loglevel > LogLevel.info) return;
				if (typeof console.status === "function") {
					if (!args || args.length === 0) {
						console.status();
					***REMOVED*** else {
						console.status(...labeledArgs());
					***REMOVED***
				***REMOVED*** else if (args && args.length !== 0) {
					console.info(...labeledArgs());
				***REMOVED***
				break;
			default:
				throw new Error(`Unexpected LogType ${type***REMOVED***`);
		***REMOVED***
	***REMOVED***;
	return logger;
***REMOVED***;
