import type {
  CodeKeywordDefinition,
  ErrorObject,
  KeywordErrorDefinition,
  SchemaObject,
***REMOVED*** from "../../types"
import type {KeywordCxt***REMOVED*** from "../../compile/validate"
import {propertyInData, allSchemaProperties, isOwnProperty***REMOVED*** from "../code"
import {alwaysValidSchema, schemaRefOrVal***REMOVED*** from "../../compile/util"
import {_, and, not, Code, Name***REMOVED*** from "../../compile/codegen"
import {checkMetadata***REMOVED*** from "./metadata"
import {checkNullableObject***REMOVED*** from "./nullable"
import {typeErrorMessage, typeErrorParams, _JTDTypeError***REMOVED*** from "./error"

enum PropError {
  Additional = "additional",
  Missing = "missing",
***REMOVED***

type PropKeyword = "properties" | "optionalProperties"

type PropSchema = {[P in string]?: SchemaObject***REMOVED***

export type JTDPropertiesError =
  | _JTDTypeError<PropKeyword, "object", PropSchema>
  | ErrorObject<PropKeyword, {error: PropError.Additional; additionalProperty: string***REMOVED***, PropSchema>
  | ErrorObject<PropKeyword, {error: PropError.Missing; missingProperty: string***REMOVED***, PropSchema>

export const error: KeywordErrorDefinition = {
  message: (cxt) => {
    const {params***REMOVED*** = cxt
    return params.propError
      ? params.propError === PropError.Additional
        ? "must NOT have additional properties"
        : `must have property '${params.missingProperty***REMOVED***'`
      : typeErrorMessage(cxt, "object")
  ***REMOVED***,
  params: (cxt) => {
    const {params***REMOVED*** = cxt
    return params.propError
      ? params.propError === PropError.Additional
        ? _`{error: ${params.propError***REMOVED***, additionalProperty: ${params.additionalProperty***REMOVED******REMOVED***`
        : _`{error: ${params.propError***REMOVED***, missingProperty: ${params.missingProperty***REMOVED******REMOVED***`
      : typeErrorParams(cxt, "object")
  ***REMOVED***,
***REMOVED***

const def: CodeKeywordDefinition = {
  keyword: "properties",
  schemaType: "object",
  error,
  code: validateProperties,
***REMOVED***

// const error: KeywordErrorDefinition = {
//   message: "should NOT have additional properties",
//   params: ({params***REMOVED***) => _`{additionalProperty: ${params.additionalProperty***REMOVED******REMOVED***`,
// ***REMOVED***

export function validateProperties(cxt: KeywordCxt): void {
  checkMetadata(cxt)
  const {gen, data, parentSchema, it***REMOVED*** = cxt
  const {additionalProperties, nullable***REMOVED*** = parentSchema
  if (it.jtdDiscriminator && nullable) throw new Error("JTD: nullable inside discriminator mapping")
  if (commonProperties()) {
    throw new Error("JTD: properties and optionalProperties have common members")
  ***REMOVED***
  const [allProps, properties] = schemaProperties("properties")
  const [allOptProps, optProperties] = schemaProperties("optionalProperties")
  if (properties.length === 0 && optProperties.length === 0 && additionalProperties) {
    return
  ***REMOVED***

  const [valid, cond] =
    it.jtdDiscriminator === undefined
      ? checkNullableObject(cxt, data)
      : [gen.let("valid", false), true]
  gen.if(cond, () =>
    gen.assign(valid, true).block(() => {
      validateProps(properties, "properties", true)
      validateProps(optProperties, "optionalProperties")
      if (!additionalProperties) validateAdditional()
    ***REMOVED***)
  )
  cxt.pass(valid)

  function commonProperties(): boolean {
    const props = parentSchema.properties as Record<string, any> | undefined
    const optProps = parentSchema.optionalProperties as Record<string, any> | undefined
    if (!(props && optProps)) return false
    for (const p in props) {
      if (Object.prototype.hasOwnProperty.call(optProps, p)) return true
    ***REMOVED***
    return false
  ***REMOVED***

  function schemaProperties(keyword: string): [string[], string[]] {
    const schema = parentSchema[keyword]
    const allPs = schema ? allSchemaProperties(schema) : []
    if (it.jtdDiscriminator && allPs.some((p) => p === it.jtdDiscriminator)) {
      throw new Error(`JTD: discriminator tag used in ${keyword***REMOVED***`)
    ***REMOVED***
    const ps = allPs.filter((p) => !alwaysValidSchema(it, schema[p]))
    return [allPs, ps]
  ***REMOVED***

  function validateProps(props: string[], keyword: string, required?: boolean): void {
    const _valid = gen.var("valid")
    for (const prop of props) {
      gen.if(
        propertyInData(gen, data, prop, it.opts.ownProperties),
        () => applyPropertySchema(prop, keyword, _valid),
        () => missingProperty(prop)
      )
      cxt.ok(_valid)
    ***REMOVED***

    function missingProperty(prop: string): void {
      if (required) {
        gen.assign(_valid, false)
        cxt.error(false, {propError: PropError.Missing, missingProperty: prop***REMOVED***, {schemaPath: prop***REMOVED***)
      ***REMOVED*** else {
        gen.assign(_valid, true)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  function applyPropertySchema(prop: string, keyword: string, _valid: Name): void {
    cxt.subschema(
      {
        keyword,
        schemaProp: prop,
        dataProp: prop,
      ***REMOVED***,
      _valid
    )
  ***REMOVED***

  function validateAdditional(): void {
    gen.forIn("key", data, (key: Name) => {
      const addProp = isAdditional(key, allProps, "properties", it.jtdDiscriminator)
      const addOptProp = isAdditional(key, allOptProps, "optionalProperties")
      const extra =
        addProp === true ? addOptProp : addOptProp === true ? addProp : and(addProp, addOptProp)
      gen.if(extra, () => {
        if (it.opts.removeAdditional) {
          gen.code(_`delete ${data***REMOVED***[${key***REMOVED***]`)
        ***REMOVED*** else {
          cxt.error(
            false,
            {propError: PropError.Additional, additionalProperty: key***REMOVED***,
            {instancePath: key, parentSchema: true***REMOVED***
          )
          if (!it.opts.allErrors) gen.break()
        ***REMOVED***
      ***REMOVED***)
    ***REMOVED***)
  ***REMOVED***

  function isAdditional(
    key: Name,
    props: string[],
    keyword: string,
    jtdDiscriminator?: string
  ): Code | true {
    let additional: Code | boolean
    if (props.length > 8) {
      // TODO maybe an option instead of hard-coded 8?
      const propsSchema = schemaRefOrVal(it, parentSchema[keyword], keyword)
      additional = not(isOwnProperty(gen, propsSchema as Code, key))
      if (jtdDiscriminator !== undefined) {
        additional = and(additional, _`${key***REMOVED*** !== ${jtdDiscriminator***REMOVED***`)
      ***REMOVED***
    ***REMOVED*** else if (props.length || jtdDiscriminator !== undefined) {
      const ps = jtdDiscriminator === undefined ? props : [jtdDiscriminator].concat(props)
      additional = and(...ps.map((p) => _`${key***REMOVED*** !== ${p***REMOVED***`))
    ***REMOVED*** else {
      additional = true
    ***REMOVED***
    return additional
  ***REMOVED***
***REMOVED***

export default def
