/**
 * @fileoverview A class of the code path.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const CodePathState = require("./code-path-state");
const IdGenerator = require("./id-generator");

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

/**
 * A code path.
 */
class CodePath {

    // eslint-disable-next-line jsdoc/require-description
    /**
     * @param {string***REMOVED*** id An identifier.
     * @param {CodePath|null***REMOVED*** upper The code path of the upper function scope.
     * @param {Function***REMOVED*** onLooped A callback function to notify looping.
     */
    constructor(id, upper, onLooped) {

        /**
         * The identifier of this code path.
         * Rules use it to store additional information of each rule.
         * @type {string***REMOVED***
         */
        this.id = id;

        /**
         * The code path of the upper function scope.
         * @type {CodePath|null***REMOVED***
         */
        this.upper = upper;

        /**
         * The code paths of nested function scopes.
         * @type {CodePath[]***REMOVED***
         */
        this.childCodePaths = [];

        // Initializes internal state.
        Object.defineProperty(
            this,
            "internal",
            { value: new CodePathState(new IdGenerator(`${id***REMOVED***_`), onLooped) ***REMOVED***
        );

        // Adds this into `childCodePaths` of `upper`.
        if (upper) {
            upper.childCodePaths.push(this);
        ***REMOVED***
    ***REMOVED***

    /**
     * Gets the state of a given code path.
     * @param {CodePath***REMOVED*** codePath A code path to get.
     * @returns {CodePathState***REMOVED*** The state of the code path.
     */
    static getState(codePath) {
        return codePath.internal;
    ***REMOVED***

    /**
     * The initial code path segment.
     * @type {CodePathSegment***REMOVED***
     */
    get initialSegment() {
        return this.internal.initialSegment;
    ***REMOVED***

    /**
     * Final code path segments.
     * This array is a mix of `returnedSegments` and `thrownSegments`.
     * @type {CodePathSegment[]***REMOVED***
     */
    get finalSegments() {
        return this.internal.finalSegments;
    ***REMOVED***

    /**
     * Final code path segments which is with `return` statements.
     * This array contains the last path segment if it's reachable.
     * Since the reachable last path returns `undefined`.
     * @type {CodePathSegment[]***REMOVED***
     */
    get returnedSegments() {
        return this.internal.returnedForkContext;
    ***REMOVED***

    /**
     * Final code path segments which is with `throw` statements.
     * @type {CodePathSegment[]***REMOVED***
     */
    get thrownSegments() {
        return this.internal.thrownForkContext;
    ***REMOVED***

    /**
     * Current code path segments.
     * @type {CodePathSegment[]***REMOVED***
     */
    get currentSegments() {
        return this.internal.currentSegments;
    ***REMOVED***

    /**
     * Traverses all segments in this code path.
     *
     *     codePath.traverseSegments(function(segment, controller) {
     *         // do something.
     *     ***REMOVED***);
     *
     * This method enumerates segments in order from the head.
     *
     * The `controller` object has two methods.
     *
     * - `controller.skip()` - Skip the following segments in this branch.
     * - `controller.break()` - Skip all following segments.
     * @param {Object***REMOVED*** [options] Omittable.
     * @param {CodePathSegment***REMOVED*** [options.first] The first segment to traverse.
     * @param {CodePathSegment***REMOVED*** [options.last] The last segment to traverse.
     * @param {Function***REMOVED*** callback A callback function.
     * @returns {void***REMOVED***
     */
    traverseSegments(options, callback) {
        let resolvedOptions;
        let resolvedCallback;

        if (typeof options === "function") {
            resolvedCallback = options;
            resolvedOptions = {***REMOVED***;
        ***REMOVED*** else {
            resolvedOptions = options || {***REMOVED***;
            resolvedCallback = callback;
        ***REMOVED***

        const startSegment = resolvedOptions.first || this.internal.initialSegment;
        const lastSegment = resolvedOptions.last;

        let item = null;
        let index = 0;
        let end = 0;
        let segment = null;
        const visited = Object.create(null);
        const stack = [[startSegment, 0]];
        let skippedSegment = null;
        let broken = false;
        const controller = {
            skip() {
                if (stack.length <= 1) {
                    broken = true;
                ***REMOVED*** else {
                    skippedSegment = stack[stack.length - 2][0];
                ***REMOVED***
            ***REMOVED***,
            break() {
                broken = true;
            ***REMOVED***
        ***REMOVED***;

        /**
         * Checks a given previous segment has been visited.
         * @param {CodePathSegment***REMOVED*** prevSegment A previous segment to check.
         * @returns {boolean***REMOVED*** `true` if the segment has been visited.
         */
        function isVisited(prevSegment) {
            return (
                visited[prevSegment.id] ||
                segment.isLoopedPrevSegment(prevSegment)
            );
        ***REMOVED***

        while (stack.length > 0) {
            item = stack[stack.length - 1];
            segment = item[0];
            index = item[1];

            if (index === 0) {

                // Skip if this segment has been visited already.
                if (visited[segment.id]) {
                    stack.pop();
                    continue;
                ***REMOVED***

                // Skip if all previous segments have not been visited.
                if (segment !== startSegment &&
                    segment.prevSegments.length > 0 &&
                    !segment.prevSegments.every(isVisited)
                ) {
                    stack.pop();
                    continue;
                ***REMOVED***

                // Reset the flag of skipping if all branches have been skipped.
                if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {
                    skippedSegment = null;
                ***REMOVED***
                visited[segment.id] = true;

                // Call the callback when the first time.
                if (!skippedSegment) {
                    resolvedCallback.call(this, segment, controller);
                    if (segment === lastSegment) {
                        controller.skip();
                    ***REMOVED***
                    if (broken) {
                        break;
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***

            // Update the stack.
            end = segment.nextSegments.length - 1;
            if (index < end) {
                item[1] += 1;
                stack.push([segment.nextSegments[index], 0]);
            ***REMOVED*** else if (index === end) {
                item[0] = segment.nextSegments[index];
                item[1] = 0;
            ***REMOVED*** else {
                stack.pop();
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***
***REMOVED***

module.exports = CodePath;
