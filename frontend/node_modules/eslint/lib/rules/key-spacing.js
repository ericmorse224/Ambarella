/**
 * @fileoverview Rule to specify spacing of object literal keys and values
 * @author Brandon Mills
 * @deprecated in ESLint v8.53.0
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");
const { getGraphemeCount ***REMOVED*** = require("../shared/string-utils");

/**
 * Checks whether a string contains a line terminator as defined in
 * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3
 * @param {string***REMOVED*** str String to test.
 * @returns {boolean***REMOVED*** True if str contains a line terminator.
 */
function containsLineTerminator(str) {
    return astUtils.LINEBREAK_MATCHER.test(str);
***REMOVED***

/**
 * Gets the last element of an array.
 * @param {Array***REMOVED*** arr An array.
 * @returns {any***REMOVED*** Last element of arr.
 */
function last(arr) {
    return arr[arr.length - 1];
***REMOVED***

/**
 * Checks whether a node is contained on a single line.
 * @param {ASTNode***REMOVED*** node AST Node being evaluated.
 * @returns {boolean***REMOVED*** True if the node is a single line.
 */
function isSingleLine(node) {
    return (node.loc.end.line === node.loc.start.line);
***REMOVED***

/**
 * Checks whether the properties on a single line.
 * @param {ASTNode[]***REMOVED*** properties List of Property AST nodes.
 * @returns {boolean***REMOVED*** True if all properties is on a single line.
 */
function isSingleLineProperties(properties) {
    const [firstProp] = properties,
        lastProp = last(properties);

    return firstProp.loc.start.line === lastProp.loc.end.line;
***REMOVED***

/**
 * Initializes a single option property from the configuration with defaults for undefined values
 * @param {Object***REMOVED*** toOptions Object to be initialized
 * @param {Object***REMOVED*** fromOptions Object to be initialized from
 * @returns {Object***REMOVED*** The object with correctly initialized options and values
 */
function initOptionProperty(toOptions, fromOptions) {
    toOptions.mode = fromOptions.mode || "strict";

    // Set value of beforeColon
    if (typeof fromOptions.beforeColon !== "undefined") {
        toOptions.beforeColon = +fromOptions.beforeColon;
    ***REMOVED*** else {
        toOptions.beforeColon = 0;
    ***REMOVED***

    // Set value of afterColon
    if (typeof fromOptions.afterColon !== "undefined") {
        toOptions.afterColon = +fromOptions.afterColon;
    ***REMOVED*** else {
        toOptions.afterColon = 1;
    ***REMOVED***

    // Set align if exists
    if (typeof fromOptions.align !== "undefined") {
        if (typeof fromOptions.align === "object") {
            toOptions.align = fromOptions.align;
        ***REMOVED*** else { // "string"
            toOptions.align = {
                on: fromOptions.align,
                mode: toOptions.mode,
                beforeColon: toOptions.beforeColon,
                afterColon: toOptions.afterColon
            ***REMOVED***;
        ***REMOVED***
    ***REMOVED***

    return toOptions;
***REMOVED***

/**
 * Initializes all the option values (singleLine, multiLine and align) from the configuration with defaults for undefined values
 * @param {Object***REMOVED*** toOptions Object to be initialized
 * @param {Object***REMOVED*** fromOptions Object to be initialized from
 * @returns {Object***REMOVED*** The object with correctly initialized options and values
 */
function initOptions(toOptions, fromOptions) {
    if (typeof fromOptions.align === "object") {

        // Initialize the alignment configuration
        toOptions.align = initOptionProperty({***REMOVED***, fromOptions.align);
        toOptions.align.on = fromOptions.align.on || "colon";
        toOptions.align.mode = fromOptions.align.mode || "strict";

        toOptions.multiLine = initOptionProperty({***REMOVED***, (fromOptions.multiLine || fromOptions));
        toOptions.singleLine = initOptionProperty({***REMOVED***, (fromOptions.singleLine || fromOptions));

    ***REMOVED*** else { // string or undefined
        toOptions.multiLine = initOptionProperty({***REMOVED***, (fromOptions.multiLine || fromOptions));
        toOptions.singleLine = initOptionProperty({***REMOVED***, (fromOptions.singleLine || fromOptions));

        // If alignment options are defined in multiLine, pull them out into the general align configuration
        if (toOptions.multiLine.align) {
            toOptions.align = {
                on: toOptions.multiLine.align.on,
                mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,
                beforeColon: toOptions.multiLine.align.beforeColon,
                afterColon: toOptions.multiLine.align.afterColon
            ***REMOVED***;
        ***REMOVED***
    ***REMOVED***

    return toOptions;
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../shared/types').Rule***REMOVED*** */
module.exports = {
    meta: {
        deprecated: true,
        replacedBy: [],
        type: "layout",

        docs: {
            description: "Enforce consistent spacing between keys and values in object literal properties",
            recommended: false,
            url: "https://eslint.org/docs/latest/rules/key-spacing"
        ***REMOVED***,

        fixable: "whitespace",

        schema: [{
            anyOf: [
                {
                    type: "object",
                    properties: {
                        align: {
                            anyOf: [
                                {
                                    enum: ["colon", "value"]
                                ***REMOVED***,
                                {
                                    type: "object",
                                    properties: {
                                        mode: {
                                            enum: ["strict", "minimum"]
                                        ***REMOVED***,
                                        on: {
                                            enum: ["colon", "value"]
                                        ***REMOVED***,
                                        beforeColon: {
                                            type: "boolean"
                                        ***REMOVED***,
                                        afterColon: {
                                            type: "boolean"
                                        ***REMOVED***
                                    ***REMOVED***,
                                    additionalProperties: false
                                ***REMOVED***
                            ]
                        ***REMOVED***,
                        mode: {
                            enum: ["strict", "minimum"]
                        ***REMOVED***,
                        beforeColon: {
                            type: "boolean"
                        ***REMOVED***,
                        afterColon: {
                            type: "boolean"
                        ***REMOVED***
                    ***REMOVED***,
                    additionalProperties: false
                ***REMOVED***,
                {
                    type: "object",
                    properties: {
                        singleLine: {
                            type: "object",
                            properties: {
                                mode: {
                                    enum: ["strict", "minimum"]
                                ***REMOVED***,
                                beforeColon: {
                                    type: "boolean"
                                ***REMOVED***,
                                afterColon: {
                                    type: "boolean"
                                ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***,
                        multiLine: {
                            type: "object",
                            properties: {
                                align: {
                                    anyOf: [
                                        {
                                            enum: ["colon", "value"]
                                        ***REMOVED***,
                                        {
                                            type: "object",
                                            properties: {
                                                mode: {
                                                    enum: ["strict", "minimum"]
                                                ***REMOVED***,
                                                on: {
                                                    enum: ["colon", "value"]
                                                ***REMOVED***,
                                                beforeColon: {
                                                    type: "boolean"
                                                ***REMOVED***,
                                                afterColon: {
                                                    type: "boolean"
                                                ***REMOVED***
                                            ***REMOVED***,
                                            additionalProperties: false
                                        ***REMOVED***
                                    ]
                                ***REMOVED***,
                                mode: {
                                    enum: ["strict", "minimum"]
                                ***REMOVED***,
                                beforeColon: {
                                    type: "boolean"
                                ***REMOVED***,
                                afterColon: {
                                    type: "boolean"
                                ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***
                    ***REMOVED***,
                    additionalProperties: false
                ***REMOVED***,
                {
                    type: "object",
                    properties: {
                        singleLine: {
                            type: "object",
                            properties: {
                                mode: {
                                    enum: ["strict", "minimum"]
                                ***REMOVED***,
                                beforeColon: {
                                    type: "boolean"
                                ***REMOVED***,
                                afterColon: {
                                    type: "boolean"
                                ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***,
                        multiLine: {
                            type: "object",
                            properties: {
                                mode: {
                                    enum: ["strict", "minimum"]
                                ***REMOVED***,
                                beforeColon: {
                                    type: "boolean"
                                ***REMOVED***,
                                afterColon: {
                                    type: "boolean"
                                ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***,
                        align: {
                            type: "object",
                            properties: {
                                mode: {
                                    enum: ["strict", "minimum"]
                                ***REMOVED***,
                                on: {
                                    enum: ["colon", "value"]
                                ***REMOVED***,
                                beforeColon: {
                                    type: "boolean"
                                ***REMOVED***,
                                afterColon: {
                                    type: "boolean"
                                ***REMOVED***
                            ***REMOVED***,
                            additionalProperties: false
                        ***REMOVED***
                    ***REMOVED***,
                    additionalProperties: false
                ***REMOVED***
            ]
        ***REMOVED***],
        messages: {
            extraKey: "Extra space after {{computed***REMOVED******REMOVED***key '{{key***REMOVED******REMOVED***'.",
            extraValue: "Extra space before value for {{computed***REMOVED******REMOVED***key '{{key***REMOVED******REMOVED***'.",
            missingKey: "Missing space after {{computed***REMOVED******REMOVED***key '{{key***REMOVED******REMOVED***'.",
            missingValue: "Missing space before value for {{computed***REMOVED******REMOVED***key '{{key***REMOVED******REMOVED***'."
        ***REMOVED***
    ***REMOVED***,

    create(context) {

        /**
         * OPTIONS
         * "key-spacing": [2, {
         *     beforeColon: false,
         *     afterColon: true,
         *     align: "colon" // Optional, or "value"
         * ***REMOVED***
         */
        const options = context.options[0] || {***REMOVED***,
            ruleOptions = initOptions({***REMOVED***, options),
            multiLineOptions = ruleOptions.multiLine,
            singleLineOptions = ruleOptions.singleLine,
            alignmentOptions = ruleOptions.align || null;

        const sourceCode = context.sourceCode;

        /**
         * Determines if the given property is key-value property.
         * @param {ASTNode***REMOVED*** property Property node to check.
         * @returns {boolean***REMOVED*** Whether the property is a key-value property.
         */
        function isKeyValueProperty(property) {
            return !(
                (property.method ||
                property.shorthand ||
                property.kind !== "init" || property.type !== "Property") // Could be "ExperimentalSpreadProperty" or "SpreadElement"
            );
        ***REMOVED***

        /**
         * Starting from the given node (a property.key node here) looks forward
         * until it finds the colon punctuator and returns it.
         * @param {ASTNode***REMOVED*** node The node to start looking from.
         * @returns {ASTNode***REMOVED*** The colon punctuator.
         */
        function getNextColon(node) {
            return sourceCode.getTokenAfter(node, astUtils.isColonToken);
        ***REMOVED***

        /**
         * Starting from the given node (a property.key node here) looks forward
         * until it finds the last token before a colon punctuator and returns it.
         * @param {ASTNode***REMOVED*** node The node to start looking from.
         * @returns {ASTNode***REMOVED*** The last token before a colon punctuator.
         */
        function getLastTokenBeforeColon(node) {
            const colonToken = getNextColon(node);

            return sourceCode.getTokenBefore(colonToken);
        ***REMOVED***

        /**
         * Starting from the given node (a property.key node here) looks forward
         * until it finds the first token after a colon punctuator and returns it.
         * @param {ASTNode***REMOVED*** node The node to start looking from.
         * @returns {ASTNode***REMOVED*** The first token after a colon punctuator.
         */
        function getFirstTokenAfterColon(node) {
            const colonToken = getNextColon(node);

            return sourceCode.getTokenAfter(colonToken);
        ***REMOVED***

        /**
         * Checks whether a property is a member of the property group it follows.
         * @param {ASTNode***REMOVED*** lastMember The last Property known to be in the group.
         * @param {ASTNode***REMOVED*** candidate The next Property that might be in the group.
         * @returns {boolean***REMOVED*** True if the candidate property is part of the group.
         */
        function continuesPropertyGroup(lastMember, candidate) {
            const groupEndLine = lastMember.loc.start.line,
                candidateValueStartLine = (isKeyValueProperty(candidate) ? getFirstTokenAfterColon(candidate.key) : candidate).loc.start.line;

            if (candidateValueStartLine - groupEndLine <= 1) {
                return true;
            ***REMOVED***

            /*
             * Check that the first comment is adjacent to the end of the group, the
             * last comment is adjacent to the candidate property, and that successive
             * comments are adjacent to each other.
             */
            const leadingComments = sourceCode.getCommentsBefore(candidate);

            if (
                leadingComments.length &&
                leadingComments[0].loc.start.line - groupEndLine <= 1 &&
                candidateValueStartLine - last(leadingComments).loc.end.line <= 1
            ) {
                for (let i = 1; i < leadingComments.length; i++) {
                    if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {
                        return false;
                    ***REMOVED***
                ***REMOVED***
                return true;
            ***REMOVED***

            return false;
        ***REMOVED***

        /**
         * Gets an object literal property's key as the identifier name or string value.
         * @param {ASTNode***REMOVED*** property Property node whose key to retrieve.
         * @returns {string***REMOVED*** The property's key.
         */
        function getKey(property) {
            const key = property.key;

            if (property.computed) {
                return sourceCode.getText().slice(key.range[0], key.range[1]);
            ***REMOVED***
            return astUtils.getStaticPropertyName(property);
        ***REMOVED***

        /**
         * Reports an appropriately-formatted error if spacing is incorrect on one
         * side of the colon.
         * @param {ASTNode***REMOVED*** property Key-value pair in an object literal.
         * @param {string***REMOVED*** side Side being verified - either "key" or "value".
         * @param {string***REMOVED*** whitespace Actual whitespace string.
         * @param {int***REMOVED*** expected Expected whitespace length.
         * @param {string***REMOVED*** mode Value of the mode as "strict" or "minimum"
         * @returns {void***REMOVED***
         */
        function report(property, side, whitespace, expected, mode) {
            const diff = whitespace.length - expected;

            if ((
                diff && mode === "strict" ||
                diff < 0 && mode === "minimum" ||
                diff > 0 && !expected && mode === "minimum") &&
                !(expected && containsLineTerminator(whitespace))
            ) {
                const nextColon = getNextColon(property.key),
                    tokenBeforeColon = sourceCode.getTokenBefore(nextColon, { includeComments: true ***REMOVED***),
                    tokenAfterColon = sourceCode.getTokenAfter(nextColon, { includeComments: true ***REMOVED***),
                    isKeySide = side === "key",
                    isExtra = diff > 0,
                    diffAbs = Math.abs(diff),
                    spaces = Array(diffAbs + 1).join(" ");

                const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;
                const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;
                const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;
                const loc = isExtra ? { start: locStart, end: locEnd ***REMOVED*** : missingLoc;

                let fix;

                if (isExtra) {
                    let range;

                    // Remove whitespace
                    if (isKeySide) {
                        range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];
                    ***REMOVED*** else {
                        range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];
                    ***REMOVED***
                    fix = function(fixer) {
                        return fixer.removeRange(range);
                    ***REMOVED***;
                ***REMOVED*** else {

                    // Add whitespace
                    if (isKeySide) {
                        fix = function(fixer) {
                            return fixer.insertTextAfter(tokenBeforeColon, spaces);
                        ***REMOVED***;
                    ***REMOVED*** else {
                        fix = function(fixer) {
                            return fixer.insertTextBefore(tokenAfterColon, spaces);
                        ***REMOVED***;
                    ***REMOVED***
                ***REMOVED***

                let messageId = "";

                if (isExtra) {
                    messageId = side === "key" ? "extraKey" : "extraValue";
                ***REMOVED*** else {
                    messageId = side === "key" ? "missingKey" : "missingValue";
                ***REMOVED***

                context.report({
                    node: property[side],
                    loc,
                    messageId,
                    data: {
                        computed: property.computed ? "computed " : "",
                        key: getKey(property)
                    ***REMOVED***,
                    fix
                ***REMOVED***);
            ***REMOVED***
        ***REMOVED***

        /**
         * Gets the number of characters in a key, including quotes around string
         * keys and braces around computed property keys.
         * @param {ASTNode***REMOVED*** property Property of on object literal.
         * @returns {int***REMOVED*** Width of the key.
         */
        function getKeyWidth(property) {
            const startToken = sourceCode.getFirstToken(property);
            const endToken = getLastTokenBeforeColon(property.key);

            return getGraphemeCount(sourceCode.getText().slice(startToken.range[0], endToken.range[1]));
        ***REMOVED***

        /**
         * Gets the whitespace around the colon in an object literal property.
         * @param {ASTNode***REMOVED*** property Property node from an object literal.
         * @returns {Object***REMOVED*** Whitespace before and after the property's colon.
         */
        function getPropertyWhitespace(property) {
            const whitespace = /(\s*):(\s*)/u.exec(sourceCode.getText().slice(
                property.key.range[1], property.value.range[0]
            ));

            if (whitespace) {
                return {
                    beforeColon: whitespace[1],
                    afterColon: whitespace[2]
                ***REMOVED***;
            ***REMOVED***
            return null;
        ***REMOVED***

        /**
         * Creates groups of properties.
         * @param {ASTNode***REMOVED*** node ObjectExpression node being evaluated.
         * @returns {Array<ASTNode[]>***REMOVED*** Groups of property AST node lists.
         */
        function createGroups(node) {
            if (node.properties.length === 1) {
                return [node.properties];
            ***REMOVED***

            return node.properties.reduce((groups, property) => {
                const currentGroup = last(groups),
                    prev = last(currentGroup);

                if (!prev || continuesPropertyGroup(prev, property)) {
                    currentGroup.push(property);
                ***REMOVED*** else {
                    groups.push([property]);
                ***REMOVED***

                return groups;
            ***REMOVED***, [
                []
            ]);
        ***REMOVED***

        /**
         * Verifies correct vertical alignment of a group of properties.
         * @param {ASTNode[]***REMOVED*** properties List of Property AST nodes.
         * @returns {void***REMOVED***
         */
        function verifyGroupAlignment(properties) {
            const length = properties.length,
                widths = properties.map(getKeyWidth), // Width of keys, including quotes
                align = alignmentOptions.on; // "value" or "colon"
            let targetWidth = Math.max(...widths),
                beforeColon, afterColon, mode;

            if (alignmentOptions && length > 1) { // When aligning values within a group, use the alignment configuration.
                beforeColon = alignmentOptions.beforeColon;
                afterColon = alignmentOptions.afterColon;
                mode = alignmentOptions.mode;
            ***REMOVED*** else {
                beforeColon = multiLineOptions.beforeColon;
                afterColon = multiLineOptions.afterColon;
                mode = alignmentOptions.mode;
            ***REMOVED***

            // Conditionally include one space before or after colon
            targetWidth += (align === "colon" ? beforeColon : afterColon);

            for (let i = 0; i < length; i++) {
                const property = properties[i];
                const whitespace = getPropertyWhitespace(property);

                if (whitespace) { // Object literal getters/setters lack a colon
                    const width = widths[i];

                    if (align === "value") {
                        report(property, "key", whitespace.beforeColon, beforeColon, mode);
                        report(property, "value", whitespace.afterColon, targetWidth - width, mode);
                    ***REMOVED*** else { // align = "colon"
                        report(property, "key", whitespace.beforeColon, targetWidth - width, mode);
                        report(property, "value", whitespace.afterColon, afterColon, mode);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        /**
         * Verifies spacing of property conforms to specified options.
         * @param {ASTNode***REMOVED*** node Property node being evaluated.
         * @param {Object***REMOVED*** lineOptions Configured singleLine or multiLine options
         * @returns {void***REMOVED***
         */
        function verifySpacing(node, lineOptions) {
            const actual = getPropertyWhitespace(node);

            if (actual) { // Object literal getters/setters lack colons
                report(node, "key", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);
                report(node, "value", actual.afterColon, lineOptions.afterColon, lineOptions.mode);
            ***REMOVED***
        ***REMOVED***

        /**
         * Verifies spacing of each property in a list.
         * @param {ASTNode[]***REMOVED*** properties List of Property AST nodes.
         * @param {Object***REMOVED*** lineOptions Configured singleLine or multiLine options
         * @returns {void***REMOVED***
         */
        function verifyListSpacing(properties, lineOptions) {
            const length = properties.length;

            for (let i = 0; i < length; i++) {
                verifySpacing(properties[i], lineOptions);
            ***REMOVED***
        ***REMOVED***

        /**
         * Verifies vertical alignment, taking into account groups of properties.
         * @param {ASTNode***REMOVED*** node ObjectExpression node being evaluated.
         * @returns {void***REMOVED***
         */
        function verifyAlignment(node) {
            createGroups(node).forEach(group => {
                const properties = group.filter(isKeyValueProperty);

                if (properties.length > 0 && isSingleLineProperties(properties)) {
                    verifyListSpacing(properties, multiLineOptions);
                ***REMOVED*** else {
                    verifyGroupAlignment(properties);
                ***REMOVED***
            ***REMOVED***);
        ***REMOVED***

        //--------------------------------------------------------------------------
        // Public API
        //--------------------------------------------------------------------------

        if (alignmentOptions) { // Verify vertical alignment

            return {
                ObjectExpression(node) {
                    if (isSingleLine(node)) {
                        verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);
                    ***REMOVED*** else {
                        verifyAlignment(node);
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***;

        ***REMOVED***

        // Obey beforeColon and afterColon in each property as configured
        return {
            Property(node) {
                verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);
            ***REMOVED***
        ***REMOVED***;


    ***REMOVED***
***REMOVED***;
