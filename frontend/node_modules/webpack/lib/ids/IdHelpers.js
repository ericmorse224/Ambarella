/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const createHash = require("../util/createHash");
const { makePathsRelative ***REMOVED*** = require("../util/identifier");
const numberHash = require("../util/numberHash");

/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {typeof import("../util/Hash")***REMOVED*** Hash */
/** @typedef {import("../util/identifier").AssociatedObjectForCache***REMOVED*** AssociatedObjectForCache */

/**
 * @param {string***REMOVED*** str string to hash
 * @param {number***REMOVED*** len max length of the hash
 * @param {string | Hash***REMOVED*** hashFunction hash function to use
 * @returns {string***REMOVED*** hash
 */
const getHash = (str, len, hashFunction) => {
	const hash = createHash(hashFunction);
	hash.update(str);
	const digest = /** @type {string***REMOVED*** */ (hash.digest("hex"));
	return digest.slice(0, len);
***REMOVED***;

/**
 * @param {string***REMOVED*** str the string
 * @returns {string***REMOVED*** string prefixed by an underscore if it is a number
 */
const avoidNumber = str => {
	// max length of a number is 21 chars, bigger numbers a written as "...e+xx"
	if (str.length > 21) return str;
	const firstChar = str.charCodeAt(0);
	// skip everything that doesn't look like a number
	// charCodes: "-": 45, "1": 49, "9": 57
	if (firstChar < 49) {
		if (firstChar !== 45) return str;
	***REMOVED*** else if (firstChar > 57) {
		return str;
	***REMOVED***
	if (str === String(Number(str))) {
		return `_${str***REMOVED***`;
	***REMOVED***
	return str;
***REMOVED***;

/**
 * @param {string***REMOVED*** request the request
 * @returns {string***REMOVED*** id representation
 */
const requestToId = request =>
	request.replace(/^(\.\.?\/)+/, "").replace(/(^[.-]|[^a-zA-Z0-9_-])+/g, "_");
module.exports.requestToId = requestToId;

/**
 * @param {string***REMOVED*** string the string
 * @param {string***REMOVED*** delimiter separator for string and hash
 * @param {string | Hash***REMOVED*** hashFunction hash function to use
 * @returns {string***REMOVED*** string with limited max length to 100 chars
 */
const shortenLongString = (string, delimiter, hashFunction) => {
	if (string.length < 100) return string;
	return (
		string.slice(0, 100 - 6 - delimiter.length) +
		delimiter +
		getHash(string, 6, hashFunction)
	);
***REMOVED***;

/**
 * @param {Module***REMOVED*** module the module
 * @param {string***REMOVED*** context context directory
 * @param {AssociatedObjectForCache=***REMOVED*** associatedObjectForCache an object to which the cache will be attached
 * @returns {string***REMOVED*** short module name
 */
const getShortModuleName = (module, context, associatedObjectForCache) => {
	const libIdent = module.libIdent({ context, associatedObjectForCache ***REMOVED***);
	if (libIdent) return avoidNumber(libIdent);
	const nameForCondition = module.nameForCondition();
	if (nameForCondition)
		return avoidNumber(
			makePathsRelative(context, nameForCondition, associatedObjectForCache)
		);
	return "";
***REMOVED***;
module.exports.getShortModuleName = getShortModuleName;

/**
 * @param {string***REMOVED*** shortName the short name
 * @param {Module***REMOVED*** module the module
 * @param {string***REMOVED*** context context directory
 * @param {string | Hash***REMOVED*** hashFunction hash function to use
 * @param {AssociatedObjectForCache=***REMOVED*** associatedObjectForCache an object to which the cache will be attached
 * @returns {string***REMOVED*** long module name
 */
const getLongModuleName = (
	shortName,
	module,
	context,
	hashFunction,
	associatedObjectForCache
) => {
	const fullName = getFullModuleName(module, context, associatedObjectForCache);
	return `${shortName***REMOVED***?${getHash(fullName, 4, hashFunction)***REMOVED***`;
***REMOVED***;
module.exports.getLongModuleName = getLongModuleName;

/**
 * @param {Module***REMOVED*** module the module
 * @param {string***REMOVED*** context context directory
 * @param {AssociatedObjectForCache=***REMOVED*** associatedObjectForCache an object to which the cache will be attached
 * @returns {string***REMOVED*** full module name
 */
const getFullModuleName = (module, context, associatedObjectForCache) =>
	makePathsRelative(context, module.identifier(), associatedObjectForCache);
module.exports.getFullModuleName = getFullModuleName;

/**
 * @param {Chunk***REMOVED*** chunk the chunk
 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @param {string***REMOVED*** context context directory
 * @param {string***REMOVED*** delimiter delimiter for names
 * @param {string | Hash***REMOVED*** hashFunction hash function to use
 * @param {AssociatedObjectForCache=***REMOVED*** associatedObjectForCache an object to which the cache will be attached
 * @returns {string***REMOVED*** short chunk name
 */
const getShortChunkName = (
	chunk,
	chunkGraph,
	context,
	delimiter,
	hashFunction,
	associatedObjectForCache
) => {
	const modules = chunkGraph.getChunkRootModules(chunk);
	const shortModuleNames = modules.map(m =>
		requestToId(getShortModuleName(m, context, associatedObjectForCache))
	);
	chunk.idNameHints.sort();
	const chunkName = Array.from(chunk.idNameHints)
		.concat(shortModuleNames)
		.filter(Boolean)
		.join(delimiter);
	return shortenLongString(chunkName, delimiter, hashFunction);
***REMOVED***;
module.exports.getShortChunkName = getShortChunkName;

/**
 * @param {Chunk***REMOVED*** chunk the chunk
 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @param {string***REMOVED*** context context directory
 * @param {string***REMOVED*** delimiter delimiter for names
 * @param {string | Hash***REMOVED*** hashFunction hash function to use
 * @param {AssociatedObjectForCache=***REMOVED*** associatedObjectForCache an object to which the cache will be attached
 * @returns {string***REMOVED*** short chunk name
 */
const getLongChunkName = (
	chunk,
	chunkGraph,
	context,
	delimiter,
	hashFunction,
	associatedObjectForCache
) => {
	const modules = chunkGraph.getChunkRootModules(chunk);
	const shortModuleNames = modules.map(m =>
		requestToId(getShortModuleName(m, context, associatedObjectForCache))
	);
	const longModuleNames = modules.map(m =>
		requestToId(
			getLongModuleName("", m, context, hashFunction, associatedObjectForCache)
		)
	);
	chunk.idNameHints.sort();
	const chunkName = Array.from(chunk.idNameHints)
		.concat(shortModuleNames, longModuleNames)
		.filter(Boolean)
		.join(delimiter);
	return shortenLongString(chunkName, delimiter, hashFunction);
***REMOVED***;
module.exports.getLongChunkName = getLongChunkName;

/**
 * @param {Chunk***REMOVED*** chunk the chunk
 * @param {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @param {string***REMOVED*** context context directory
 * @param {AssociatedObjectForCache=***REMOVED*** associatedObjectForCache an object to which the cache will be attached
 * @returns {string***REMOVED*** full chunk name
 */
const getFullChunkName = (
	chunk,
	chunkGraph,
	context,
	associatedObjectForCache
) => {
	if (chunk.name) return chunk.name;
	const modules = chunkGraph.getChunkRootModules(chunk);
	const fullModuleNames = modules.map(m =>
		makePathsRelative(context, m.identifier(), associatedObjectForCache)
	);
	return fullModuleNames.join();
***REMOVED***;
module.exports.getFullChunkName = getFullChunkName;

/**
 * @template K
 * @template V
 * @param {Map<K, V[]>***REMOVED*** map a map from key to values
 * @param {K***REMOVED*** key key
 * @param {V***REMOVED*** value value
 * @returns {void***REMOVED***
 */
const addToMapOfItems = (map, key, value) => {
	let array = map.get(key);
	if (array === undefined) {
		array = [];
		map.set(key, array);
	***REMOVED***
	array.push(value);
***REMOVED***;

/**
 * @param {Compilation***REMOVED*** compilation the compilation
 * @param {((module: Module) => boolean)=***REMOVED*** filter filter modules
 * @returns {[Set<string>, Module[]]***REMOVED*** used module ids as strings and modules without id matching the filter
 */
const getUsedModuleIdsAndModules = (compilation, filter) => {
	const chunkGraph = compilation.chunkGraph;

	const modules = [];

	/** @type {Set<string>***REMOVED*** */
	const usedIds = new Set();
	if (compilation.usedModuleIds) {
		for (const id of compilation.usedModuleIds) {
			usedIds.add(String(id));
		***REMOVED***
	***REMOVED***

	for (const module of compilation.modules) {
		if (!module.needId) continue;
		const moduleId = chunkGraph.getModuleId(module);
		if (moduleId !== null) {
			usedIds.add(String(moduleId));
		***REMOVED*** else if (
			(!filter || filter(module)) &&
			chunkGraph.getNumberOfModuleChunks(module) !== 0
		) {
			modules.push(module);
		***REMOVED***
	***REMOVED***

	return [usedIds, modules];
***REMOVED***;
module.exports.getUsedModuleIdsAndModules = getUsedModuleIdsAndModules;

/**
 * @param {Compilation***REMOVED*** compilation the compilation
 * @returns {Set<string>***REMOVED*** used chunk ids as strings
 */
const getUsedChunkIds = compilation => {
	/** @type {Set<string>***REMOVED*** */
	const usedIds = new Set();
	if (compilation.usedChunkIds) {
		for (const id of compilation.usedChunkIds) {
			usedIds.add(String(id));
		***REMOVED***
	***REMOVED***

	for (const chunk of compilation.chunks) {
		const chunkId = chunk.id;
		if (chunkId !== null) {
			usedIds.add(String(chunkId));
		***REMOVED***
	***REMOVED***

	return usedIds;
***REMOVED***;
module.exports.getUsedChunkIds = getUsedChunkIds;

/**
 * @template T
 * @param {Iterable<T>***REMOVED*** items list of items to be named
 * @param {(item: T) => string***REMOVED*** getShortName get a short name for an item
 * @param {(item: T, name: string) => string***REMOVED*** getLongName get a long name for an item
 * @param {(a: T, b: T) => -1 | 0 | 1***REMOVED*** comparator order of items
 * @param {Set<string>***REMOVED*** usedIds already used ids, will not be assigned
 * @param {(item: T, name: string) => void***REMOVED*** assignName assign a name to an item
 * @returns {T[]***REMOVED*** list of items without a name
 */
const assignNames = (
	items,
	getShortName,
	getLongName,
	comparator,
	usedIds,
	assignName
) => {
	/** @type {Map<string, T[]>***REMOVED*** */
	const nameToItems = new Map();

	for (const item of items) {
		const name = getShortName(item);
		addToMapOfItems(nameToItems, name, item);
	***REMOVED***

	/** @type {Map<string, T[]>***REMOVED*** */
	const nameToItems2 = new Map();

	for (const [name, items] of nameToItems) {
		if (items.length > 1 || !name) {
			for (const item of items) {
				const longName = getLongName(item, name);
				addToMapOfItems(nameToItems2, longName, item);
			***REMOVED***
		***REMOVED*** else {
			addToMapOfItems(nameToItems2, name, items[0]);
		***REMOVED***
	***REMOVED***

	/** @type {T[]***REMOVED*** */
	const unnamedItems = [];

	for (const [name, items] of nameToItems2) {
		if (!name) {
			for (const item of items) {
				unnamedItems.push(item);
			***REMOVED***
		***REMOVED*** else if (items.length === 1 && !usedIds.has(name)) {
			assignName(items[0], name);
			usedIds.add(name);
		***REMOVED*** else {
			items.sort(comparator);
			let i = 0;
			for (const item of items) {
				while (nameToItems2.has(name + i) && usedIds.has(name + i)) i++;
				assignName(item, name + i);
				usedIds.add(name + i);
				i++;
			***REMOVED***
		***REMOVED***
	***REMOVED***

	unnamedItems.sort(comparator);
	return unnamedItems;
***REMOVED***;
module.exports.assignNames = assignNames;

/**
 * @template T
 * @param {T[]***REMOVED*** items list of items to be named
 * @param {(item: T) => string***REMOVED*** getName get a name for an item
 * @param {(a: T, n: T) => -1 | 0 | 1***REMOVED*** comparator order of items
 * @param {(item: T, id: number) => boolean***REMOVED*** assignId assign an id to an item
 * @param {number[]***REMOVED*** ranges usable ranges for ids
 * @param {number***REMOVED*** expandFactor factor to create more ranges
 * @param {number***REMOVED*** extraSpace extra space to allocate, i. e. when some ids are already used
 * @param {number***REMOVED*** salt salting number to initialize hashing
 * @returns {void***REMOVED***
 */
const assignDeterministicIds = (
	items,
	getName,
	comparator,
	assignId,
	ranges = [10],
	expandFactor = 10,
	extraSpace = 0,
	salt = 0
) => {
	items.sort(comparator);

	// max 5% fill rate
	const optimalRange = Math.min(
		items.length * 20 + extraSpace,
		Number.MAX_SAFE_INTEGER
	);

	let i = 0;
	let range = ranges[i];
	while (range < optimalRange) {
		i++;
		if (i < ranges.length) {
			range = Math.min(ranges[i], Number.MAX_SAFE_INTEGER);
		***REMOVED*** else if (expandFactor) {
			range = Math.min(range * expandFactor, Number.MAX_SAFE_INTEGER);
		***REMOVED*** else {
			break;
		***REMOVED***
	***REMOVED***

	for (const item of items) {
		const ident = getName(item);
		let id;
		let i = salt;
		do {
			id = numberHash(ident + i++, range);
		***REMOVED*** while (!assignId(item, id));
	***REMOVED***
***REMOVED***;
module.exports.assignDeterministicIds = assignDeterministicIds;

/**
 * @param {Set<string>***REMOVED*** usedIds used ids
 * @param {Iterable<Module>***REMOVED*** modules the modules
 * @param {Compilation***REMOVED*** compilation the compilation
 * @returns {void***REMOVED***
 */
const assignAscendingModuleIds = (usedIds, modules, compilation) => {
	const chunkGraph = compilation.chunkGraph;

	let nextId = 0;
	let assignId;
	if (usedIds.size > 0) {
		/**
		 * @param {Module***REMOVED*** module the module
		 */
		assignId = module => {
			if (chunkGraph.getModuleId(module) === null) {
				while (usedIds.has(String(nextId))) nextId++;
				chunkGraph.setModuleId(module, nextId++);
			***REMOVED***
		***REMOVED***;
	***REMOVED*** else {
		/**
		 * @param {Module***REMOVED*** module the module
		 */
		assignId = module => {
			if (chunkGraph.getModuleId(module) === null) {
				chunkGraph.setModuleId(module, nextId++);
			***REMOVED***
		***REMOVED***;
	***REMOVED***
	for (const module of modules) {
		assignId(module);
	***REMOVED***
***REMOVED***;
module.exports.assignAscendingModuleIds = assignAscendingModuleIds;

/**
 * @param {Iterable<Chunk>***REMOVED*** chunks the chunks
 * @param {Compilation***REMOVED*** compilation the compilation
 * @returns {void***REMOVED***
 */
const assignAscendingChunkIds = (chunks, compilation) => {
	const usedIds = getUsedChunkIds(compilation);

	let nextId = 0;
	if (usedIds.size > 0) {
		for (const chunk of chunks) {
			if (chunk.id === null) {
				while (usedIds.has(String(nextId))) nextId++;
				chunk.id = nextId;
				chunk.ids = [nextId];
				nextId++;
			***REMOVED***
		***REMOVED***
	***REMOVED*** else {
		for (const chunk of chunks) {
			if (chunk.id === null) {
				chunk.id = nextId;
				chunk.ids = [nextId];
				nextId++;
			***REMOVED***
		***REMOVED***
	***REMOVED***
***REMOVED***;
module.exports.assignAscendingChunkIds = assignAscendingChunkIds;
