"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.hasSideEffects = exports.containsLeap = void 0;
var _assert = require("assert");
var _util = require("./util.js");
const mMap = new WeakMap();
function m(node) {
  if (!mMap.has(node)) {
    mMap.set(node, {***REMOVED***);
  ***REMOVED***
  return mMap.get(node);
***REMOVED***
const hasOwn = Object.prototype.hasOwnProperty;
function makePredicate(propertyName, knownTypes) {
  function onlyChildren(node) {
    const t = (0, _util.getTypes)();
    t.assertNode(node);
    let result = false;
    function check(child) {
      if (result) {***REMOVED*** else if (Array.isArray(child)) {
        child.some(check);
      ***REMOVED*** else if (t.isNode(child)) {
        _assert.strictEqual(result, false);
        result = predicate(child);
      ***REMOVED***
      return result;
    ***REMOVED***
    const keys = t.VISITOR_KEYS[node.type];
    if (keys) {
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const child = node[key];
        check(child);
      ***REMOVED***
    ***REMOVED***
    return result;
  ***REMOVED***
  function predicate(node) {
    (0, _util.getTypes)().assertNode(node);
    const meta = m(node);
    if (hasOwn.call(meta, propertyName)) return meta[propertyName];
    if (hasOwn.call(opaqueTypes, node.type)) return meta[propertyName] = false;
    if (hasOwn.call(knownTypes, node.type)) return meta[propertyName] = true;
    return meta[propertyName] = onlyChildren(node);
  ***REMOVED***
  predicate.onlyChildren = onlyChildren;
  return predicate;
***REMOVED***
const opaqueTypes = {
  FunctionExpression: true,
  ArrowFunctionExpression: true
***REMOVED***;
const sideEffectTypes = {
  CallExpression: true,
  ForInStatement: true,
  UnaryExpression: true,
  BinaryExpression: true,
  AssignmentExpression: true,
  UpdateExpression: true,
  NewExpression: true
***REMOVED***;
const leapTypes = {
  YieldExpression: true,
  BreakStatement: true,
  ContinueStatement: true,
  ReturnStatement: true,
  ThrowStatement: true
***REMOVED***;
for (const type in leapTypes) {
  if (hasOwn.call(leapTypes, type)) {
    sideEffectTypes[type] = leapTypes[type];
  ***REMOVED***
***REMOVED***
const hasSideEffects = exports.hasSideEffects = makePredicate("hasSideEffects", sideEffectTypes);
const containsLeap = exports.containsLeap = makePredicate("containsLeap", leapTypes);

//# sourceMappingURL=meta.js.map
