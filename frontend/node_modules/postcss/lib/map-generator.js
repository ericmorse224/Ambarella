'use strict'

let { dirname, relative, resolve, sep ***REMOVED*** = require('path')
let { SourceMapConsumer, SourceMapGenerator ***REMOVED*** = require('source-map-js')
let { pathToFileURL ***REMOVED*** = require('url')

let Input = require('./input')

let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)
let pathAvailable = Boolean(dirname && resolve && relative && sep)

class MapGenerator {
  constructor(stringify, root, opts, cssString) {
    this.stringify = stringify
    this.mapOpts = opts.map || {***REMOVED***
    this.root = root
    this.opts = opts
    this.css = cssString
    this.originalCSS = cssString
    this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute

    this.memoizedFileURLs = new Map()
    this.memoizedPaths = new Map()
    this.memoizedURLs = new Map()
  ***REMOVED***

  addAnnotation() {
    let content

    if (this.isInline()) {
      content =
        'data:application/json;base64,' + this.toBase64(this.map.toString())
    ***REMOVED*** else if (typeof this.mapOpts.annotation === 'string') {
      content = this.mapOpts.annotation
    ***REMOVED*** else if (typeof this.mapOpts.annotation === 'function') {
      content = this.mapOpts.annotation(this.opts.to, this.root)
    ***REMOVED*** else {
      content = this.outputFile() + '.map'
    ***REMOVED***
    let eol = '\n'
    if (this.css.includes('\r\n')) eol = '\r\n'

    this.css += eol + '/*# sourceMappingURL=' + content + ' */'
  ***REMOVED***

  applyPrevMaps() {
    for (let prev of this.previous()) {
      let from = this.toUrl(this.path(prev.file))
      let root = prev.root || dirname(prev.file)
      let map

      if (this.mapOpts.sourcesContent === false) {
        map = new SourceMapConsumer(prev.text)
        if (map.sourcesContent) {
          map.sourcesContent = null
        ***REMOVED***
      ***REMOVED*** else {
        map = prev.consumer()
      ***REMOVED***

      this.map.applySourceMap(map, from, this.toUrl(this.path(root)))
    ***REMOVED***
  ***REMOVED***

  clearAnnotation() {
    if (this.mapOpts.annotation === false) return

    if (this.root) {
      let node
      for (let i = this.root.nodes.length - 1; i >= 0; i--) {
        node = this.root.nodes[i]
        if (node.type !== 'comment') continue
        if (node.text.startsWith('# sourceMappingURL=')) {
          this.root.removeChild(i)
        ***REMOVED***
      ***REMOVED***
    ***REMOVED*** else if (this.css) {
      this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, '')
    ***REMOVED***
  ***REMOVED***

  generate() {
    this.clearAnnotation()
    if (pathAvailable && sourceMapAvailable && this.isMap()) {
      return this.generateMap()
    ***REMOVED*** else {
      let result = ''
      this.stringify(this.root, i => {
        result += i
      ***REMOVED***)
      return [result]
    ***REMOVED***
  ***REMOVED***

  generateMap() {
    if (this.root) {
      this.generateString()
    ***REMOVED*** else if (this.previous().length === 1) {
      let prev = this.previous()[0].consumer()
      prev.file = this.outputFile()
      this.map = SourceMapGenerator.fromSourceMap(prev, {
        ignoreInvalidMapping: true
      ***REMOVED***)
    ***REMOVED*** else {
      this.map = new SourceMapGenerator({
        file: this.outputFile(),
        ignoreInvalidMapping: true
      ***REMOVED***)
      this.map.addMapping({
        generated: { column: 0, line: 1 ***REMOVED***,
        original: { column: 0, line: 1 ***REMOVED***,
        source: this.opts.from
          ? this.toUrl(this.path(this.opts.from))
          : '<no source>'
      ***REMOVED***)
    ***REMOVED***

    if (this.isSourcesContent()) this.setSourcesContent()
    if (this.root && this.previous().length > 0) this.applyPrevMaps()
    if (this.isAnnotation()) this.addAnnotation()

    if (this.isInline()) {
      return [this.css]
    ***REMOVED*** else {
      return [this.css, this.map]
    ***REMOVED***
  ***REMOVED***

  generateString() {
    this.css = ''
    this.map = new SourceMapGenerator({
      file: this.outputFile(),
      ignoreInvalidMapping: true
    ***REMOVED***)

    let line = 1
    let column = 1

    let noSource = '<no source>'
    let mapping = {
      generated: { column: 0, line: 0 ***REMOVED***,
      original: { column: 0, line: 0 ***REMOVED***,
      source: ''
    ***REMOVED***

    let last, lines
    this.stringify(this.root, (str, node, type) => {
      this.css += str

      if (node && type !== 'end') {
        mapping.generated.line = line
        mapping.generated.column = column - 1
        if (node.source && node.source.start) {
          mapping.source = this.sourcePath(node)
          mapping.original.line = node.source.start.line
          mapping.original.column = node.source.start.column - 1
          this.map.addMapping(mapping)
        ***REMOVED*** else {
          mapping.source = noSource
          mapping.original.line = 1
          mapping.original.column = 0
          this.map.addMapping(mapping)
        ***REMOVED***
      ***REMOVED***

      lines = str.match(/\n/g)
      if (lines) {
        line += lines.length
        last = str.lastIndexOf('\n')
        column = str.length - last
      ***REMOVED*** else {
        column += str.length
      ***REMOVED***

      if (node && type !== 'start') {
        let p = node.parent || { raws: {***REMOVED*** ***REMOVED***
        let childless =
          node.type === 'decl' || (node.type === 'atrule' && !node.nodes)
        if (!childless || node !== p.last || p.raws.semicolon) {
          if (node.source && node.source.end) {
            mapping.source = this.sourcePath(node)
            mapping.original.line = node.source.end.line
            mapping.original.column = node.source.end.column - 1
            mapping.generated.line = line
            mapping.generated.column = column - 2
            this.map.addMapping(mapping)
          ***REMOVED*** else {
            mapping.source = noSource
            mapping.original.line = 1
            mapping.original.column = 0
            mapping.generated.line = line
            mapping.generated.column = column - 1
            this.map.addMapping(mapping)
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***)
  ***REMOVED***

  isAnnotation() {
    if (this.isInline()) {
      return true
    ***REMOVED***
    if (typeof this.mapOpts.annotation !== 'undefined') {
      return this.mapOpts.annotation
    ***REMOVED***
    if (this.previous().length) {
      return this.previous().some(i => i.annotation)
    ***REMOVED***
    return true
  ***REMOVED***

  isInline() {
    if (typeof this.mapOpts.inline !== 'undefined') {
      return this.mapOpts.inline
    ***REMOVED***

    let annotation = this.mapOpts.annotation
    if (typeof annotation !== 'undefined' && annotation !== true) {
      return false
    ***REMOVED***

    if (this.previous().length) {
      return this.previous().some(i => i.inline)
    ***REMOVED***
    return true
  ***REMOVED***

  isMap() {
    if (typeof this.opts.map !== 'undefined') {
      return !!this.opts.map
    ***REMOVED***
    return this.previous().length > 0
  ***REMOVED***

  isSourcesContent() {
    if (typeof this.mapOpts.sourcesContent !== 'undefined') {
      return this.mapOpts.sourcesContent
    ***REMOVED***
    if (this.previous().length) {
      return this.previous().some(i => i.withContent())
    ***REMOVED***
    return true
  ***REMOVED***

  outputFile() {
    if (this.opts.to) {
      return this.path(this.opts.to)
    ***REMOVED*** else if (this.opts.from) {
      return this.path(this.opts.from)
    ***REMOVED*** else {
      return 'to.css'
    ***REMOVED***
  ***REMOVED***

  path(file) {
    if (this.mapOpts.absolute) return file
    if (file.charCodeAt(0) === 60 /* `<` */) return file
    if (/^\w+:\/\//.test(file)) return file
    let cached = this.memoizedPaths.get(file)
    if (cached) return cached

    let from = this.opts.to ? dirname(this.opts.to) : '.'

    if (typeof this.mapOpts.annotation === 'string') {
      from = dirname(resolve(from, this.mapOpts.annotation))
    ***REMOVED***

    let path = relative(from, file)
    this.memoizedPaths.set(file, path)

    return path
  ***REMOVED***

  previous() {
    if (!this.previousMaps) {
      this.previousMaps = []
      if (this.root) {
        this.root.walk(node => {
          if (node.source && node.source.input.map) {
            let map = node.source.input.map
            if (!this.previousMaps.includes(map)) {
              this.previousMaps.push(map)
            ***REMOVED***
          ***REMOVED***
        ***REMOVED***)
      ***REMOVED*** else {
        let input = new Input(this.originalCSS, this.opts)
        if (input.map) this.previousMaps.push(input.map)
      ***REMOVED***
    ***REMOVED***

    return this.previousMaps
  ***REMOVED***

  setSourcesContent() {
    let already = {***REMOVED***
    if (this.root) {
      this.root.walk(node => {
        if (node.source) {
          let from = node.source.input.from
          if (from && !already[from]) {
            already[from] = true
            let fromUrl = this.usesFileUrls
              ? this.toFileUrl(from)
              : this.toUrl(this.path(from))
            this.map.setSourceContent(fromUrl, node.source.input.css)
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***)
    ***REMOVED*** else if (this.css) {
      let from = this.opts.from
        ? this.toUrl(this.path(this.opts.from))
        : '<no source>'
      this.map.setSourceContent(from, this.css)
    ***REMOVED***
  ***REMOVED***

  sourcePath(node) {
    if (this.mapOpts.from) {
      return this.toUrl(this.mapOpts.from)
    ***REMOVED*** else if (this.usesFileUrls) {
      return this.toFileUrl(node.source.input.from)
    ***REMOVED*** else {
      return this.toUrl(this.path(node.source.input.from))
    ***REMOVED***
  ***REMOVED***

  toBase64(str) {
    if (Buffer) {
      return Buffer.from(str).toString('base64')
    ***REMOVED*** else {
      return window.btoa(unescape(encodeURIComponent(str)))
    ***REMOVED***
  ***REMOVED***

  toFileUrl(path) {
    let cached = this.memoizedFileURLs.get(path)
    if (cached) return cached

    if (pathToFileURL) {
      let fileURL = pathToFileURL(path).toString()
      this.memoizedFileURLs.set(path, fileURL)

      return fileURL
    ***REMOVED*** else {
      throw new Error(
        '`map.absolute` option is not available in this PostCSS build'
      )
    ***REMOVED***
  ***REMOVED***

  toUrl(path) {
    let cached = this.memoizedURLs.get(path)
    if (cached) return cached

    if (sep === '\\') {
      path = path.replace(/\\/g, '/')
    ***REMOVED***

    let url = encodeURI(path).replace(/[#?]/g, encodeURIComponent)
    this.memoizedURLs.set(path, url)

    return url
  ***REMOVED***
***REMOVED***

module.exports = MapGenerator
