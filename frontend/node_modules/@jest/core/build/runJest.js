'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
***REMOVED***);
exports.default = runJest;

function path() {
  const data = _interopRequireWildcard(require('path'));

  path = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

function _chalk() {
  const data = _interopRequireDefault(require('chalk'));

  _chalk = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

function _exit() {
  const data = _interopRequireDefault(require('exit'));

  _exit = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

function fs() {
  const data = _interopRequireWildcard(require('graceful-fs'));

  fs = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

function _console() {
  const data = require('@jest/console');

  _console = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

function _testResult() {
  const data = require('@jest/test-result');

  _testResult = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

function _jestResolve() {
  const data = _interopRequireDefault(require('jest-resolve'));

  _jestResolve = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

function _jestUtil() {
  const data = require('jest-util');

  _jestUtil = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

function _jestWatcher() {
  const data = require('jest-watcher');

  _jestWatcher = function () {
    return data;
  ***REMOVED***;

  return data;
***REMOVED***

var _SearchSource = _interopRequireDefault(require('./SearchSource'));

var _TestScheduler = require('./TestScheduler');

var _collectHandles = _interopRequireDefault(require('./collectHandles'));

var _getNoTestsFoundMessage = _interopRequireDefault(
  require('./getNoTestsFoundMessage')
);

var _runGlobalHook = _interopRequireDefault(require('./runGlobalHook'));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj***REMOVED***;
***REMOVED***

function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== 'function') return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  ***REMOVED***)(nodeInterop);
***REMOVED***

function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  ***REMOVED***
  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
    return {default: obj***REMOVED***;
  ***REMOVED***
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  ***REMOVED***
  var newObj = {***REMOVED***;
  var hasPropertyDescriptor =
    Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor
        ? Object.getOwnPropertyDescriptor(obj, key)
        : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      ***REMOVED*** else {
        newObj[key] = obj[key];
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  ***REMOVED***
  return newObj;
***REMOVED***

/**
 * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
const getTestPaths = async (
  globalConfig,
  source,
  outputStream,
  changedFiles,
  jestHooks,
  filter
) => {
  const data = await source.getTestPaths(globalConfig, changedFiles, filter);

  if (!data.tests.length && globalConfig.onlyChanged && data.noSCM) {
    new (_console().CustomConsole)(outputStream, outputStream).log(
      'Jest can only find uncommitted changed files in a git or hg ' +
        'repository. If you make your project a git or hg ' +
        'repository (`git init` or `hg init`), Jest will be able ' +
        'to only run tests related to files changed since the last ' +
        'commit.'
    );
  ***REMOVED***

  const shouldTestArray = await Promise.all(
    data.tests.map(test =>
      jestHooks.shouldRunTestSuite({
        config: test.context.config,
        duration: test.duration,
        testPath: test.path
      ***REMOVED***)
    )
  );
  const filteredTests = data.tests.filter((_test, i) => shouldTestArray[i]);
  return {...data, allTests: filteredTests.length, tests: filteredTests***REMOVED***;
***REMOVED***;

const processResults = async (runResults, options) => {
  const {
    outputFile,
    json: isJSON,
    onComplete,
    outputStream,
    testResultsProcessor,
    collectHandles
  ***REMOVED*** = options;

  if (collectHandles) {
    runResults.openHandles = await collectHandles();
  ***REMOVED*** else {
    runResults.openHandles = [];
  ***REMOVED***

  if (testResultsProcessor) {
    const processor = await (0, _jestUtil().requireOrImportModule)(
      testResultsProcessor
    );
    runResults = processor(runResults);
  ***REMOVED***

  if (isJSON) {
    if (outputFile) {
      const cwd = (0, _jestUtil().tryRealpath)(process.cwd());
      const filePath = path().resolve(cwd, outputFile);
      fs().writeFileSync(
        filePath,
        JSON.stringify((0, _testResult().formatTestResults)(runResults))
      );
      outputStream.write(
        `Test results written to: ${path().relative(cwd, filePath)***REMOVED***\n`
      );
    ***REMOVED*** else {
      process.stdout.write(
        JSON.stringify((0, _testResult().formatTestResults)(runResults))
      );
    ***REMOVED***
  ***REMOVED***

  onComplete === null || onComplete === void 0
    ? void 0
    : onComplete(runResults);
***REMOVED***;

const testSchedulerContext = {
  firstRun: true,
  previousSuccess: true
***REMOVED***;

async function runJest({
  contexts,
  globalConfig,
  outputStream,
  testWatcher,
  jestHooks = new (_jestWatcher().JestHook)().getEmitter(),
  startRun,
  changedFilesPromise,
  onComplete,
  failedTestsCache,
  filter
***REMOVED***) {
  // Clear cache for required modules - there might be different resolutions
  // from Jest's config loading to running the tests
  _jestResolve().default.clearDefaultResolverCache();

  const Sequencer = await (0, _jestUtil().requireOrImportModule)(
    globalConfig.testSequencer
  );
  const sequencer = new Sequencer();
  let allTests = [];

  if (changedFilesPromise && globalConfig.watch) {
    const {repos***REMOVED*** = await changedFilesPromise;
    const noSCM = Object.keys(repos).every(scm => repos[scm].size === 0);

    if (noSCM) {
      process.stderr.write(
        '\n' +
          _chalk().default.bold('--watch') +
          ' is not supported without git/hg, please use --watchAll ' +
          '\n'
      );
      (0, _exit().default)(1);
    ***REMOVED***
  ***REMOVED***

  const searchSources = contexts.map(
    context => new _SearchSource.default(context)
  );
  const testRunData = await Promise.all(
    contexts.map(async (context, index) => {
      const searchSource = searchSources[index];
      const matches = await getTestPaths(
        globalConfig,
        searchSource,
        outputStream,
        changedFilesPromise && (await changedFilesPromise),
        jestHooks,
        filter
      );
      allTests = allTests.concat(matches.tests);
      return {
        context,
        matches
      ***REMOVED***;
    ***REMOVED***)
  );
  allTests = await sequencer.sort(allTests);

  if (globalConfig.listTests) {
    const testsPaths = Array.from(new Set(allTests.map(test => test.path)));
    /* eslint-disable no-console */

    if (globalConfig.json) {
      console.log(JSON.stringify(testsPaths));
    ***REMOVED*** else {
      console.log(testsPaths.join('\n'));
    ***REMOVED***
    /* eslint-enable */

    onComplete &&
      onComplete((0, _testResult().makeEmptyAggregatedTestResult)());
    return;
  ***REMOVED***

  if (globalConfig.onlyFailures) {
    if (failedTestsCache) {
      allTests = failedTestsCache.filterTests(allTests);
    ***REMOVED*** else {
      allTests = await sequencer.allFailedTests(allTests);
    ***REMOVED***
  ***REMOVED***

  const hasTests = allTests.length > 0;

  if (!hasTests) {
    const noTestsFoundMessage = (0, _getNoTestsFoundMessage.default)(
      testRunData,
      globalConfig
    );

    if (
      globalConfig.passWithNoTests ||
      globalConfig.findRelatedTests ||
      globalConfig.lastCommit ||
      globalConfig.onlyChanged
    ) {
      new (_console().CustomConsole)(outputStream, outputStream).log(
        noTestsFoundMessage
      );
    ***REMOVED*** else {
      new (_console().CustomConsole)(outputStream, outputStream).error(
        noTestsFoundMessage
      );
      (0, _exit().default)(1);
    ***REMOVED***
  ***REMOVED*** else if (
    allTests.length === 1 &&
    globalConfig.silent !== true &&
    globalConfig.verbose !== false
  ) {
    const newConfig = {...globalConfig, verbose: true***REMOVED***;
    globalConfig = Object.freeze(newConfig);
  ***REMOVED***

  let collectHandles;

  if (globalConfig.detectOpenHandles) {
    collectHandles = (0, _collectHandles.default)();
  ***REMOVED***

  if (hasTests) {
    await (0, _runGlobalHook.default)({
      allTests,
      globalConfig,
      moduleName: 'globalSetup'
    ***REMOVED***);
  ***REMOVED***

  if (changedFilesPromise) {
    const changedFilesInfo = await changedFilesPromise;

    if (changedFilesInfo.changedFiles) {
      testSchedulerContext.changedFiles = changedFilesInfo.changedFiles;
      const sourcesRelatedToTestsInChangedFilesArray = (
        await Promise.all(
          contexts.map(async (_, index) => {
            const searchSource = searchSources[index];
            return searchSource.findRelatedSourcesFromTestsInChangedFiles(
              changedFilesInfo
            );
          ***REMOVED***)
        )
      ).reduce((total, paths) => total.concat(paths), []);
      testSchedulerContext.sourcesRelatedToTestsInChangedFiles = new Set(
        sourcesRelatedToTestsInChangedFilesArray
      );
    ***REMOVED***
  ***REMOVED***

  const scheduler = await (0, _TestScheduler.createTestScheduler)(
    globalConfig,
    {
      startRun
    ***REMOVED***,
    testSchedulerContext
  );
  const results = await scheduler.scheduleTests(allTests, testWatcher);
  await sequencer.cacheResults(allTests, results);

  if (hasTests) {
    await (0, _runGlobalHook.default)({
      allTests,
      globalConfig,
      moduleName: 'globalTeardown'
    ***REMOVED***);
  ***REMOVED***

  await processResults(results, {
    collectHandles,
    json: globalConfig.json,
    onComplete,
    outputFile: globalConfig.outputFile,
    outputStream,
    testResultsProcessor: globalConfig.testResultsProcessor
  ***REMOVED***);
***REMOVED***
