'use strict';

/**
 * @typedef {import('./types').XastNode***REMOVED*** XastNode
 * @typedef {import('./types').XastChild***REMOVED*** XastChild
 * @typedef {import('./types').XastParent***REMOVED*** XastParent
 * @typedef {import('./types').Visitor***REMOVED*** Visitor
 */

const { selectAll, selectOne, is ***REMOVED*** = require('css-select');
const xastAdaptor = require('./svgo/css-select-adapter.js');

const cssSelectOptions = {
  xmlMode: true,
  adapter: xastAdaptor,
***REMOVED***;

/**
 * @type {(node: XastNode, selector: string) => Array<XastChild>***REMOVED***
 */
const querySelectorAll = (node, selector) => {
  return selectAll(selector, node, cssSelectOptions);
***REMOVED***;
exports.querySelectorAll = querySelectorAll;

/**
 * @type {(node: XastNode, selector: string) => null | XastChild***REMOVED***
 */
const querySelector = (node, selector) => {
  return selectOne(selector, node, cssSelectOptions);
***REMOVED***;
exports.querySelector = querySelector;

/**
 * @type {(node: XastChild, selector: string) => boolean***REMOVED***
 */
const matches = (node, selector) => {
  return is(node, selector, cssSelectOptions);
***REMOVED***;
exports.matches = matches;

/**
 * @type {(node: XastChild, name: string) => null | XastChild***REMOVED***
 */
const closestByName = (node, name) => {
  let currentNode = node;
  while (currentNode) {
    if (currentNode.type === 'element' && currentNode.name === name) {
      return currentNode;
    ***REMOVED***
    // @ts-ignore parentNode is hidden from public usage
    currentNode = currentNode.parentNode;
  ***REMOVED***
  return null;
***REMOVED***;
exports.closestByName = closestByName;

const visitSkip = Symbol();
exports.visitSkip = visitSkip;

/**
 * @type {(node: XastNode, visitor: Visitor, parentNode?: any) => void***REMOVED***
 */
const visit = (node, visitor, parentNode) => {
  const callbacks = visitor[node.type];
  if (callbacks && callbacks.enter) {
    // @ts-ignore hard to infer
    const symbol = callbacks.enter(node, parentNode);
    if (symbol === visitSkip) {
      return;
    ***REMOVED***
  ***REMOVED***
  // visit root children
  if (node.type === 'root') {
    // copy children array to not loose cursor when children is spliced
    for (const child of node.children) {
      visit(child, visitor, node);
    ***REMOVED***
  ***REMOVED***
  // visit element children if still attached to parent
  if (node.type === 'element') {
    if (parentNode.children.includes(node)) {
      for (const child of node.children) {
        visit(child, visitor, node);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  if (callbacks && callbacks.exit) {
    // @ts-ignore hard to infer
    callbacks.exit(node, parentNode);
  ***REMOVED***
***REMOVED***;
exports.visit = visit;

/**
 * @type {(node: XastChild, parentNode: XastParent) => void***REMOVED***
 */
const detachNodeFromParent = (node, parentNode) => {
  // avoid splice to not break for loops
  parentNode.children = parentNode.children.filter((child) => child !== node);
***REMOVED***;
exports.detachNodeFromParent = detachNodeFromParent;
