"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.annexB33FunctionsVisitor = void 0;
exports.isVarScope = isVarScope;
var _core = require("@babel/core");
const annexB33FunctionsVisitor = exports.annexB33FunctionsVisitor = Object.assign({
  VariableDeclaration(path) {
    if (isStrict(path)) return;
    if (path.node.kind !== "var") return;
    const varScope = path.scope.getFunctionParent() || path.scope.getProgramParent();
    varScope.path.traverse(functionsToVarVisitor, {
      names: Object.keys(path.getBindingIdentifiers())
    ***REMOVED***);
  ***REMOVED***
***REMOVED***, {
  BlockStatement(path) {
    if (isStrict(path)) return;
    if (_core.types.isFunction(path.parent, {
      body: path.node
    ***REMOVED***)) return;
    transformStatementList(path.get("body"));
  ***REMOVED***,
  SwitchCase(path) {
    if (isStrict(path)) return;
    transformStatementList(path.get("consequent"));
  ***REMOVED***
***REMOVED***);
function transformStatementList(paths) {
  outer: for (const path of paths) {
    if (!path.isFunctionDeclaration()) continue;
    if (path.node.async || path.node.generator) return;
    const {
      scope
    ***REMOVED*** = path.parentPath;
    if (isVarScope(scope)) return;
    const {
      name
    ***REMOVED*** = path.node.id;
    let currScope = scope;
    do {
      if (currScope.parent.hasOwnBinding(name)) continue outer;
      currScope = currScope.parent;
    ***REMOVED*** while (!isVarScope(currScope));
    maybeTransformBlockScopedFunction(path);
  ***REMOVED***
***REMOVED***
function maybeTransformBlockScopedFunction(path) {
  const {
    node,
    parentPath: {
      scope
    ***REMOVED***
  ***REMOVED*** = path;
  const {
    id
  ***REMOVED*** = node;
  scope.removeOwnBinding(id.name);
  node.id = null;
  const varNode = _core.types.variableDeclaration("var", [_core.types.variableDeclarator(id, _core.types.toExpression(node))]);
  varNode._blockHoist = 2;
  const [varPath] = path.replaceWith(varNode);
  scope.registerDeclaration(varPath);
***REMOVED***
const functionsToVarVisitor = {
  Scope(path, {
    names
  ***REMOVED***) {
    for (const name of names) {
      const binding = path.scope.getOwnBinding(name);
      if (binding && binding.kind === "hoisted") {
        maybeTransformBlockScopedFunction(binding.path);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***,
  "Expression|Declaration"(path) {
    path.skip();
  ***REMOVED***
***REMOVED***;
function isVarScope(scope) {
  return scope.path.isFunctionParent() || scope.path.isProgram();
***REMOVED***
function isStrict(path) {
  return !!path.find(({
    node
  ***REMOVED***) => {
    var _node$directives;
    if (_core.types.isProgram(node)) {
      if (node.sourceType === "module") return true;
    ***REMOVED*** else if (_core.types.isClass(node)) {
      return true;
    ***REMOVED*** else if (!_core.types.isBlockStatement(node)) {
      return false;
    ***REMOVED***
    return (_node$directives = node.directives) == null ? void 0 : _node$directives.some(directive => directive.value.value === "use strict");
  ***REMOVED***);
***REMOVED***

//# sourceMappingURL=annex-B_3_3.js.map
