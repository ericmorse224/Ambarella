/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const RuntimeGlobals = require("../RuntimeGlobals");
const RuntimeModule = require("../RuntimeModule");
const Template = require("../Template");

/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../Chunk").ChunkId***REMOVED*** ChunkId */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../ChunkGraph").ModuleId***REMOVED*** ModuleId */
/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("./RemoteModule")***REMOVED*** RemoteModule */

class RemoteRuntimeModule extends RuntimeModule {
	constructor() {
		super("remotes loading");
	***REMOVED***

	/**
	 * @returns {string | null***REMOVED*** runtime code
	 */
	generate() {
		const compilation = /** @type {Compilation***REMOVED*** */ (this.compilation);
		const chunkGraph = /** @type {ChunkGraph***REMOVED*** */ (this.chunkGraph);
		const { runtimeTemplate, moduleGraph ***REMOVED*** = compilation;
		/** @type {Record<ChunkId, (string | number)[]>***REMOVED*** */
		const chunkToRemotesMapping = {***REMOVED***;
		/** @type {Record<ModuleId, [string, string, string | number | null]>***REMOVED*** */
		const idToExternalAndNameMapping = {***REMOVED***;
		for (const chunk of /** @type {Chunk***REMOVED*** */ (
			this.chunk
		).getAllReferencedChunks()) {
			const modules = chunkGraph.getChunkModulesIterableBySourceType(
				chunk,
				"remote"
			);
			if (!modules) continue;
			/** @type {ModuleId[]***REMOVED*** */
			const remotes = (chunkToRemotesMapping[
				/** @type {ChunkId***REMOVED*** */
				(chunk.id)
			] = []);
			for (const m of modules) {
				const module = /** @type {RemoteModule***REMOVED*** */ (m);
				const name = module.internalRequest;
				const id = /** @type {ModuleId***REMOVED*** */ (chunkGraph.getModuleId(module));
				const shareScope = module.shareScope;
				const dep = module.dependencies[0];
				const externalModule = moduleGraph.getModule(dep);
				const externalModuleId =
					/** @type {ModuleId***REMOVED*** */
					(externalModule && chunkGraph.getModuleId(externalModule));
				remotes.push(id);
				idToExternalAndNameMapping[id] = [shareScope, name, externalModuleId];
			***REMOVED***
		***REMOVED***
		return Template.asString([
			`var chunkMapping = ${JSON.stringify(
				chunkToRemotesMapping,
				null,
				"\t"
			)***REMOVED***;`,
			`var idToExternalAndNameMapping = ${JSON.stringify(
				idToExternalAndNameMapping,
				null,
				"\t"
			)***REMOVED***;`,
			`${
				RuntimeGlobals.ensureChunkHandlers
			***REMOVED***.remotes = ${runtimeTemplate.basicFunction("chunkId, promises", [
				`if(${RuntimeGlobals.hasOwnProperty***REMOVED***(chunkMapping, chunkId)) {`,
				Template.indent([
					`chunkMapping[chunkId].forEach(${runtimeTemplate.basicFunction("id", [
						`var getScope = ${RuntimeGlobals.currentRemoteGetScope***REMOVED***;`,
						"if(!getScope) getScope = [];",
						"var data = idToExternalAndNameMapping[id];",
						"if(getScope.indexOf(data) >= 0) return;",
						"getScope.push(data);",
						"if(data.p) return promises.push(data.p);",
						`var onError = ${runtimeTemplate.basicFunction("error", [
							'if(!error) error = new Error("Container missing");',
							'if(typeof error.message === "string")',
							Template.indent(
								"error.message += '\\nwhile loading \"' + data[1] + '\" from ' + data[2];"
							),
							`${
								RuntimeGlobals.moduleFactories
							***REMOVED***[id] = ${runtimeTemplate.basicFunction("", ["throw error;"])***REMOVED***`,
							"data.p = 0;"
						])***REMOVED***;`,
						`var handleFunction = ${runtimeTemplate.basicFunction(
							"fn, arg1, arg2, d, next, first",
							[
								"try {",
								Template.indent([
									"var promise = fn(arg1, arg2);",
									"if(promise && promise.then) {",
									Template.indent([
										`var p = promise.then(${runtimeTemplate.returningFunction(
											"next(result, d)",
											"result"
										)***REMOVED***, onError);`,
										"if(first) promises.push(data.p = p); else return p;"
									]),
									"***REMOVED*** else {",
									Template.indent(["return next(promise, d, first);"]),
									"***REMOVED***"
								]),
								"***REMOVED*** catch(error) {",
								Template.indent(["onError(error);"]),
								"***REMOVED***"
							]
						)***REMOVED***`,
						`var onExternal = ${runtimeTemplate.returningFunction(
							`external ? handleFunction(${RuntimeGlobals.initializeSharing***REMOVED***, data[0], 0, external, onInitialized, first) : onError()`,
							"external, _, first"
						)***REMOVED***;`,
						`var onInitialized = ${runtimeTemplate.returningFunction(
							"handleFunction(external.get, data[1], getScope, 0, onFactory, first)",
							"_, external, first"
						)***REMOVED***;`,
						`var onFactory = ${runtimeTemplate.basicFunction("factory", [
							"data.p = 1;",
							`${
								RuntimeGlobals.moduleFactories
							***REMOVED***[id] = ${runtimeTemplate.basicFunction("module", [
								"module.exports = factory();"
							])***REMOVED***`
						])***REMOVED***;`,
						`handleFunction(${RuntimeGlobals.require***REMOVED***, data[2], 0, 0, onExternal, 1);`
					])***REMOVED***);`
				]),
				"***REMOVED***"
			])***REMOVED***`
		]);
	***REMOVED***
***REMOVED***

module.exports = RemoteRuntimeModule;
