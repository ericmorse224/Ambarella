/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { create: createResolver ***REMOVED*** = require("enhanced-resolve");
const nodeModule = require("module");
const asyncLib = require("neo-async");
const { isAbsolute ***REMOVED*** = require("path");
const { DEFAULTS ***REMOVED*** = require("./config/defaults");
const AsyncQueue = require("./util/AsyncQueue");
const StackedCacheMap = require("./util/StackedCacheMap");
const createHash = require("./util/createHash");
const { join, dirname, relative, lstatReadlinkAbsolute ***REMOVED*** = require("./util/fs");
const makeSerializable = require("./util/makeSerializable");
const processAsyncTree = require("./util/processAsyncTree");

/** @typedef {import("enhanced-resolve").Resolver***REMOVED*** Resolver */
/** @typedef {import("enhanced-resolve").ResolveRequest***REMOVED*** ResolveRequest */
/** @typedef {import("enhanced-resolve").ResolveFunctionAsync***REMOVED*** ResolveFunctionAsync */
/** @typedef {import("./WebpackError")***REMOVED*** WebpackError */
/** @typedef {import("./logging/Logger").Logger***REMOVED*** Logger */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectDeserializerContext***REMOVED*** ObjectDeserializerContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectSerializerContext***REMOVED*** ObjectSerializerContext */
/** @typedef {import("../declarations/WebpackOptions").HashFunction***REMOVED*** HashFunction */
/** @typedef {import("./util/fs").IStats***REMOVED*** IStats */
/** @typedef {import("./util/fs").InputFileSystem***REMOVED*** InputFileSystem */
/** @typedef {import("./util/fs").PathLike***REMOVED*** PathLike */
/** @typedef {import("./util/fs").StringCallback***REMOVED*** StringCallback */
/**
 * @template T
 * @typedef {import("./util/AsyncQueue").Callback<T>***REMOVED*** ProcessorCallback
 */
/**
 * @template T, R
 * @typedef {import("./util/AsyncQueue").Processor<T, R>***REMOVED*** Processor
 */

const supportsEsm = Number(process.versions.modules) >= 83;

/** @type {Set<string>***REMOVED*** */
const builtinModules = new Set(nodeModule.builtinModules);

let FS_ACCURACY = 2000;

const EMPTY_SET = new Set();

const RBDT_RESOLVE_CJS = 0;
const RBDT_RESOLVE_ESM = 1;
const RBDT_RESOLVE_DIRECTORY = 2;
const RBDT_RESOLVE_CJS_FILE = 3;
const RBDT_RESOLVE_CJS_FILE_AS_CHILD = 4;
const RBDT_RESOLVE_ESM_FILE = 5;
const RBDT_DIRECTORY = 6;
const RBDT_FILE = 7;
const RBDT_DIRECTORY_DEPENDENCIES = 8;
const RBDT_FILE_DEPENDENCIES = 9;

/** @typedef {RBDT_RESOLVE_CJS | RBDT_RESOLVE_ESM | RBDT_RESOLVE_DIRECTORY | RBDT_RESOLVE_CJS_FILE | RBDT_RESOLVE_CJS_FILE_AS_CHILD | RBDT_RESOLVE_ESM_FILE | RBDT_DIRECTORY | RBDT_FILE | RBDT_DIRECTORY_DEPENDENCIES | RBDT_FILE_DEPENDENCIES***REMOVED*** JobType */

const INVALID = Symbol("invalid");

/**
 * @typedef {object***REMOVED*** FileSystemInfoEntry
 * @property {number***REMOVED*** safeTime
 * @property {number=***REMOVED*** timestamp
 */

/**
 * @typedef {object***REMOVED*** ResolvedContextFileSystemInfoEntry
 * @property {number***REMOVED*** safeTime
 * @property {string=***REMOVED*** timestampHash
 */

/** @typedef {Set<string>***REMOVED*** Symlinks */

/**
 * @typedef {object***REMOVED*** ContextFileSystemInfoEntry
 * @property {number***REMOVED*** safeTime
 * @property {string=***REMOVED*** timestampHash
 * @property {ResolvedContextFileSystemInfoEntry=***REMOVED*** resolved
 * @property {Symlinks=***REMOVED*** symlinks
 */

/**
 * @typedef {object***REMOVED*** TimestampAndHash
 * @property {number***REMOVED*** safeTime
 * @property {number=***REMOVED*** timestamp
 * @property {string***REMOVED*** hash
 */

/**
 * @typedef {object***REMOVED*** ResolvedContextTimestampAndHash
 * @property {number***REMOVED*** safeTime
 * @property {string=***REMOVED*** timestampHash
 * @property {string***REMOVED*** hash
 */

/**
 * @typedef {object***REMOVED*** ContextTimestampAndHash
 * @property {number***REMOVED*** safeTime
 * @property {string=***REMOVED*** timestampHash
 * @property {string***REMOVED*** hash
 * @property {ResolvedContextTimestampAndHash=***REMOVED*** resolved
 * @property {Symlinks=***REMOVED*** symlinks
 */

/**
 * @typedef {object***REMOVED*** ContextHash
 * @property {string***REMOVED*** hash
 * @property {string=***REMOVED*** resolved
 * @property {Symlinks=***REMOVED*** symlinks
 */

/** @typedef {Set<string>***REMOVED*** SnapshotContent */

/**
 * @typedef {object***REMOVED*** SnapshotOptimizationEntry
 * @property {Snapshot***REMOVED*** snapshot
 * @property {number***REMOVED*** shared
 * @property {SnapshotContent | undefined***REMOVED*** snapshotContent
 * @property {Set<SnapshotOptimizationEntry> | undefined***REMOVED*** children
 */

/** @typedef {Map<string, string | false | undefined>***REMOVED*** ResolveResults */

/** @typedef {Set<string>***REMOVED*** Files */
/** @typedef {Set<string>***REMOVED*** Directories */
/** @typedef {Set<string>***REMOVED*** Missing */

/**
 * @typedef {object***REMOVED*** ResolveDependencies
 * @property {Files***REMOVED*** files list of files
 * @property {Directories***REMOVED*** directories list of directories
 * @property {Missing***REMOVED*** missing list of missing entries
 */

/**
 * @typedef {object***REMOVED*** ResolveBuildDependenciesResult
 * @property {Files***REMOVED*** files list of files
 * @property {Directories***REMOVED*** directories list of directories
 * @property {Missing***REMOVED*** missing list of missing entries
 * @property {ResolveResults***REMOVED*** resolveResults stored resolve results
 * @property {ResolveDependencies***REMOVED*** resolveDependencies dependencies of the resolving
 */

/**
 * @typedef {object***REMOVED*** SnapshotOptions
 * @property {boolean=***REMOVED*** hash should use hash to snapshot
 * @property {boolean=***REMOVED*** timestamp should use timestamp to snapshot
 */

const DONE_ITERATOR_RESULT = new Set().keys().next();

// cspell:word tshs
// Tsh = Timestamp + Hash
// Tshs = Timestamp + Hash combinations

class SnapshotIterator {
	/**
	 * @param {() => IteratorResult<string>***REMOVED*** next next
	 */
	constructor(next) {
		this.next = next;
	***REMOVED***
***REMOVED***

/** @typedef {Map<string, TODO> | Set<string> | undefined***REMOVED*** SnapshotMap */
/** @typedef {(snapshot: Snapshot) => SnapshotMap[]***REMOVED*** GetMapsFunction */

class SnapshotIterable {
	/**
	 * @param {Snapshot***REMOVED*** snapshot snapshot
	 * @param {GetMapsFunction***REMOVED*** getMaps get maps function
	 */
	constructor(snapshot, getMaps) {
		this.snapshot = snapshot;
		this.getMaps = getMaps;
	***REMOVED***

	[Symbol.iterator]() {
		let state = 0;
		/** @type {IterableIterator<string>***REMOVED*** */
		let it;
		/** @type {GetMapsFunction***REMOVED*** */
		let getMaps;
		/** @type {SnapshotMap[]***REMOVED*** */
		let maps;
		/** @type {Snapshot***REMOVED*** */
		let snapshot;
		/** @type {Snapshot[] | undefined***REMOVED*** */
		let queue;
		return new SnapshotIterator(() => {
			for (;;) {
				switch (state) {
					case 0:
						snapshot = this.snapshot;
						getMaps = this.getMaps;
						maps = getMaps(snapshot);
						state = 1;
					/* falls through */
					case 1:
						if (maps.length > 0) {
							const map = maps.pop();
							if (map !== undefined) {
								it = map.keys();
								state = 2;
							***REMOVED*** else {
								break;
							***REMOVED***
						***REMOVED*** else {
							state = 3;
							break;
						***REMOVED***
					/* falls through */
					case 2: {
						const result = it.next();
						if (!result.done) return result;
						state = 1;
						break;
					***REMOVED***
					case 3: {
						const children = snapshot.children;
						if (children !== undefined) {
							if (children.size === 1) {
								// shortcut for a single child
								// avoids allocation of queue
								for (const child of children) snapshot = child;
								maps = getMaps(snapshot);
								state = 1;
								break;
							***REMOVED***
							if (queue === undefined) queue = [];
							for (const child of children) {
								queue.push(child);
							***REMOVED***
						***REMOVED***
						if (queue !== undefined && queue.length > 0) {
							snapshot = /** @type {Snapshot***REMOVED*** */ (queue.pop());
							maps = getMaps(snapshot);
							state = 1;
							break;
						***REMOVED*** else {
							state = 4;
						***REMOVED***
					***REMOVED***
					/* falls through */
					case 4:
						return DONE_ITERATOR_RESULT;
				***REMOVED***
			***REMOVED***
		***REMOVED***);
	***REMOVED***
***REMOVED***

/** @typedef {Map<string, FileSystemInfoEntry | null>***REMOVED*** FileTimestamps */
/** @typedef {Map<string, string | null>***REMOVED*** FileHashes */
/** @typedef {Map<string, TimestampAndHash | string | null>***REMOVED*** FileTshs */
/** @typedef {Map<string, ResolvedContextFileSystemInfoEntry | null>***REMOVED*** ContextTimestamps */
/** @typedef {Map<string, string | null>***REMOVED*** ContextHashes */
/** @typedef {Map<string, ResolvedContextTimestampAndHash | null>***REMOVED*** ContextTshs */
/** @typedef {Map<string, boolean>***REMOVED*** MissingExistence */
/** @typedef {Map<string, string>***REMOVED*** ManagedItemInfo */
/** @typedef {Set<string>***REMOVED*** ManagedFiles */
/** @typedef {Set<string>***REMOVED*** ManagedContexts */
/** @typedef {Set<string>***REMOVED*** ManagedMissing */
/** @typedef {Set<Snapshot>***REMOVED*** Children */

class Snapshot {
	constructor() {
		this._flags = 0;
		/** @type {Iterable<string> | undefined***REMOVED*** */
		this._cachedFileIterable = undefined;
		/** @type {Iterable<string> | undefined***REMOVED*** */
		this._cachedContextIterable = undefined;
		/** @type {Iterable<string> | undefined***REMOVED*** */
		this._cachedMissingIterable = undefined;
		/** @type {number | undefined***REMOVED*** */
		this.startTime = undefined;
		/** @type {FileTimestamps | undefined***REMOVED*** */
		this.fileTimestamps = undefined;
		/** @type {FileHashes | undefined***REMOVED*** */
		this.fileHashes = undefined;
		/** @type {FileTshs | undefined***REMOVED*** */
		this.fileTshs = undefined;
		/** @type {ContextTimestamps | undefined***REMOVED*** */
		this.contextTimestamps = undefined;
		/** @type {ContextHashes | undefined***REMOVED*** */
		this.contextHashes = undefined;
		/** @type {ContextTshs | undefined***REMOVED*** */
		this.contextTshs = undefined;
		/** @type {MissingExistence | undefined***REMOVED*** */
		this.missingExistence = undefined;
		/** @type {ManagedItemInfo | undefined***REMOVED*** */
		this.managedItemInfo = undefined;
		/** @type {ManagedFiles | undefined***REMOVED*** */
		this.managedFiles = undefined;
		/** @type {ManagedContexts | undefined***REMOVED*** */
		this.managedContexts = undefined;
		/** @type {ManagedMissing | undefined***REMOVED*** */
		this.managedMissing = undefined;
		/** @type {Children | undefined***REMOVED*** */
		this.children = undefined;
	***REMOVED***

	hasStartTime() {
		return (this._flags & 1) !== 0;
	***REMOVED***

	/**
	 * @param {number***REMOVED*** value start value
	 */
	setStartTime(value) {
		this._flags = this._flags | 1;
		this.startTime = value;
	***REMOVED***

	/**
	 * @param {number | undefined***REMOVED*** value value
	 * @param {Snapshot***REMOVED*** snapshot snapshot
	 */
	setMergedStartTime(value, snapshot) {
		if (value) {
			if (snapshot.hasStartTime()) {
				this.setStartTime(
					Math.min(
						value,
						/** @type {NonNullable<Snapshot["startTime"]>***REMOVED*** */
						(snapshot.startTime)
					)
				);
			***REMOVED*** else {
				this.setStartTime(value);
			***REMOVED***
		***REMOVED*** else if (snapshot.hasStartTime()) {
			this.setStartTime(
				/** @type {NonNullable<Snapshot["startTime"]>***REMOVED*** */
				(snapshot.startTime)
			);
		***REMOVED***
	***REMOVED***

	hasFileTimestamps() {
		return (this._flags & 2) !== 0;
	***REMOVED***

	/**
	 * @param {FileTimestamps***REMOVED*** value file timestamps
	 */
	setFileTimestamps(value) {
		this._flags = this._flags | 2;
		this.fileTimestamps = value;
	***REMOVED***

	hasFileHashes() {
		return (this._flags & 4) !== 0;
	***REMOVED***

	/**
	 * @param {FileHashes***REMOVED*** value file hashes
	 */
	setFileHashes(value) {
		this._flags = this._flags | 4;
		this.fileHashes = value;
	***REMOVED***

	hasFileTshs() {
		return (this._flags & 8) !== 0;
	***REMOVED***

	/**
	 * @param {FileTshs***REMOVED*** value file tshs
	 */
	setFileTshs(value) {
		this._flags = this._flags | 8;
		this.fileTshs = value;
	***REMOVED***

	hasContextTimestamps() {
		return (this._flags & 0x10) !== 0;
	***REMOVED***

	/**
	 * @param {ContextTimestamps***REMOVED*** value context timestamps
	 */
	setContextTimestamps(value) {
		this._flags = this._flags | 0x10;
		this.contextTimestamps = value;
	***REMOVED***

	hasContextHashes() {
		return (this._flags & 0x20) !== 0;
	***REMOVED***

	/**
	 * @param {ContextHashes***REMOVED*** value context hashes
	 */
	setContextHashes(value) {
		this._flags = this._flags | 0x20;
		this.contextHashes = value;
	***REMOVED***

	hasContextTshs() {
		return (this._flags & 0x40) !== 0;
	***REMOVED***

	/**
	 * @param {ContextTshs***REMOVED*** value context tshs
	 */
	setContextTshs(value) {
		this._flags = this._flags | 0x40;
		this.contextTshs = value;
	***REMOVED***

	hasMissingExistence() {
		return (this._flags & 0x80) !== 0;
	***REMOVED***

	/**
	 * @param {MissingExistence***REMOVED*** value context tshs
	 */
	setMissingExistence(value) {
		this._flags = this._flags | 0x80;
		this.missingExistence = value;
	***REMOVED***

	hasManagedItemInfo() {
		return (this._flags & 0x100) !== 0;
	***REMOVED***

	/**
	 * @param {ManagedItemInfo***REMOVED*** value managed item info
	 */
	setManagedItemInfo(value) {
		this._flags = this._flags | 0x100;
		this.managedItemInfo = value;
	***REMOVED***

	hasManagedFiles() {
		return (this._flags & 0x200) !== 0;
	***REMOVED***

	/**
	 * @param {ManagedFiles***REMOVED*** value managed files
	 */
	setManagedFiles(value) {
		this._flags = this._flags | 0x200;
		this.managedFiles = value;
	***REMOVED***

	hasManagedContexts() {
		return (this._flags & 0x400) !== 0;
	***REMOVED***

	/**
	 * @param {ManagedContexts***REMOVED*** value managed contexts
	 */
	setManagedContexts(value) {
		this._flags = this._flags | 0x400;
		this.managedContexts = value;
	***REMOVED***

	hasManagedMissing() {
		return (this._flags & 0x800) !== 0;
	***REMOVED***

	/**
	 * @param {ManagedMissing***REMOVED*** value managed missing
	 */
	setManagedMissing(value) {
		this._flags = this._flags | 0x800;
		this.managedMissing = value;
	***REMOVED***

	hasChildren() {
		return (this._flags & 0x1000) !== 0;
	***REMOVED***

	/**
	 * @param {Children***REMOVED*** value children
	 */
	setChildren(value) {
		this._flags = this._flags | 0x1000;
		this.children = value;
	***REMOVED***

	/**
	 * @param {Snapshot***REMOVED*** child children
	 */
	addChild(child) {
		if (!this.hasChildren()) {
			this.setChildren(new Set());
		***REMOVED***
		/** @type {Children***REMOVED*** */
		(this.children).add(child);
	***REMOVED***

	/**
	 * @param {ObjectSerializerContext***REMOVED*** context context
	 */
	serialize({ write ***REMOVED***) {
		write(this._flags);
		if (this.hasStartTime()) write(this.startTime);
		if (this.hasFileTimestamps()) write(this.fileTimestamps);
		if (this.hasFileHashes()) write(this.fileHashes);
		if (this.hasFileTshs()) write(this.fileTshs);
		if (this.hasContextTimestamps()) write(this.contextTimestamps);
		if (this.hasContextHashes()) write(this.contextHashes);
		if (this.hasContextTshs()) write(this.contextTshs);
		if (this.hasMissingExistence()) write(this.missingExistence);
		if (this.hasManagedItemInfo()) write(this.managedItemInfo);
		if (this.hasManagedFiles()) write(this.managedFiles);
		if (this.hasManagedContexts()) write(this.managedContexts);
		if (this.hasManagedMissing()) write(this.managedMissing);
		if (this.hasChildren()) write(this.children);
	***REMOVED***

	/**
	 * @param {ObjectDeserializerContext***REMOVED*** context context
	 */
	deserialize({ read ***REMOVED***) {
		this._flags = read();
		if (this.hasStartTime()) this.startTime = read();
		if (this.hasFileTimestamps()) this.fileTimestamps = read();
		if (this.hasFileHashes()) this.fileHashes = read();
		if (this.hasFileTshs()) this.fileTshs = read();
		if (this.hasContextTimestamps()) this.contextTimestamps = read();
		if (this.hasContextHashes()) this.contextHashes = read();
		if (this.hasContextTshs()) this.contextTshs = read();
		if (this.hasMissingExistence()) this.missingExistence = read();
		if (this.hasManagedItemInfo()) this.managedItemInfo = read();
		if (this.hasManagedFiles()) this.managedFiles = read();
		if (this.hasManagedContexts()) this.managedContexts = read();
		if (this.hasManagedMissing()) this.managedMissing = read();
		if (this.hasChildren()) this.children = read();
	***REMOVED***

	/**
	 * @param {GetMapsFunction***REMOVED*** getMaps first
	 * @returns {Iterable<string>***REMOVED*** iterable
	 */
	_createIterable(getMaps) {
		return new SnapshotIterable(this, getMaps);
	***REMOVED***

	/**
	 * @returns {Iterable<string>***REMOVED*** iterable
	 */
	getFileIterable() {
		if (this._cachedFileIterable === undefined) {
			this._cachedFileIterable = this._createIterable(s => [
				s.fileTimestamps,
				s.fileHashes,
				s.fileTshs,
				s.managedFiles
			]);
		***REMOVED***
		return this._cachedFileIterable;
	***REMOVED***

	/**
	 * @returns {Iterable<string>***REMOVED*** iterable
	 */
	getContextIterable() {
		if (this._cachedContextIterable === undefined) {
			this._cachedContextIterable = this._createIterable(s => [
				s.contextTimestamps,
				s.contextHashes,
				s.contextTshs,
				s.managedContexts
			]);
		***REMOVED***
		return this._cachedContextIterable;
	***REMOVED***

	/**
	 * @returns {Iterable<string>***REMOVED*** iterable
	 */
	getMissingIterable() {
		if (this._cachedMissingIterable === undefined) {
			this._cachedMissingIterable = this._createIterable(s => [
				s.missingExistence,
				s.managedMissing
			]);
		***REMOVED***
		return this._cachedMissingIterable;
	***REMOVED***
***REMOVED***

makeSerializable(Snapshot, "webpack/lib/FileSystemInfo", "Snapshot");

const MIN_COMMON_SNAPSHOT_SIZE = 3;

/**
 * @template U, T
 * @typedef {U extends true ? Set<string> : Map<string, T>***REMOVED*** SnapshotOptimizationValue
 */

/**
 * @template T
 * @template {boolean***REMOVED*** [U=false]
 */
class SnapshotOptimization {
	/**
	 * @param {(snapshot: Snapshot) => boolean***REMOVED*** has has value
	 * @param {(snapshot: Snapshot) => SnapshotOptimizationValue<U, T> | undefined***REMOVED*** get get value
	 * @param {(snapshot: Snapshot, value: SnapshotOptimizationValue<U, T>) => void***REMOVED*** set set value
	 * @param {boolean=***REMOVED*** useStartTime use the start time of snapshots
	 * @param {U=***REMOVED*** isSet value is an Set instead of a Map
	 */
	constructor(
		has,
		get,
		set,
		useStartTime = true,
		isSet = /** @type {U***REMOVED*** */ (false)
	) {
		this._has = has;
		this._get = get;
		this._set = set;
		this._useStartTime = useStartTime;
		/** @type {U***REMOVED*** */
		this._isSet = isSet;
		/** @type {Map<string, SnapshotOptimizationEntry>***REMOVED*** */
		this._map = new Map();
		this._statItemsShared = 0;
		this._statItemsUnshared = 0;
		this._statSharedSnapshots = 0;
		this._statReusedSharedSnapshots = 0;
	***REMOVED***

	getStatisticMessage() {
		const total = this._statItemsShared + this._statItemsUnshared;
		if (total === 0) return;
		return `${
			this._statItemsShared && Math.round((this._statItemsShared * 100) / total)
		***REMOVED***% (${this._statItemsShared***REMOVED***/${total***REMOVED***) entries shared via ${
			this._statSharedSnapshots
		***REMOVED*** shared snapshots (${
			this._statReusedSharedSnapshots + this._statSharedSnapshots
		***REMOVED*** times referenced)`;
	***REMOVED***

	clear() {
		this._map.clear();
		this._statItemsShared = 0;
		this._statItemsUnshared = 0;
		this._statSharedSnapshots = 0;
		this._statReusedSharedSnapshots = 0;
	***REMOVED***

	/**
	 * @param {Snapshot***REMOVED*** newSnapshot snapshot
	 * @param {Set<string>***REMOVED*** capturedFiles files to snapshot/share
	 * @returns {void***REMOVED***
	 */
	optimize(newSnapshot, capturedFiles) {
		/**
		 * @param {SnapshotOptimizationEntry***REMOVED*** entry optimization entry
		 * @returns {void***REMOVED***
		 */
		const increaseSharedAndStoreOptimizationEntry = entry => {
			if (entry.children !== undefined) {
				for (const child of entry.children) {
					increaseSharedAndStoreOptimizationEntry(child);
				***REMOVED***
			***REMOVED***
			entry.shared++;
			storeOptimizationEntry(entry);
		***REMOVED***;
		/**
		 * @param {SnapshotOptimizationEntry***REMOVED*** entry optimization entry
		 * @returns {void***REMOVED***
		 */
		const storeOptimizationEntry = entry => {
			for (const path of /** @type {SnapshotContent***REMOVED*** */ (
				entry.snapshotContent
			)) {
				const old =
					/** @type {SnapshotOptimizationEntry***REMOVED*** */
					(this._map.get(path));
				if (old.shared < entry.shared) {
					this._map.set(path, entry);
				***REMOVED***
				capturedFiles.delete(path);
			***REMOVED***
		***REMOVED***;

		/** @type {SnapshotOptimizationEntry | undefined***REMOVED*** */
		let newOptimizationEntry;

		const capturedFilesSize = capturedFiles.size;

		/** @type {Set<SnapshotOptimizationEntry> | undefined***REMOVED*** */
		const optimizationEntries = new Set();

		for (const path of capturedFiles) {
			const optimizationEntry = this._map.get(path);
			if (optimizationEntry === undefined) {
				if (newOptimizationEntry === undefined) {
					newOptimizationEntry = {
						snapshot: newSnapshot,
						shared: 0,
						snapshotContent: undefined,
						children: undefined
					***REMOVED***;
				***REMOVED***
				this._map.set(path, newOptimizationEntry);
				continue;
			***REMOVED*** else {
				optimizationEntries.add(optimizationEntry);
			***REMOVED***
		***REMOVED***

		optimizationEntriesLabel: for (const optimizationEntry of optimizationEntries) {
			const snapshot = optimizationEntry.snapshot;
			if (optimizationEntry.shared > 0) {
				// It's a shared snapshot
				// We can't change it, so we can only use it when all files match
				// and startTime is compatible
				if (
					this._useStartTime &&
					newSnapshot.startTime &&
					(!snapshot.startTime || snapshot.startTime > newSnapshot.startTime)
				) {
					continue;
				***REMOVED***
				const nonSharedFiles = new Set();
				const snapshotContent =
					/** @type {NonNullable<SnapshotOptimizationEntry["snapshotContent"]>***REMOVED*** */
					(optimizationEntry.snapshotContent);
				const snapshotEntries =
					/** @type {SnapshotOptimizationValue<U, T>***REMOVED*** */
					(this._get(snapshot));
				for (const path of snapshotContent) {
					if (!capturedFiles.has(path)) {
						if (!snapshotEntries.has(path)) {
							// File is not shared and can't be removed from the snapshot
							// because it's in a child of the snapshot
							continue optimizationEntriesLabel;
						***REMOVED***
						nonSharedFiles.add(path);
						continue;
					***REMOVED***
				***REMOVED***
				if (nonSharedFiles.size === 0) {
					// The complete snapshot is shared
					// add it as child
					newSnapshot.addChild(snapshot);
					increaseSharedAndStoreOptimizationEntry(optimizationEntry);
					this._statReusedSharedSnapshots++;
				***REMOVED*** else {
					// Only a part of the snapshot is shared
					const sharedCount = snapshotContent.size - nonSharedFiles.size;
					if (sharedCount < MIN_COMMON_SNAPSHOT_SIZE) {
						// Common part it too small
						continue;
					***REMOVED***
					// Extract common timestamps from both snapshots
					let commonMap;
					if (this._isSet) {
						commonMap = new Set();
						for (const path of /** @type {Set<string>***REMOVED*** */ (snapshotEntries)) {
							if (nonSharedFiles.has(path)) continue;
							commonMap.add(path);
							snapshotEntries.delete(path);
						***REMOVED***
					***REMOVED*** else {
						commonMap = new Map();
						const map = /** @type {Map<string, T>***REMOVED*** */ (snapshotEntries);
						for (const [path, value] of map) {
							if (nonSharedFiles.has(path)) continue;
							commonMap.set(path, value);
							snapshotEntries.delete(path);
						***REMOVED***
					***REMOVED***
					// Create and attach snapshot
					const commonSnapshot = new Snapshot();
					if (this._useStartTime) {
						commonSnapshot.setMergedStartTime(newSnapshot.startTime, snapshot);
					***REMOVED***
					this._set(
						commonSnapshot,
						/** @type {SnapshotOptimizationValue<U, T>***REMOVED*** */ (commonMap)
					);
					newSnapshot.addChild(commonSnapshot);
					snapshot.addChild(commonSnapshot);
					// Create optimization entry
					const newEntry = {
						snapshot: commonSnapshot,
						shared: optimizationEntry.shared + 1,
						snapshotContent: new Set(commonMap.keys()),
						children: undefined
					***REMOVED***;
					if (optimizationEntry.children === undefined)
						optimizationEntry.children = new Set();
					optimizationEntry.children.add(newEntry);
					storeOptimizationEntry(newEntry);
					this._statSharedSnapshots++;
				***REMOVED***
			***REMOVED*** else {
				// It's a unshared snapshot
				// We can extract a common shared snapshot
				// with all common files
				const snapshotEntries = this._get(snapshot);
				if (snapshotEntries === undefined) {
					// Incomplete snapshot, that can't be used
					continue;
				***REMOVED***
				let commonMap;
				if (this._isSet) {
					commonMap = new Set();
					const set = /** @type {Set<string>***REMOVED*** */ (snapshotEntries);
					if (capturedFiles.size < set.size) {
						for (const path of capturedFiles) {
							if (set.has(path)) commonMap.add(path);
						***REMOVED***
					***REMOVED*** else {
						for (const path of set) {
							if (capturedFiles.has(path)) commonMap.add(path);
						***REMOVED***
					***REMOVED***
				***REMOVED*** else {
					commonMap = new Map();
					const map = /** @type {Map<string, T>***REMOVED*** */ (snapshotEntries);
					for (const path of capturedFiles) {
						const ts = map.get(path);
						if (ts === undefined) continue;
						commonMap.set(path, ts);
					***REMOVED***
				***REMOVED***

				if (commonMap.size < MIN_COMMON_SNAPSHOT_SIZE) {
					// Common part it too small
					continue;
				***REMOVED***
				// Create and attach snapshot
				const commonSnapshot = new Snapshot();
				if (this._useStartTime) {
					commonSnapshot.setMergedStartTime(newSnapshot.startTime, snapshot);
				***REMOVED***
				this._set(
					commonSnapshot,
					/** @type {SnapshotOptimizationValue<U, T>***REMOVED*** */
					(commonMap)
				);
				newSnapshot.addChild(commonSnapshot);
				snapshot.addChild(commonSnapshot);
				// Remove files from snapshot
				for (const path of commonMap.keys()) snapshotEntries.delete(path);
				const sharedCount = commonMap.size;
				this._statItemsUnshared -= sharedCount;
				this._statItemsShared += sharedCount;
				// Create optimization entry
				storeOptimizationEntry({
					snapshot: commonSnapshot,
					shared: 2,
					snapshotContent: new Set(commonMap.keys()),
					children: undefined
				***REMOVED***);
				this._statSharedSnapshots++;
			***REMOVED***
		***REMOVED***
		const unshared = capturedFiles.size;
		this._statItemsUnshared += unshared;
		this._statItemsShared += capturedFilesSize - unshared;
	***REMOVED***
***REMOVED***

/**
 * @param {string***REMOVED*** str input
 * @returns {string***REMOVED*** result
 */
const parseString = str => {
	if (str[0] === "'" || str[0] === "`")
		str = `"${str.slice(1, -1).replace(/"/g, '\\"')***REMOVED***"`;
	return JSON.parse(str);
***REMOVED***;

/* istanbul ignore next */
/**
 * @param {number***REMOVED*** mtime mtime
 */
const applyMtime = mtime => {
	if (FS_ACCURACY > 1 && mtime % 2 !== 0) FS_ACCURACY = 1;
	else if (FS_ACCURACY > 10 && mtime % 20 !== 0) FS_ACCURACY = 10;
	else if (FS_ACCURACY > 100 && mtime % 200 !== 0) FS_ACCURACY = 100;
	else if (FS_ACCURACY > 1000 && mtime % 2000 !== 0) FS_ACCURACY = 1000;
***REMOVED***;

/**
 * @template T
 * @template K
 * @param {Map<T, K> | undefined***REMOVED*** a source map
 * @param {Map<T, K> | undefined***REMOVED*** b joining map
 * @returns {Map<T, K>***REMOVED*** joined map
 */
const mergeMaps = (a, b) => {
	if (!b || b.size === 0) return /** @type {Map<T, K>***REMOVED*** */ (a);
	if (!a || a.size === 0) return /** @type {Map<T, K>***REMOVED*** */ (b);
	/** @type {Map<T, K>***REMOVED*** */
	const map = new Map(a);
	for (const [key, value] of b) {
		map.set(key, value);
	***REMOVED***
	return map;
***REMOVED***;

/**
 * @template T
 * @param {Set<T> | undefined***REMOVED*** a source map
 * @param {Set<T> | undefined***REMOVED*** b joining map
 * @returns {Set<T>***REMOVED*** joined map
 */
const mergeSets = (a, b) => {
	if (!b || b.size === 0) return /** @type {Set<T>***REMOVED*** */ (a);
	if (!a || a.size === 0) return /** @type {Set<T>***REMOVED*** */ (b);
	/** @type {Set<T>***REMOVED*** */
	const map = new Set(a);
	for (const item of b) {
		map.add(item);
	***REMOVED***
	return map;
***REMOVED***;

/**
 * Finding file or directory to manage
 * @param {string***REMOVED*** managedPath path that is managing by {@link FileSystemInfo***REMOVED***
 * @param {string***REMOVED*** path path to file or directory
 * @returns {string|null***REMOVED*** managed item
 * @example
 * getManagedItem(
 *   '/Users/user/my-project/node_modules/',
 *   '/Users/user/my-project/node_modules/package/index.js'
 * ) === '/Users/user/my-project/node_modules/package'
 * getManagedItem(
 *   '/Users/user/my-project/node_modules/',
 *   '/Users/user/my-project/node_modules/package1/node_modules/package2'
 * ) === '/Users/user/my-project/node_modules/package1/node_modules/package2'
 * getManagedItem(
 *   '/Users/user/my-project/node_modules/',
 *   '/Users/user/my-project/node_modules/.bin/script.js'
 * ) === null // hidden files are disallowed as managed items
 * getManagedItem(
 *   '/Users/user/my-project/node_modules/',
 *   '/Users/user/my-project/node_modules/package'
 * ) === '/Users/user/my-project/node_modules/package'
 */
const getManagedItem = (managedPath, path) => {
	let i = managedPath.length;
	let slashes = 1;
	let startingPosition = true;
	loop: while (i < path.length) {
		switch (path.charCodeAt(i)) {
			case 47: // slash
			case 92: // backslash
				if (--slashes === 0) break loop;
				startingPosition = true;
				break;
			case 46: // .
				// hidden files are disallowed as managed items
				// it's probably .yarn-integrity or .cache
				if (startingPosition) return null;
				break;
			case 64: // @
				if (!startingPosition) return null;
				slashes++;
				break;
			default:
				startingPosition = false;
				break;
		***REMOVED***
		i++;
	***REMOVED***
	if (i === path.length) slashes--;
	// return null when path is incomplete
	if (slashes !== 0) return null;
	// if (path.slice(i + 1, i + 13) === "node_modules")
	if (
		path.length >= i + 13 &&
		path.charCodeAt(i + 1) === 110 &&
		path.charCodeAt(i + 2) === 111 &&
		path.charCodeAt(i + 3) === 100 &&
		path.charCodeAt(i + 4) === 101 &&
		path.charCodeAt(i + 5) === 95 &&
		path.charCodeAt(i + 6) === 109 &&
		path.charCodeAt(i + 7) === 111 &&
		path.charCodeAt(i + 8) === 100 &&
		path.charCodeAt(i + 9) === 117 &&
		path.charCodeAt(i + 10) === 108 &&
		path.charCodeAt(i + 11) === 101 &&
		path.charCodeAt(i + 12) === 115
	) {
		// if this is the end of the path
		if (path.length === i + 13) {
			// return the node_modules directory
			// it's special
			return path;
		***REMOVED***
		const c = path.charCodeAt(i + 13);
		// if next symbol is slash or backslash
		if (c === 47 || c === 92) {
			// Managed subpath
			return getManagedItem(path.slice(0, i + 14), path);
		***REMOVED***
	***REMOVED***
	return path.slice(0, i);
***REMOVED***;

/**
 * @template {ContextFileSystemInfoEntry | ContextTimestampAndHash***REMOVED*** T
 * @param {T | null***REMOVED*** entry entry
 * @returns {T["resolved"] | null | undefined***REMOVED*** the resolved entry
 */
const getResolvedTimestamp = entry => {
	if (entry === null) return null;
	if (entry.resolved !== undefined) return entry.resolved;
	return entry.symlinks === undefined ? entry : undefined;
***REMOVED***;

/**
 * @param {ContextHash | null***REMOVED*** entry entry
 * @returns {string | null | undefined***REMOVED*** the resolved entry
 */
const getResolvedHash = entry => {
	if (entry === null) return null;
	if (entry.resolved !== undefined) return entry.resolved;
	return entry.symlinks === undefined ? entry.hash : undefined;
***REMOVED***;

/**
 * @template T
 * @param {Set<T>***REMOVED*** source source
 * @param {Set<T>***REMOVED*** target target
 */
const addAll = (source, target) => {
	for (const key of source) target.add(key);
***REMOVED***;

/** @typedef {Set<string>***REMOVED*** LoggedPaths */

/** @typedef {FileSystemInfoEntry | "ignore" | null***REMOVED*** FileTimestamp */
/** @typedef {ContextFileSystemInfoEntry | "ignore" | null***REMOVED*** ContextTimestamp */
/** @typedef {ResolvedContextFileSystemInfoEntry | "ignore" | null***REMOVED*** ResolvedContextTimestamp */

/** @typedef {(err?: WebpackError | null, result?: boolean) => void***REMOVED*** CheckSnapshotValidCallback */

/**
 * Used to access information about the filesystem in a cached way
 */
class FileSystemInfo {
	/**
	 * @param {InputFileSystem***REMOVED*** fs file system
	 * @param {object***REMOVED*** options options
	 * @param {Iterable<string | RegExp>=***REMOVED*** options.unmanagedPaths paths that are not managed by a package manager and the contents are subject to change
	 * @param {Iterable<string | RegExp>=***REMOVED*** options.managedPaths paths that are only managed by a package manager
	 * @param {Iterable<string | RegExp>=***REMOVED*** options.immutablePaths paths that are immutable
	 * @param {Logger=***REMOVED*** options.logger logger used to log invalid snapshots
	 * @param {HashFunction=***REMOVED*** options.hashFunction the hash function to use
	 */
	constructor(
		fs,
		{
			unmanagedPaths = [],
			managedPaths = [],
			immutablePaths = [],
			logger,
			hashFunction = DEFAULTS.HASH_FUNCTION
		***REMOVED*** = {***REMOVED***
	) {
		this.fs = fs;
		this.logger = logger;
		this._remainingLogs = logger ? 40 : 0;
		/** @type {LoggedPaths | undefined***REMOVED*** */
		this._loggedPaths = logger ? new Set() : undefined;
		this._hashFunction = hashFunction;
		/** @type {WeakMap<Snapshot, boolean | CheckSnapshotValidCallback[]>***REMOVED*** */
		this._snapshotCache = new WeakMap();
		this._fileTimestampsOptimization = new SnapshotOptimization(
			s => s.hasFileTimestamps(),
			s => s.fileTimestamps,
			(s, v) => s.setFileTimestamps(v)
		);
		this._fileHashesOptimization = new SnapshotOptimization(
			s => s.hasFileHashes(),
			s => s.fileHashes,
			(s, v) => s.setFileHashes(v),
			false
		);
		this._fileTshsOptimization = new SnapshotOptimization(
			s => s.hasFileTshs(),
			s => s.fileTshs,
			(s, v) => s.setFileTshs(v)
		);
		this._contextTimestampsOptimization = new SnapshotOptimization(
			s => s.hasContextTimestamps(),
			s => s.contextTimestamps,
			(s, v) => s.setContextTimestamps(v)
		);
		this._contextHashesOptimization = new SnapshotOptimization(
			s => s.hasContextHashes(),
			s => s.contextHashes,
			(s, v) => s.setContextHashes(v),
			false
		);
		this._contextTshsOptimization = new SnapshotOptimization(
			s => s.hasContextTshs(),
			s => s.contextTshs,
			(s, v) => s.setContextTshs(v)
		);
		this._missingExistenceOptimization = new SnapshotOptimization(
			s => s.hasMissingExistence(),
			s => s.missingExistence,
			(s, v) => s.setMissingExistence(v),
			false
		);
		this._managedItemInfoOptimization = new SnapshotOptimization(
			s => s.hasManagedItemInfo(),
			s => s.managedItemInfo,
			(s, v) => s.setManagedItemInfo(v),
			false
		);
		this._managedFilesOptimization = new SnapshotOptimization(
			s => s.hasManagedFiles(),
			s => s.managedFiles,
			(s, v) => s.setManagedFiles(v),
			false,
			true
		);
		this._managedContextsOptimization = new SnapshotOptimization(
			s => s.hasManagedContexts(),
			s => s.managedContexts,
			(s, v) => s.setManagedContexts(v),
			false,
			true
		);
		this._managedMissingOptimization = new SnapshotOptimization(
			s => s.hasManagedMissing(),
			s => s.managedMissing,
			(s, v) => s.setManagedMissing(v),
			false,
			true
		);
		/** @type {StackedCacheMap<string, FileTimestamp>***REMOVED*** */
		this._fileTimestamps = new StackedCacheMap();
		/** @type {Map<string, string | null>***REMOVED*** */
		this._fileHashes = new Map();
		/** @type {Map<string, TimestampAndHash | string>***REMOVED*** */
		this._fileTshs = new Map();
		/** @type {StackedCacheMap<string, ContextTimestamp>***REMOVED*** */
		this._contextTimestamps = new StackedCacheMap();
		/** @type {Map<string, ContextHash>***REMOVED*** */
		this._contextHashes = new Map();
		/** @type {Map<string, ContextTimestampAndHash>***REMOVED*** */
		this._contextTshs = new Map();
		/** @type {Map<string, string>***REMOVED*** */
		this._managedItems = new Map();
		/** @type {AsyncQueue<string, string, FileSystemInfoEntry>***REMOVED*** */
		this.fileTimestampQueue = new AsyncQueue({
			name: "file timestamp",
			parallelism: 30,
			processor: this._readFileTimestamp.bind(this)
		***REMOVED***);
		/** @type {AsyncQueue<string, string, string>***REMOVED*** */
		this.fileHashQueue = new AsyncQueue({
			name: "file hash",
			parallelism: 10,
			processor: this._readFileHash.bind(this)
		***REMOVED***);
		/** @type {AsyncQueue<string, string, ContextFileSystemInfoEntry>***REMOVED*** */
		this.contextTimestampQueue = new AsyncQueue({
			name: "context timestamp",
			parallelism: 2,
			processor: this._readContextTimestamp.bind(this)
		***REMOVED***);
		/** @type {AsyncQueue<string, string, ContextHash>***REMOVED*** */
		this.contextHashQueue = new AsyncQueue({
			name: "context hash",
			parallelism: 2,
			processor: this._readContextHash.bind(this)
		***REMOVED***);
		/** @type {AsyncQueue<string, string, ContextTimestampAndHash>***REMOVED*** */
		this.contextTshQueue = new AsyncQueue({
			name: "context hash and timestamp",
			parallelism: 2,
			processor: this._readContextTimestampAndHash.bind(this)
		***REMOVED***);
		/** @type {AsyncQueue<string, string, string>***REMOVED*** */
		this.managedItemQueue = new AsyncQueue({
			name: "managed item info",
			parallelism: 10,
			processor: this._getManagedItemInfo.bind(this)
		***REMOVED***);
		/** @type {AsyncQueue<string, string, Set<string>>***REMOVED*** */
		this.managedItemDirectoryQueue = new AsyncQueue({
			name: "managed item directory info",
			parallelism: 10,
			processor: this._getManagedItemDirectoryInfo.bind(this)
		***REMOVED***);
		const _unmanagedPaths = Array.from(unmanagedPaths);
		this.unmanagedPathsWithSlash =
			/** @type {string[]***REMOVED*** */
			(_unmanagedPaths.filter(p => typeof p === "string")).map(p =>
				join(fs, p, "_").slice(0, -1)
			);
		this.unmanagedPathsRegExps =
			/** @type {RegExp[]***REMOVED*** */
			(_unmanagedPaths.filter(p => typeof p !== "string"));

		this.managedPaths = Array.from(managedPaths);
		this.managedPathsWithSlash =
			/** @type {string[]***REMOVED*** */
			(this.managedPaths.filter(p => typeof p === "string")).map(p =>
				join(fs, p, "_").slice(0, -1)
			);

		this.managedPathsRegExps =
			/** @type {RegExp[]***REMOVED*** */
			(this.managedPaths.filter(p => typeof p !== "string"));
		this.immutablePaths = Array.from(immutablePaths);
		this.immutablePathsWithSlash =
			/** @type {string[]***REMOVED*** */
			(this.immutablePaths.filter(p => typeof p === "string")).map(p =>
				join(fs, p, "_").slice(0, -1)
			);
		this.immutablePathsRegExps =
			/** @type {RegExp[]***REMOVED*** */
			(this.immutablePaths.filter(p => typeof p !== "string"));

		this._cachedDeprecatedFileTimestamps = undefined;
		this._cachedDeprecatedContextTimestamps = undefined;

		this._warnAboutExperimentalEsmTracking = false;

		this._statCreatedSnapshots = 0;
		this._statTestedSnapshotsCached = 0;
		this._statTestedSnapshotsNotCached = 0;
		this._statTestedChildrenCached = 0;
		this._statTestedChildrenNotCached = 0;
		this._statTestedEntries = 0;
	***REMOVED***

	logStatistics() {
		const logger = /** @type {Logger***REMOVED*** */ (this.logger);
		/**
		 * @param {string***REMOVED*** header header
		 * @param {string | undefined***REMOVED*** message message
		 */
		const logWhenMessage = (header, message) => {
			if (message) {
				logger.log(`${header***REMOVED***: ${message***REMOVED***`);
			***REMOVED***
		***REMOVED***;
		logger.log(`${this._statCreatedSnapshots***REMOVED*** new snapshots created`);
		logger.log(
			`${
				this._statTestedSnapshotsNotCached &&
				Math.round(
					(this._statTestedSnapshotsNotCached * 100) /
						(this._statTestedSnapshotsCached +
							this._statTestedSnapshotsNotCached)
				)
			***REMOVED***% root snapshot uncached (${this._statTestedSnapshotsNotCached***REMOVED*** / ${
				this._statTestedSnapshotsCached + this._statTestedSnapshotsNotCached
			***REMOVED***)`
		);
		logger.log(
			`${
				this._statTestedChildrenNotCached &&
				Math.round(
					(this._statTestedChildrenNotCached * 100) /
						(this._statTestedChildrenCached + this._statTestedChildrenNotCached)
				)
			***REMOVED***% children snapshot uncached (${this._statTestedChildrenNotCached***REMOVED*** / ${
				this._statTestedChildrenCached + this._statTestedChildrenNotCached
			***REMOVED***)`
		);
		logger.log(`${this._statTestedEntries***REMOVED*** entries tested`);
		logger.log(
			`File info in cache: ${this._fileTimestamps.size***REMOVED*** timestamps ${this._fileHashes.size***REMOVED*** hashes ${this._fileTshs.size***REMOVED*** timestamp hash combinations`
		);
		logWhenMessage(
			"File timestamp snapshot optimization",
			this._fileTimestampsOptimization.getStatisticMessage()
		);
		logWhenMessage(
			"File hash snapshot optimization",
			this._fileHashesOptimization.getStatisticMessage()
		);
		logWhenMessage(
			"File timestamp hash combination snapshot optimization",
			this._fileTshsOptimization.getStatisticMessage()
		);
		logger.log(
			`Directory info in cache: ${this._contextTimestamps.size***REMOVED*** timestamps ${this._contextHashes.size***REMOVED*** hashes ${this._contextTshs.size***REMOVED*** timestamp hash combinations`
		);
		logWhenMessage(
			"Directory timestamp snapshot optimization",
			this._contextTimestampsOptimization.getStatisticMessage()
		);
		logWhenMessage(
			"Directory hash snapshot optimization",
			this._contextHashesOptimization.getStatisticMessage()
		);
		logWhenMessage(
			"Directory timestamp hash combination snapshot optimization",
			this._contextTshsOptimization.getStatisticMessage()
		);
		logWhenMessage(
			"Missing items snapshot optimization",
			this._missingExistenceOptimization.getStatisticMessage()
		);
		logger.log(`Managed items info in cache: ${this._managedItems.size***REMOVED*** items`);
		logWhenMessage(
			"Managed items snapshot optimization",
			this._managedItemInfoOptimization.getStatisticMessage()
		);
		logWhenMessage(
			"Managed files snapshot optimization",
			this._managedFilesOptimization.getStatisticMessage()
		);
		logWhenMessage(
			"Managed contexts snapshot optimization",
			this._managedContextsOptimization.getStatisticMessage()
		);
		logWhenMessage(
			"Managed missing snapshot optimization",
			this._managedMissingOptimization.getStatisticMessage()
		);
	***REMOVED***

	/**
	 * @private
	 * @param {string***REMOVED*** path path
	 * @param {string***REMOVED*** reason reason
	 * @param {EXPECTED_ANY[]***REMOVED*** args arguments
	 */
	_log(path, reason, ...args) {
		const key = path + reason;
		const loggedPaths = /** @type {LoggedPaths***REMOVED*** */ (this._loggedPaths);
		if (loggedPaths.has(key)) return;
		loggedPaths.add(key);
		/** @type {Logger***REMOVED*** */
		(this.logger).debug(`${path***REMOVED*** invalidated because ${reason***REMOVED***`, ...args);
		if (--this._remainingLogs === 0) {
			/** @type {Logger***REMOVED*** */
			(this.logger).debug(
				"Logging limit has been reached and no further logging will be emitted by FileSystemInfo"
			);
		***REMOVED***
	***REMOVED***

	clear() {
		this._remainingLogs = this.logger ? 40 : 0;
		if (this._loggedPaths !== undefined) this._loggedPaths.clear();

		this._snapshotCache = new WeakMap();
		this._fileTimestampsOptimization.clear();
		this._fileHashesOptimization.clear();
		this._fileTshsOptimization.clear();
		this._contextTimestampsOptimization.clear();
		this._contextHashesOptimization.clear();
		this._contextTshsOptimization.clear();
		this._missingExistenceOptimization.clear();
		this._managedItemInfoOptimization.clear();
		this._managedFilesOptimization.clear();
		this._managedContextsOptimization.clear();
		this._managedMissingOptimization.clear();
		this._fileTimestamps.clear();
		this._fileHashes.clear();
		this._fileTshs.clear();
		this._contextTimestamps.clear();
		this._contextHashes.clear();
		this._contextTshs.clear();
		this._managedItems.clear();
		this._managedItems.clear();

		this._cachedDeprecatedFileTimestamps = undefined;
		this._cachedDeprecatedContextTimestamps = undefined;

		this._statCreatedSnapshots = 0;
		this._statTestedSnapshotsCached = 0;
		this._statTestedSnapshotsNotCached = 0;
		this._statTestedChildrenCached = 0;
		this._statTestedChildrenNotCached = 0;
		this._statTestedEntries = 0;
	***REMOVED***

	/**
	 * @param {ReadonlyMap<string, FileTimestamp>***REMOVED*** map timestamps
	 * @param {boolean=***REMOVED*** immutable if 'map' is immutable and FileSystemInfo can keep referencing it
	 * @returns {void***REMOVED***
	 */
	addFileTimestamps(map, immutable) {
		this._fileTimestamps.addAll(map, immutable);
		this._cachedDeprecatedFileTimestamps = undefined;
	***REMOVED***

	/**
	 * @param {ReadonlyMap<string, ContextTimestamp>***REMOVED*** map timestamps
	 * @param {boolean=***REMOVED*** immutable if 'map' is immutable and FileSystemInfo can keep referencing it
	 * @returns {void***REMOVED***
	 */
	addContextTimestamps(map, immutable) {
		this._contextTimestamps.addAll(map, immutable);
		this._cachedDeprecatedContextTimestamps = undefined;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** path file path
	 * @param {(err?: WebpackError | null, fileTimestamp?: FileTimestamp) => void***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	getFileTimestamp(path, callback) {
		const cache = this._fileTimestamps.get(path);
		if (cache !== undefined) return callback(null, cache);
		this.fileTimestampQueue.add(path, callback);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** path context path
	 * @param {(err?: WebpackError | null, resolvedContextTimestamp?: ResolvedContextTimestamp) => void***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	getContextTimestamp(path, callback) {
		const cache = this._contextTimestamps.get(path);
		if (cache !== undefined) {
			if (cache === "ignore") return callback(null, "ignore");
			const resolved = getResolvedTimestamp(cache);
			if (resolved !== undefined) return callback(null, resolved);
			return this._resolveContextTimestamp(
				/** @type {ResolvedContextFileSystemInfoEntry***REMOVED*** */
				(cache),
				callback
			);
		***REMOVED***
		this.contextTimestampQueue.add(path, (err, _entry) => {
			if (err) return callback(err);
			const entry = /** @type {ContextFileSystemInfoEntry***REMOVED*** */ (_entry);
			const resolved = getResolvedTimestamp(entry);
			if (resolved !== undefined) return callback(null, resolved);
			this._resolveContextTimestamp(entry, callback);
		***REMOVED***);
	***REMOVED***

	/**
	 * @private
	 * @param {string***REMOVED*** path context path
	 * @param {(err?: WebpackError | null, contextTimestamp?: ContextTimestamp) => void***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	_getUnresolvedContextTimestamp(path, callback) {
		const cache = this._contextTimestamps.get(path);
		if (cache !== undefined) return callback(null, cache);
		this.contextTimestampQueue.add(path, callback);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** path file path
	 * @param {(err?: WebpackError | null, hash?: string | null) => void***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	getFileHash(path, callback) {
		const cache = this._fileHashes.get(path);
		if (cache !== undefined) return callback(null, cache);
		this.fileHashQueue.add(path, callback);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** path context path
	 * @param {(err?: WebpackError | null, contextHash?: string) => void***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	getContextHash(path, callback) {
		const cache = this._contextHashes.get(path);
		if (cache !== undefined) {
			const resolved = getResolvedHash(cache);
			if (resolved !== undefined)
				return callback(null, /** @type {string***REMOVED*** */ (resolved));
			return this._resolveContextHash(cache, callback);
		***REMOVED***
		this.contextHashQueue.add(path, (err, _entry) => {
			if (err) return callback(err);
			const entry = /** @type {ContextHash***REMOVED*** */ (_entry);
			const resolved = getResolvedHash(entry);
			if (resolved !== undefined)
				return callback(null, /** @type {string***REMOVED*** */ (resolved));
			this._resolveContextHash(entry, callback);
		***REMOVED***);
	***REMOVED***

	/**
	 * @private
	 * @param {string***REMOVED*** path context path
	 * @param {(err?: WebpackError | null, contextHash?: ContextHash | null) => void***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	_getUnresolvedContextHash(path, callback) {
		const cache = this._contextHashes.get(path);
		if (cache !== undefined) return callback(null, cache);
		this.contextHashQueue.add(path, callback);
	***REMOVED***

	/**
	 * @param {string***REMOVED*** path context path
	 * @param {(err?: WebpackError | null, resolvedContextTimestampAndHash?: ResolvedContextTimestampAndHash | null) => void***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	getContextTsh(path, callback) {
		const cache = this._contextTshs.get(path);
		if (cache !== undefined) {
			const resolved = getResolvedTimestamp(cache);
			if (resolved !== undefined) return callback(null, resolved);
			return this._resolveContextTsh(cache, callback);
		***REMOVED***
		this.contextTshQueue.add(path, (err, _entry) => {
			if (err) return callback(err);
			const entry = /** @type {ContextTimestampAndHash***REMOVED*** */ (_entry);
			const resolved = getResolvedTimestamp(entry);
			if (resolved !== undefined) return callback(null, resolved);
			this._resolveContextTsh(entry, callback);
		***REMOVED***);
	***REMOVED***

	/**
	 * @private
	 * @param {string***REMOVED*** path context path
	 * @param {(err?: WebpackError | null, contextTimestampAndHash?: ContextTimestampAndHash | null) => void***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	_getUnresolvedContextTsh(path, callback) {
		const cache = this._contextTshs.get(path);
		if (cache !== undefined) return callback(null, cache);
		this.contextTshQueue.add(path, callback);
	***REMOVED***

	_createBuildDependenciesResolvers() {
		const resolveContext = createResolver({
			resolveToContext: true,
			exportsFields: [],
			fileSystem: this.fs
		***REMOVED***);
		const resolveCjs = createResolver({
			extensions: [".js", ".json", ".node"],
			conditionNames: ["require", "node"],
			exportsFields: ["exports"],
			fileSystem: this.fs
		***REMOVED***);
		const resolveCjsAsChild = createResolver({
			extensions: [".js", ".json", ".node"],
			conditionNames: ["require", "node"],
			exportsFields: [],
			fileSystem: this.fs
		***REMOVED***);
		const resolveEsm = createResolver({
			extensions: [".js", ".json", ".node"],
			fullySpecified: true,
			conditionNames: ["import", "node"],
			exportsFields: ["exports"],
			fileSystem: this.fs
		***REMOVED***);
		return { resolveContext, resolveEsm, resolveCjs, resolveCjsAsChild ***REMOVED***;
	***REMOVED***

	/**
	 * @param {string***REMOVED*** context context directory
	 * @param {Iterable<string>***REMOVED*** deps dependencies
	 * @param {(err?: Error | null, resolveBuildDependenciesResult?: ResolveBuildDependenciesResult) => void***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	resolveBuildDependencies(context, deps, callback) {
		const { resolveContext, resolveEsm, resolveCjs, resolveCjsAsChild ***REMOVED*** =
			this._createBuildDependenciesResolvers();

		/** @type {Files***REMOVED*** */
		const files = new Set();
		/** @type {Symlinks***REMOVED*** */
		const fileSymlinks = new Set();
		/** @type {Directories***REMOVED*** */
		const directories = new Set();
		/** @type {Symlinks***REMOVED*** */
		const directorySymlinks = new Set();
		/** @type {Missing***REMOVED*** */
		const missing = new Set();
		/** @type {ResolveDependencies["files"]***REMOVED*** */
		const resolveFiles = new Set();
		/** @type {ResolveDependencies["directories"]***REMOVED*** */
		const resolveDirectories = new Set();
		/** @type {ResolveDependencies["missing"]***REMOVED*** */
		const resolveMissing = new Set();
		/** @type {ResolveResults***REMOVED*** */
		const resolveResults = new Map();
		/** @type {Set<string>***REMOVED*** */
		const invalidResolveResults = new Set();
		const resolverContext = {
			fileDependencies: resolveFiles,
			contextDependencies: resolveDirectories,
			missingDependencies: resolveMissing
		***REMOVED***;
		/**
		 * @param {undefined | boolean | string***REMOVED*** expected expected result
		 * @returns {string***REMOVED*** expected result
		 */
		const expectedToString = expected =>
			expected ? ` (expected ${expected***REMOVED***)` : "";
		/** @typedef {{ type: JobType, context: string | undefined, path: string, issuer: Job | undefined, expected: undefined | boolean | string ***REMOVED******REMOVED*** Job */

		/**
		 * @param {Job***REMOVED*** job job
		 * @returns {`resolve commonjs file ${string***REMOVED***${string***REMOVED***`|`resolve esm file ${string***REMOVED***${string***REMOVED***`|`resolve esm ${string***REMOVED***${string***REMOVED***`|`resolve directory ${string***REMOVED***`|`file ${string***REMOVED***`|`unknown ${string***REMOVED*** ${string***REMOVED***`|`resolve commonjs ${string***REMOVED***${string***REMOVED***`|`directory ${string***REMOVED***`|`file dependencies ${string***REMOVED***`|`directory dependencies ${string***REMOVED***`***REMOVED*** result
		 */
		const jobToString = job => {
			switch (job.type) {
				case RBDT_RESOLVE_CJS:
					return `resolve commonjs ${job.path***REMOVED***${expectedToString(
						job.expected
					)***REMOVED***`;
				case RBDT_RESOLVE_ESM:
					return `resolve esm ${job.path***REMOVED***${expectedToString(job.expected)***REMOVED***`;
				case RBDT_RESOLVE_DIRECTORY:
					return `resolve directory ${job.path***REMOVED***`;
				case RBDT_RESOLVE_CJS_FILE:
					return `resolve commonjs file ${job.path***REMOVED***${expectedToString(
						job.expected
					)***REMOVED***`;
				case RBDT_RESOLVE_ESM_FILE:
					return `resolve esm file ${job.path***REMOVED***${expectedToString(
						job.expected
					)***REMOVED***`;
				case RBDT_DIRECTORY:
					return `directory ${job.path***REMOVED***`;
				case RBDT_FILE:
					return `file ${job.path***REMOVED***`;
				case RBDT_DIRECTORY_DEPENDENCIES:
					return `directory dependencies ${job.path***REMOVED***`;
				case RBDT_FILE_DEPENDENCIES:
					return `file dependencies ${job.path***REMOVED***`;
			***REMOVED***
			return `unknown ${job.type***REMOVED*** ${job.path***REMOVED***`;
		***REMOVED***;
		/**
		 * @param {Job***REMOVED*** job job
		 * @returns {string***REMOVED*** string value
		 */
		const pathToString = job => {
			let result = ` at ${jobToString(job)***REMOVED***`;
			/** @type {Job | undefined***REMOVED*** */
			(job) = job.issuer;
			while (job !== undefined) {
				result += `\n at ${jobToString(job)***REMOVED***`;
				job = /** @type {Job***REMOVED*** */ (job.issuer);
			***REMOVED***
			return result;
		***REMOVED***;
		const logger = /** @type {Logger***REMOVED*** */ (this.logger);
		processAsyncTree(
			Array.from(
				deps,
				dep =>
					/** @type {Job***REMOVED*** */ ({
						type: RBDT_RESOLVE_CJS,
						context,
						path: dep,
						expected: undefined,
						issuer: undefined
					***REMOVED***)
			),
			20,
			(job, push, callback) => {
				const { type, context, path, expected ***REMOVED*** = job;
				/**
				 * @param {string***REMOVED*** path path
				 * @returns {void***REMOVED***
				 */
				const resolveDirectory = path => {
					const key = `d\n${context***REMOVED***\n${path***REMOVED***`;
					if (resolveResults.has(key)) {
						return callback();
					***REMOVED***
					resolveResults.set(key, undefined);
					resolveContext(
						/** @type {string***REMOVED*** */ (context),
						path,
						resolverContext,
						(err, _, result) => {
							if (err) {
								if (expected === false) {
									resolveResults.set(key, false);
									return callback();
								***REMOVED***
								invalidResolveResults.add(key);
								err.message += `\nwhile resolving '${path***REMOVED***' in ${context***REMOVED*** to a directory`;
								return callback(err);
							***REMOVED***
							const resultPath = /** @type {ResolveRequest***REMOVED*** */ (result).path;
							resolveResults.set(key, resultPath);
							push({
								type: RBDT_DIRECTORY,
								context: undefined,
								path: /** @type {string***REMOVED*** */ (resultPath),
								expected: undefined,
								issuer: job
							***REMOVED***);
							callback();
						***REMOVED***
					);
				***REMOVED***;
				/**
				 * @param {string***REMOVED*** path path
				 * @param {("f" | "c" | "e")=***REMOVED*** symbol symbol
				 * @param {(ResolveFunctionAsync)=***REMOVED*** resolve resolve fn
				 * @returns {void***REMOVED***
				 */
				const resolveFile = (path, symbol, resolve) => {
					const key = `${symbol***REMOVED***\n${context***REMOVED***\n${path***REMOVED***`;
					if (resolveResults.has(key)) {
						return callback();
					***REMOVED***
					resolveResults.set(key, undefined);
					/** @type {ResolveFunctionAsync***REMOVED*** */
					(resolve)(
						/** @type {string***REMOVED*** */ (context),
						path,
						resolverContext,
						(err, _, result) => {
							if (typeof expected === "string") {
								if (!err && result && result.path === expected) {
									resolveResults.set(key, result.path);
								***REMOVED*** else {
									invalidResolveResults.add(key);
									logger.warn(
										`Resolving '${path***REMOVED***' in ${context***REMOVED*** for build dependencies doesn't lead to expected result '${expected***REMOVED***', but to '${
											err || (result && result.path)
										***REMOVED***' instead. Resolving dependencies are ignored for this path.\n${pathToString(
											job
										)***REMOVED***`
									);
								***REMOVED***
							***REMOVED*** else {
								if (err) {
									if (expected === false) {
										resolveResults.set(key, false);
										return callback();
									***REMOVED***
									invalidResolveResults.add(key);
									err.message += `\nwhile resolving '${path***REMOVED***' in ${context***REMOVED*** as file\n${pathToString(
										job
									)***REMOVED***`;
									return callback(err);
								***REMOVED***
								const resultPath = /** @type {ResolveRequest***REMOVED*** */ (result).path;
								resolveResults.set(key, resultPath);
								push({
									type: RBDT_FILE,
									context: undefined,
									path: /** @type {string***REMOVED*** */ (resultPath),
									expected: undefined,
									issuer: job
								***REMOVED***);
							***REMOVED***
							callback();
						***REMOVED***
					);
				***REMOVED***;
				switch (type) {
					case RBDT_RESOLVE_CJS: {
						const isDirectory = /[\\/]$/.test(path);
						if (isDirectory) {
							resolveDirectory(path.slice(0, -1));
						***REMOVED*** else {
							resolveFile(path, "f", resolveCjs);
						***REMOVED***
						break;
					***REMOVED***
					case RBDT_RESOLVE_ESM: {
						const isDirectory = /[\\/]$/.test(path);
						if (isDirectory) {
							resolveDirectory(path.slice(0, -1));
						***REMOVED*** else {
							resolveFile(path);
						***REMOVED***
						break;
					***REMOVED***
					case RBDT_RESOLVE_DIRECTORY: {
						resolveDirectory(path);
						break;
					***REMOVED***
					case RBDT_RESOLVE_CJS_FILE: {
						resolveFile(path, "f", resolveCjs);
						break;
					***REMOVED***
					case RBDT_RESOLVE_CJS_FILE_AS_CHILD: {
						resolveFile(path, "c", resolveCjsAsChild);
						break;
					***REMOVED***
					case RBDT_RESOLVE_ESM_FILE: {
						resolveFile(path, "e", resolveEsm);
						break;
					***REMOVED***
					case RBDT_FILE: {
						if (files.has(path)) {
							callback();
							break;
						***REMOVED***
						files.add(path);
						/** @type {NonNullable<InputFileSystem["realpath"]>***REMOVED*** */
						(this.fs.realpath)(path, (err, _realPath) => {
							if (err) return callback(err);
							const realPath = /** @type {string***REMOVED*** */ (_realPath);
							if (realPath !== path) {
								fileSymlinks.add(path);
								resolveFiles.add(path);
								if (files.has(realPath)) return callback();
								files.add(realPath);
							***REMOVED***
							push({
								type: RBDT_FILE_DEPENDENCIES,
								context: undefined,
								path: realPath,
								expected: undefined,
								issuer: job
							***REMOVED***);
							callback();
						***REMOVED***);
						break;
					***REMOVED***
					case RBDT_DIRECTORY: {
						if (directories.has(path)) {
							callback();
							break;
						***REMOVED***
						directories.add(path);
						/** @type {NonNullable<InputFileSystem["realpath"]>***REMOVED*** */
						(this.fs.realpath)(path, (err, _realPath) => {
							if (err) return callback(err);
							const realPath = /** @type {string***REMOVED*** */ (_realPath);
							if (realPath !== path) {
								directorySymlinks.add(path);
								resolveFiles.add(path);
								if (directories.has(realPath)) return callback();
								directories.add(realPath);
							***REMOVED***
							push({
								type: RBDT_DIRECTORY_DEPENDENCIES,
								context: undefined,
								path: realPath,
								expected: undefined,
								issuer: job
							***REMOVED***);
							callback();
						***REMOVED***);
						break;
					***REMOVED***
					case RBDT_FILE_DEPENDENCIES: {
						// Check for known files without dependencies
						if (/\.json5?$|\.yarn-integrity$|yarn\.lock$|\.ya?ml/.test(path)) {
							process.nextTick(callback);
							break;
						***REMOVED***
						// Check commonjs cache for the module
						/** @type {NodeModule | undefined***REMOVED*** */
						const module = require.cache[path];
						if (module && Array.isArray(module.children)) {
							children: for (const child of module.children) {
								const childPath = child.filename;
								if (childPath) {
									push({
										type: RBDT_FILE,
										context: undefined,
										path: childPath,
										expected: undefined,
										issuer: job
									***REMOVED***);
									const context = dirname(this.fs, path);
									for (const modulePath of module.paths) {
										if (childPath.startsWith(modulePath)) {
											const subPath = childPath.slice(modulePath.length + 1);
											const packageMatch = /^(@[^\\/]+[\\/])[^\\/]+/.exec(
												subPath
											);
											if (packageMatch) {
												push({
													type: RBDT_FILE,
													context: undefined,
													path: `${
														modulePath +
														childPath[modulePath.length] +
														packageMatch[0] +
														childPath[modulePath.length]
													***REMOVED***package.json`,
													expected: false,
													issuer: job
												***REMOVED***);
											***REMOVED***
											let request = subPath.replace(/\\/g, "/");
											if (request.endsWith(".js"))
												request = request.slice(0, -3);
											push({
												type: RBDT_RESOLVE_CJS_FILE_AS_CHILD,
												context,
												path: request,
												expected: child.filename,
												issuer: job
											***REMOVED***);
											continue children;
										***REMOVED***
									***REMOVED***
									let request = relative(this.fs, context, childPath);
									if (request.endsWith(".js")) request = request.slice(0, -3);
									request = request.replace(/\\/g, "/");
									if (!request.startsWith("../") && !isAbsolute(request)) {
										request = `./${request***REMOVED***`;
									***REMOVED***
									push({
										type: RBDT_RESOLVE_CJS_FILE,
										context,
										path: request,
										expected: child.filename,
										issuer: job
									***REMOVED***);
								***REMOVED***
							***REMOVED***
						***REMOVED*** else if (supportsEsm && /\.m?js$/.test(path)) {
							if (!this._warnAboutExperimentalEsmTracking) {
								logger.log(
									"Node.js doesn't offer a (nice) way to introspect the ESM dependency graph yet.\n" +
										"Until a full solution is available webpack uses an experimental ESM tracking based on parsing.\n" +
										"As best effort webpack parses the ESM files to guess dependencies. But this can lead to expensive and incorrect tracking."
								);
								this._warnAboutExperimentalEsmTracking = true;
							***REMOVED***
							const lexer = require("es-module-lexer");
							lexer.init.then(() => {
								this.fs.readFile(path, (err, content) => {
									if (err) return callback(err);
									try {
										const context = dirname(this.fs, path);
										const source = /** @type {Buffer***REMOVED*** */ (content).toString();
										const [imports] = lexer.parse(source);
										for (const imp of imports) {
											try {
												let dependency;
												if (imp.d === -1) {
													// import ... from "..."
													dependency = parseString(
														source.substring(imp.s - 1, imp.e + 1)
													);
												***REMOVED*** else if (imp.d > -1) {
													// import()
													const expr = source.substring(imp.s, imp.e).trim();
													dependency = parseString(expr);
												***REMOVED*** else {
													// e.g. import.meta
													continue;
												***REMOVED***

												// we should not track Node.js build dependencies
												if (dependency.startsWith("node:")) continue;
												if (builtinModules.has(dependency)) continue;

												push({
													type: RBDT_RESOLVE_ESM_FILE,
													context,
													path: dependency,
													expected: imp.d > -1 ? false : undefined,
													issuer: job
												***REMOVED***);
											***REMOVED*** catch (err1) {
												logger.warn(
													`Parsing of ${path***REMOVED*** for build dependencies failed at 'import(${source.substring(
														imp.s,
														imp.e
													)***REMOVED***)'.\n` +
														"Build dependencies behind this expression are ignored and might cause incorrect cache invalidation."
												);
												logger.debug(pathToString(job));
												logger.debug(/** @type {Error***REMOVED*** */ (err1).stack);
											***REMOVED***
										***REMOVED***
									***REMOVED*** catch (err2) {
										logger.warn(
											`Parsing of ${path***REMOVED*** for build dependencies failed and all dependencies of this file are ignored, which might cause incorrect cache invalidation..`
										);
										logger.debug(pathToString(job));
										logger.debug(/** @type {Error***REMOVED*** */ (err2).stack);
									***REMOVED***
									process.nextTick(callback);
								***REMOVED***);
							***REMOVED***, callback);
							break;
						***REMOVED*** else {
							logger.log(
								`Assuming ${path***REMOVED*** has no dependencies as we were unable to assign it to any module system.`
							);
							logger.debug(pathToString(job));
						***REMOVED***
						process.nextTick(callback);
						break;
					***REMOVED***
					case RBDT_DIRECTORY_DEPENDENCIES: {
						const match =
							/(^.+[\\/]node_modules[\\/](?:@[^\\/]+[\\/])?[^\\/]+)/.exec(path);
						const packagePath = match ? match[1] : path;
						const packageJson = join(this.fs, packagePath, "package.json");
						this.fs.readFile(packageJson, (err, content) => {
							if (err) {
								if (err.code === "ENOENT") {
									resolveMissing.add(packageJson);
									const parent = dirname(this.fs, packagePath);
									if (parent !== packagePath) {
										push({
											type: RBDT_DIRECTORY_DEPENDENCIES,
											context: undefined,
											path: parent,
											expected: undefined,
											issuer: job
										***REMOVED***);
									***REMOVED***
									callback();
									return;
								***REMOVED***
								return callback(err);
							***REMOVED***
							resolveFiles.add(packageJson);
							let packageData;
							try {
								packageData = JSON.parse(
									/** @type {Buffer***REMOVED*** */ (content).toString("utf-8")
								);
							***REMOVED*** catch (parseErr) {
								return callback(/** @type {Error***REMOVED*** */ (parseErr));
							***REMOVED***
							const depsObject = packageData.dependencies;
							const optionalDepsObject = packageData.optionalDependencies;
							const allDeps = new Set();
							const optionalDeps = new Set();
							if (typeof depsObject === "object" && depsObject) {
								for (const dep of Object.keys(depsObject)) {
									allDeps.add(dep);
								***REMOVED***
							***REMOVED***
							if (
								typeof optionalDepsObject === "object" &&
								optionalDepsObject
							) {
								for (const dep of Object.keys(optionalDepsObject)) {
									allDeps.add(dep);
									optionalDeps.add(dep);
								***REMOVED***
							***REMOVED***
							for (const dep of allDeps) {
								push({
									type: RBDT_RESOLVE_DIRECTORY,
									context: packagePath,
									path: dep,
									expected: !optionalDeps.has(dep),
									issuer: job
								***REMOVED***);
							***REMOVED***
							callback();
						***REMOVED***);
						break;
					***REMOVED***
				***REMOVED***
			***REMOVED***,
			err => {
				if (err) return callback(err);
				for (const l of fileSymlinks) files.delete(l);
				for (const l of directorySymlinks) directories.delete(l);
				for (const k of invalidResolveResults) resolveResults.delete(k);
				callback(null, {
					files,
					directories,
					missing,
					resolveResults,
					resolveDependencies: {
						files: resolveFiles,
						directories: resolveDirectories,
						missing: resolveMissing
					***REMOVED***
				***REMOVED***);
			***REMOVED***
		);
	***REMOVED***

	/**
	 * @param {ResolveResults***REMOVED*** resolveResults results from resolving
	 * @param {(err?: Error | null, result?: boolean) => void***REMOVED*** callback callback with true when resolveResults resolve the same way
	 * @returns {void***REMOVED***
	 */
	checkResolveResultsValid(resolveResults, callback) {
		const { resolveCjs, resolveCjsAsChild, resolveEsm, resolveContext ***REMOVED*** =
			this._createBuildDependenciesResolvers();
		asyncLib.eachLimit(
			resolveResults,
			20,
			([key, expectedResult], callback) => {
				const [type, context, path] = key.split("\n");
				switch (type) {
					case "d":
						resolveContext(context, path, {***REMOVED***, (err, _, result) => {
							if (expectedResult === false)
								return callback(err ? undefined : INVALID);
							if (err) return callback(err);
							const resultPath = /** @type {ResolveRequest***REMOVED*** */ (result).path;
							if (resultPath !== expectedResult) return callback(INVALID);
							callback();
						***REMOVED***);
						break;
					case "f":
						resolveCjs(context, path, {***REMOVED***, (err, _, result) => {
							if (expectedResult === false)
								return callback(err ? undefined : INVALID);
							if (err) return callback(err);
							const resultPath = /** @type {ResolveRequest***REMOVED*** */ (result).path;
							if (resultPath !== expectedResult) return callback(INVALID);
							callback();
						***REMOVED***);
						break;
					case "c":
						resolveCjsAsChild(context, path, {***REMOVED***, (err, _, result) => {
							if (expectedResult === false)
								return callback(err ? undefined : INVALID);
							if (err) return callback(err);
							const resultPath = /** @type {ResolveRequest***REMOVED*** */ (result).path;
							if (resultPath !== expectedResult) return callback(INVALID);
							callback();
						***REMOVED***);
						break;
					case "e":
						resolveEsm(context, path, {***REMOVED***, (err, _, result) => {
							if (expectedResult === false)
								return callback(err ? undefined : INVALID);
							if (err) return callback(err);
							const resultPath = /** @type {ResolveRequest***REMOVED*** */ (result).path;
							if (resultPath !== expectedResult) return callback(INVALID);
							callback();
						***REMOVED***);
						break;
					default:
						callback(new Error("Unexpected type in resolve result key"));
						break;
				***REMOVED***
			***REMOVED***,
			/**
			 * @param {Error | typeof INVALID=***REMOVED*** err error or invalid flag
			 * @returns {void***REMOVED***
			 */
			err => {
				if (err === INVALID) {
					return callback(null, false);
				***REMOVED***
				if (err) {
					return callback(err);
				***REMOVED***
				return callback(null, true);
			***REMOVED***
		);
	***REMOVED***

	/**
	 * @param {number | null | undefined***REMOVED*** startTime when processing the files has started
	 * @param {Iterable<string> | null***REMOVED*** files all files
	 * @param {Iterable<string> | null***REMOVED*** directories all directories
	 * @param {Iterable<string> | null***REMOVED*** missing all missing files or directories
	 * @param {SnapshotOptions | null | undefined***REMOVED*** options options object (for future extensions)
	 * @param {(err: WebpackError | null, snapshot: Snapshot | null) => void***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	createSnapshot(startTime, files, directories, missing, options, callback) {
		/** @type {FileTimestamps***REMOVED*** */
		const fileTimestamps = new Map();
		/** @type {FileHashes***REMOVED*** */
		const fileHashes = new Map();
		/** @type {FileTshs***REMOVED*** */
		const fileTshs = new Map();
		/** @type {ContextTimestamps***REMOVED*** */
		const contextTimestamps = new Map();
		/** @type {ContextHashes***REMOVED*** */
		const contextHashes = new Map();
		/** @type {ContextTshs***REMOVED*** */
		const contextTshs = new Map();
		/** @type {MissingExistence***REMOVED*** */
		const missingExistence = new Map();
		/** @type {ManagedItemInfo***REMOVED*** */
		const managedItemInfo = new Map();
		/** @type {ManagedFiles***REMOVED*** */
		const managedFiles = new Set();
		/** @type {ManagedContexts***REMOVED*** */
		const managedContexts = new Set();
		/** @type {ManagedMissing***REMOVED*** */
		const managedMissing = new Set();
		/** @type {Children***REMOVED*** */
		const children = new Set();

		const snapshot = new Snapshot();
		if (startTime) snapshot.setStartTime(startTime);

		/** @type {Set<string>***REMOVED*** */
		const managedItems = new Set();

		/** 1 = timestamp, 2 = hash, 3 = timestamp + hash */
		const mode = options && options.hash ? (options.timestamp ? 3 : 2) : 1;

		let jobs = 1;
		const jobDone = () => {
			if (--jobs === 0) {
				if (fileTimestamps.size !== 0) {
					snapshot.setFileTimestamps(fileTimestamps);
				***REMOVED***
				if (fileHashes.size !== 0) {
					snapshot.setFileHashes(fileHashes);
				***REMOVED***
				if (fileTshs.size !== 0) {
					snapshot.setFileTshs(fileTshs);
				***REMOVED***
				if (contextTimestamps.size !== 0) {
					snapshot.setContextTimestamps(contextTimestamps);
				***REMOVED***
				if (contextHashes.size !== 0) {
					snapshot.setContextHashes(contextHashes);
				***REMOVED***
				if (contextTshs.size !== 0) {
					snapshot.setContextTshs(contextTshs);
				***REMOVED***
				if (missingExistence.size !== 0) {
					snapshot.setMissingExistence(missingExistence);
				***REMOVED***
				if (managedItemInfo.size !== 0) {
					snapshot.setManagedItemInfo(managedItemInfo);
				***REMOVED***
				this._managedFilesOptimization.optimize(snapshot, managedFiles);
				if (managedFiles.size !== 0) {
					snapshot.setManagedFiles(managedFiles);
				***REMOVED***
				this._managedContextsOptimization.optimize(snapshot, managedContexts);
				if (managedContexts.size !== 0) {
					snapshot.setManagedContexts(managedContexts);
				***REMOVED***
				this._managedMissingOptimization.optimize(snapshot, managedMissing);
				if (managedMissing.size !== 0) {
					snapshot.setManagedMissing(managedMissing);
				***REMOVED***
				if (children.size !== 0) {
					snapshot.setChildren(children);
				***REMOVED***
				this._snapshotCache.set(snapshot, true);
				this._statCreatedSnapshots++;

				callback(null, snapshot);
			***REMOVED***
		***REMOVED***;
		const jobError = () => {
			if (jobs > 0) {
				// large negative number instead of NaN or something else to keep jobs to stay a SMI (v8)
				jobs = -100000000;
				callback(null, null);
			***REMOVED***
		***REMOVED***;
		/**
		 * @param {string***REMOVED*** path path
		 * @param {ManagedFiles***REMOVED*** managedSet managed set
		 * @returns {boolean***REMOVED*** true when managed
		 */
		const checkManaged = (path, managedSet) => {
			for (const unmanagedPath of this.unmanagedPathsRegExps) {
				if (unmanagedPath.test(path)) return false;
			***REMOVED***
			for (const unmanagedPath of this.unmanagedPathsWithSlash) {
				if (path.startsWith(unmanagedPath)) return false;
			***REMOVED***
			for (const immutablePath of this.immutablePathsRegExps) {
				if (immutablePath.test(path)) {
					managedSet.add(path);
					return true;
				***REMOVED***
			***REMOVED***
			for (const immutablePath of this.immutablePathsWithSlash) {
				if (path.startsWith(immutablePath)) {
					managedSet.add(path);
					return true;
				***REMOVED***
			***REMOVED***
			for (const managedPath of this.managedPathsRegExps) {
				const match = managedPath.exec(path);
				if (match) {
					const managedItem = getManagedItem(match[1], path);
					if (managedItem) {
						managedItems.add(managedItem);
						managedSet.add(path);
						return true;
					***REMOVED***
				***REMOVED***
			***REMOVED***
			for (const managedPath of this.managedPathsWithSlash) {
				if (path.startsWith(managedPath)) {
					const managedItem = getManagedItem(managedPath, path);
					if (managedItem) {
						managedItems.add(managedItem);
						managedSet.add(path);
						return true;
					***REMOVED***
				***REMOVED***
			***REMOVED***
			return false;
		***REMOVED***;
		/**
		 * @param {Iterable<string>***REMOVED*** items items
		 * @param {Set<string>***REMOVED*** managedSet managed set
		 * @returns {Set<string>***REMOVED*** result
		 */
		const captureNonManaged = (items, managedSet) => {
			/** @type {Set<string>***REMOVED*** */
			const capturedItems = new Set();
			for (const path of items) {
				if (!checkManaged(path, managedSet)) capturedItems.add(path);
			***REMOVED***
			return capturedItems;
		***REMOVED***;
		/**
		 * @param {ManagedFiles***REMOVED*** capturedFiles captured files
		 */
		const processCapturedFiles = capturedFiles => {
			switch (mode) {
				case 3:
					this._fileTshsOptimization.optimize(snapshot, capturedFiles);
					for (const path of capturedFiles) {
						const cache = this._fileTshs.get(path);
						if (cache !== undefined) {
							fileTshs.set(path, cache);
						***REMOVED*** else {
							jobs++;
							this._getFileTimestampAndHash(path, (err, entry) => {
								if (err) {
									if (this.logger) {
										this.logger.debug(
											`Error snapshotting file timestamp hash combination of ${path***REMOVED***: ${err.stack***REMOVED***`
										);
									***REMOVED***
									jobError();
								***REMOVED*** else {
									fileTshs.set(path, /** @type {TimestampAndHash***REMOVED*** */ (entry));
									jobDone();
								***REMOVED***
							***REMOVED***);
						***REMOVED***
					***REMOVED***
					break;
				case 2:
					this._fileHashesOptimization.optimize(snapshot, capturedFiles);
					for (const path of capturedFiles) {
						const cache = this._fileHashes.get(path);
						if (cache !== undefined) {
							fileHashes.set(path, cache);
						***REMOVED*** else {
							jobs++;
							this.fileHashQueue.add(path, (err, entry) => {
								if (err) {
									if (this.logger) {
										this.logger.debug(
											`Error snapshotting file hash of ${path***REMOVED***: ${err.stack***REMOVED***`
										);
									***REMOVED***
									jobError();
								***REMOVED*** else {
									fileHashes.set(path, /** @type {string***REMOVED*** */ (entry));
									jobDone();
								***REMOVED***
							***REMOVED***);
						***REMOVED***
					***REMOVED***
					break;
				case 1:
					this._fileTimestampsOptimization.optimize(snapshot, capturedFiles);
					for (const path of capturedFiles) {
						const cache = this._fileTimestamps.get(path);
						if (cache !== undefined) {
							if (cache !== "ignore") {
								fileTimestamps.set(path, cache);
							***REMOVED***
						***REMOVED*** else {
							jobs++;
							this.fileTimestampQueue.add(path, (err, entry) => {
								if (err) {
									if (this.logger) {
										this.logger.debug(
											`Error snapshotting file timestamp of ${path***REMOVED***: ${err.stack***REMOVED***`
										);
									***REMOVED***
									jobError();
								***REMOVED*** else {
									fileTimestamps.set(
										path,
										/** @type {FileSystemInfoEntry***REMOVED*** */
										(entry)
									);
									jobDone();
								***REMOVED***
							***REMOVED***);
						***REMOVED***
					***REMOVED***
					break;
			***REMOVED***
		***REMOVED***;
		if (files) {
			processCapturedFiles(captureNonManaged(files, managedFiles));
		***REMOVED***
		/**
		 * @param {ManagedContexts***REMOVED*** capturedDirectories captured directories
		 */
		const processCapturedDirectories = capturedDirectories => {
			switch (mode) {
				case 3:
					this._contextTshsOptimization.optimize(snapshot, capturedDirectories);
					for (const path of capturedDirectories) {
						const cache = this._contextTshs.get(path);
						/** @type {ResolvedContextTimestampAndHash | null | undefined***REMOVED*** */
						let resolved;
						if (
							cache !== undefined &&
							(resolved = getResolvedTimestamp(cache)) !== undefined
						) {
							contextTshs.set(path, resolved);
						***REMOVED*** else {
							jobs++;
							/**
							 * @param {(WebpackError | null)=***REMOVED*** err error
							 * @param {(ResolvedContextTimestampAndHash | null)=***REMOVED*** entry entry
							 * @returns {void***REMOVED***
							 */
							const callback = (err, entry) => {
								if (err) {
									if (this.logger) {
										this.logger.debug(
											`Error snapshotting context timestamp hash combination of ${path***REMOVED***: ${err.stack***REMOVED***`
										);
									***REMOVED***
									jobError();
								***REMOVED*** else {
									contextTshs.set(
										path,
										/** @type {ResolvedContextTimestampAndHash | null***REMOVED*** */
										(entry)
									);
									jobDone();
								***REMOVED***
							***REMOVED***;
							if (cache !== undefined) {
								this._resolveContextTsh(cache, callback);
							***REMOVED*** else {
								this.getContextTsh(path, callback);
							***REMOVED***
						***REMOVED***
					***REMOVED***
					break;
				case 2:
					this._contextHashesOptimization.optimize(
						snapshot,
						capturedDirectories
					);
					for (const path of capturedDirectories) {
						const cache = this._contextHashes.get(path);
						let resolved;
						if (
							cache !== undefined &&
							(resolved = getResolvedHash(cache)) !== undefined
						) {
							contextHashes.set(path, resolved);
						***REMOVED*** else {
							jobs++;
							/**
							 * @param {(WebpackError | null)=***REMOVED*** err err
							 * @param {string=***REMOVED*** entry entry
							 */
							const callback = (err, entry) => {
								if (err) {
									if (this.logger) {
										this.logger.debug(
											`Error snapshotting context hash of ${path***REMOVED***: ${err.stack***REMOVED***`
										);
									***REMOVED***
									jobError();
								***REMOVED*** else {
									contextHashes.set(path, /** @type {string***REMOVED*** */ (entry));
									jobDone();
								***REMOVED***
							***REMOVED***;
							if (cache !== undefined) {
								this._resolveContextHash(cache, callback);
							***REMOVED*** else {
								this.getContextHash(path, callback);
							***REMOVED***
						***REMOVED***
					***REMOVED***
					break;
				case 1:
					this._contextTimestampsOptimization.optimize(
						snapshot,
						capturedDirectories
					);
					for (const path of capturedDirectories) {
						const cache = this._contextTimestamps.get(path);
						if (cache === "ignore") continue;
						let resolved;
						if (
							cache !== undefined &&
							(resolved = getResolvedTimestamp(cache)) !== undefined
						) {
							contextTimestamps.set(path, resolved);
						***REMOVED*** else {
							jobs++;
							/**
							 * @param {(Error | null)=***REMOVED*** err error
							 * @param {FileTimestamp=***REMOVED*** entry entry
							 * @returns {void***REMOVED***
							 */
							const callback = (err, entry) => {
								if (err) {
									if (this.logger) {
										this.logger.debug(
											`Error snapshotting context timestamp of ${path***REMOVED***: ${err.stack***REMOVED***`
										);
									***REMOVED***
									jobError();
								***REMOVED*** else {
									contextTimestamps.set(
										path,
										/** @type {FileSystemInfoEntry | null***REMOVED*** */
										(entry)
									);
									jobDone();
								***REMOVED***
							***REMOVED***;
							if (cache !== undefined) {
								this._resolveContextTimestamp(
									/** @type {ContextFileSystemInfoEntry***REMOVED*** */
									(cache),
									callback
								);
							***REMOVED*** else {
								this.getContextTimestamp(path, callback);
							***REMOVED***
						***REMOVED***
					***REMOVED***
					break;
			***REMOVED***
		***REMOVED***;
		if (directories) {
			processCapturedDirectories(
				captureNonManaged(directories, managedContexts)
			);
		***REMOVED***
		/**
		 * @param {ManagedMissing***REMOVED*** capturedMissing captured missing
		 */
		const processCapturedMissing = capturedMissing => {
			this._missingExistenceOptimization.optimize(snapshot, capturedMissing);
			for (const path of capturedMissing) {
				const cache = this._fileTimestamps.get(path);
				if (cache !== undefined) {
					if (cache !== "ignore") {
						missingExistence.set(path, Boolean(cache));
					***REMOVED***
				***REMOVED*** else {
					jobs++;
					this.fileTimestampQueue.add(path, (err, entry) => {
						if (err) {
							if (this.logger) {
								this.logger.debug(
									`Error snapshotting missing timestamp of ${path***REMOVED***: ${err.stack***REMOVED***`
								);
							***REMOVED***
							jobError();
						***REMOVED*** else {
							missingExistence.set(path, Boolean(entry));
							jobDone();
						***REMOVED***
					***REMOVED***);
				***REMOVED***
			***REMOVED***
		***REMOVED***;
		if (missing) {
			processCapturedMissing(captureNonManaged(missing, managedMissing));
		***REMOVED***
		this._managedItemInfoOptimization.optimize(snapshot, managedItems);
		for (const path of managedItems) {
			const cache = this._managedItems.get(path);
			if (cache !== undefined) {
				if (!cache.startsWith("*")) {
					managedFiles.add(join(this.fs, path, "package.json"));
				***REMOVED*** else if (cache === "*nested") {
					managedMissing.add(join(this.fs, path, "package.json"));
				***REMOVED***
				managedItemInfo.set(path, cache);
			***REMOVED*** else {
				jobs++;
				this.managedItemQueue.add(path, (err, entry) => {
					if (err) {
						if (this.logger) {
							this.logger.debug(
								`Error snapshotting managed item ${path***REMOVED***: ${err.stack***REMOVED***`
							);
						***REMOVED***
						jobError();
					***REMOVED*** else if (entry) {
						if (!entry.startsWith("*")) {
							managedFiles.add(join(this.fs, path, "package.json"));
						***REMOVED*** else if (cache === "*nested") {
							managedMissing.add(join(this.fs, path, "package.json"));
						***REMOVED***
						managedItemInfo.set(path, entry);
						jobDone();
					***REMOVED*** else {
						// Fallback to normal snapshotting
						/**
						 * @param {Set<string>***REMOVED*** set set
						 * @param {(set: Set<string>) => void***REMOVED*** fn fn
						 */
						const process = (set, fn) => {
							if (set.size === 0) return;
							const captured = new Set();
							for (const file of set) {
								if (file.startsWith(path)) captured.add(file);
							***REMOVED***
							if (captured.size > 0) fn(captured);
						***REMOVED***;
						process(managedFiles, processCapturedFiles);
						process(managedContexts, processCapturedDirectories);
						process(managedMissing, processCapturedMissing);
						jobDone();
					***REMOVED***
				***REMOVED***);
			***REMOVED***
		***REMOVED***
		jobDone();
	***REMOVED***

	/**
	 * @param {Snapshot***REMOVED*** snapshot1 a snapshot
	 * @param {Snapshot***REMOVED*** snapshot2 a snapshot
	 * @returns {Snapshot***REMOVED*** merged snapshot
	 */
	mergeSnapshots(snapshot1, snapshot2) {
		const snapshot = new Snapshot();
		if (snapshot1.hasStartTime() && snapshot2.hasStartTime()) {
			snapshot.setStartTime(
				Math.min(
					/** @type {NonNullable<Snapshot["startTime"]>***REMOVED*** */
					(snapshot1.startTime),
					/** @type {NonNullable<Snapshot["startTime"]>***REMOVED*** */
					(snapshot2.startTime)
				)
			);
		***REMOVED*** else if (snapshot2.hasStartTime()) {
			snapshot.startTime = snapshot2.startTime;
		***REMOVED*** else if (snapshot1.hasStartTime()) {
			snapshot.startTime = snapshot1.startTime;
		***REMOVED***
		if (snapshot1.hasFileTimestamps() || snapshot2.hasFileTimestamps()) {
			snapshot.setFileTimestamps(
				mergeMaps(snapshot1.fileTimestamps, snapshot2.fileTimestamps)
			);
		***REMOVED***
		if (snapshot1.hasFileHashes() || snapshot2.hasFileHashes()) {
			snapshot.setFileHashes(
				mergeMaps(snapshot1.fileHashes, snapshot2.fileHashes)
			);
		***REMOVED***
		if (snapshot1.hasFileTshs() || snapshot2.hasFileTshs()) {
			snapshot.setFileTshs(mergeMaps(snapshot1.fileTshs, snapshot2.fileTshs));
		***REMOVED***
		if (snapshot1.hasContextTimestamps() || snapshot2.hasContextTimestamps()) {
			snapshot.setContextTimestamps(
				mergeMaps(snapshot1.contextTimestamps, snapshot2.contextTimestamps)
			);
		***REMOVED***
		if (snapshot1.hasContextHashes() || snapshot2.hasContextHashes()) {
			snapshot.setContextHashes(
				mergeMaps(snapshot1.contextHashes, snapshot2.contextHashes)
			);
		***REMOVED***
		if (snapshot1.hasContextTshs() || snapshot2.hasContextTshs()) {
			snapshot.setContextTshs(
				mergeMaps(snapshot1.contextTshs, snapshot2.contextTshs)
			);
		***REMOVED***
		if (snapshot1.hasMissingExistence() || snapshot2.hasMissingExistence()) {
			snapshot.setMissingExistence(
				mergeMaps(snapshot1.missingExistence, snapshot2.missingExistence)
			);
		***REMOVED***
		if (snapshot1.hasManagedItemInfo() || snapshot2.hasManagedItemInfo()) {
			snapshot.setManagedItemInfo(
				mergeMaps(snapshot1.managedItemInfo, snapshot2.managedItemInfo)
			);
		***REMOVED***
		if (snapshot1.hasManagedFiles() || snapshot2.hasManagedFiles()) {
			snapshot.setManagedFiles(
				mergeSets(snapshot1.managedFiles, snapshot2.managedFiles)
			);
		***REMOVED***
		if (snapshot1.hasManagedContexts() || snapshot2.hasManagedContexts()) {
			snapshot.setManagedContexts(
				mergeSets(snapshot1.managedContexts, snapshot2.managedContexts)
			);
		***REMOVED***
		if (snapshot1.hasManagedMissing() || snapshot2.hasManagedMissing()) {
			snapshot.setManagedMissing(
				mergeSets(snapshot1.managedMissing, snapshot2.managedMissing)
			);
		***REMOVED***
		if (snapshot1.hasChildren() || snapshot2.hasChildren()) {
			snapshot.setChildren(mergeSets(snapshot1.children, snapshot2.children));
		***REMOVED***
		if (
			this._snapshotCache.get(snapshot1) === true &&
			this._snapshotCache.get(snapshot2) === true
		) {
			this._snapshotCache.set(snapshot, true);
		***REMOVED***
		return snapshot;
	***REMOVED***

	/**
	 * @param {Snapshot***REMOVED*** snapshot the snapshot made
	 * @param {CheckSnapshotValidCallback***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	checkSnapshotValid(snapshot, callback) {
		const cachedResult = this._snapshotCache.get(snapshot);
		if (cachedResult !== undefined) {
			this._statTestedSnapshotsCached++;
			if (typeof cachedResult === "boolean") {
				callback(null, cachedResult);
			***REMOVED*** else {
				cachedResult.push(callback);
			***REMOVED***
			return;
		***REMOVED***
		this._statTestedSnapshotsNotCached++;
		this._checkSnapshotValidNoCache(snapshot, callback);
	***REMOVED***

	/**
	 * @private
	 * @param {Snapshot***REMOVED*** snapshot the snapshot made
	 * @param {CheckSnapshotValidCallback***REMOVED*** callback callback function
	 * @returns {void***REMOVED***
	 */
	_checkSnapshotValidNoCache(snapshot, callback) {
		/** @type {number | undefined***REMOVED*** */
		let startTime;
		if (snapshot.hasStartTime()) {
			startTime = snapshot.startTime;
		***REMOVED***
		let jobs = 1;
		const jobDone = () => {
			if (--jobs === 0) {
				this._snapshotCache.set(snapshot, true);
				callback(null, true);
			***REMOVED***
		***REMOVED***;
		const invalid = () => {
			if (jobs > 0) {
				// large negative number instead of NaN or something else to keep jobs to stay a SMI (v8)
				jobs = -100000000;
				this._snapshotCache.set(snapshot, false);
				callback(null, false);
			***REMOVED***
		***REMOVED***;
		/**
		 * @param {string***REMOVED*** path path
		 * @param {WebpackError***REMOVED*** err err
		 */
		const invalidWithError = (path, err) => {
			if (this._remainingLogs > 0) {
				this._log(path, "error occurred: %s", err);
			***REMOVED***
			invalid();
		***REMOVED***;
		/**
		 * @param {string***REMOVED*** path file path
		 * @param {string | null***REMOVED*** current current hash
		 * @param {string | null***REMOVED*** snap snapshot hash
		 * @returns {boolean***REMOVED*** true, if ok
		 */
		const checkHash = (path, current, snap) => {
			if (current !== snap) {
				// If hash differ it's invalid
				if (this._remainingLogs > 0) {
					this._log(path, "hashes differ (%s != %s)", current, snap);
				***REMOVED***
				return false;
			***REMOVED***
			return true;
		***REMOVED***;
		/**
		 * @param {string***REMOVED*** path file path
		 * @param {boolean***REMOVED*** current current entry
		 * @param {boolean***REMOVED*** snap entry from snapshot
		 * @returns {boolean***REMOVED*** true, if ok
		 */
		const checkExistence = (path, current, snap) => {
			if (!current !== !snap) {
				// If existence of item differs
				// it's invalid
				if (this._remainingLogs > 0) {
					this._log(
						path,
						current ? "it didn't exist before" : "it does no longer exist"
					);
				***REMOVED***
				return false;
			***REMOVED***
			return true;
		***REMOVED***;
		/**
		 * @param {string***REMOVED*** path file path
		 * @param {FileSystemInfoEntry | null***REMOVED*** c current entry
		 * @param {FileSystemInfoEntry | null***REMOVED*** s entry from snapshot
		 * @param {boolean***REMOVED*** log log reason
		 * @returns {boolean***REMOVED*** true, if ok
		 */
		const checkFile = (path, c, s, log = true) => {
			if (c === s) return true;
			if (!checkExistence(path, Boolean(c), Boolean(s))) return false;
			if (c) {
				// For existing items only
				if (typeof startTime === "number" && c.safeTime > startTime) {
					// If a change happened after starting reading the item
					// this may no longer be valid
					if (log && this._remainingLogs > 0) {
						this._log(
							path,
							"it may have changed (%d) after the start time of the snapshot (%d)",
							c.safeTime,
							startTime
						);
					***REMOVED***
					return false;
				***REMOVED***
				const snap = /** @type {FileSystemInfoEntry***REMOVED*** */ (s);
				if (snap.timestamp !== undefined && c.timestamp !== snap.timestamp) {
					// If we have a timestamp (it was a file or symlink) and it differs from current timestamp
					// it's invalid
					if (log && this._remainingLogs > 0) {
						this._log(
							path,
							"timestamps differ (%d != %d)",
							c.timestamp,
							snap.timestamp
						);
					***REMOVED***
					return false;
				***REMOVED***
			***REMOVED***
			return true;
		***REMOVED***;
		/**
		 * @param {string***REMOVED*** path file path
		 * @param {ResolvedContextFileSystemInfoEntry | null***REMOVED*** c current entry
		 * @param {ResolvedContextFileSystemInfoEntry | null***REMOVED*** s entry from snapshot
		 * @param {boolean***REMOVED*** log log reason
		 * @returns {boolean***REMOVED*** true, if ok
		 */
		const checkContext = (path, c, s, log = true) => {
			if (c === s) return true;
			if (!checkExistence(path, Boolean(c), Boolean(s))) return false;
			if (c) {
				// For existing items only
				if (typeof startTime === "number" && c.safeTime > startTime) {
					// If a change happened after starting reading the item
					// this may no longer be valid
					if (log && this._remainingLogs > 0) {
						this._log(
							path,
							"it may have changed (%d) after the start time of the snapshot (%d)",
							c.safeTime,
							startTime
						);
					***REMOVED***
					return false;
				***REMOVED***
				const snap = /** @type {ResolvedContextFileSystemInfoEntry***REMOVED*** */ (s);
				if (
					snap.timestampHash !== undefined &&
					c.timestampHash !== snap.timestampHash
				) {
					// If we have a timestampHash (it was a directory) and it differs from current timestampHash
					// it's invalid
					if (log && this._remainingLogs > 0) {
						this._log(
							path,
							"timestamps hashes differ (%s != %s)",
							c.timestampHash,
							snap.timestampHash
						);
					***REMOVED***
					return false;
				***REMOVED***
			***REMOVED***
			return true;
		***REMOVED***;
		if (snapshot.hasChildren()) {
			/**
			 * @param {(WebpackError | null)=***REMOVED*** err err
			 * @param {boolean=***REMOVED*** result result
			 * @returns {void***REMOVED***
			 */
			const childCallback = (err, result) => {
				if (err || !result) return invalid();
				jobDone();
			***REMOVED***;
			for (const child of /** @type {Children***REMOVED*** */ (snapshot.children)) {
				const cache = this._snapshotCache.get(child);
				if (cache !== undefined) {
					this._statTestedChildrenCached++;
					/* istanbul ignore else */
					if (typeof cache === "boolean") {
						if (cache === false) {
							invalid();
							return;
						***REMOVED***
					***REMOVED*** else {
						jobs++;
						cache.push(childCallback);
					***REMOVED***
				***REMOVED*** else {
					this._statTestedChildrenNotCached++;
					jobs++;
					this._checkSnapshotValidNoCache(child, childCallback);
				***REMOVED***
			***REMOVED***
		***REMOVED***
		if (snapshot.hasFileTimestamps()) {
			const fileTimestamps =
				/** @type {FileTimestamps***REMOVED*** */
				(snapshot.fileTimestamps);
			this._statTestedEntries += fileTimestamps.size;
			for (const [path, ts] of fileTimestamps) {
				const cache = this._fileTimestamps.get(path);
				if (cache !== undefined) {
					if (cache !== "ignore" && !checkFile(path, cache, ts)) {
						invalid();
						return;
					***REMOVED***
				***REMOVED*** else {
					jobs++;
					this.fileTimestampQueue.add(path, (err, entry) => {
						if (err) return invalidWithError(path, err);
						if (
							!checkFile(
								path,
								/** @type {FileSystemInfoEntry | null***REMOVED*** */ (entry),
								ts
							)
						) {
							invalid();
						***REMOVED*** else {
							jobDone();
						***REMOVED***
					***REMOVED***);
				***REMOVED***
			***REMOVED***
		***REMOVED***
		/**
		 * @param {string***REMOVED*** path file path
		 * @param {string | null***REMOVED*** hash hash
		 */
		const processFileHashSnapshot = (path, hash) => {
			const cache = this._fileHashes.get(path);
			if (cache !== undefined) {
				if (cache !== "ignore" && !checkHash(path, cache, hash)) {
					invalid();
				***REMOVED***
			***REMOVED*** else {
				jobs++;
				this.fileHashQueue.add(path, (err, entry) => {
					if (err) return invalidWithError(path, err);
					if (!checkHash(path, /** @type {string***REMOVED*** */ (entry), hash)) {
						invalid();
					***REMOVED*** else {
						jobDone();
					***REMOVED***
				***REMOVED***);
			***REMOVED***
		***REMOVED***;
		if (snapshot.hasFileHashes()) {
			const fileHashes = /** @type {FileHashes***REMOVED*** */ (snapshot.fileHashes);
			this._statTestedEntries += fileHashes.size;
			for (const [path, hash] of fileHashes) {
				processFileHashSnapshot(path, hash);
			***REMOVED***
		***REMOVED***
		if (snapshot.hasFileTshs()) {
			const fileTshs = /** @type {FileTshs***REMOVED*** */ (snapshot.fileTshs);
			this._statTestedEntries += fileTshs.size;
			for (const [path, tsh] of fileTshs) {
				if (typeof tsh === "string") {
					processFileHashSnapshot(path, tsh);
				***REMOVED*** else {
					const cache = this._fileTimestamps.get(path);
					if (cache !== undefined) {
						if (cache === "ignore" || !checkFile(path, cache, tsh, false)) {
							processFileHashSnapshot(path, tsh && tsh.hash);
						***REMOVED***
					***REMOVED*** else {
						jobs++;
						this.fileTimestampQueue.add(path, (err, entry) => {
							if (err) return invalidWithError(path, err);
							if (
								!checkFile(
									path,
									/** @type {FileSystemInfoEntry | null***REMOVED*** */
									(entry),
									tsh,
									false
								)
							) {
								processFileHashSnapshot(path, tsh && tsh.hash);
							***REMOVED***
							jobDone();
						***REMOVED***);
					***REMOVED***
				***REMOVED***
			***REMOVED***
		***REMOVED***
		if (snapshot.hasContextTimestamps()) {
			const contextTimestamps =
				/** @type {ContextTimestamps***REMOVED*** */
				(snapshot.contextTimestamps);
			this._statTestedEntries += contextTimestamps.size;
			for (const [path, ts] of contextTimestamps) {
				const cache = this._contextTimestamps.get(path);
				if (cache === "ignore") continue;
				let resolved;
				if (
					cache !== undefined &&
					(resolved = getResolvedTimestamp(cache)) !== undefined
				) {
					if (!checkContext(path, resolved, ts)) {
						invalid();
						return;
					***REMOVED***
				***REMOVED*** else {
					jobs++;
					/**
					 * @param {(WebpackError | null)=***REMOVED*** err error
					 * @param {ResolvedContextTimestamp=***REMOVED*** entry entry
					 * @returns {void***REMOVED***
					 */
					const callback = (err, entry) => {
						if (err) return invalidWithError(path, err);
						if (
							!checkContext(
								path,
								/** @type {ResolvedContextFileSystemInfoEntry | null***REMOVED*** */
								(entry),
								ts
							)
						) {
							invalid();
						***REMOVED*** else {
							jobDone();
						***REMOVED***
					***REMOVED***;
					if (cache !== undefined) {
						this._resolveContextTimestamp(
							/** @type {ContextFileSystemInfoEntry***REMOVED*** */
							(cache),
							callback
						);
					***REMOVED*** else {
						this.getContextTimestamp(path, callback);
					***REMOVED***
				***REMOVED***
			***REMOVED***
		***REMOVED***
		/**
		 * @param {string***REMOVED*** path path
		 * @param {string | null***REMOVED*** hash hash
		 */
		const processContextHashSnapshot = (path, hash) => {
			const cache = this._contextHashes.get(path);
			let resolved;
			if (
				cache !== undefined &&
				(resolved = getResolvedHash(cache)) !== undefined
			) {
				if (!checkHash(path, resolved, hash)) {
					invalid();
				***REMOVED***
			***REMOVED*** else {
				jobs++;
				/**
				 * @param {(WebpackError | null)=***REMOVED*** err err
				 * @param {string=***REMOVED*** entry entry
				 * @returns {void***REMOVED***
				 */
				const callback = (err, entry) => {
					if (err) return invalidWithError(path, err);
					if (!checkHash(path, /** @type {string***REMOVED*** */ (entry), hash)) {
						invalid();
					***REMOVED*** else {
						jobDone();
					***REMOVED***
				***REMOVED***;
				if (cache !== undefined) {
					this._resolveContextHash(cache, callback);
				***REMOVED*** else {
					this.getContextHash(path, callback);
				***REMOVED***
			***REMOVED***
		***REMOVED***;
		if (snapshot.hasContextHashes()) {
			const contextHashes =
				/** @type {ContextHashes***REMOVED*** */
				(snapshot.contextHashes);
			this._statTestedEntries += contextHashes.size;
			for (const [path, hash] of contextHashes) {
				processContextHashSnapshot(path, hash);
			***REMOVED***
		***REMOVED***
		if (snapshot.hasContextTshs()) {
			const contextTshs = /** @type {ContextTshs***REMOVED*** */ (snapshot.contextTshs);
			this._statTestedEntries += contextTshs.size;
			for (const [path, tsh] of contextTshs) {
				if (typeof tsh === "string") {
					processContextHashSnapshot(path, tsh);
				***REMOVED*** else {
					const cache = this._contextTimestamps.get(path);
					if (cache === "ignore") continue;
					let resolved;
					if (
						cache !== undefined &&
						(resolved = getResolvedTimestamp(cache)) !== undefined
					) {
						if (
							!checkContext(
								path,
								/** @type {ResolvedContextFileSystemInfoEntry | null***REMOVED*** */
								(resolved),
								tsh,
								false
							)
						) {
							processContextHashSnapshot(path, tsh && tsh.hash);
						***REMOVED***
					***REMOVED*** else {
						jobs++;
						/**
						 * @param {(WebpackError | null)=***REMOVED*** err error
						 * @param {ResolvedContextTimestamp=***REMOVED*** entry entry
						 * @returns {void***REMOVED***
						 */
						const callback = (err, entry) => {
							if (err) return invalidWithError(path, err);
							if (
								!checkContext(
									path,
									// TODO: test with `"ignore"`
									/** @type {ResolvedContextFileSystemInfoEntry | null***REMOVED*** */
									(entry),
									tsh,
									false
								)
							) {
								processContextHashSnapshot(path, tsh && tsh.hash);
							***REMOVED***
							jobDone();
						***REMOVED***;
						if (cache !== undefined) {
							this._resolveContextTimestamp(
								/** @type {ContextFileSystemInfoEntry***REMOVED*** */
								(cache),
								callback
							);
						***REMOVED*** else {
							this.getContextTimestamp(path, callback);
						***REMOVED***
					***REMOVED***
				***REMOVED***
			***REMOVED***
		***REMOVED***
		if (snapshot.hasMissingExistence()) {
			const missingExistence =
				/** @type {MissingExistence***REMOVED*** */
				(snapshot.missingExistence);
			this._statTestedEntries += missingExistence.size;
			for (const [path, existence] of missingExistence) {
				const cache = this._fileTimestamps.get(path);
				if (cache !== undefined) {
					if (
						cache !== "ignore" &&
						!checkExistence(path, Boolean(cache), Boolean(existence))
					) {
						invalid();
						return;
					***REMOVED***
				***REMOVED*** else {
					jobs++;
					this.fileTimestampQueue.add(path, (err, entry) => {
						if (err) return invalidWithError(path, err);
						if (!checkExistence(path, Boolean(entry), Boolean(existence))) {
							invalid();
						***REMOVED*** else {
							jobDone();
						***REMOVED***
					***REMOVED***);
				***REMOVED***
			***REMOVED***
		***REMOVED***
		if (snapshot.hasManagedItemInfo()) {
			const managedItemInfo =
				/** @type {ManagedItemInfo***REMOVED*** */
				(snapshot.managedItemInfo);
			this._statTestedEntries += managedItemInfo.size;
			for (const [path, info] of managedItemInfo) {
				const cache = this._managedItems.get(path);
				if (cache !== undefined) {
					if (!checkHash(path, cache, info)) {
						invalid();
						return;
					***REMOVED***
				***REMOVED*** else {
					jobs++;
					this.managedItemQueue.add(path, (err, entry) => {
						if (err) return invalidWithError(path, err);
						if (!checkHash(path, /** @type {string***REMOVED*** */ (entry), info)) {
							invalid();
						***REMOVED*** else {
							jobDone();
						***REMOVED***
					***REMOVED***);
				***REMOVED***
			***REMOVED***
		***REMOVED***
		jobDone();

		// if there was an async action
		// try to join multiple concurrent request for this snapshot
		if (jobs > 0) {
			const callbacks = [callback];
			callback = (err, result) => {
				for (const callback of callbacks) callback(err, result);
			***REMOVED***;
			this._snapshotCache.set(snapshot, callbacks);
		***REMOVED***
	***REMOVED***

	/**
	 * @private
	 * @type {Processor<string, FileSystemInfoEntry>***REMOVED***
	 */
	_readFileTimestamp(path, callback) {
		this.fs.stat(path, (err, _stat) => {
			if (err) {
				if (err.code === "ENOENT") {
					this._fileTimestamps.set(path, null);
					this._cachedDeprecatedFileTimestamps = undefined;
					return callback(null, null);
				***REMOVED***
				return callback(/** @type {WebpackError***REMOVED*** */ (err));
			***REMOVED***
			const stat = /** @type {IStats***REMOVED*** */ (_stat);
			let ts;
			if (stat.isDirectory()) {
				ts = {
					safeTime: 0,
					timestamp: undefined
				***REMOVED***;
			***REMOVED*** else {
				const mtime = Number(stat.mtime);

				if (mtime) applyMtime(mtime);

				ts = {
					safeTime: mtime ? mtime + FS_ACCURACY : Infinity,
					timestamp: mtime
				***REMOVED***;
			***REMOVED***

			this._fileTimestamps.set(path, ts);
			this._cachedDeprecatedFileTimestamps = undefined;

			callback(null, ts);
		***REMOVED***);
	***REMOVED***

	/**
	 * @private
	 * @type {Processor<string, string>***REMOVED***
	 */
	_readFileHash(path, callback) {
		this.fs.readFile(path, (err, content) => {
			if (err) {
				if (err.code === "EISDIR") {
					this._fileHashes.set(path, "directory");
					return callback(null, "directory");
				***REMOVED***
				if (err.code === "ENOENT") {
					this._fileHashes.set(path, null);
					return callback(null, null);
				***REMOVED***
				if (err.code === "ERR_FS_FILE_TOO_LARGE") {
					/** @type {Logger***REMOVED*** */
					(this.logger).warn(`Ignoring ${path***REMOVED*** for hashing as it's very large`);
					this._fileHashes.set(path, "too large");
					return callback(null, "too large");
				***REMOVED***
				return callback(/** @type {WebpackError***REMOVED*** */ (err));
			***REMOVED***

			const hash = createHash(this._hashFunction);

			hash.update(/** @type {string | Buffer***REMOVED*** */ (content));

			const digest = /** @type {string***REMOVED*** */ (hash.digest("hex"));

			this._fileHashes.set(path, digest);

			callback(null, digest);
		***REMOVED***);
	***REMOVED***

	/**
	 * @private
	 * @param {string***REMOVED*** path path
	 * @param {(err: WebpackError | null, timestampAndHash?: TimestampAndHash) => void***REMOVED*** callback callback
	 */
	_getFileTimestampAndHash(path, callback) {
		/**
		 * @param {string***REMOVED*** hash hash
		 * @returns {void***REMOVED***
		 */
		const continueWithHash = hash => {
			const cache = this._fileTimestamps.get(path);
			if (cache !== undefined) {
				if (cache !== "ignore") {
					/** @type {TimestampAndHash***REMOVED*** */
					const result = {
						.../** @type {FileSystemInfoEntry***REMOVED*** */ (cache),
						hash
					***REMOVED***;
					this._fileTshs.set(path, result);
					return callback(null, result);
				***REMOVED***
				this._fileTshs.set(path, hash);
				return callback(null, /** @type {TODO***REMOVED*** */ (hash));
			***REMOVED***
			this.fileTimestampQueue.add(path, (err, entry) => {
				if (err) {
					return callback(err);
				***REMOVED***
				/** @type {TimestampAndHash***REMOVED*** */
				const result = {
					.../** @type {FileSystemInfoEntry***REMOVED*** */ (entry),
					hash
				***REMOVED***;
				this._fileTshs.set(path, result);
				return callback(null, result);
			***REMOVED***);
		***REMOVED***;

		const cache = this._fileHashes.get(path);
		if (cache !== undefined) {
			continueWithHash(/** @type {string***REMOVED*** */ (cache));
		***REMOVED*** else {
			this.fileHashQueue.add(path, (err, entry) => {
				if (err) {
					return callback(err);
				***REMOVED***
				continueWithHash(/** @type {string***REMOVED*** */ (entry));
			***REMOVED***);
		***REMOVED***
	***REMOVED***

	/**
	 * @private
	 * @template T
	 * @template ItemType
	 * @param {object***REMOVED*** options options
	 * @param {string***REMOVED*** options.path path
	 * @param {(value: string) => ItemType***REMOVED*** options.fromImmutablePath called when context item is an immutable path
	 * @param {(value: string) => ItemType***REMOVED*** options.fromManagedItem called when context item is a managed path
	 * @param {(value: string, result: string, callback: (err?: WebpackError | null, itemType?: ItemType) => void) => void***REMOVED*** options.fromSymlink called when context item is a symlink
	 * @param {(value: string, stats: IStats, callback: (err?: WebpackError | null, itemType?: ItemType | null) => void) => void***REMOVED*** options.fromFile called when context item is a file
	 * @param {(value: string, stats: IStats, callback: (err?: WebpackError | null, itemType?: ItemType) => void) => void***REMOVED*** options.fromDirectory called when context item is a directory
	 * @param {(arr: string[], arr1: ItemType[]) => T***REMOVED*** options.reduce called from all context items
	 * @param {(err?: Error | null, result?: T | null) => void***REMOVED*** callback callback
	 */
	_readContext(
		{
			path,
			fromImmutablePath,
			fromManagedItem,
			fromSymlink,
			fromFile,
			fromDirectory,
			reduce
		***REMOVED***,
		callback
	) {
		this.fs.readdir(path, (err, _files) => {
			if (err) {
				if (err.code === "ENOENT") {
					return callback(null, null);
				***REMOVED***
				return callback(err);
			***REMOVED***
			const files = /** @type {string[]***REMOVED*** */ (_files)
				.map(file => file.normalize("NFC"))
				.filter(file => !/^\./.test(file))
				.sort();
			asyncLib.map(
				files,
				(file, callback) => {
					const child = join(this.fs, path, file);
					for (const immutablePath of this.immutablePathsRegExps) {
						if (immutablePath.test(path)) {
							// ignore any immutable path for timestamping
							return callback(null, fromImmutablePath(path));
						***REMOVED***
					***REMOVED***
					for (const immutablePath of this.immutablePathsWithSlash) {
						if (path.startsWith(immutablePath)) {
							// ignore any immutable path for timestamping
							return callback(null, fromImmutablePath(path));
						***REMOVED***
					***REMOVED***
					for (const managedPath of this.managedPathsRegExps) {
						const match = managedPath.exec(path);
						if (match) {
							const managedItem = getManagedItem(match[1], path);
							if (managedItem) {
								// construct timestampHash from managed info
								return this.managedItemQueue.add(managedItem, (err, info) => {
									if (err) return callback(err);
									return callback(
										null,
										fromManagedItem(/** @type {string***REMOVED*** */ (info))
									);
								***REMOVED***);
							***REMOVED***
						***REMOVED***
					***REMOVED***
					for (const managedPath of this.managedPathsWithSlash) {
						if (path.startsWith(managedPath)) {
							const managedItem = getManagedItem(managedPath, child);
							if (managedItem) {
								// construct timestampHash from managed info
								return this.managedItemQueue.add(managedItem, (err, info) => {
									if (err) return callback(err);
									return callback(
										null,
										fromManagedItem(/** @type {string***REMOVED*** */ (info))
									);
								***REMOVED***);
							***REMOVED***
						***REMOVED***
					***REMOVED***

					lstatReadlinkAbsolute(this.fs, child, (err, _stat) => {
						if (err) return callback(err);

						const stat = /** @type {IStats | string***REMOVED*** */ (_stat);

						if (typeof stat === "string") {
							return fromSymlink(child, stat, callback);
						***REMOVED***

						if (stat.isFile()) {
							return fromFile(child, stat, callback);
						***REMOVED***
						if (stat.isDirectory()) {
							return fromDirectory(child, stat, callback);
						***REMOVED***
						callback(null, null);
					***REMOVED***);
				***REMOVED***,
				(err, results) => {
					if (err) return callback(err);
					const result = reduce(files, /** @type {ItemType[]***REMOVED*** */ (results));
					callback(null, result);
				***REMOVED***
			);
		***REMOVED***);
	***REMOVED***

	/**
	 * @private
	 * @type {Processor<string, ContextFileSystemInfoEntry>***REMOVED***
	 */
	_readContextTimestamp(path, callback) {
		this._readContext(
			{
				path,
				fromImmutablePath: () =>
					/** @type {ContextFileSystemInfoEntry | FileSystemInfoEntry | "ignore" | null***REMOVED*** */
					(null),
				fromManagedItem: info => ({
					safeTime: 0,
					timestampHash: info
				***REMOVED***),
				fromSymlink: (file, target, callback) => {
					callback(
						null,
						/** @type {ContextFileSystemInfoEntry***REMOVED*** */
						({
							timestampHash: target,
							symlinks: new Set([target])
						***REMOVED***)
					);
				***REMOVED***,
				fromFile: (file, stat, callback) => {
					// Prefer the cached value over our new stat to report consistent results
					const cache = this._fileTimestamps.get(file);
					if (cache !== undefined)
						return callback(null, cache === "ignore" ? null : cache);

					const mtime = Number(stat.mtime);

					if (mtime) applyMtime(mtime);

					/** @type {FileSystemInfoEntry***REMOVED*** */
					const ts = {
						safeTime: mtime ? mtime + FS_ACCURACY : Infinity,
						timestamp: mtime
					***REMOVED***;

					this._fileTimestamps.set(file, ts);
					this._cachedDeprecatedFileTimestamps = undefined;
					callback(null, ts);
				***REMOVED***,
				fromDirectory: (directory, stat, callback) => {
					this.contextTimestampQueue.increaseParallelism();
					this._getUnresolvedContextTimestamp(directory, (err, tsEntry) => {
						this.contextTimestampQueue.decreaseParallelism();
						callback(err, tsEntry);
					***REMOVED***);
				***REMOVED***,
				reduce: (files, tsEntries) => {
					let symlinks;

					const hash = createHash(this._hashFunction);

					for (const file of files) hash.update(file);
					let safeTime = 0;
					for (const _e of tsEntries) {
						if (!_e) {
							hash.update("n");
							continue;
						***REMOVED***
						const entry =
							/** @type {FileSystemInfoEntry | ContextFileSystemInfoEntry***REMOVED*** */
							(_e);
						if (/** @type {FileSystemInfoEntry***REMOVED*** */ (entry).timestamp) {
							hash.update("f");
							hash.update(
								`${/** @type {FileSystemInfoEntry***REMOVED*** */ (entry).timestamp***REMOVED***`
							);
						***REMOVED*** else if (
							/** @type {ContextFileSystemInfoEntry***REMOVED*** */ (entry).timestampHash
						) {
							hash.update("d");
							hash.update(
								`${/** @type {ContextFileSystemInfoEntry***REMOVED*** */ (entry).timestampHash***REMOVED***`
							);
						***REMOVED***
						if (
							/** @type {ContextFileSystemInfoEntry***REMOVED*** */
							(entry).symlinks !== undefined
						) {
							if (symlinks === undefined) symlinks = new Set();
							addAll(
								/** @type {ContextFileSystemInfoEntry***REMOVED*** */ (entry).symlinks,
								symlinks
							);
						***REMOVED***
						if (entry.safeTime) {
							safeTime = Math.max(safeTime, entry.safeTime);
						***REMOVED***
					***REMOVED***

					const digest = /** @type {string***REMOVED*** */ (hash.digest("hex"));
					/** @type {ContextFileSystemInfoEntry***REMOVED*** */
					const result = {
						safeTime,
						timestampHash: digest
					***REMOVED***;
					if (symlinks) result.symlinks = symlinks;
					return result;
				***REMOVED***
			***REMOVED***,
			(err, result) => {
				if (err) return callback(/** @type {WebpackError***REMOVED*** */ (err));
				this._contextTimestamps.set(path, result);
				this._cachedDeprecatedContextTimestamps = undefined;

				callback(null, result);
			***REMOVED***
		);
	***REMOVED***

	/**
	 * @private
	 * @param {ContextFileSystemInfoEntry***REMOVED*** entry entry
	 * @param {(err?: WebpackError | null, resolvedContextTimestamp?: ResolvedContextTimestamp) => void***REMOVED*** callback callback
	 * @returns {void***REMOVED***
	 */
	_resolveContextTimestamp(entry, callback) {
		/** @type {string[]***REMOVED*** */
		const hashes = [];
		let safeTime = 0;
		processAsyncTree(
			/** @type {NonNullable<ContextHash["symlinks"]>***REMOVED*** */ (entry.symlinks),
			10,
			(target, push, callback) => {
				this._getUnresolvedContextTimestamp(target, (err, entry) => {
					if (err) return callback(err);
					if (entry && entry !== "ignore") {
						hashes.push(/** @type {string***REMOVED*** */ (entry.timestampHash));
						if (entry.safeTime) {
							safeTime = Math.max(safeTime, entry.safeTime);
						***REMOVED***
						if (entry.symlinks !== undefined) {
							for (const target of entry.symlinks) push(target);
						***REMOVED***
					***REMOVED***
					callback();
				***REMOVED***);
			***REMOVED***,
			err => {
				if (err) return callback(/** @type {WebpackError***REMOVED*** */ (err));
				const hash = createHash(this._hashFunction);
				hash.update(/** @type {string***REMOVED*** */ (entry.timestampHash));
				if (entry.safeTime) {
					safeTime = Math.max(safeTime, entry.safeTime);
				***REMOVED***
				hashes.sort();
				for (const h of hashes) {
					hash.update(h);
				***REMOVED***
				callback(
					null,
					(entry.resolved = {
						safeTime,
						timestampHash: /** @type {string***REMOVED*** */ (hash.digest("hex"))
					***REMOVED***)
				);
			***REMOVED***
		);
	***REMOVED***

	/**
	 * @private
	 * @type {Processor<string, ContextHash>***REMOVED***
	 */
	_readContextHash(path, callback) {
		this._readContext(
			{
				path,
				fromImmutablePath: () => /** @type {ContextHash | ""***REMOVED*** */ (""),
				fromManagedItem: info => info || "",
				fromSymlink: (file, target, callback) => {
					callback(
						null,
						/** @type {ContextHash***REMOVED*** */
						({
							hash: target,
							symlinks: new Set([target])
						***REMOVED***)
					);
				***REMOVED***,
				fromFile: (file, stat, callback) =>
					this.getFileHash(file, (err, hash) => {
						callback(err, hash || "");
					***REMOVED***),
				fromDirectory: (directory, stat, callback) => {
					this.contextHashQueue.increaseParallelism();
					this._getUnresolvedContextHash(directory, (err, hash) => {
						this.contextHashQueue.decreaseParallelism();
						callback(err, hash || "");
					***REMOVED***);
				***REMOVED***,
				/**
				 * @param {string[]***REMOVED*** files files
				 * @param {(string | ContextHash)[]***REMOVED*** fileHashes hashes
				 * @returns {ContextHash***REMOVED*** reduced hash
				 */
				reduce: (files, fileHashes) => {
					let symlinks;
					const hash = createHash(this._hashFunction);

					for (const file of files) hash.update(file);
					for (const entry of fileHashes) {
						if (typeof entry === "string") {
							hash.update(entry);
						***REMOVED*** else {
							hash.update(entry.hash);
							if (entry.symlinks) {
								if (symlinks === undefined) symlinks = new Set();
								addAll(entry.symlinks, symlinks);
							***REMOVED***
						***REMOVED***
					***REMOVED***

					/** @type {ContextHash***REMOVED*** */
					const result = {
						hash: /** @type {string***REMOVED*** */ (hash.digest("hex"))
					***REMOVED***;
					if (symlinks) result.symlinks = symlinks;
					return result;
				***REMOVED***
			***REMOVED***,
			(err, _result) => {
				if (err) return callback(/** @type {WebpackError***REMOVED*** */ (err));
				const result = /** @type {ContextHash***REMOVED*** */ (_result);
				this._contextHashes.set(path, result);
				return callback(null, result);
			***REMOVED***
		);
	***REMOVED***

	/**
	 * @private
	 * @param {ContextHash***REMOVED*** entry context hash
	 * @param {(err: WebpackError | null, contextHash?: string) => void***REMOVED*** callback callback
	 * @returns {void***REMOVED***
	 */
	_resolveContextHash(entry, callback) {
		/** @type {string[]***REMOVED*** */
		const hashes = [];
		processAsyncTree(
			/** @type {NonNullable<ContextHash["symlinks"]>***REMOVED*** */ (entry.symlinks),
			10,
			(target, push, callback) => {
				this._getUnresolvedContextHash(target, (err, hash) => {
					if (err) return callback(err);
					if (hash) {
						hashes.push(hash.hash);
						if (hash.symlinks !== undefined) {
							for (const target of hash.symlinks) push(target);
						***REMOVED***
					***REMOVED***
					callback();
				***REMOVED***);
			***REMOVED***,
			err => {
				if (err) return callback(/** @type {WebpackError***REMOVED*** */ (err));
				const hash = createHash(this._hashFunction);
				hash.update(entry.hash);
				hashes.sort();
				for (const h of hashes) {
					hash.update(h);
				***REMOVED***
				callback(
					null,
					(entry.resolved = /** @type {string***REMOVED*** */ (hash.digest("hex")))
				);
			***REMOVED***
		);
	***REMOVED***

	/**
	 * @private
	 * @type {Processor<string, ContextTimestampAndHash>***REMOVED***
	 */
	_readContextTimestampAndHash(path, callback) {
		/**
		 * @param {ContextTimestamp***REMOVED*** timestamp timestamp
		 * @param {ContextHash***REMOVED*** hash hash
		 */
		const finalize = (timestamp, hash) => {
			const result =
				/** @type {ContextTimestampAndHash***REMOVED*** */
				(timestamp === "ignore" ? hash : { ...timestamp, ...hash ***REMOVED***);
			this._contextTshs.set(path, result);
			callback(null, result);
		***REMOVED***;
		const cachedHash = this._contextHashes.get(path);
		const cachedTimestamp = this._contextTimestamps.get(path);
		if (cachedHash !== undefined) {
			if (cachedTimestamp !== undefined) {
				finalize(cachedTimestamp, cachedHash);
			***REMOVED*** else {
				this.contextTimestampQueue.add(path, (err, entry) => {
					if (err) return callback(err);
					finalize(
						/** @type {ContextFileSystemInfoEntry***REMOVED*** */
						(entry),
						cachedHash
					);
				***REMOVED***);
			***REMOVED***
		***REMOVED*** else if (cachedTimestamp !== undefined) {
			this.contextHashQueue.add(path, (err, entry) => {
				if (err) return callback(err);
				finalize(cachedTimestamp, /** @type {ContextHash***REMOVED*** */ (entry));
			***REMOVED***);
		***REMOVED*** else {
			this._readContext(
				{
					path,
					fromImmutablePath: () =>
						/** @type {ContextTimestampAndHash | null***REMOVED*** */ (null),
					fromManagedItem: info => ({
						safeTime: 0,
						timestampHash: info,
						hash: info || ""
					***REMOVED***),
					fromSymlink: (file, target, callback) => {
						callback(
							null,
							/** @type {TODO***REMOVED*** */
							({
								timestampHash: target,
								hash: target,
								symlinks: new Set([target])
							***REMOVED***)
						);
					***REMOVED***,
					fromFile: (file, stat, callback) => {
						this._getFileTimestampAndHash(file, callback);
					***REMOVED***,
					fromDirectory: (directory, stat, callback) => {
						this.contextTshQueue.increaseParallelism();
						this.contextTshQueue.add(directory, (err, result) => {
							this.contextTshQueue.decreaseParallelism();
							callback(err, result);
						***REMOVED***);
					***REMOVED***,
					/**
					 * @param {string[]***REMOVED*** files files
					 * @param {(Partial<TimestampAndHash> & Partial<ContextTimestampAndHash> | string | null)[]***REMOVED*** results results
					 * @returns {ContextTimestampAndHash***REMOVED*** tsh
					 */
					reduce: (files, results) => {
						let symlinks;

						const tsHash = createHash(this._hashFunction);
						const hash = createHash(this._hashFunction);

						for (const file of files) {
							tsHash.update(file);
							hash.update(file);
						***REMOVED***
						let safeTime = 0;
						for (const entry of results) {
							if (!entry) {
								tsHash.update("n");
								continue;
							***REMOVED***
							if (typeof entry === "string") {
								tsHash.update("n");
								hash.update(entry);
								continue;
							***REMOVED***
							if (entry.timestamp) {
								tsHash.update("f");
								tsHash.update(`${entry.timestamp***REMOVED***`);
							***REMOVED*** else if (entry.timestampHash) {
								tsHash.update("d");
								tsHash.update(`${entry.timestampHash***REMOVED***`);
							***REMOVED***
							if (entry.symlinks !== undefined) {
								if (symlinks === undefined) symlinks = new Set();
								addAll(entry.symlinks, symlinks);
							***REMOVED***
							if (entry.safeTime) {
								safeTime = Math.max(safeTime, entry.safeTime);
							***REMOVED***
							hash.update(/** @type {string***REMOVED*** */ (entry.hash));
						***REMOVED***

						/** @type {ContextTimestampAndHash***REMOVED*** */
						const result = {
							safeTime,
							timestampHash: /** @type {string***REMOVED*** */ (tsHash.digest("hex")),
							hash: /** @type {string***REMOVED*** */ (hash.digest("hex"))
						***REMOVED***;
						if (symlinks) result.symlinks = symlinks;
						return result;
					***REMOVED***
				***REMOVED***,
				(err, _result) => {
					if (err) return callback(/** @type {WebpackError***REMOVED*** */ (err));
					const result = /** @type {ContextTimestampAndHash***REMOVED*** */ (_result);
					this._contextTshs.set(path, result);
					return callback(null, result);
				***REMOVED***
			);
		***REMOVED***
	***REMOVED***

	/**
	 * @private
	 * @param {ContextTimestampAndHash***REMOVED*** entry entry
	 * @param {ProcessorCallback<ResolvedContextTimestampAndHash>***REMOVED*** callback callback
	 * @returns {void***REMOVED***
	 */
	_resolveContextTsh(entry, callback) {
		/** @type {string[]***REMOVED*** */
		const hashes = [];
		/** @type {string[]***REMOVED*** */
		const tsHashes = [];
		let safeTime = 0;
		processAsyncTree(
			/** @type {NonNullable<ContextHash["symlinks"]>***REMOVED*** */ (entry.symlinks),
			10,
			(target, push, callback) => {
				this._getUnresolvedContextTsh(target, (err, entry) => {
					if (err) return callback(err);
					if (entry) {
						hashes.push(entry.hash);
						if (entry.timestampHash) tsHashes.push(entry.timestampHash);
						if (entry.safeTime) {
							safeTime = Math.max(safeTime, entry.safeTime);
						***REMOVED***
						if (entry.symlinks !== undefined) {
							for (const target of entry.symlinks) push(target);
						***REMOVED***
					***REMOVED***
					callback();
				***REMOVED***);
			***REMOVED***,
			err => {
				if (err) return callback(/** @type {WebpackError***REMOVED*** */ (err));
				const hash = createHash(this._hashFunction);
				const tsHash = createHash(this._hashFunction);
				hash.update(entry.hash);
				if (entry.timestampHash) tsHash.update(entry.timestampHash);
				if (entry.safeTime) {
					safeTime = Math.max(safeTime, entry.safeTime);
				***REMOVED***
				hashes.sort();
				for (const h of hashes) {
					hash.update(h);
				***REMOVED***
				tsHashes.sort();
				for (const h of tsHashes) {
					tsHash.update(h);
				***REMOVED***
				callback(
					null,
					(entry.resolved = {
						safeTime,
						timestampHash: /** @type {string***REMOVED*** */ (tsHash.digest("hex")),
						hash: /** @type {string***REMOVED*** */ (hash.digest("hex"))
					***REMOVED***)
				);
			***REMOVED***
		);
	***REMOVED***

	/**
	 * @private
	 * @type {Processor<string, Set<string>>***REMOVED***
	 */
	_getManagedItemDirectoryInfo(path, callback) {
		this.fs.readdir(path, (err, elements) => {
			if (err) {
				if (err.code === "ENOENT" || err.code === "ENOTDIR") {
					return callback(null, EMPTY_SET);
				***REMOVED***
				return callback(/** @type {WebpackError***REMOVED*** */ (err));
			***REMOVED***
			const set = new Set(
				/** @type {string[]***REMOVED*** */ (elements).map(element =>
					join(this.fs, path, element)
				)
			);
			callback(null, set);
		***REMOVED***);
	***REMOVED***

	/**
	 * @private
	 * @type {Processor<string, string>***REMOVED***
	 */
	_getManagedItemInfo(path, callback) {
		const dir = dirname(this.fs, path);
		this.managedItemDirectoryQueue.add(dir, (err, elements) => {
			if (err) {
				return callback(err);
			***REMOVED***
			if (!(/** @type {Set<string>***REMOVED*** */ (elements).has(path))) {
				// file or directory doesn't exist
				this._managedItems.set(path, "*missing");
				return callback(null, "*missing");
			***REMOVED***
			// something exists
			// it may be a file or directory
			if (
				path.endsWith("node_modules") &&
				(path.endsWith("/node_modules") || path.endsWith("\\node_modules"))
			) {
				// we are only interested in existence of this special directory
				this._managedItems.set(path, "*node_modules");
				return callback(null, "*node_modules");
			***REMOVED***

			// we assume it's a directory, as files shouldn't occur in managed paths
			const packageJsonPath = join(this.fs, path, "package.json");
			this.fs.readFile(packageJsonPath, (err, content) => {
				if (err) {
					if (err.code === "ENOENT" || err.code === "ENOTDIR") {
						// no package.json or path is not a directory
						this.fs.readdir(path, (err, elements) => {
							if (
								!err &&
								/** @type {string[]***REMOVED*** */ (elements).length === 1 &&
								/** @type {string[]***REMOVED*** */ (elements)[0] === "node_modules"
							) {
								// This is only a grouping folder e.g. used by yarn
								// we are only interested in existence of this special directory
								this._managedItems.set(path, "*nested");
								return callback(null, "*nested");
							***REMOVED***
							/** @type {Logger***REMOVED*** */
							(this.logger).warn(
								`Managed item ${path***REMOVED*** isn't a directory or doesn't contain a package.json (see snapshot.managedPaths option)`
							);
							return callback();
						***REMOVED***);
						return;
					***REMOVED***
					return callback(/** @type {WebpackError***REMOVED*** */ (err));
				***REMOVED***
				let data;
				try {
					data = JSON.parse(/** @type {Buffer***REMOVED*** */ (content).toString("utf-8"));
				***REMOVED*** catch (parseErr) {
					return callback(/** @type {WebpackError***REMOVED*** */ (parseErr));
				***REMOVED***
				if (!data.name) {
					/** @type {Logger***REMOVED*** */
					(this.logger).warn(
						`${packageJsonPath***REMOVED*** doesn't contain a "name" property (see snapshot.managedPaths option)`
					);
					return callback();
				***REMOVED***
				const info = `${data.name || ""***REMOVED***@${data.version || ""***REMOVED***`;
				this._managedItems.set(path, info);
				callback(null, info);
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	getDeprecatedFileTimestamps() {
		if (this._cachedDeprecatedFileTimestamps !== undefined)
			return this._cachedDeprecatedFileTimestamps;
		/** @type {Map<string, number | null>***REMOVED*** */
		const map = new Map();
		for (const [path, info] of this._fileTimestamps) {
			if (info) map.set(path, typeof info === "object" ? info.safeTime : null);
		***REMOVED***
		return (this._cachedDeprecatedFileTimestamps = map);
	***REMOVED***

	getDeprecatedContextTimestamps() {
		if (this._cachedDeprecatedContextTimestamps !== undefined)
			return this._cachedDeprecatedContextTimestamps;
		/** @type {Map<string, number | null>***REMOVED*** */
		const map = new Map();
		for (const [path, info] of this._contextTimestamps) {
			if (info) map.set(path, typeof info === "object" ? info.safeTime : null);
		***REMOVED***
		return (this._cachedDeprecatedContextTimestamps = map);
	***REMOVED***
***REMOVED***

module.exports = FileSystemInfo;
module.exports.Snapshot = Snapshot;
