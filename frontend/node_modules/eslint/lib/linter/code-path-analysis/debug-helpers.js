/**
 * @fileoverview Helpers to debug for code path analysis.
 * @author Toru Nagashima
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const debug = require("debug")("eslint:code-path");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

/**
 * Gets id of a given segment.
 * @param {CodePathSegment***REMOVED*** segment A segment to get.
 * @returns {string***REMOVED*** Id of the segment.
 */
/* c8 ignore next */
// eslint-disable-next-line jsdoc/require-jsdoc -- Ignoring
function getId(segment) {
	return segment.id + (segment.reachable ? "" : "!");
***REMOVED***

/**
 * Get string for the given node and operation.
 * @param {ASTNode***REMOVED*** node The node to convert.
 * @param {"enter" | "exit" | undefined***REMOVED*** label The operation label.
 * @returns {string***REMOVED*** The string representation.
 */
function nodeToString(node, label) {
	const suffix = label ? `:${label***REMOVED***` : "";

	switch (node.type) {
		case "Identifier":
			return `${node.type***REMOVED***${suffix***REMOVED*** (${node.name***REMOVED***)`;
		case "Literal":
			return `${node.type***REMOVED***${suffix***REMOVED*** (${node.value***REMOVED***)`;
		default:
			return `${node.type***REMOVED***${suffix***REMOVED***`;
	***REMOVED***
***REMOVED***

//------------------------------------------------------------------------------
// Public Interface
//------------------------------------------------------------------------------

module.exports = {
	/**
	 * A flag that debug dumping is enabled or not.
	 * @type {boolean***REMOVED***
	 */
	enabled: debug.enabled,

	/**
	 * Dumps given objects.
	 * @param {...any***REMOVED*** args objects to dump.
	 * @returns {void***REMOVED***
	 */
	dump: debug,

	/**
	 * Dumps the current analyzing state.
	 * @param {ASTNode***REMOVED*** node A node to dump.
	 * @param {CodePathState***REMOVED*** state A state to dump.
	 * @param {boolean***REMOVED*** leaving A flag whether or not it's leaving
	 * @returns {void***REMOVED***
	 */
	dumpState: !debug.enabled
		? debug
		: /* c8 ignore next */ function (node, state, leaving) {
				for (let i = 0; i < state.currentSegments.length; ++i) {
					const segInternal = state.currentSegments[i].internal;

					if (leaving) {
						const last = segInternal.nodes.length - 1;

						if (
							last >= 0 &&
							segInternal.nodes[last] ===
								nodeToString(node, "enter")
						) {
							segInternal.nodes[last] = nodeToString(
								node,
								void 0,
							);
						***REMOVED*** else {
							segInternal.nodes.push(nodeToString(node, "exit"));
						***REMOVED***
					***REMOVED*** else {
						segInternal.nodes.push(nodeToString(node, "enter"));
					***REMOVED***
				***REMOVED***

				debug(
					[
						`${state.currentSegments.map(getId).join(",")***REMOVED***)`,
						`${node.type***REMOVED***${leaving ? ":exit" : ""***REMOVED***`,
					].join(" "),
				);
			***REMOVED***,

	/**
	 * Dumps a DOT code of a given code path.
	 * The DOT code can be visualized with Graphvis.
	 * @param {CodePath***REMOVED*** codePath A code path to dump.
	 * @returns {void***REMOVED***
	 * @see http://www.graphviz.org
	 * @see http://www.webgraphviz.com
	 */
	dumpDot: !debug.enabled
		? debug
		: /* c8 ignore next */ function (codePath) {
				let text =
					"\n" +
					"digraph {\n" +
					'node[shape=box,style="rounded,filled",fillcolor=white];\n' +
					'initial[label="",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\n';

				if (codePath.returnedSegments.length > 0) {
					text +=
						'final[label="",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\n';
				***REMOVED***
				if (codePath.thrownSegments.length > 0) {
					text +=
						'thrown[label="âœ˜",shape=circle,width=0.3,height=0.3,fixedsize=true];\n';
				***REMOVED***

				const traceMap = Object.create(null);
				const arrows = this.makeDotArrows(codePath, traceMap);

				// eslint-disable-next-line guard-for-in -- Want ability to traverse prototype
				for (const id in traceMap) {
					const segment = traceMap[id];

					text += `${id***REMOVED***[`;

					if (segment.reachable) {
						text += 'label="';
					***REMOVED*** else {
						text +=
							'style="rounded,dashed,filled",fillcolor="#FF9800",label="<<unreachable>>\\n';
					***REMOVED***

					if (segment.internal.nodes.length > 0) {
						text += segment.internal.nodes.join("\\n");
					***REMOVED*** else {
						text += "????";
					***REMOVED***

					text += '"];\n';
				***REMOVED***

				text += `${arrows***REMOVED***\n`;
				text += "***REMOVED***";
				debug("DOT", text);
			***REMOVED***,

	/**
	 * Makes a DOT code of a given code path.
	 * The DOT code can be visualized with Graphvis.
	 * @param {CodePath***REMOVED*** codePath A code path to make DOT.
	 * @param {Object***REMOVED*** traceMap Optional. A map to check whether or not segments had been done.
	 * @returns {string***REMOVED*** A DOT code of the code path.
	 */
	makeDotArrows(codePath, traceMap) {
		const stack = [[codePath.initialSegment, 0]];
		const done = traceMap || Object.create(null);
		let lastId = codePath.initialSegment.id;
		let text = `initial->${codePath.initialSegment.id***REMOVED***`;

		while (stack.length > 0) {
			const item = stack.pop();
			const segment = item[0];
			const index = item[1];

			if (done[segment.id] && index === 0) {
				continue;
			***REMOVED***
			done[segment.id] = segment;

			const nextSegment = segment.allNextSegments[index];

			if (!nextSegment) {
				continue;
			***REMOVED***

			if (lastId === segment.id) {
				text += `->${nextSegment.id***REMOVED***`;
			***REMOVED*** else {
				text += `;\n${segment.id***REMOVED***->${nextSegment.id***REMOVED***`;
			***REMOVED***
			lastId = nextSegment.id;

			stack.unshift([segment, 1 + index]);
			stack.push([nextSegment, 0]);
		***REMOVED***

		codePath.returnedSegments.forEach(finalSegment => {
			if (lastId === finalSegment.id) {
				text += "->final";
			***REMOVED*** else {
				text += `;\n${finalSegment.id***REMOVED***->final`;
			***REMOVED***
			lastId = null;
		***REMOVED***);

		codePath.thrownSegments.forEach(finalSegment => {
			if (lastId === finalSegment.id) {
				text += "->thrown";
			***REMOVED*** else {
				text += `;\n${finalSegment.id***REMOVED***->thrown`;
			***REMOVED***
			lastId = null;
		***REMOVED***);

		return `${text***REMOVED***;`;
	***REMOVED***,
***REMOVED***;
