/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const asyncLib = require("neo-async");

/** @typedef {import("./MultiCompiler")***REMOVED*** MultiCompiler */
/** @typedef {import("./Watching")***REMOVED*** Watching */

/**
 * @template T
 * @callback Callback
 * @param {(Error | null)=***REMOVED*** err
 * @param {T=***REMOVED*** result
 */

class MultiWatching {
	/**
	 * @param {Watching[]***REMOVED*** watchings child compilers' watchers
	 * @param {MultiCompiler***REMOVED*** compiler the compiler
	 */
	constructor(watchings, compiler) {
		this.watchings = watchings;
		this.compiler = compiler;
	***REMOVED***

	/**
	 * @param {Callback<void>=***REMOVED*** callback signals when the build has completed again
	 * @returns {void***REMOVED***
	 */
	invalidate(callback) {
		if (callback) {
			asyncLib.each(
				this.watchings,
				(watching, callback) => watching.invalidate(callback),
				callback
			);
		***REMOVED*** else {
			for (const watching of this.watchings) {
				watching.invalidate();
			***REMOVED***
		***REMOVED***
	***REMOVED***

	suspend() {
		for (const watching of this.watchings) {
			watching.suspend();
		***REMOVED***
	***REMOVED***

	resume() {
		for (const watching of this.watchings) {
			watching.resume();
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Callback<void>***REMOVED*** callback signals when the watcher is closed
	 * @returns {void***REMOVED***
	 */
	close(callback) {
		asyncLib.each(
			this.watchings,
			(watching, finishedCallback) => {
				watching.close(finishedCallback);
			***REMOVED***,
			err => {
				this.compiler.hooks.watchClose.call();
				if (typeof callback === "function") {
					this.compiler.running = false;
					callback(err);
				***REMOVED***
			***REMOVED***
		);
	***REMOVED***
***REMOVED***

module.exports = MultiWatching;
