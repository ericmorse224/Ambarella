'use strict';

const stringify = require('./lib/stringify');
const compile = require('./lib/compile');
const expand = require('./lib/expand');
const parse = require('./lib/parse');

/**
 * Expand the given pattern or create a regex-compatible string.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces('{a,b,c***REMOVED***', { compile: true ***REMOVED***)); //=> ['(a|b|c)']
 * console.log(braces('{a,b,c***REMOVED***')); //=> ['a', 'b', 'c']
 * ```
 * @param {String***REMOVED*** `str`
 * @param {Object***REMOVED*** `options`
 * @return {String***REMOVED***
 * @api public
 */

const braces = (input, options = {***REMOVED***) => {
  let output = [];

  if (Array.isArray(input)) {
    for (const pattern of input) {
      const result = braces.create(pattern, options);
      if (Array.isArray(result)) {
        output.push(...result);
      ***REMOVED*** else {
        output.push(result);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED*** else {
    output = [].concat(braces.create(input, options));
  ***REMOVED***

  if (options && options.expand === true && options.nodupes === true) {
    output = [...new Set(output)];
  ***REMOVED***
  return output;
***REMOVED***;

/**
 * Parse the given `str` with the given `options`.
 *
 * ```js
 * // braces.parse(pattern, [, options]);
 * const ast = braces.parse('a/{b,c***REMOVED***/d');
 * console.log(ast);
 * ```
 * @param {String***REMOVED*** pattern Brace pattern to parse
 * @param {Object***REMOVED*** options
 * @return {Object***REMOVED*** Returns an AST
 * @api public
 */

braces.parse = (input, options = {***REMOVED***) => parse(input, options);

/**
 * Creates a braces string from an AST, or an AST node.
 *
 * ```js
 * const braces = require('braces');
 * let ast = braces.parse('foo/{a,b***REMOVED***/bar');
 * console.log(stringify(ast.nodes[2])); //=> '{a,b***REMOVED***'
 * ```
 * @param {String***REMOVED*** `input` Brace pattern or AST.
 * @param {Object***REMOVED*** `options`
 * @return {Array***REMOVED*** Returns an array of expanded values.
 * @api public
 */

braces.stringify = (input, options = {***REMOVED***) => {
  if (typeof input === 'string') {
    return stringify(braces.parse(input, options), options);
  ***REMOVED***
  return stringify(input, options);
***REMOVED***;

/**
 * Compiles a brace pattern into a regex-compatible, optimized string.
 * This method is called by the main [braces](#braces) function by default.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.compile('a/{b,c***REMOVED***/d'));
 * //=> ['a/(b|c)/d']
 * ```
 * @param {String***REMOVED*** `input` Brace pattern or AST.
 * @param {Object***REMOVED*** `options`
 * @return {Array***REMOVED*** Returns an array of expanded values.
 * @api public
 */

braces.compile = (input, options = {***REMOVED***) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  ***REMOVED***
  return compile(input, options);
***REMOVED***;

/**
 * Expands a brace pattern into an array. This method is called by the
 * main [braces](#braces) function when `options.expand` is true. Before
 * using this method it's recommended that you read the [performance notes](#performance))
 * and advantages of using [.compile](#compile) instead.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.expand('a/{b,c***REMOVED***/d'));
 * //=> ['a/b/d', 'a/c/d'];
 * ```
 * @param {String***REMOVED*** `pattern` Brace pattern
 * @param {Object***REMOVED*** `options`
 * @return {Array***REMOVED*** Returns an array of expanded values.
 * @api public
 */

braces.expand = (input, options = {***REMOVED***) => {
  if (typeof input === 'string') {
    input = braces.parse(input, options);
  ***REMOVED***

  let result = expand(input, options);

  // filter out empty strings if specified
  if (options.noempty === true) {
    result = result.filter(Boolean);
  ***REMOVED***

  // filter out duplicates if specified
  if (options.nodupes === true) {
    result = [...new Set(result)];
  ***REMOVED***

  return result;
***REMOVED***;

/**
 * Processes a brace pattern and returns either an expanded array
 * (if `options.expand` is true), a highly optimized regex-compatible string.
 * This method is called by the main [braces](#braces) function.
 *
 * ```js
 * const braces = require('braces');
 * console.log(braces.create('user-{200..300***REMOVED***/project-{a,b,c***REMOVED***-{1..10***REMOVED***'))
 * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'
 * ```
 * @param {String***REMOVED*** `pattern` Brace pattern
 * @param {Object***REMOVED*** `options`
 * @return {Array***REMOVED*** Returns an array of expanded values.
 * @api public
 */

braces.create = (input, options = {***REMOVED***) => {
  if (input === '' || input.length < 3) {
    return [input];
  ***REMOVED***

  return options.expand !== true
    ? braces.compile(input, options)
    : braces.expand(input, options);
***REMOVED***;

/**
 * Expose "braces"
 */

module.exports = braces;
