/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Florent Cailhol @ooflorent
*/

"use strict";

const { ConcatSource ***REMOVED*** = require("webpack-sources");
const makeSerializable = require("./util/makeSerializable");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("./Generator").GenerateContext***REMOVED*** GenerateContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectDeserializerContext***REMOVED*** ObjectDeserializerContext */
/** @typedef {import("./serialization/ObjectMiddleware").ObjectSerializerContext***REMOVED*** ObjectSerializerContext */

/**
 * @template T
 * @param {InitFragment<T>***REMOVED*** fragment the init fragment
 * @param {number***REMOVED*** index index
 * @returns {[InitFragment<T>, number]***REMOVED*** tuple with both
 */
const extractFragmentIndex = (fragment, index) => [fragment, index];

/**
 * @template T
 * @param {[InitFragment<T>, number]***REMOVED*** a first pair
 * @param {[InitFragment<T>, number]***REMOVED*** b second pair
 * @returns {number***REMOVED*** sort value
 */
const sortFragmentWithIndex = ([a, i], [b, j]) => {
	const stageCmp = a.stage - b.stage;
	if (stageCmp !== 0) return stageCmp;
	const positionCmp = a.position - b.position;
	if (positionCmp !== 0) return positionCmp;
	return i - j;
***REMOVED***;

/**
 * @template GenerateContext
 */
class InitFragment {
	/**
	 * @param {string | Source | undefined***REMOVED*** content the source code that will be included as initialization code
	 * @param {number***REMOVED*** stage category of initialization code (contribute to order)
	 * @param {number***REMOVED*** position position in the category (contribute to order)
	 * @param {string=***REMOVED*** key unique key to avoid emitting the same initialization code twice
	 * @param {string | Source=***REMOVED*** endContent the source code that will be included at the end of the module
	 */
	constructor(content, stage, position, key, endContent) {
		this.content = content;
		this.stage = stage;
		this.position = position;
		this.key = key;
		this.endContent = endContent;
	***REMOVED***

	/**
	 * @param {GenerateContext***REMOVED*** context context
	 * @returns {string | Source | undefined***REMOVED*** the source code that will be included as initialization code
	 */
	getContent(context) {
		return this.content;
	***REMOVED***

	/**
	 * @param {GenerateContext***REMOVED*** context context
	 * @returns {string | Source=***REMOVED*** the source code that will be included at the end of the module
	 */
	getEndContent(context) {
		return this.endContent;
	***REMOVED***

	/**
	 * @template Context
	 * @template T
	 * @param {Source***REMOVED*** source sources
	 * @param {InitFragment<T>[]***REMOVED*** initFragments init fragments
	 * @param {Context***REMOVED*** context context
	 * @returns {Source***REMOVED*** source
	 */
	static addToSource(source, initFragments, context) {
		if (initFragments.length > 0) {
			// Sort fragments by position. If 2 fragments have the same position,
			// use their index.
			const sortedFragments = initFragments
				.map(extractFragmentIndex)
				.sort(sortFragmentWithIndex);

			// Deduplicate fragments. If a fragment has no key, it is always included.
			const keyedFragments = new Map();
			for (const [fragment] of sortedFragments) {
				if (
					typeof (
						/** @type {InitFragment<T> & { mergeAll?: (fragments: InitFragment<Context>[]) => InitFragment<Context>[] ***REMOVED******REMOVED*** */
						(fragment).mergeAll
					) === "function"
				) {
					if (!fragment.key) {
						throw new Error(
							`InitFragment with mergeAll function must have a valid key: ${fragment.constructor.name***REMOVED***`
						);
					***REMOVED***
					const oldValue = keyedFragments.get(fragment.key);
					if (oldValue === undefined) {
						keyedFragments.set(fragment.key, fragment);
					***REMOVED*** else if (Array.isArray(oldValue)) {
						oldValue.push(fragment);
					***REMOVED*** else {
						keyedFragments.set(fragment.key, [oldValue, fragment]);
					***REMOVED***
					continue;
				***REMOVED*** else if (typeof fragment.merge === "function") {
					const oldValue = keyedFragments.get(fragment.key);
					if (oldValue !== undefined) {
						keyedFragments.set(fragment.key, fragment.merge(oldValue));
						continue;
					***REMOVED***
				***REMOVED***
				keyedFragments.set(fragment.key || Symbol("fragment key"), fragment);
			***REMOVED***

			const concatSource = new ConcatSource();
			const endContents = [];
			for (let fragment of keyedFragments.values()) {
				if (Array.isArray(fragment)) {
					fragment = fragment[0].mergeAll(fragment);
				***REMOVED***
				concatSource.add(fragment.getContent(context));
				const endContent = fragment.getEndContent(context);
				if (endContent) {
					endContents.push(endContent);
				***REMOVED***
			***REMOVED***

			concatSource.add(source);
			for (const content of endContents.reverse()) {
				concatSource.add(content);
			***REMOVED***
			return concatSource;
		***REMOVED***
		return source;
	***REMOVED***

	/**
	 * @param {ObjectSerializerContext***REMOVED*** context context
	 */
	serialize(context) {
		const { write ***REMOVED*** = context;

		write(this.content);
		write(this.stage);
		write(this.position);
		write(this.key);
		write(this.endContent);
	***REMOVED***

	/**
	 * @param {ObjectDeserializerContext***REMOVED*** context context
	 */
	deserialize(context) {
		const { read ***REMOVED*** = context;

		this.content = read();
		this.stage = read();
		this.position = read();
		this.key = read();
		this.endContent = read();
	***REMOVED***
***REMOVED***

makeSerializable(InitFragment, "webpack/lib/InitFragment");

InitFragment.prototype.merge =
	/** @type {TODO***REMOVED*** */
	(undefined);

InitFragment.STAGE_CONSTANTS = 10;
InitFragment.STAGE_ASYNC_BOUNDARY = 20;
InitFragment.STAGE_HARMONY_EXPORTS = 30;
InitFragment.STAGE_HARMONY_IMPORTS = 40;
InitFragment.STAGE_PROVIDES = 50;
InitFragment.STAGE_ASYNC_DEPENDENCIES = 60;
InitFragment.STAGE_ASYNC_HARMONY_IMPORTS = 70;

module.exports = InitFragment;
