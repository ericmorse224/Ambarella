'use strict';

var callBound = require('call-bound');
var hasToStringTag = require('has-tostringtag/shams')();
var hasOwn = require('hasown');
var gOPD = require('gopd');

/** @type {import('.')***REMOVED*** */
var fn;

if (hasToStringTag) {
	/** @type {(receiver: ThisParameterType<typeof RegExp.prototype.exec>, ...args: Parameters<typeof RegExp.prototype.exec>) => ReturnType<typeof RegExp.prototype.exec>***REMOVED*** */
	var $exec = callBound('RegExp.prototype.exec');
	/** @type {object***REMOVED*** */
	var isRegexMarker = {***REMOVED***;

	var throwRegexMarker = function () {
		throw isRegexMarker;
	***REMOVED***;
	/** @type {{ toString(): never, valueOf(): never, [Symbol.toPrimitive]?(): never ***REMOVED******REMOVED*** */
	var badStringifier = {
		toString: throwRegexMarker,
		valueOf: throwRegexMarker
	***REMOVED***;

	if (typeof Symbol.toPrimitive === 'symbol') {
		badStringifier[Symbol.toPrimitive] = throwRegexMarker;
	***REMOVED***

	/** @type {import('.')***REMOVED*** */
	// @ts-expect-error TS can't figure out that the $exec call always throws
	// eslint-disable-next-line consistent-return
	fn = function isRegex(value) {
		if (!value || typeof value !== 'object') {
			return false;
		***REMOVED***

		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {NonNullable<typeof gOPD>***REMOVED*** */ (gOPD)(/** @type {{ lastIndex?: unknown ***REMOVED******REMOVED*** */ (value), 'lastIndex');
		var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, 'value');
		if (!hasLastIndexDataProperty) {
			return false;
		***REMOVED***

		try {
			// eslint-disable-next-line no-extra-parens
			$exec(value, /** @type {string***REMOVED*** */ (/** @type {unknown***REMOVED*** */ (badStringifier)));
		***REMOVED*** catch (e) {
			return e === isRegexMarker;
		***REMOVED***
	***REMOVED***;
***REMOVED*** else {
	/** @type {(receiver: ThisParameterType<typeof Object.prototype.toString>, ...args: Parameters<typeof Object.prototype.toString>) => ReturnType<typeof Object.prototype.toString>***REMOVED*** */
	var $toString = callBound('Object.prototype.toString');
	/** @const @type {'[object RegExp]'***REMOVED*** */
	var regexClass = '[object RegExp]';

	/** @type {import('.')***REMOVED*** */
	fn = function isRegex(value) {
		// In older browsers, typeof regex incorrectly returns 'function'
		if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
			return false;
		***REMOVED***

		return $toString(value) === regexClass;
	***REMOVED***;
***REMOVED***

module.exports = fn;
