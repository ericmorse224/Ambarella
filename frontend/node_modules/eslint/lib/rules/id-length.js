/**
 * @fileoverview Rule that warns when identifier names are shorter or longer
 * than the values provided in configuration.
 * @author Burak Yigit Kaya aka BYK
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const { getGraphemeCount ***REMOVED*** = require("../shared/string-utils");
const {
	getModuleExportName,
	isImportAttributeKey,
***REMOVED*** = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "suggestion",

		defaultOptions: [
			{
				exceptionPatterns: [],
				exceptions: [],
				min: 2,
				properties: "always",
			***REMOVED***,
		],

		docs: {
			description: "Enforce minimum and maximum identifier lengths",
			recommended: false,
			frozen: true,
			url: "https://eslint.org/docs/latest/rules/id-length",
		***REMOVED***,

		schema: [
			{
				type: "object",
				properties: {
					min: {
						type: "integer",
					***REMOVED***,
					max: {
						type: "integer",
					***REMOVED***,
					exceptions: {
						type: "array",
						uniqueItems: true,
						items: {
							type: "string",
						***REMOVED***,
					***REMOVED***,
					exceptionPatterns: {
						type: "array",
						uniqueItems: true,
						items: {
							type: "string",
						***REMOVED***,
					***REMOVED***,
					properties: {
						enum: ["always", "never"],
					***REMOVED***,
				***REMOVED***,
				additionalProperties: false,
			***REMOVED***,
		],
		messages: {
			tooShort: "Identifier name '{{name***REMOVED******REMOVED***' is too short (< {{min***REMOVED******REMOVED***).",
			tooShortPrivate:
				"Identifier name '#{{name***REMOVED******REMOVED***' is too short (< {{min***REMOVED******REMOVED***).",
			tooLong: "Identifier name '{{name***REMOVED******REMOVED***' is too long (> {{max***REMOVED******REMOVED***).",
			tooLongPrivate:
				"Identifier name #'{{name***REMOVED******REMOVED***' is too long (> {{max***REMOVED******REMOVED***).",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const [options] = context.options;
		const { max: maxLength = Infinity, min: minLength ***REMOVED*** = options;
		const properties = options.properties !== "never";
		const exceptions = new Set(options.exceptions);
		const exceptionPatterns = options.exceptionPatterns.map(
			pattern => new RegExp(pattern, "u"),
		);
		const reportedNodes = new Set();

		/**
		 * Checks if a string matches the provided exception patterns
		 * @param {string***REMOVED*** name The string to check.
		 * @returns {boolean***REMOVED*** if the string is a match
		 * @private
		 */
		function matchesExceptionPattern(name) {
			return exceptionPatterns.some(pattern => pattern.test(name));
		***REMOVED***

		const SUPPORTED_EXPRESSIONS = {
			MemberExpression:
				properties &&
				function (parent) {
					return (
						!parent.computed &&
						// regular property assignment
						((parent.parent.left === parent &&
							parent.parent.type === "AssignmentExpression") ||
							// or the last identifier in an ObjectPattern destructuring
							(parent.parent.type === "Property" &&
								parent.parent.value === parent &&
								parent.parent.parent.type === "ObjectPattern" &&
								parent.parent.parent.parent.left ===
									parent.parent.parent))
					);
				***REMOVED***,
			AssignmentPattern(parent, node) {
				return parent.left === node;
			***REMOVED***,
			VariableDeclarator(parent, node) {
				return parent.id === node;
			***REMOVED***,
			Property(parent, node) {
				if (parent.parent.type === "ObjectPattern") {
					const isKeyAndValueSame =
						parent.value.name === parent.key.name;

					return (
						(!isKeyAndValueSame && parent.value === node) ||
						(isKeyAndValueSame && parent.key === node && properties)
					);
				***REMOVED***
				return (
					properties &&
					!isImportAttributeKey(node) &&
					!parent.computed &&
					parent.key.name === node.name
				);
			***REMOVED***,
			ImportSpecifier(parent, node) {
				return (
					parent.local === node &&
					getModuleExportName(parent.imported) !==
						getModuleExportName(parent.local)
				);
			***REMOVED***,
			ImportDefaultSpecifier: true,
			ImportNamespaceSpecifier: true,
			RestElement: true,
			FunctionExpression: true,
			ArrowFunctionExpression: true,
			ClassDeclaration: true,
			FunctionDeclaration: true,
			MethodDefinition: true,
			PropertyDefinition: true,
			CatchClause: true,
			ArrayPattern: true,
		***REMOVED***;

		return {
			[["Identifier", "PrivateIdentifier"]](node) {
				const name = node.name;
				const parent = node.parent;

				const nameLength = getGraphemeCount(name);

				const isShort = nameLength < minLength;
				const isLong = nameLength > maxLength;

				if (
					!(isShort || isLong) ||
					exceptions.has(name) ||
					matchesExceptionPattern(name)
				) {
					return; // Nothing to report
				***REMOVED***

				const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];

				/*
				 * We used the range instead of the node because it's possible
				 * for the same identifier to be represented by two different
				 * nodes, with the most clear example being shorthand properties:
				 * { foo ***REMOVED***
				 * In this case, "foo" is represented by one node for the name
				 * and one for the value. The only way to know they are the same
				 * is to look at the range.
				 */
				if (
					isValidExpression &&
					!reportedNodes.has(node.range.toString()) &&
					(isValidExpression === true ||
						isValidExpression(parent, node))
				) {
					reportedNodes.add(node.range.toString());

					let messageId = isShort ? "tooShort" : "tooLong";

					if (node.type === "PrivateIdentifier") {
						messageId += "Private";
					***REMOVED***

					context.report({
						node,
						messageId,
						data: { name, min: minLength, max: maxLength ***REMOVED***,
					***REMOVED***);
				***REMOVED***
			***REMOVED***,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
