import type {
  CodeKeywordDefinition,
  KeywordErrorDefinition,
  ErrorObject,
  AnySchema,
***REMOVED*** from "../../types"
import {_, not, and, Name, Code***REMOVED*** from "../../compile/codegen"
import {alwaysValidSchema, Type***REMOVED*** from "../../compile/util"
import N from "../../compile/names"

export type UnevaluatedPropertiesError = ErrorObject<
  "unevaluatedProperties",
  {unevaluatedProperty: string***REMOVED***,
  AnySchema
>

const error: KeywordErrorDefinition = {
  message: "must NOT have unevaluated properties",
  params: ({params***REMOVED***) => _`{unevaluatedProperty: ${params.unevaluatedProperty***REMOVED******REMOVED***`,
***REMOVED***

const def: CodeKeywordDefinition = {
  keyword: "unevaluatedProperties",
  type: "object",
  schemaType: ["boolean", "object"],
  trackErrors: true,
  error,
  code(cxt) {
    const {gen, schema, data, errsCount, it***REMOVED*** = cxt
    /* istanbul ignore if */
    if (!errsCount) throw new Error("ajv implementation error")
    const {allErrors, props***REMOVED*** = it
    if (props instanceof Name) {
      gen.if(_`${props***REMOVED*** !== true`, () =>
        gen.forIn("key", data, (key: Name) =>
          gen.if(unevaluatedDynamic(props, key), () => unevaluatedPropCode(key))
        )
      )
    ***REMOVED*** else if (props !== true) {
      gen.forIn("key", data, (key: Name) =>
        props === undefined
          ? unevaluatedPropCode(key)
          : gen.if(unevaluatedStatic(props, key), () => unevaluatedPropCode(key))
      )
    ***REMOVED***
    it.props = true
    cxt.ok(_`${errsCount***REMOVED*** === ${N.errors***REMOVED***`)

    function unevaluatedPropCode(key: Name): void {
      if (schema === false) {
        cxt.setParams({unevaluatedProperty: key***REMOVED***)
        cxt.error()
        if (!allErrors) gen.break()
        return
      ***REMOVED***

      if (!alwaysValidSchema(it, schema)) {
        const valid = gen.name("valid")
        cxt.subschema(
          {
            keyword: "unevaluatedProperties",
            dataProp: key,
            dataPropType: Type.Str,
          ***REMOVED***,
          valid
        )
        if (!allErrors) gen.if(not(valid), () => gen.break())
      ***REMOVED***
    ***REMOVED***

    function unevaluatedDynamic(evaluatedProps: Name, key: Name): Code {
      return _`!${evaluatedProps***REMOVED*** || !${evaluatedProps***REMOVED***[${key***REMOVED***]`
    ***REMOVED***

    function unevaluatedStatic(evaluatedProps: {[K in string]?: true***REMOVED***, key: Name): Code {
      const ps: Code[] = []
      for (const p in evaluatedProps) {
        if (evaluatedProps[p] === true) ps.push(_`${key***REMOVED*** !== ${p***REMOVED***`)
      ***REMOVED***
      return and(...ps)
    ***REMOVED***
  ***REMOVED***,
***REMOVED***

export default def
