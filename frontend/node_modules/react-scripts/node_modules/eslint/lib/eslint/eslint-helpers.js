/**
 * @fileoverview Helper functions for ESLint class
 * @author Nicholas C. Zakas
 */

"use strict";

//-----------------------------------------------------------------------------
// Requirements
//-----------------------------------------------------------------------------

const path = require("path");
const fs = require("fs");
const fsp = fs.promises;
const isGlob = require("is-glob");
const hash = require("../cli-engine/hash");
const minimatch = require("minimatch");
const fswalk = require("@nodelib/fs.walk");
const globParent = require("glob-parent");
const isPathInside = require("is-path-inside");

//-----------------------------------------------------------------------------
// Fixup references
//-----------------------------------------------------------------------------

const Minimatch = minimatch.Minimatch;
const MINIMATCH_OPTIONS = { dot: true ***REMOVED***;

//-----------------------------------------------------------------------------
// Types
//-----------------------------------------------------------------------------

/**
 * @typedef {Object***REMOVED*** GlobSearch
 * @property {Array<string>***REMOVED*** patterns The normalized patterns to use for a search.
 * @property {Array<string>***REMOVED*** rawPatterns The patterns as entered by the user
 *      before doing any normalization.
 */

//-----------------------------------------------------------------------------
// Errors
//-----------------------------------------------------------------------------

/**
 * The error type when no files match a glob.
 */
class NoFilesFoundError extends Error {

    /**
     * @param {string***REMOVED*** pattern The glob pattern which was not found.
     * @param {boolean***REMOVED*** globEnabled If `false` then the pattern was a glob pattern, but glob was disabled.
     */
    constructor(pattern, globEnabled) {
        super(`No files matching '${pattern***REMOVED***' were found${!globEnabled ? " (glob was disabled)" : ""***REMOVED***.`);
        this.messageTemplate = "file-not-found";
        this.messageData = { pattern, globDisabled: !globEnabled ***REMOVED***;
    ***REMOVED***
***REMOVED***

/**
 * The error type when a search fails to match multiple patterns.
 */
class UnmatchedSearchPatternsError extends Error {

    /**
     * @param {Object***REMOVED*** options The options for the error.
     * @param {string***REMOVED*** options.basePath The directory that was searched.
     * @param {Array<string>***REMOVED*** options.unmatchedPatterns The glob patterns
     *      which were not found.
     * @param {Array<string>***REMOVED*** options.patterns The glob patterns that were
     *      searched.
     * @param {Array<string>***REMOVED*** options.rawPatterns The raw glob patterns that
     *      were searched.
     */
    constructor({ basePath, unmatchedPatterns, patterns, rawPatterns ***REMOVED***) {
        super(`No files matching '${rawPatterns***REMOVED***' in '${basePath***REMOVED***' were found.`);
        this.basePath = basePath;
        this.unmatchedPatterns = unmatchedPatterns;
        this.patterns = patterns;
        this.rawPatterns = rawPatterns;
    ***REMOVED***
***REMOVED***

/**
 * The error type when there are files matched by a glob, but all of them have been ignored.
 */
class AllFilesIgnoredError extends Error {

    /**
     * @param {string***REMOVED*** pattern The glob pattern which was not found.
     */
    constructor(pattern) {
        super(`All files matched by '${pattern***REMOVED***' are ignored.`);
        this.messageTemplate = "all-files-ignored";
        this.messageData = { pattern ***REMOVED***;
    ***REMOVED***
***REMOVED***


//-----------------------------------------------------------------------------
// General Helpers
//-----------------------------------------------------------------------------

/**
 * Check if a given value is a non-empty string or not.
 * @param {any***REMOVED*** x The value to check.
 * @returns {boolean***REMOVED*** `true` if `x` is a non-empty string.
 */
function isNonEmptyString(x) {
    return typeof x === "string" && x.trim() !== "";
***REMOVED***

/**
 * Check if a given value is an array of non-empty strings or not.
 * @param {any***REMOVED*** x The value to check.
 * @returns {boolean***REMOVED*** `true` if `x` is an array of non-empty strings.
 */
function isArrayOfNonEmptyString(x) {
    return Array.isArray(x) && x.every(isNonEmptyString);
***REMOVED***

//-----------------------------------------------------------------------------
// File-related Helpers
//-----------------------------------------------------------------------------

/**
 * Normalizes slashes in a file pattern to posix-style.
 * @param {string***REMOVED*** pattern The pattern to replace slashes in.
 * @returns {string***REMOVED*** The pattern with slashes normalized.
 */
function normalizeToPosix(pattern) {
    return pattern.replace(/\\/gu, "/");
***REMOVED***

/**
 * Check if a string is a glob pattern or not.
 * @param {string***REMOVED*** pattern A glob pattern.
 * @returns {boolean***REMOVED*** `true` if the string is a glob pattern.
 */
function isGlobPattern(pattern) {
    return isGlob(path.sep === "\\" ? normalizeToPosix(pattern) : pattern);
***REMOVED***


/**
 * Determines if a given glob pattern will return any results.
 * Used primarily to help with useful error messages.
 * @param {Object***REMOVED*** options The options for the function.
 * @param {string***REMOVED*** options.basePath The directory to search.
 * @param {string***REMOVED*** options.pattern A glob pattern to match.
 * @returns {Promise<boolean>***REMOVED*** True if there is a glob match, false if not.
 */
function globMatch({ basePath, pattern ***REMOVED***) {

    let found = false;
    const patternToUse = path.isAbsolute(pattern)
        ? normalizeToPosix(path.relative(basePath, pattern))
        : pattern;

    const matcher = new Minimatch(patternToUse, MINIMATCH_OPTIONS);

    const fsWalkSettings = {

        deepFilter(entry) {
            const relativePath = normalizeToPosix(path.relative(basePath, entry.path));

            return !found && matcher.match(relativePath, true);
        ***REMOVED***,

        entryFilter(entry) {
            if (found || entry.dirent.isDirectory()) {
                return false;
            ***REMOVED***

            const relativePath = normalizeToPosix(path.relative(basePath, entry.path));

            if (matcher.match(relativePath)) {
                found = true;
                return true;
            ***REMOVED***

            return false;
        ***REMOVED***
    ***REMOVED***;

    return new Promise(resolve => {

        // using a stream so we can exit early because we just need one match
        const globStream = fswalk.walkStream(basePath, fsWalkSettings);

        globStream.on("data", () => {
            globStream.destroy();
            resolve(true);
        ***REMOVED***);

        // swallow errors as they're not important here
        globStream.on("error", () => { ***REMOVED***);

        globStream.on("end", () => {
            resolve(false);
        ***REMOVED***);
        globStream.read();
    ***REMOVED***);

***REMOVED***

/**
 * Searches a directory looking for matching glob patterns. This uses
 * the config array's logic to determine if a directory or file should
 * be ignored, so it is consistent with how ignoring works throughout
 * ESLint.
 * @param {Object***REMOVED*** options The options for this function.
 * @param {string***REMOVED*** options.basePath The directory to search.
 * @param {Array<string>***REMOVED*** options.patterns An array of glob patterns
 *      to match.
 * @param {Array<string>***REMOVED*** options.rawPatterns An array of glob patterns
 *      as the user inputted them. Used for errors.
 * @param {FlatConfigArray***REMOVED*** options.configs The config array to use for
 *      determining what to ignore.
 * @param {boolean***REMOVED*** options.errorOnUnmatchedPattern Determines if an error
 *      should be thrown when a pattern is unmatched.
 * @returns {Promise<Array<string>>***REMOVED*** An array of matching file paths
 *      or an empty array if there are no matches.
 * @throws {UnmatchedSearchPatternsError***REMOVED*** If there is a pattern that doesn't
 *      match any files.
 */
async function globSearch({
    basePath,
    patterns,
    rawPatterns,
    configs,
    errorOnUnmatchedPattern
***REMOVED***) {

    if (patterns.length === 0) {
        return [];
    ***REMOVED***

    /*
     * In this section we are converting the patterns into Minimatch
     * instances for performance reasons. Because we are doing the same
     * matches repeatedly, it's best to compile those patterns once and
     * reuse them multiple times.
     *
     * To do that, we convert any patterns with an absolute path into a
     * relative path and normalize it to Posix-style slashes. We also keep
     * track of the relative patterns to map them back to the original
     * patterns, which we need in order to throw an error if there are any
     * unmatched patterns.
     */
    const relativeToPatterns = new Map();
    const matchers = patterns.map((pattern, i) => {
        const patternToUse = path.isAbsolute(pattern)
            ? normalizeToPosix(path.relative(basePath, pattern))
            : pattern;

        relativeToPatterns.set(patternToUse, patterns[i]);

        return new Minimatch(patternToUse, MINIMATCH_OPTIONS);
    ***REMOVED***);

    /*
     * We track unmatched patterns because we may want to throw an error when
     * they occur. To start, this set is initialized with all of the patterns.
     * Every time a match occurs, the pattern is removed from the set, making
     * it easy to tell if we have any unmatched patterns left at the end of
     * search.
     */
    const unmatchedPatterns = new Set([...relativeToPatterns.keys()]);

    const filePaths = (await new Promise((resolve, reject) => {

        let promiseRejected = false;

        /**
         * Wraps a boolean-returning filter function. The wrapped function will reject the promise if an error occurs.
         * @param {Function***REMOVED*** filter A filter function to wrap.
         * @returns {Function***REMOVED*** A function similar to the wrapped filter that rejects the promise if an error occurs.
         */
        function wrapFilter(filter) {
            return (...args) => {

                // No need to run the filter if an error has been thrown.
                if (!promiseRejected) {
                    try {
                        return filter(...args);
                    ***REMOVED*** catch (error) {
                        promiseRejected = true;
                        reject(error);
                    ***REMOVED***
                ***REMOVED***
                return false;
            ***REMOVED***;
        ***REMOVED***

        fswalk.walk(
            basePath,
            {
                deepFilter: wrapFilter(entry => {
                    const relativePath = normalizeToPosix(path.relative(basePath, entry.path));
                    const matchesPattern = matchers.some(matcher => matcher.match(relativePath, true));

                    return matchesPattern && !configs.isDirectoryIgnored(entry.path);
                ***REMOVED***),
                entryFilter: wrapFilter(entry => {
                    const relativePath = normalizeToPosix(path.relative(basePath, entry.path));

                    // entries may be directories or files so filter out directories
                    if (entry.dirent.isDirectory()) {
                        return false;
                    ***REMOVED***

                    /*
                     * Optimization: We need to track when patterns are left unmatched
                     * and so we use `unmatchedPatterns` to do that. There is a bit of
                     * complexity here because the same file can be matched by more than
                     * one pattern. So, when we start, we actually need to test every
                     * pattern against every file. Once we know there are no remaining
                     * unmatched patterns, then we can switch to just looking for the
                     * first matching pattern for improved speed.
                     */
                    const matchesPattern = unmatchedPatterns.size > 0
                        ? matchers.reduce((previousValue, matcher) => {
                            const pathMatches = matcher.match(relativePath);

                            /*
                             * We updated the unmatched patterns set only if the path
                             * matches and the file isn't ignored. If the file is
                             * ignored, that means there wasn't a match for the
                             * pattern so it should not be removed.
                             *
                             * Performance note: isFileIgnored() aggressively caches
                             * results so there is no performance penalty for calling
                             * it twice with the same argument.
                             */
                            if (pathMatches && !configs.isFileIgnored(entry.path)) {
                                unmatchedPatterns.delete(matcher.pattern);
                            ***REMOVED***

                            return pathMatches || previousValue;
                        ***REMOVED***, false)
                        : matchers.some(matcher => matcher.match(relativePath));

                    return matchesPattern && !configs.isFileIgnored(entry.path);
                ***REMOVED***)
            ***REMOVED***,
            (error, entries) => {

                // If the promise is already rejected, calling `resolve` or `reject` will do nothing.
                if (error) {
                    reject(error);
                ***REMOVED*** else {
                    resolve(entries);
                ***REMOVED***
            ***REMOVED***
        );
    ***REMOVED***)).map(entry => entry.path);

    // now check to see if we have any unmatched patterns
    if (errorOnUnmatchedPattern && unmatchedPatterns.size > 0) {
        throw new UnmatchedSearchPatternsError({
            basePath,
            unmatchedPatterns: [...unmatchedPatterns].map(
                pattern => relativeToPatterns.get(pattern)
            ),
            patterns,
            rawPatterns
        ***REMOVED***);
    ***REMOVED***

    return filePaths;
***REMOVED***

/**
 * Throws an error for unmatched patterns. The error will only contain information about the first one.
 * Checks to see if there are any ignored results for a given search.
 * @param {Object***REMOVED*** options The options for this function.
 * @param {string***REMOVED*** options.basePath The directory to search.
 * @param {Array<string>***REMOVED*** options.patterns An array of glob patterns
 *      that were used in the original search.
 * @param {Array<string>***REMOVED*** options.rawPatterns An array of glob patterns
 *      as the user inputted them. Used for errors.
 * @param {Array<string>***REMOVED*** options.unmatchedPatterns A non-empty array of glob patterns
 *      that were unmatched in the original search.
 * @returns {void***REMOVED*** Always throws an error.
 * @throws {NoFilesFoundError***REMOVED*** If the first unmatched pattern
 *      doesn't match any files even when there are no ignores.
 * @throws {AllFilesIgnoredError***REMOVED*** If the first unmatched pattern
 *      matches some files when there are no ignores.
 */
async function throwErrorForUnmatchedPatterns({
    basePath,
    patterns,
    rawPatterns,
    unmatchedPatterns
***REMOVED***) {

    const pattern = unmatchedPatterns[0];
    const rawPattern = rawPatterns[patterns.indexOf(pattern)];

    const patternHasMatch = await globMatch({
        basePath,
        pattern
    ***REMOVED***);

    if (patternHasMatch) {
        throw new AllFilesIgnoredError(rawPattern);
    ***REMOVED***

    // if we get here there are truly no matches
    throw new NoFilesFoundError(rawPattern, true);
***REMOVED***

/**
 * Performs multiple glob searches in parallel.
 * @param {Object***REMOVED*** options The options for this function.
 * @param {Map<string,GlobSearch>***REMOVED*** options.searches
 *      An array of glob patterns to match.
 * @param {FlatConfigArray***REMOVED*** options.configs The config array to use for
 *      determining what to ignore.
 * @param {boolean***REMOVED*** options.errorOnUnmatchedPattern Determines if an
 *      unmatched glob pattern should throw an error.
 * @returns {Promise<Array<string>>***REMOVED*** An array of matching file paths
 *      or an empty array if there are no matches.
 */
async function globMultiSearch({ searches, configs, errorOnUnmatchedPattern ***REMOVED***) {

    /*
     * For convenience, we normalized the search map into an array of objects.
     * Next, we filter out all searches that have no patterns. This happens
     * primarily for the cwd, which is prepopulated in the searches map as an
     * optimization. However, if it has no patterns, it means all patterns
     * occur outside of the cwd and we can safely filter out that search.
     */
    const normalizedSearches = [...searches].map(
        ([basePath, { patterns, rawPatterns ***REMOVED***]) => ({ basePath, patterns, rawPatterns ***REMOVED***)
    ).filter(({ patterns ***REMOVED***) => patterns.length > 0);

    const results = await Promise.allSettled(
        normalizedSearches.map(
            ({ basePath, patterns, rawPatterns ***REMOVED***) => globSearch({
                basePath,
                patterns,
                rawPatterns,
                configs,
                errorOnUnmatchedPattern
            ***REMOVED***)
        )
    );

    const filePaths = [];

    for (let i = 0; i < results.length; i++) {

        const result = results[i];
        const currentSearch = normalizedSearches[i];

        if (result.status === "fulfilled") {

            // if the search was successful just add the results
            if (result.value.length > 0) {
                filePaths.push(...result.value);
            ***REMOVED***

            continue;
        ***REMOVED***

        // if we make it here then there was an error
        const error = result.reason;

        // unexpected errors should be re-thrown
        if (!error.basePath) {
            throw error;
        ***REMOVED***

        if (errorOnUnmatchedPattern) {

            await throwErrorForUnmatchedPatterns({
                ...currentSearch,
                unmatchedPatterns: error.unmatchedPatterns
            ***REMOVED***);

        ***REMOVED***

    ***REMOVED***

    return filePaths;

***REMOVED***

/**
 * Finds all files matching the options specified.
 * @param {Object***REMOVED*** args The arguments objects.
 * @param {Array<string>***REMOVED*** args.patterns An array of glob patterns.
 * @param {boolean***REMOVED*** args.globInputPaths true to interpret glob patterns,
 *      false to not interpret glob patterns.
 * @param {string***REMOVED*** args.cwd The current working directory to find from.
 * @param {FlatConfigArray***REMOVED*** args.configs The configs for the current run.
 * @param {boolean***REMOVED*** args.errorOnUnmatchedPattern Determines if an unmatched pattern
 *      should throw an error.
 * @returns {Promise<Array<string>>***REMOVED*** The fully resolved file paths.
 * @throws {AllFilesIgnoredError***REMOVED*** If there are no results due to an ignore pattern.
 * @throws {NoFilesFoundError***REMOVED*** If no files matched the given patterns.
 */
async function findFiles({
    patterns,
    globInputPaths,
    cwd,
    configs,
    errorOnUnmatchedPattern
***REMOVED***) {

    const results = [];
    const missingPatterns = [];
    let globbyPatterns = [];
    let rawPatterns = [];
    const searches = new Map([[cwd, { patterns: globbyPatterns, rawPatterns: [] ***REMOVED***]]);

    // check to see if we have explicit files and directories
    const filePaths = patterns.map(filePath => path.resolve(cwd, filePath));
    const stats = await Promise.all(
        filePaths.map(
            filePath => fsp.stat(filePath).catch(() => { ***REMOVED***)
        )
    );

    stats.forEach((stat, index) => {

        const filePath = filePaths[index];
        const pattern = normalizeToPosix(patterns[index]);

        if (stat) {

            // files are added directly to the list
            if (stat.isFile()) {
                results.push(filePath);
            ***REMOVED***

            // directories need extensions attached
            if (stat.isDirectory()) {

                // group everything in cwd together and split out others
                if (isPathInside(filePath, cwd)) {
                    ({ patterns: globbyPatterns, rawPatterns ***REMOVED*** = searches.get(cwd));
                ***REMOVED*** else {
                    if (!searches.has(filePath)) {
                        searches.set(filePath, { patterns: [], rawPatterns: [] ***REMOVED***);
                    ***REMOVED***
                    ({ patterns: globbyPatterns, rawPatterns ***REMOVED*** = searches.get(filePath));
                ***REMOVED***

                globbyPatterns.push(`${normalizeToPosix(filePath)***REMOVED***/**`);
                rawPatterns.push(pattern);
            ***REMOVED***

            return;
        ***REMOVED***

        // save patterns for later use based on whether globs are enabled
        if (globInputPaths && isGlobPattern(pattern)) {

            const basePath = path.resolve(cwd, globParent(pattern));

            // group in cwd if possible and split out others
            if (isPathInside(basePath, cwd)) {
                ({ patterns: globbyPatterns, rawPatterns ***REMOVED*** = searches.get(cwd));
            ***REMOVED*** else {
                if (!searches.has(basePath)) {
                    searches.set(basePath, { patterns: [], rawPatterns: [] ***REMOVED***);
                ***REMOVED***
                ({ patterns: globbyPatterns, rawPatterns ***REMOVED*** = searches.get(basePath));
            ***REMOVED***

            globbyPatterns.push(filePath);
            rawPatterns.push(pattern);
        ***REMOVED*** else {
            missingPatterns.push(pattern);
        ***REMOVED***
    ***REMOVED***);

    // there were patterns that didn't match anything, tell the user
    if (errorOnUnmatchedPattern && missingPatterns.length) {
        throw new NoFilesFoundError(missingPatterns[0], globInputPaths);
    ***REMOVED***

    // now we are safe to do the search
    const globbyResults = await globMultiSearch({
        searches,
        configs,
        errorOnUnmatchedPattern
    ***REMOVED***);

    return [
        ...new Set([
            ...results,
            ...globbyResults.map(filePath => path.resolve(filePath))
        ])
    ];
***REMOVED***

//-----------------------------------------------------------------------------
// Results-related Helpers
//-----------------------------------------------------------------------------

/**
 * Checks if the given message is an error message.
 * @param {LintMessage***REMOVED*** message The message to check.
 * @returns {boolean***REMOVED*** Whether or not the message is an error message.
 * @private
 */
function isErrorMessage(message) {
    return message.severity === 2;
***REMOVED***

/**
 * Returns result with warning by ignore settings
 * @param {string***REMOVED*** filePath File path of checked code
 * @param {string***REMOVED*** baseDir Absolute path of base directory
 * @returns {LintResult***REMOVED*** Result with single warning
 * @private
 */
function createIgnoreResult(filePath, baseDir) {
    let message;
    const isInNodeModules = baseDir && path.dirname(path.relative(baseDir, filePath)).split(path.sep).includes("node_modules");

    if (isInNodeModules) {
        message = "File ignored by default because it is located under the node_modules directory. Use ignore pattern \"!**/node_modules/\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
    ***REMOVED*** else {
        message = "File ignored because of a matching ignore pattern. Use \"--no-ignore\" to disable file ignore settings or use \"--no-warn-ignored\" to suppress this warning.";
    ***REMOVED***

    return {
        filePath: path.resolve(filePath),
        messages: [
            {
                ruleId: null,
                fatal: false,
                severity: 1,
                message,
                nodeType: null
            ***REMOVED***
        ],
        suppressedMessages: [],
        errorCount: 0,
        warningCount: 1,
        fatalErrorCount: 0,
        fixableErrorCount: 0,
        fixableWarningCount: 0
    ***REMOVED***;
***REMOVED***

//-----------------------------------------------------------------------------
// Options-related Helpers
//-----------------------------------------------------------------------------


/**
 * Check if a given value is a valid fix type or not.
 * @param {any***REMOVED*** x The value to check.
 * @returns {boolean***REMOVED*** `true` if `x` is valid fix type.
 */
function isFixType(x) {
    return x === "directive" || x === "problem" || x === "suggestion" || x === "layout";
***REMOVED***

/**
 * Check if a given value is an array of fix types or not.
 * @param {any***REMOVED*** x The value to check.
 * @returns {boolean***REMOVED*** `true` if `x` is an array of fix types.
 */
function isFixTypeArray(x) {
    return Array.isArray(x) && x.every(isFixType);
***REMOVED***

/**
 * The error for invalid options.
 */
class ESLintInvalidOptionsError extends Error {
    constructor(messages) {
        super(`Invalid Options:\n- ${messages.join("\n- ")***REMOVED***`);
        this.code = "ESLINT_INVALID_OPTIONS";
        Error.captureStackTrace(this, ESLintInvalidOptionsError);
    ***REMOVED***
***REMOVED***

/**
 * Validates and normalizes options for the wrapped CLIEngine instance.
 * @param {FlatESLintOptions***REMOVED*** options The options to process.
 * @throws {ESLintInvalidOptionsError***REMOVED*** If of any of a variety of type errors.
 * @returns {FlatESLintOptions***REMOVED*** The normalized options.
 */
function processOptions({
    allowInlineConfig = true, // ← we cannot use `overrideConfig.noInlineConfig` instead because `allowInlineConfig` has side-effect that suppress warnings that show inline configs are ignored.
    baseConfig = null,
    cache = false,
    cacheLocation = ".eslintcache",
    cacheStrategy = "metadata",
    cwd = process.cwd(),
    errorOnUnmatchedPattern = true,
    fix = false,
    fixTypes = null, // ← should be null by default because if it's an array then it suppresses rules that don't have the `meta.type` property.
    globInputPaths = true,
    ignore = true,
    ignorePatterns = null,
    overrideConfig = null,
    overrideConfigFile = null,
    plugins = {***REMOVED***,
    warnIgnored = true,
    ...unknownOptions
***REMOVED***) {
    const errors = [];
    const unknownOptionKeys = Object.keys(unknownOptions);

    if (unknownOptionKeys.length >= 1) {
        errors.push(`Unknown options: ${unknownOptionKeys.join(", ")***REMOVED***`);
        if (unknownOptionKeys.includes("cacheFile")) {
            errors.push("'cacheFile' has been removed. Please use the 'cacheLocation' option instead.");
        ***REMOVED***
        if (unknownOptionKeys.includes("configFile")) {
            errors.push("'configFile' has been removed. Please use the 'overrideConfigFile' option instead.");
        ***REMOVED***
        if (unknownOptionKeys.includes("envs")) {
            errors.push("'envs' has been removed.");
        ***REMOVED***
        if (unknownOptionKeys.includes("extensions")) {
            errors.push("'extensions' has been removed.");
        ***REMOVED***
        if (unknownOptionKeys.includes("resolvePluginsRelativeTo")) {
            errors.push("'resolvePluginsRelativeTo' has been removed.");
        ***REMOVED***
        if (unknownOptionKeys.includes("globals")) {
            errors.push("'globals' has been removed. Please use the 'overrideConfig.languageOptions.globals' option instead.");
        ***REMOVED***
        if (unknownOptionKeys.includes("ignorePath")) {
            errors.push("'ignorePath' has been removed.");
        ***REMOVED***
        if (unknownOptionKeys.includes("ignorePattern")) {
            errors.push("'ignorePattern' has been removed. Please use the 'overrideConfig.ignorePatterns' option instead.");
        ***REMOVED***
        if (unknownOptionKeys.includes("parser")) {
            errors.push("'parser' has been removed. Please use the 'overrideConfig.languageOptions.parser' option instead.");
        ***REMOVED***
        if (unknownOptionKeys.includes("parserOptions")) {
            errors.push("'parserOptions' has been removed. Please use the 'overrideConfig.languageOptions.parserOptions' option instead.");
        ***REMOVED***
        if (unknownOptionKeys.includes("rules")) {
            errors.push("'rules' has been removed. Please use the 'overrideConfig.rules' option instead.");
        ***REMOVED***
        if (unknownOptionKeys.includes("rulePaths")) {
            errors.push("'rulePaths' has been removed. Please define your rules using plugins.");
        ***REMOVED***
        if (unknownOptionKeys.includes("reportUnusedDisableDirectives")) {
            errors.push("'reportUnusedDisableDirectives' has been removed. Please use the 'overrideConfig.linterOptions.reportUnusedDisableDirectives' option instead.");
        ***REMOVED***
    ***REMOVED***
    if (typeof allowInlineConfig !== "boolean") {
        errors.push("'allowInlineConfig' must be a boolean.");
    ***REMOVED***
    if (typeof baseConfig !== "object") {
        errors.push("'baseConfig' must be an object or null.");
    ***REMOVED***
    if (typeof cache !== "boolean") {
        errors.push("'cache' must be a boolean.");
    ***REMOVED***
    if (!isNonEmptyString(cacheLocation)) {
        errors.push("'cacheLocation' must be a non-empty string.");
    ***REMOVED***
    if (
        cacheStrategy !== "metadata" &&
        cacheStrategy !== "content"
    ) {
        errors.push("'cacheStrategy' must be any of \"metadata\", \"content\".");
    ***REMOVED***
    if (!isNonEmptyString(cwd) || !path.isAbsolute(cwd)) {
        errors.push("'cwd' must be an absolute path.");
    ***REMOVED***
    if (typeof errorOnUnmatchedPattern !== "boolean") {
        errors.push("'errorOnUnmatchedPattern' must be a boolean.");
    ***REMOVED***
    if (typeof fix !== "boolean" && typeof fix !== "function") {
        errors.push("'fix' must be a boolean or a function.");
    ***REMOVED***
    if (fixTypes !== null && !isFixTypeArray(fixTypes)) {
        errors.push("'fixTypes' must be an array of any of \"directive\", \"problem\", \"suggestion\", and \"layout\".");
    ***REMOVED***
    if (typeof globInputPaths !== "boolean") {
        errors.push("'globInputPaths' must be a boolean.");
    ***REMOVED***
    if (typeof ignore !== "boolean") {
        errors.push("'ignore' must be a boolean.");
    ***REMOVED***
    if (!isArrayOfNonEmptyString(ignorePatterns) && ignorePatterns !== null) {
        errors.push("'ignorePatterns' must be an array of non-empty strings or null.");
    ***REMOVED***
    if (typeof overrideConfig !== "object") {
        errors.push("'overrideConfig' must be an object or null.");
    ***REMOVED***
    if (!isNonEmptyString(overrideConfigFile) && overrideConfigFile !== null && overrideConfigFile !== true) {
        errors.push("'overrideConfigFile' must be a non-empty string, null, or true.");
    ***REMOVED***
    if (typeof plugins !== "object") {
        errors.push("'plugins' must be an object or null.");
    ***REMOVED*** else if (plugins !== null && Object.keys(plugins).includes("")) {
        errors.push("'plugins' must not include an empty string.");
    ***REMOVED***
    if (Array.isArray(plugins)) {
        errors.push("'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.");
    ***REMOVED***
    if (typeof warnIgnored !== "boolean") {
        errors.push("'warnIgnored' must be a boolean.");
    ***REMOVED***
    if (errors.length > 0) {
        throw new ESLintInvalidOptionsError(errors);
    ***REMOVED***

    return {
        allowInlineConfig,
        baseConfig,
        cache,
        cacheLocation,
        cacheStrategy,

        // when overrideConfigFile is true that means don't do config file lookup
        configFile: overrideConfigFile === true ? false : overrideConfigFile,
        overrideConfig,
        cwd: path.normalize(cwd),
        errorOnUnmatchedPattern,
        fix,
        fixTypes,
        globInputPaths,
        ignore,
        ignorePatterns,
        warnIgnored
    ***REMOVED***;
***REMOVED***


//-----------------------------------------------------------------------------
// Cache-related helpers
//-----------------------------------------------------------------------------

/**
 * return the cacheFile to be used by eslint, based on whether the provided parameter is
 * a directory or looks like a directory (ends in `path.sep`), in which case the file
 * name will be the `cacheFile/.cache_hashOfCWD`
 *
 * if cacheFile points to a file or looks like a file then in will just use that file
 * @param {string***REMOVED*** cacheFile The name of file to be used to store the cache
 * @param {string***REMOVED*** cwd Current working directory
 * @returns {string***REMOVED*** the resolved path to the cache file
 */
function getCacheFile(cacheFile, cwd) {

    /*
     * make sure the path separators are normalized for the environment/os
     * keeping the trailing path separator if present
     */
    const normalizedCacheFile = path.normalize(cacheFile);

    const resolvedCacheFile = path.resolve(cwd, normalizedCacheFile);
    const looksLikeADirectory = normalizedCacheFile.slice(-1) === path.sep;

    /**
     * return the name for the cache file in case the provided parameter is a directory
     * @returns {string***REMOVED*** the resolved path to the cacheFile
     */
    function getCacheFileForDirectory() {
        return path.join(resolvedCacheFile, `.cache_${hash(cwd)***REMOVED***`);
    ***REMOVED***

    let fileStats;

    try {
        fileStats = fs.lstatSync(resolvedCacheFile);
    ***REMOVED*** catch {
        fileStats = null;
    ***REMOVED***


    /*
     * in case the file exists we need to verify if the provided path
     * is a directory or a file. If it is a directory we want to create a file
     * inside that directory
     */
    if (fileStats) {

        /*
         * is a directory or is a file, but the original file the user provided
         * looks like a directory but `path.resolve` removed the `last path.sep`
         * so we need to still treat this like a directory
         */
        if (fileStats.isDirectory() || looksLikeADirectory) {
            return getCacheFileForDirectory();
        ***REMOVED***

        // is file so just use that file
        return resolvedCacheFile;
    ***REMOVED***

    /*
     * here we known the file or directory doesn't exist,
     * so we will try to infer if its a directory if it looks like a directory
     * for the current operating system.
     */

    // if the last character passed is a path separator we assume is a directory
    if (looksLikeADirectory) {
        return getCacheFileForDirectory();
    ***REMOVED***

    return resolvedCacheFile;
***REMOVED***


//-----------------------------------------------------------------------------
// Exports
//-----------------------------------------------------------------------------

module.exports = {
    isGlobPattern,
    findFiles,

    isNonEmptyString,
    isArrayOfNonEmptyString,

    createIgnoreResult,
    isErrorMessage,

    processOptions,

    getCacheFile
***REMOVED***;
