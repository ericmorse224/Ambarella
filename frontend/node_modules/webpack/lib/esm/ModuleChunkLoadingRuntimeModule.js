/*
	MIT License http://www.opensource.org/licenses/mit-license.php
*/

"use strict";

const { SyncWaterfallHook ***REMOVED*** = require("tapable");
const Compilation = require("../Compilation");
const RuntimeGlobals = require("../RuntimeGlobals");
const RuntimeModule = require("../RuntimeModule");
const Template = require("../Template");
const {
	getChunkFilenameTemplate,
	chunkHasJs
***REMOVED*** = require("../javascript/JavascriptModulesPlugin");
const { getInitialChunkIds ***REMOVED*** = require("../javascript/StartupHelpers");
const compileBooleanMatcher = require("../util/compileBooleanMatcher");
const { getUndoPath ***REMOVED*** = require("../util/identifier");

/** @typedef {import("../../declarations/WebpackOptions").Environment***REMOVED*** Environment */
/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../Module").ReadOnlyRuntimeRequirements***REMOVED*** ReadOnlyRuntimeRequirements */

/**
 * @typedef {object***REMOVED*** JsonpCompilationPluginHooks
 * @property {SyncWaterfallHook<[string, Chunk]>***REMOVED*** linkPreload
 * @property {SyncWaterfallHook<[string, Chunk]>***REMOVED*** linkPrefetch
 */

/** @type {WeakMap<Compilation, JsonpCompilationPluginHooks>***REMOVED*** */
const compilationHooksMap = new WeakMap();

class ModuleChunkLoadingRuntimeModule extends RuntimeModule {
	/**
	 * @param {Compilation***REMOVED*** compilation the compilation
	 * @returns {JsonpCompilationPluginHooks***REMOVED*** hooks
	 */
	static getCompilationHooks(compilation) {
		if (!(compilation instanceof Compilation)) {
			throw new TypeError(
				"The 'compilation' argument must be an instance of Compilation"
			);
		***REMOVED***
		let hooks = compilationHooksMap.get(compilation);
		if (hooks === undefined) {
			hooks = {
				linkPreload: new SyncWaterfallHook(["source", "chunk"]),
				linkPrefetch: new SyncWaterfallHook(["source", "chunk"])
			***REMOVED***;
			compilationHooksMap.set(compilation, hooks);
		***REMOVED***
		return hooks;
	***REMOVED***

	/**
	 * @param {ReadOnlyRuntimeRequirements***REMOVED*** runtimeRequirements runtime requirements
	 */
	constructor(runtimeRequirements) {
		super("import chunk loading", RuntimeModule.STAGE_ATTACH);
		this._runtimeRequirements = runtimeRequirements;
	***REMOVED***

	/**
	 * @private
	 * @param {Chunk***REMOVED*** chunk chunk
	 * @param {string***REMOVED*** rootOutputDir root output directory
	 * @returns {string***REMOVED*** generated code
	 */
	_generateBaseUri(chunk, rootOutputDir) {
		const options = chunk.getEntryOptions();
		if (options && options.baseUri) {
			return `${RuntimeGlobals.baseURI***REMOVED*** = ${JSON.stringify(options.baseUri)***REMOVED***;`;
		***REMOVED***
		const compilation = /** @type {Compilation***REMOVED*** */ (this.compilation);
		const {
			outputOptions: { importMetaName ***REMOVED***
		***REMOVED*** = compilation;
		return `${RuntimeGlobals.baseURI***REMOVED*** = new URL(${JSON.stringify(
			rootOutputDir
		)***REMOVED***, ${importMetaName***REMOVED***.url);`;
	***REMOVED***

	/**
	 * @returns {string | null***REMOVED*** runtime code
	 */
	generate() {
		const compilation = /** @type {Compilation***REMOVED*** */ (this.compilation);
		const chunkGraph = /** @type {ChunkGraph***REMOVED*** */ (this.chunkGraph);
		const chunk = /** @type {Chunk***REMOVED*** */ (this.chunk);
		const environment =
			/** @type {Environment***REMOVED*** */
			(compilation.outputOptions.environment);
		const {
			runtimeTemplate,
			outputOptions: { importFunctionName, crossOriginLoading, charset ***REMOVED***
		***REMOVED*** = compilation;
		const fn = RuntimeGlobals.ensureChunkHandlers;
		const withBaseURI = this._runtimeRequirements.has(RuntimeGlobals.baseURI);
		const withExternalInstallChunk = this._runtimeRequirements.has(
			RuntimeGlobals.externalInstallChunk
		);
		const withLoading = this._runtimeRequirements.has(
			RuntimeGlobals.ensureChunkHandlers
		);
		const withOnChunkLoad = this._runtimeRequirements.has(
			RuntimeGlobals.onChunksLoaded
		);
		const withHmr = this._runtimeRequirements.has(
			RuntimeGlobals.hmrDownloadUpdateHandlers
		);
		const { linkPreload, linkPrefetch ***REMOVED*** =
			ModuleChunkLoadingRuntimeModule.getCompilationHooks(compilation);
		const isNeutralPlatform = runtimeTemplate.isNeutralPlatform();
		const withPrefetch =
			(environment.document || isNeutralPlatform) &&
			this._runtimeRequirements.has(RuntimeGlobals.prefetchChunkHandlers) &&
			chunk.hasChildByOrder(chunkGraph, "prefetch", true, chunkHasJs);
		const withPreload =
			(environment.document || isNeutralPlatform) &&
			this._runtimeRequirements.has(RuntimeGlobals.preloadChunkHandlers) &&
			chunk.hasChildByOrder(chunkGraph, "preload", true, chunkHasJs);
		const conditionMap = chunkGraph.getChunkConditionMap(chunk, chunkHasJs);
		const hasJsMatcher = compileBooleanMatcher(conditionMap);
		const initialChunkIds = getInitialChunkIds(chunk, chunkGraph, chunkHasJs);

		const outputName = compilation.getPath(
			getChunkFilenameTemplate(chunk, compilation.outputOptions),
			{
				chunk,
				contentHashType: "javascript"
			***REMOVED***
		);
		const rootOutputDir = getUndoPath(
			outputName,
			/** @type {string***REMOVED*** */ (compilation.outputOptions.path),
			true
		);

		const stateExpression = withHmr
			? `${RuntimeGlobals.hmrRuntimeStatePrefix***REMOVED***_module`
			: undefined;

		return Template.asString([
			withBaseURI
				? this._generateBaseUri(chunk, rootOutputDir)
				: "// no baseURI",
			"",
			"// object to store loaded and loading chunks",
			"// undefined = chunk not loaded, null = chunk preloaded/prefetched",
			"// [resolve, Promise] = chunk loading, 0 = chunk loaded",
			`var installedChunks = ${
				stateExpression ? `${stateExpression***REMOVED*** = ${stateExpression***REMOVED*** || ` : ""
			***REMOVED***{`,
			Template.indent(
				Array.from(initialChunkIds, id => `${JSON.stringify(id)***REMOVED***: 0`).join(
					",\n"
				)
			),
			"***REMOVED***;",
			"",
			withLoading || withExternalInstallChunk
				? `var installChunk = ${runtimeTemplate.basicFunction("data", [
						runtimeTemplate.destructureObject(
							["__webpack_ids__", "__webpack_modules__", "__webpack_runtime__"],
							"data"
						),
						'// add "modules" to the modules object,',
						'// then flag all "ids" as loaded and fire callback',
						"var moduleId, chunkId, i = 0;",
						"for(moduleId in __webpack_modules__) {",
						Template.indent([
							`if(${RuntimeGlobals.hasOwnProperty***REMOVED***(__webpack_modules__, moduleId)) {`,
							Template.indent(
								`${RuntimeGlobals.moduleFactories***REMOVED***[moduleId] = __webpack_modules__[moduleId];`
							),
							"***REMOVED***"
						]),
						"***REMOVED***",
						`if(__webpack_runtime__) __webpack_runtime__(${RuntimeGlobals.require***REMOVED***);`,
						"for(;i < __webpack_ids__.length; i++) {",
						Template.indent([
							"chunkId = __webpack_ids__[i];",
							`if(${RuntimeGlobals.hasOwnProperty***REMOVED***(installedChunks, chunkId) && installedChunks[chunkId]) {`,
							Template.indent("installedChunks[chunkId][0]();"),
							"***REMOVED***",
							"installedChunks[__webpack_ids__[i]] = 0;"
						]),
						"***REMOVED***",
						withOnChunkLoad ? `${RuntimeGlobals.onChunksLoaded***REMOVED***();` : ""
					])***REMOVED***`
				: "// no install chunk",
			"",
			withLoading
				? Template.asString([
						`${fn***REMOVED***.j = ${runtimeTemplate.basicFunction(
							"chunkId, promises",
							hasJsMatcher !== false
								? Template.indent([
										"// import() chunk loading for javascript",
										`var installedChunkData = ${RuntimeGlobals.hasOwnProperty***REMOVED***(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;`,
										'if(installedChunkData !== 0) { // 0 means "already installed".',
										Template.indent([
											"",
											'// a Promise means "currently loading".',
											"if(installedChunkData) {",
											Template.indent([
												"promises.push(installedChunkData[1]);"
											]),
											"***REMOVED*** else {",
											Template.indent([
												hasJsMatcher === true
													? "if(true) { // all chunks have JS"
													: `if(${hasJsMatcher("chunkId")***REMOVED***) {`,
												Template.indent([
													"// setup Promise in chunk cache",
													`var promise = ${importFunctionName***REMOVED***(${
														compilation.outputOptions.publicPath === "auto"
															? ""
															: `${RuntimeGlobals.publicPath***REMOVED*** + `
													***REMOVED***${JSON.stringify(rootOutputDir)***REMOVED*** + ${
														RuntimeGlobals.getChunkScriptFilename
													***REMOVED***(chunkId)).then(installChunk, ${runtimeTemplate.basicFunction(
														"e",
														[
															"if(installedChunks[chunkId] !== 0) installedChunks[chunkId] = undefined;",
															"throw e;"
														]
													)***REMOVED***);`,
													`var promise = Promise.race([promise, new Promise(${runtimeTemplate.expressionFunction(
														"installedChunkData = installedChunks[chunkId] = [resolve]",
														"resolve"
													)***REMOVED***)])`,
													"promises.push(installedChunkData[1] = promise);"
												]),
												hasJsMatcher === true
													? "***REMOVED***"
													: "***REMOVED*** else installedChunks[chunkId] = 0;"
											]),
											"***REMOVED***"
										]),
										"***REMOVED***"
									])
								: Template.indent(["installedChunks[chunkId] = 0;"])
						)***REMOVED***;`
					])
				: "// no chunk on demand loading",
			"",
			withPrefetch && hasJsMatcher !== false
				? `${
						RuntimeGlobals.prefetchChunkHandlers
					***REMOVED***.j = ${runtimeTemplate.basicFunction("chunkId", [
						isNeutralPlatform
							? "if (typeof document === 'undefined') return;"
							: "",
						`if((!${
							RuntimeGlobals.hasOwnProperty
						***REMOVED***(installedChunks, chunkId) || installedChunks[chunkId] === undefined) && ${
							hasJsMatcher === true ? "true" : hasJsMatcher("chunkId")
						***REMOVED***) {`,
						Template.indent([
							"installedChunks[chunkId] = null;",
							linkPrefetch.call(
								Template.asString([
									"var link = document.createElement('link');",
									charset ? "link.charset = 'utf-8';" : "",
									crossOriginLoading
										? `link.crossOrigin = ${JSON.stringify(
												crossOriginLoading
											)***REMOVED***;`
										: "",
									`if (${RuntimeGlobals.scriptNonce***REMOVED***) {`,
									Template.indent(
										`link.setAttribute("nonce", ${RuntimeGlobals.scriptNonce***REMOVED***);`
									),
									"***REMOVED***",
									'link.rel = "prefetch";',
									'link.as = "script";',
									`link.href = ${RuntimeGlobals.publicPath***REMOVED*** + ${RuntimeGlobals.getChunkScriptFilename***REMOVED***(chunkId);`
								]),
								chunk
							),
							"document.head.appendChild(link);"
						]),
						"***REMOVED***"
					])***REMOVED***;`
				: "// no prefetching",
			"",
			withPreload && hasJsMatcher !== false
				? `${
						RuntimeGlobals.preloadChunkHandlers
					***REMOVED***.j = ${runtimeTemplate.basicFunction("chunkId", [
						isNeutralPlatform
							? "if (typeof document === 'undefined') return;"
							: "",
						`if((!${
							RuntimeGlobals.hasOwnProperty
						***REMOVED***(installedChunks, chunkId) || installedChunks[chunkId] === undefined) && ${
							hasJsMatcher === true ? "true" : hasJsMatcher("chunkId")
						***REMOVED***) {`,
						Template.indent([
							"installedChunks[chunkId] = null;",
							linkPreload.call(
								Template.asString([
									"var link = document.createElement('link');",
									charset ? "link.charset = 'utf-8';" : "",
									`if (${RuntimeGlobals.scriptNonce***REMOVED***) {`,
									Template.indent(
										`link.setAttribute("nonce", ${RuntimeGlobals.scriptNonce***REMOVED***);`
									),
									"***REMOVED***",
									'link.rel = "modulepreload";',
									`link.href = ${RuntimeGlobals.publicPath***REMOVED*** + ${RuntimeGlobals.getChunkScriptFilename***REMOVED***(chunkId);`,
									crossOriginLoading
										? crossOriginLoading === "use-credentials"
											? 'link.crossOrigin = "use-credentials";'
											: Template.asString([
													"if (link.href.indexOf(window.location.origin + '/') !== 0) {",
													Template.indent(
														`link.crossOrigin = ${JSON.stringify(
															crossOriginLoading
														)***REMOVED***;`
													),
													"***REMOVED***"
												])
										: ""
								]),
								chunk
							),
							"document.head.appendChild(link);"
						]),
						"***REMOVED***"
					])***REMOVED***;`
				: "// no preloaded",
			"",
			withExternalInstallChunk
				? Template.asString([
						`${RuntimeGlobals.externalInstallChunk***REMOVED*** = installChunk;`
					])
				: "// no external install chunk",
			"",
			withOnChunkLoad
				? `${
						RuntimeGlobals.onChunksLoaded
					***REMOVED***.j = ${runtimeTemplate.returningFunction(
						"installedChunks[chunkId] === 0",
						"chunkId"
					)***REMOVED***;`
				: "// no on chunks loaded"
		]);
	***REMOVED***
***REMOVED***

module.exports = ModuleChunkLoadingRuntimeModule;
