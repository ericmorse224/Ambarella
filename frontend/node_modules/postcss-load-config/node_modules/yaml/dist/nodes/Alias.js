'use strict';

var anchors = require('../doc/anchors.js');
var visit = require('../visit.js');
var identity = require('./identity.js');
var Node = require('./Node.js');
var toJS = require('./toJS.js');

class Alias extends Node.NodeBase {
    constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, 'tag', {
            set() {
                throw new Error('Alias nodes cannot have tags');
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */
    resolve(doc) {
        let found = undefined;
        visit.visit(doc, {
            Node: (_key, node) => {
                if (node === this)
                    return visit.visit.BREAK;
                if (node.anchor === this.source)
                    found = node;
            ***REMOVED***
        ***REMOVED***);
        return found;
    ***REMOVED***
    toJSON(_arg, ctx) {
        if (!ctx)
            return { source: this.source ***REMOVED***;
        const { anchors, doc, maxAliasCount ***REMOVED*** = ctx;
        const source = this.resolve(doc);
        if (!source) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source***REMOVED***`;
            throw new ReferenceError(msg);
        ***REMOVED***
        let data = anchors.get(source);
        if (!data) {
            // Resolve anchors for Node.prototype.toJS()
            toJS.toJS(source, null, ctx);
            data = anchors.get(source);
        ***REMOVED***
        /* istanbul ignore if */
        if (!data || data.res === undefined) {
            const msg = 'This should not happen: Alias anchor was not resolved?';
            throw new ReferenceError(msg);
        ***REMOVED***
        if (maxAliasCount >= 0) {
            data.count += 1;
            if (data.aliasCount === 0)
                data.aliasCount = getAliasCount(doc, source, anchors);
            if (data.count * data.aliasCount > maxAliasCount) {
                const msg = 'Excessive alias count indicates a resource exhaustion attack';
                throw new ReferenceError(msg);
            ***REMOVED***
        ***REMOVED***
        return data.res;
    ***REMOVED***
    toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source***REMOVED***`;
        if (ctx) {
            anchors.anchorIsValid(this.source);
            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source***REMOVED***`;
                throw new Error(msg);
            ***REMOVED***
            if (ctx.implicitKey)
                return `${src***REMOVED*** `;
        ***REMOVED***
        return src;
    ***REMOVED***
***REMOVED***
function getAliasCount(doc, node, anchors) {
    if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors && source && anchors.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
    ***REMOVED***
    else if (identity.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
            const c = getAliasCount(doc, item, anchors);
            if (c > count)
                count = c;
        ***REMOVED***
        return count;
    ***REMOVED***
    else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors);
        const vc = getAliasCount(doc, node.value, anchors);
        return Math.max(kc, vc);
    ***REMOVED***
    return 1;
***REMOVED***

exports.Alias = Alias;
