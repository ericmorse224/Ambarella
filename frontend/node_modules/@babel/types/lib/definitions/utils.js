"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.allExpandedTypes = exports.VISITOR_KEYS = exports.NODE_PARENT_VALIDATIONS = exports.NODE_FIELDS = exports.FLIPPED_ALIAS_KEYS = exports.DEPRECATED_KEYS = exports.BUILDER_KEYS = exports.ALIAS_KEYS = void 0;
exports.arrayOf = arrayOf;
exports.arrayOfType = arrayOfType;
exports.assertEach = assertEach;
exports.assertNodeOrValueType = assertNodeOrValueType;
exports.assertNodeType = assertNodeType;
exports.assertOneOf = assertOneOf;
exports.assertOptionalChainStart = assertOptionalChainStart;
exports.assertShape = assertShape;
exports.assertValueType = assertValueType;
exports.chain = chain;
exports.default = defineType;
exports.defineAliasedType = defineAliasedType;
exports.validate = validate;
exports.validateArrayOfType = validateArrayOfType;
exports.validateOptional = validateOptional;
exports.validateOptionalType = validateOptionalType;
exports.validateType = validateType;
var _is = require("../validators/is.js");
var _validate = require("../validators/validate.js");
const VISITOR_KEYS = exports.VISITOR_KEYS = {***REMOVED***;
const ALIAS_KEYS = exports.ALIAS_KEYS = {***REMOVED***;
const FLIPPED_ALIAS_KEYS = exports.FLIPPED_ALIAS_KEYS = {***REMOVED***;
const NODE_FIELDS = exports.NODE_FIELDS = {***REMOVED***;
const BUILDER_KEYS = exports.BUILDER_KEYS = {***REMOVED***;
const DEPRECATED_KEYS = exports.DEPRECATED_KEYS = {***REMOVED***;
const NODE_PARENT_VALIDATIONS = exports.NODE_PARENT_VALIDATIONS = {***REMOVED***;
function getType(val) {
  if (Array.isArray(val)) {
    return "array";
  ***REMOVED*** else if (val === null) {
    return "null";
  ***REMOVED*** else {
    return typeof val;
  ***REMOVED***
***REMOVED***
function validate(validate) {
  return {
    validate
  ***REMOVED***;
***REMOVED***
function validateType(...typeNames) {
  return validate(assertNodeType(...typeNames));
***REMOVED***
function validateOptional(validate) {
  return {
    validate,
    optional: true
  ***REMOVED***;
***REMOVED***
function validateOptionalType(...typeNames) {
  return {
    validate: assertNodeType(...typeNames),
    optional: true
  ***REMOVED***;
***REMOVED***
function arrayOf(elementType) {
  return chain(assertValueType("array"), assertEach(elementType));
***REMOVED***
function arrayOfType(...typeNames) {
  return arrayOf(assertNodeType(...typeNames));
***REMOVED***
function validateArrayOfType(...typeNames) {
  return validate(arrayOfType(...typeNames));
***REMOVED***
function assertEach(callback) {
  const childValidator = process.env.BABEL_TYPES_8_BREAKING ? _validate.validateChild : () => {***REMOVED***;
  function validator(node, key, val) {
    if (!Array.isArray(val)) return;
    let i = 0;
    const subKey = {
      toString() {
        return `${key***REMOVED***[${i***REMOVED***]`;
      ***REMOVED***
    ***REMOVED***;
    for (; i < val.length; i++) {
      const v = val[i];
      callback(node, subKey, v);
      childValidator(node, subKey, v);
    ***REMOVED***
  ***REMOVED***
  validator.each = callback;
  return validator;
***REMOVED***
function assertOneOf(...values) {
  function validate(node, key, val) {
    if (!values.includes(val)) {
      throw new TypeError(`Property ${key***REMOVED*** expected value to be one of ${JSON.stringify(values)***REMOVED*** but got ${JSON.stringify(val)***REMOVED***`);
    ***REMOVED***
  ***REMOVED***
  validate.oneOf = values;
  return validate;
***REMOVED***
const allExpandedTypes = exports.allExpandedTypes = [];
function assertNodeType(...types) {
  const expandedTypes = new Set();
  allExpandedTypes.push({
    types,
    set: expandedTypes
  ***REMOVED***);
  function validate(node, key, val) {
    const valType = val == null ? void 0 : val.type;
    if (valType != null) {
      if (expandedTypes.has(valType)) {
        (0, _validate.validateChild)(node, key, val);
        return;
      ***REMOVED***
      if (valType === "Placeholder") {
        for (const type of types) {
          if ((0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node, key, val);
            return;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    throw new TypeError(`Property ${key***REMOVED*** of ${node.type***REMOVED*** expected node to be of a type ${JSON.stringify(types)***REMOVED*** but instead got ${JSON.stringify(valType)***REMOVED***`);
  ***REMOVED***
  validate.oneOfNodeTypes = types;
  return validate;
***REMOVED***
function assertNodeOrValueType(...types) {
  function validate(node, key, val) {
    const primitiveType = getType(val);
    for (const type of types) {
      if (primitiveType === type || (0, _is.default)(type, val)) {
        (0, _validate.validateChild)(node, key, val);
        return;
      ***REMOVED***
    ***REMOVED***
    throw new TypeError(`Property ${key***REMOVED*** of ${node.type***REMOVED*** expected node to be of a type ${JSON.stringify(types)***REMOVED*** but instead got ${JSON.stringify(val == null ? void 0 : val.type)***REMOVED***`);
  ***REMOVED***
  validate.oneOfNodeOrValueTypes = types;
  return validate;
***REMOVED***
function assertValueType(type) {
  function validate(node, key, val) {
    if (getType(val) === type) {
      return;
    ***REMOVED***
    throw new TypeError(`Property ${key***REMOVED*** expected type of ${type***REMOVED*** but got ${getType(val)***REMOVED***`);
  ***REMOVED***
  validate.type = type;
  return validate;
***REMOVED***
function assertShape(shape) {
  const keys = Object.keys(shape);
  function validate(node, key, val) {
    const errors = [];
    for (const property of keys) {
      try {
        (0, _validate.validateField)(node, property, val[property], shape[property]);
      ***REMOVED*** catch (error) {
        if (error instanceof TypeError) {
          errors.push(error.message);
          continue;
        ***REMOVED***
        throw error;
      ***REMOVED***
    ***REMOVED***
    if (errors.length) {
      throw new TypeError(`Property ${key***REMOVED*** of ${node.type***REMOVED*** expected to have the following:\n${errors.join("\n")***REMOVED***`);
    ***REMOVED***
  ***REMOVED***
  validate.shapeOf = shape;
  return validate;
***REMOVED***
function assertOptionalChainStart() {
  function validate(node) {
    var _current;
    let current = node;
    while (node) {
      const {
        type
      ***REMOVED*** = current;
      if (type === "OptionalCallExpression") {
        if (current.optional) return;
        current = current.callee;
        continue;
      ***REMOVED***
      if (type === "OptionalMemberExpression") {
        if (current.optional) return;
        current = current.object;
        continue;
      ***REMOVED***
      break;
    ***REMOVED***
    throw new TypeError(`Non-optional ${node.type***REMOVED*** must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type***REMOVED***`);
  ***REMOVED***
  return validate;
***REMOVED***
function chain(...fns) {
  function validate(...args) {
    for (const fn of fns) {
      fn(...args);
    ***REMOVED***
  ***REMOVED***
  validate.chainOf = fns;
  if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
    throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
  ***REMOVED***
  return validate;
***REMOVED***
const validTypeOpts = new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]);
const validFieldKeys = new Set(["default", "optional", "deprecated", "validate"]);
const store = {***REMOVED***;
function defineAliasedType(...aliases) {
  return (type, opts = {***REMOVED***) => {
    let defined = opts.aliases;
    if (!defined) {
      var _store$opts$inherits$;
      if (opts.inherits) defined = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
      defined != null ? defined : defined = [];
      opts.aliases = defined;
    ***REMOVED***
    const additional = aliases.filter(a => !defined.includes(a));
    defined.unshift(...additional);
    defineType(type, opts);
  ***REMOVED***;
***REMOVED***
function defineType(type, opts = {***REMOVED***) {
  const inherits = opts.inherits && store[opts.inherits] || {***REMOVED***;
  let fields = opts.fields;
  if (!fields) {
    fields = {***REMOVED***;
    if (inherits.fields) {
      const keys = Object.getOwnPropertyNames(inherits.fields);
      for (const key of keys) {
        const field = inherits.fields[key];
        const def = field.default;
        if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
          throw new Error("field defaults can only be primitives or empty arrays currently");
        ***REMOVED***
        fields[key] = {
          default: Array.isArray(def) ? [] : def,
          optional: field.optional,
          deprecated: field.deprecated,
          validate: field.validate
        ***REMOVED***;
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  const visitor = opts.visitor || inherits.visitor || [];
  const aliases = opts.aliases || inherits.aliases || [];
  const builder = opts.builder || inherits.builder || opts.visitor || [];
  for (const k of Object.keys(opts)) {
    if (!validTypeOpts.has(k)) {
      throw new Error(`Unknown type option "${k***REMOVED***" on ${type***REMOVED***`);
    ***REMOVED***
  ***REMOVED***
  if (opts.deprecatedAlias) {
    DEPRECATED_KEYS[opts.deprecatedAlias] = type;
  ***REMOVED***
  for (const key of visitor.concat(builder)) {
    fields[key] = fields[key] || {***REMOVED***;
  ***REMOVED***
  for (const key of Object.keys(fields)) {
    const field = fields[key];
    if (field.default !== undefined && !builder.includes(key)) {
      field.optional = true;
    ***REMOVED***
    if (field.default === undefined) {
      field.default = null;
    ***REMOVED*** else if (!field.validate && field.default != null) {
      field.validate = assertValueType(getType(field.default));
    ***REMOVED***
    for (const k of Object.keys(field)) {
      if (!validFieldKeys.has(k)) {
        throw new Error(`Unknown field key "${k***REMOVED***" on ${type***REMOVED***.${key***REMOVED***`);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***
  VISITOR_KEYS[type] = opts.visitor = visitor;
  BUILDER_KEYS[type] = opts.builder = builder;
  NODE_FIELDS[type] = opts.fields = fields;
  ALIAS_KEYS[type] = opts.aliases = aliases;
  aliases.forEach(alias => {
    FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
    FLIPPED_ALIAS_KEYS[alias].push(type);
  ***REMOVED***);
  if (opts.validate) {
    NODE_PARENT_VALIDATIONS[type] = opts.validate;
  ***REMOVED***
  store[type] = opts;
***REMOVED***

//# sourceMappingURL=utils.js.map
