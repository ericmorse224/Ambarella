/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

/** @typedef {import("http").IncomingMessage***REMOVED*** IncomingMessage */
/** @typedef {import("http").RequestListener***REMOVED*** RequestListener */
/** @typedef {import("http").ServerOptions***REMOVED*** HttpServerOptions */
/** @typedef {import("http").ServerResponse***REMOVED*** ServerResponse */
/** @typedef {import("https").ServerOptions***REMOVED*** HttpsServerOptions */
/** @typedef {import("net").AddressInfo***REMOVED*** AddressInfo */
/** @typedef {import("net").Server***REMOVED*** Server */
/** @typedef {import("../../declarations/WebpackOptions").LazyCompilationDefaultBackendOptions***REMOVED*** LazyCompilationDefaultBackendOptions */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("./LazyCompilationPlugin").BackendApi***REMOVED*** BackendApi */
/** @typedef {import("./LazyCompilationPlugin").BackendHandler***REMOVED*** BackendHandler */

/**
 * @param {Omit<LazyCompilationDefaultBackendOptions, "client"> & { client: NonNullable<LazyCompilationDefaultBackendOptions["client"]>***REMOVED******REMOVED*** options additional options for the backend
 * @returns {BackendHandler***REMOVED*** backend
 */
module.exports = options => (compiler, callback) => {
	const logger = compiler.getInfrastructureLogger("LazyCompilationBackend");
	const activeModules = new Map();
	const prefix = "/lazy-compilation-using-";

	const isHttps =
		options.protocol === "https" ||
		(typeof options.server === "object" &&
			("key" in options.server || "pfx" in options.server));

	const createServer =
		typeof options.server === "function"
			? options.server
			: (() => {
					const http = isHttps ? require("https") : require("http");
					return http.createServer.bind(
						http,
						/** @type {HttpServerOptions | HttpsServerOptions***REMOVED*** */
						(options.server)
					);
				***REMOVED***)();
	/** @type {(server: Server) => void***REMOVED*** */
	const listen =
		typeof options.listen === "function"
			? options.listen
			: server => {
					let listen = options.listen;
					if (typeof listen === "object" && !("port" in listen))
						listen = { ...listen, port: undefined ***REMOVED***;
					server.listen(listen);
				***REMOVED***;

	const protocol = options.protocol || (isHttps ? "https" : "http");

	/** @type {RequestListener***REMOVED*** */
	const requestListener = (req, res) => {
		if (req.url === undefined) return;
		const keys = req.url.slice(prefix.length).split("@");
		req.socket.on("close", () => {
			setTimeout(() => {
				for (const key of keys) {
					const oldValue = activeModules.get(key) || 0;
					activeModules.set(key, oldValue - 1);
					if (oldValue === 1) {
						logger.log(
							`${key***REMOVED*** is no longer in use. Next compilation will skip this module.`
						);
					***REMOVED***
				***REMOVED***
			***REMOVED***, 120000);
		***REMOVED***);
		req.socket.setNoDelay(true);
		res.writeHead(200, {
			"content-type": "text/event-stream",
			"Access-Control-Allow-Origin": "*",
			"Access-Control-Allow-Methods": "*",
			"Access-Control-Allow-Headers": "*"
		***REMOVED***);
		res.write("\n");
		let moduleActivated = false;
		for (const key of keys) {
			const oldValue = activeModules.get(key) || 0;
			activeModules.set(key, oldValue + 1);
			if (oldValue === 0) {
				logger.log(`${key***REMOVED*** is now in use and will be compiled.`);
				moduleActivated = true;
			***REMOVED***
		***REMOVED***
		if (moduleActivated && compiler.watching) compiler.watching.invalidate();
	***REMOVED***;

	const server = /** @type {Server***REMOVED*** */ (createServer());
	server.on("request", requestListener);

	let isClosing = false;
	/** @type {Set<import("net").Socket>***REMOVED*** */
	const sockets = new Set();
	server.on("connection", socket => {
		sockets.add(socket);
		socket.on("close", () => {
			sockets.delete(socket);
		***REMOVED***);
		if (isClosing) socket.destroy();
	***REMOVED***);
	server.on("clientError", e => {
		if (e.message !== "Server is disposing") logger.warn(e);
	***REMOVED***);

	server.on(
		"listening",
		/**
		 * @param {Error***REMOVED*** err error
		 * @returns {void***REMOVED***
		 */
		err => {
			if (err) return callback(err);
			const _addr = server.address();
			if (typeof _addr === "string")
				throw new Error("addr must not be a string");
			const addr = /** @type {AddressInfo***REMOVED*** */ (_addr);
			const urlBase =
				addr.address === "::" || addr.address === "0.0.0.0"
					? `${protocol***REMOVED***://localhost:${addr.port***REMOVED***`
					: addr.family === "IPv6"
						? `${protocol***REMOVED***://[${addr.address***REMOVED***]:${addr.port***REMOVED***`
						: `${protocol***REMOVED***://${addr.address***REMOVED***:${addr.port***REMOVED***`;
			logger.log(
				`Server-Sent-Events server for lazy compilation open at ${urlBase***REMOVED***.`
			);
			callback(null, {
				dispose(callback) {
					isClosing = true;
					// Removing the listener is a workaround for a memory leak in node.js
					server.off("request", requestListener);
					server.close(err => {
						callback(err);
					***REMOVED***);
					for (const socket of sockets) {
						socket.destroy(new Error("Server is disposing"));
					***REMOVED***
				***REMOVED***,
				module(originalModule) {
					const key = `${encodeURIComponent(
						originalModule.identifier().replace(/\\/g, "/").replace(/@/g, "_")
					).replace(/%(2F|3A|24|26|2B|2C|3B|3D)/g, decodeURIComponent)***REMOVED***`;
					const active = activeModules.get(key) > 0;
					return {
						client: `${options.client***REMOVED***?${encodeURIComponent(urlBase + prefix)***REMOVED***`,
						data: key,
						active
					***REMOVED***;
				***REMOVED***
			***REMOVED***);
		***REMOVED***
	);
	listen(server);
***REMOVED***;
