'use strict';

Object.defineProperty(exports, '__esModule', { value: true ***REMOVED***);

var helperPluginUtils = require('@babel/helper-plugin-utils');
var core = require('@babel/core');
var helperSkipTransparentExpressionWrappers = require('@babel/helper-skip-transparent-expression-wrappers');

function willPathCastToBoolean(path) {
  const maybeWrapped = findOutermostTransparentParent(path);
  const {
    node,
    parentPath
  ***REMOVED*** = maybeWrapped;
  if (parentPath.isLogicalExpression()) {
    const {
      operator,
      right
    ***REMOVED*** = parentPath.node;
    if (operator === "&&" || operator === "||" || operator === "??" && node === right) {
      return willPathCastToBoolean(parentPath);
    ***REMOVED***
  ***REMOVED***
  if (parentPath.isSequenceExpression()) {
    const {
      expressions
    ***REMOVED*** = parentPath.node;
    if (expressions[expressions.length - 1] === node) {
      return willPathCastToBoolean(parentPath);
    ***REMOVED*** else {
      return true;
    ***REMOVED***
  ***REMOVED***
  return parentPath.isConditional({
    test: node
  ***REMOVED***) || parentPath.isUnaryExpression({
    operator: "!"
  ***REMOVED***) || parentPath.isLoop({
    test: node
  ***REMOVED***);
***REMOVED***
function findOutermostTransparentParent(path) {
  let maybeWrapped = path;
  path.findParent(p => {
    if (!helperSkipTransparentExpressionWrappers.isTransparentExprWrapper(p.node)) return true;
    maybeWrapped = p;
  ***REMOVED***);
  return maybeWrapped;
***REMOVED***

const last = arr => arr[arr.length - 1];
function isSimpleMemberExpression(expression) {
  expression = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(expression);
  return core.types.isIdentifier(expression) || core.types.isSuper(expression) || core.types.isMemberExpression(expression) && !expression.computed && isSimpleMemberExpression(expression.object);
***REMOVED***
function needsMemoize(path) {
  let optionalPath = path;
  const {
    scope
  ***REMOVED*** = path;
  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
    const {
      node
    ***REMOVED*** = optionalPath;
    const childPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.isOptionalMemberExpression() ? optionalPath.get("object") : optionalPath.get("callee"));
    if (node.optional) {
      return !scope.isStatic(childPath.node);
    ***REMOVED***
    optionalPath = childPath;
  ***REMOVED***
***REMOVED***
const NULLISH_CHECK = core.template.expression(`%%check%% === null || %%ref%% === void 0`);
const NULLISH_CHECK_NO_DDA = core.template.expression(`%%check%% == null`);
const NULLISH_CHECK_NEG = core.template.expression(`%%check%% !== null && %%ref%% !== void 0`);
const NULLISH_CHECK_NO_DDA_NEG = core.template.expression(`%%check%% != null`);
function transformOptionalChain(path, {
  pureGetters,
  noDocumentAll
***REMOVED***, replacementPath, ifNullish, wrapLast) {
  const {
    scope
  ***REMOVED*** = path;
  if (scope.path.isPattern() && needsMemoize(path)) {
    replacementPath.replaceWith(core.template.expression.ast`(() => ${replacementPath.node***REMOVED***)()`);
    return;
  ***REMOVED***
  const optionals = [];
  let optionalPath = path;
  while (optionalPath.isOptionalMemberExpression() || optionalPath.isOptionalCallExpression()) {
    const {
      node
    ***REMOVED*** = optionalPath;
    if (node.optional) {
      optionals.push(node);
    ***REMOVED***
    if (optionalPath.isOptionalMemberExpression()) {
      optionalPath.node.type = "MemberExpression";
      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("object"));
    ***REMOVED*** else if (optionalPath.isOptionalCallExpression()) {
      optionalPath.node.type = "CallExpression";
      optionalPath = helperSkipTransparentExpressionWrappers.skipTransparentExprWrappers(optionalPath.get("callee"));
    ***REMOVED***
  ***REMOVED***
  if (optionals.length === 0) {
    return;
  ***REMOVED***
  const checks = [];
  let tmpVar;
  for (let i = optionals.length - 1; i >= 0; i--) {
    const node = optionals[i];
    const isCall = core.types.isCallExpression(node);
    const chainWithTypes = isCall ? node.callee : node.object;
    const chain = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(chainWithTypes);
    let ref;
    let check;
    if (isCall && core.types.isIdentifier(chain, {
      name: "eval"
    ***REMOVED***)) {
      check = ref = chain;
      node.callee = core.types.sequenceExpression([core.types.numericLiteral(0), ref]);
    ***REMOVED*** else if (pureGetters && isCall && isSimpleMemberExpression(chain)) {
      check = ref = node.callee;
    ***REMOVED*** else if (scope.isStatic(chain)) {
      check = ref = chainWithTypes;
    ***REMOVED*** else {
      if (!tmpVar || isCall) {
        tmpVar = scope.generateUidIdentifierBasedOnNode(chain);
        scope.push({
          id: core.types.cloneNode(tmpVar)
        ***REMOVED***);
      ***REMOVED***
      ref = tmpVar;
      check = core.types.assignmentExpression("=", core.types.cloneNode(tmpVar), chainWithTypes);
      if (isCall) {
        node.callee = ref;
      ***REMOVED*** else {
        node.object = ref;
      ***REMOVED***
    ***REMOVED***
    if (isCall && core.types.isMemberExpression(chain)) {
      if (pureGetters && isSimpleMemberExpression(chain)) {
        node.callee = chainWithTypes;
      ***REMOVED*** else {
        const {
          object
        ***REMOVED*** = chain;
        let context;
        if (core.types.isSuper(object)) {
          context = core.types.thisExpression();
        ***REMOVED*** else {
          const memoized = scope.maybeGenerateMemoised(object);
          if (memoized) {
            context = memoized;
            chain.object = core.types.assignmentExpression("=", memoized, object);
          ***REMOVED*** else {
            context = object;
          ***REMOVED***
        ***REMOVED***
        node.arguments.unshift(core.types.cloneNode(context));
        node.callee = core.types.memberExpression(node.callee, core.types.identifier("call"));
      ***REMOVED***
    ***REMOVED***
    const data = {
      check: core.types.cloneNode(check),
      ref: core.types.cloneNode(ref)
    ***REMOVED***;
    Object.defineProperty(data, "ref", {
      enumerable: false
    ***REMOVED***);
    checks.push(data);
  ***REMOVED***
  let result = replacementPath.node;
  if (wrapLast) result = wrapLast(result);
  const ifNullishBoolean = core.types.isBooleanLiteral(ifNullish);
  const ifNullishFalse = ifNullishBoolean && ifNullish.value === false;
  const ifNullishVoid = !ifNullishBoolean && core.types.isUnaryExpression(ifNullish, {
    operator: "void"
  ***REMOVED***);
  const isEvaluationValueIgnored = core.types.isExpressionStatement(replacementPath.parent) && !replacementPath.isCompletionRecord() || core.types.isSequenceExpression(replacementPath.parent) && last(replacementPath.parent.expressions) !== replacementPath.node;
  const tpl = ifNullishFalse ? noDocumentAll ? NULLISH_CHECK_NO_DDA_NEG : NULLISH_CHECK_NEG : noDocumentAll ? NULLISH_CHECK_NO_DDA : NULLISH_CHECK;
  const logicalOp = ifNullishFalse ? "&&" : "||";
  const check = checks.map(tpl).reduce((expr, check) => core.types.logicalExpression(logicalOp, expr, check));
  replacementPath.replaceWith(ifNullishBoolean || ifNullishVoid && isEvaluationValueIgnored ? core.types.logicalExpression(logicalOp, check, result) : core.types.conditionalExpression(check, ifNullish, result));
***REMOVED***
function transform(path, assumptions) {
  const {
    scope
  ***REMOVED*** = path;
  const maybeWrapped = findOutermostTransparentParent(path);
  const {
    parentPath
  ***REMOVED*** = maybeWrapped;
  if (parentPath.isUnaryExpression({
    operator: "delete"
  ***REMOVED***)) {
    transformOptionalChain(path, assumptions, parentPath, core.types.booleanLiteral(true));
  ***REMOVED*** else {
    let wrapLast;
    if (parentPath.isCallExpression({
      callee: maybeWrapped.node
    ***REMOVED***) && path.isOptionalMemberExpression()) {
      wrapLast = replacement => {
        const object = helperSkipTransparentExpressionWrappers.skipTransparentExprWrapperNodes(replacement.object);
        let baseRef;
        if (!assumptions.pureGetters || !isSimpleMemberExpression(object)) {
          baseRef = scope.maybeGenerateMemoised(object);
          if (baseRef) {
            replacement.object = core.types.assignmentExpression("=", baseRef, object);
          ***REMOVED***
        ***REMOVED***
        return core.types.callExpression(core.types.memberExpression(replacement, core.types.identifier("bind")), [core.types.cloneNode(baseRef != null ? baseRef : object)]);
      ***REMOVED***;
    ***REMOVED***
    transformOptionalChain(path, assumptions, path, willPathCastToBoolean(maybeWrapped) ? core.types.booleanLiteral(false) : scope.buildUndefinedNode(), wrapLast);
  ***REMOVED***
***REMOVED***

var index = helperPluginUtils.declare((api, options) => {
  var _api$assumption, _api$assumption2;
  api.assertVersion("^7.0.0-0 || >8.0.0-alpha <8.0.0-beta");
  const {
    loose = false
  ***REMOVED*** = options;
  const noDocumentAll = (_api$assumption = api.assumption("noDocumentAll")) != null ? _api$assumption : loose;
  const pureGetters = (_api$assumption2 = api.assumption("pureGetters")) != null ? _api$assumption2 : loose;
  return {
    name: "transform-optional-chaining",
    manipulateOptions: (_, parser) => parser.plugins.push("optionalChaining"),
    visitor: {
      "OptionalCallExpression|OptionalMemberExpression"(path) {
        transform(path, {
          noDocumentAll,
          pureGetters
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***;
***REMOVED***);

exports.default = index;
exports.transform = transform;
exports.transformOptionalChain = transformOptionalChain;
//# sourceMappingURL=index.js.map
