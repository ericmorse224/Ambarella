/**
 * @fileoverview Rule to flag use of constructors without capital letters
 * @author Nicholas C. Zakas
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Helpers
//------------------------------------------------------------------------------

const CAPS_ALLOWED = [
	"Array",
	"Boolean",
	"Date",
	"Error",
	"Function",
	"Number",
	"Object",
	"RegExp",
	"String",
	"Symbol",
	"BigInt",
];

/**
 * A reducer function to invert an array to an Object mapping the string form of the key, to `true`.
 * @param {Object***REMOVED*** map Accumulator object for the reduce.
 * @param {string***REMOVED*** key Object key to set to `true`.
 * @returns {Object***REMOVED*** Returns the updated Object for further reduction.
 */
function invert(map, key) {
	map[key] = true;
	return map;
***REMOVED***

/**
 * Creates an object with the cap is new exceptions as its keys and true as their values.
 * @param {Object***REMOVED*** config Rule configuration
 * @returns {Object***REMOVED*** Object with cap is new exceptions.
 */
function calculateCapIsNewExceptions(config) {
	const capIsNewExceptions = Array.from(
		new Set([...config.capIsNewExceptions, ...CAPS_ALLOWED]),
	);

	return capIsNewExceptions.reduce(invert, {***REMOVED***);
***REMOVED***

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "suggestion",

		docs: {
			description:
				"Require constructor names to begin with a capital letter",
			recommended: false,
			url: "https://eslint.org/docs/latest/rules/new-cap",
		***REMOVED***,

		schema: [
			{
				type: "object",
				properties: {
					newIsCap: {
						type: "boolean",
					***REMOVED***,
					capIsNew: {
						type: "boolean",
					***REMOVED***,
					newIsCapExceptions: {
						type: "array",
						items: {
							type: "string",
						***REMOVED***,
					***REMOVED***,
					newIsCapExceptionPattern: {
						type: "string",
					***REMOVED***,
					capIsNewExceptions: {
						type: "array",
						items: {
							type: "string",
						***REMOVED***,
					***REMOVED***,
					capIsNewExceptionPattern: {
						type: "string",
					***REMOVED***,
					properties: {
						type: "boolean",
					***REMOVED***,
				***REMOVED***,
				additionalProperties: false,
			***REMOVED***,
		],

		defaultOptions: [
			{
				capIsNew: true,
				capIsNewExceptions: CAPS_ALLOWED,
				newIsCap: true,
				newIsCapExceptions: [],
				properties: true,
			***REMOVED***,
		],

		messages: {
			upper: "A function with a name starting with an uppercase letter should only be used as a constructor.",
			lower: "A constructor name should not start with a lowercase letter.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const [config] = context.options;
		const skipProperties = !config.properties;

		const newIsCapExceptions = config.newIsCapExceptions.reduce(invert, {***REMOVED***);
		const newIsCapExceptionPattern = config.newIsCapExceptionPattern
			? new RegExp(config.newIsCapExceptionPattern, "u")
			: null;

		const capIsNewExceptions = calculateCapIsNewExceptions(config);
		const capIsNewExceptionPattern = config.capIsNewExceptionPattern
			? new RegExp(config.capIsNewExceptionPattern, "u")
			: null;

		const listeners = {***REMOVED***;

		const sourceCode = context.sourceCode;

		//--------------------------------------------------------------------------
		// Helpers
		//--------------------------------------------------------------------------

		/**
		 * Get exact callee name from expression
		 * @param {ASTNode***REMOVED*** node CallExpression or NewExpression node
		 * @returns {string***REMOVED*** name
		 */
		function extractNameFromExpression(node) {
			return node.callee.type === "Identifier"
				? node.callee.name
				: astUtils.getStaticPropertyName(node.callee) || "";
		***REMOVED***

		/**
		 * Returns the capitalization state of the string -
		 * Whether the first character is uppercase, lowercase, or non-alphabetic
		 * @param {string***REMOVED*** str String
		 * @returns {string***REMOVED*** capitalization state: "non-alpha", "lower", or "upper"
		 */
		function getCap(str) {
			const firstChar = str.charAt(0);

			const firstCharLower = firstChar.toLowerCase();
			const firstCharUpper = firstChar.toUpperCase();

			if (firstCharLower === firstCharUpper) {
				// char has no uppercase variant, so it's non-alphabetic
				return "non-alpha";
			***REMOVED***
			if (firstChar === firstCharLower) {
				return "lower";
			***REMOVED***
			return "upper";
		***REMOVED***

		/**
		 * Check if capitalization is allowed for a CallExpression
		 * @param {Object***REMOVED*** allowedMap Object mapping calleeName to a Boolean
		 * @param {ASTNode***REMOVED*** node CallExpression node
		 * @param {string***REMOVED*** calleeName Capitalized callee name from a CallExpression
		 * @param {Object***REMOVED*** pattern RegExp object from options pattern
		 * @returns {boolean***REMOVED*** Returns true if the callee may be capitalized
		 */
		function isCapAllowed(allowedMap, node, calleeName, pattern) {
			const sourceText = sourceCode.getText(node.callee);

			if (allowedMap[calleeName] || allowedMap[sourceText]) {
				return true;
			***REMOVED***

			if (pattern && pattern.test(sourceText)) {
				return true;
			***REMOVED***

			const callee = astUtils.skipChainExpression(node.callee);

			if (calleeName === "UTC" && callee.type === "MemberExpression") {
				// allow if callee is Date.UTC
				return (
					callee.object.type === "Identifier" &&
					callee.object.name === "Date"
				);
			***REMOVED***

			return skipProperties && callee.type === "MemberExpression";
		***REMOVED***

		/**
		 * Reports the given messageId for the given node. The location will be the start of the property or the callee.
		 * @param {ASTNode***REMOVED*** node CallExpression or NewExpression node.
		 * @param {string***REMOVED*** messageId The messageId to report.
		 * @returns {void***REMOVED***
		 */
		function report(node, messageId) {
			let callee = astUtils.skipChainExpression(node.callee);

			if (callee.type === "MemberExpression") {
				callee = callee.property;
			***REMOVED***

			context.report({ node, loc: callee.loc, messageId ***REMOVED***);
		***REMOVED***

		//--------------------------------------------------------------------------
		// Public
		//--------------------------------------------------------------------------

		if (config.newIsCap) {
			listeners.NewExpression = function (node) {
				const constructorName = extractNameFromExpression(node);

				if (constructorName) {
					const capitalization = getCap(constructorName);
					const isAllowed =
						capitalization !== "lower" ||
						isCapAllowed(
							newIsCapExceptions,
							node,
							constructorName,
							newIsCapExceptionPattern,
						);

					if (!isAllowed) {
						report(node, "lower");
					***REMOVED***
				***REMOVED***
			***REMOVED***;
		***REMOVED***

		if (config.capIsNew) {
			listeners.CallExpression = function (node) {
				const calleeName = extractNameFromExpression(node);

				if (calleeName) {
					const capitalization = getCap(calleeName);
					const isAllowed =
						capitalization !== "upper" ||
						isCapAllowed(
							capIsNewExceptions,
							node,
							calleeName,
							capIsNewExceptionPattern,
						);

					if (!isAllowed) {
						report(node, "upper");
					***REMOVED***
				***REMOVED***
			***REMOVED***;
		***REMOVED***

		return listeners;
	***REMOVED***,
***REMOVED***;
