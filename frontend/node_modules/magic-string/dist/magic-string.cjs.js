'use strict';

var sourcemapCodec = require('sourcemap-codec');

var BitSet = function BitSet(arg) {
	this.bits = arg instanceof BitSet ? arg.bits.slice() : [];
***REMOVED***;

BitSet.prototype.add = function add (n) {
	this.bits[n >> 5] |= 1 << (n & 31);
***REMOVED***;

BitSet.prototype.has = function has (n) {
	return !!(this.bits[n >> 5] & (1 << (n & 31)));
***REMOVED***;

var Chunk = function Chunk(start, end, content) {
	this.start = start;
	this.end = end;
	this.original = content;

	this.intro = '';
	this.outro = '';

	this.content = content;
	this.storeName = false;
	this.edited = false;

	// we make these non-enumerable, for sanity while debugging
	Object.defineProperties(this, {
		previous: { writable: true, value: null ***REMOVED***,
		next: { writable: true, value: null ***REMOVED***,
	***REMOVED***);
***REMOVED***;

Chunk.prototype.appendLeft = function appendLeft (content) {
	this.outro += content;
***REMOVED***;

Chunk.prototype.appendRight = function appendRight (content) {
	this.intro = this.intro + content;
***REMOVED***;

Chunk.prototype.clone = function clone () {
	var chunk = new Chunk(this.start, this.end, this.original);

	chunk.intro = this.intro;
	chunk.outro = this.outro;
	chunk.content = this.content;
	chunk.storeName = this.storeName;
	chunk.edited = this.edited;

	return chunk;
***REMOVED***;

Chunk.prototype.contains = function contains (index) {
	return this.start < index && index < this.end;
***REMOVED***;

Chunk.prototype.eachNext = function eachNext (fn) {
	var chunk = this;
	while (chunk) {
		fn(chunk);
		chunk = chunk.next;
	***REMOVED***
***REMOVED***;

Chunk.prototype.eachPrevious = function eachPrevious (fn) {
	var chunk = this;
	while (chunk) {
		fn(chunk);
		chunk = chunk.previous;
	***REMOVED***
***REMOVED***;

Chunk.prototype.edit = function edit (content, storeName, contentOnly) {
	this.content = content;
	if (!contentOnly) {
		this.intro = '';
		this.outro = '';
	***REMOVED***
	this.storeName = storeName;

	this.edited = true;

	return this;
***REMOVED***;

Chunk.prototype.prependLeft = function prependLeft (content) {
	this.outro = content + this.outro;
***REMOVED***;

Chunk.prototype.prependRight = function prependRight (content) {
	this.intro = content + this.intro;
***REMOVED***;

Chunk.prototype.split = function split (index) {
	var sliceIndex = index - this.start;

	var originalBefore = this.original.slice(0, sliceIndex);
	var originalAfter = this.original.slice(sliceIndex);

	this.original = originalBefore;

	var newChunk = new Chunk(index, this.end, originalAfter);
	newChunk.outro = this.outro;
	this.outro = '';

	this.end = index;

	if (this.edited) {
		// TODO is this block necessary?...
		newChunk.edit('', false);
		this.content = '';
	***REMOVED*** else {
		this.content = originalBefore;
	***REMOVED***

	newChunk.next = this.next;
	if (newChunk.next) { newChunk.next.previous = newChunk; ***REMOVED***
	newChunk.previous = this;
	this.next = newChunk;

	return newChunk;
***REMOVED***;

Chunk.prototype.toString = function toString () {
	return this.intro + this.content + this.outro;
***REMOVED***;

Chunk.prototype.trimEnd = function trimEnd (rx) {
	this.outro = this.outro.replace(rx, '');
	if (this.outro.length) { return true; ***REMOVED***

	var trimmed = this.content.replace(rx, '');

	if (trimmed.length) {
		if (trimmed !== this.content) {
			this.split(this.start + trimmed.length).edit('', undefined, true);
		***REMOVED***
		return true;
	***REMOVED*** else {
		this.edit('', undefined, true);

		this.intro = this.intro.replace(rx, '');
		if (this.intro.length) { return true; ***REMOVED***
	***REMOVED***
***REMOVED***;

Chunk.prototype.trimStart = function trimStart (rx) {
	this.intro = this.intro.replace(rx, '');
	if (this.intro.length) { return true; ***REMOVED***

	var trimmed = this.content.replace(rx, '');

	if (trimmed.length) {
		if (trimmed !== this.content) {
			this.split(this.end - trimmed.length);
			this.edit('', undefined, true);
		***REMOVED***
		return true;
	***REMOVED*** else {
		this.edit('', undefined, true);

		this.outro = this.outro.replace(rx, '');
		if (this.outro.length) { return true; ***REMOVED***
	***REMOVED***
***REMOVED***;

var btoa = function () {
	throw new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');
***REMOVED***;
if (typeof window !== 'undefined' && typeof window.btoa === 'function') {
	btoa = function (str) { return window.btoa(unescape(encodeURIComponent(str))); ***REMOVED***;
***REMOVED*** else if (typeof Buffer === 'function') {
	btoa = function (str) { return Buffer.from(str, 'utf-8').toString('base64'); ***REMOVED***;
***REMOVED***

var SourceMap = function SourceMap(properties) {
	this.version = 3;
	this.file = properties.file;
	this.sources = properties.sources;
	this.sourcesContent = properties.sourcesContent;
	this.names = properties.names;
	this.mappings = sourcemapCodec.encode(properties.mappings);
***REMOVED***;

SourceMap.prototype.toString = function toString () {
	return JSON.stringify(this);
***REMOVED***;

SourceMap.prototype.toUrl = function toUrl () {
	return 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());
***REMOVED***;

function guessIndent(code) {
	var lines = code.split('\n');

	var tabbed = lines.filter(function (line) { return /^\t+/.test(line); ***REMOVED***);
	var spaced = lines.filter(function (line) { return /^ {2,***REMOVED***/.test(line); ***REMOVED***);

	if (tabbed.length === 0 && spaced.length === 0) {
		return null;
	***REMOVED***

	// More lines tabbed than spaced? Assume tabs, and
	// default to tabs in the case of a tie (or nothing
	// to go on)
	if (tabbed.length >= spaced.length) {
		return '\t';
	***REMOVED***

	// Otherwise, we need to guess the multiple
	var min = spaced.reduce(function (previous, current) {
		var numSpaces = /^ +/.exec(current)[0].length;
		return Math.min(numSpaces, previous);
	***REMOVED***, Infinity);

	return new Array(min + 1).join(' ');
***REMOVED***

function getRelativePath(from, to) {
	var fromParts = from.split(/[/\\]/);
	var toParts = to.split(/[/\\]/);

	fromParts.pop(); // get dirname

	while (fromParts[0] === toParts[0]) {
		fromParts.shift();
		toParts.shift();
	***REMOVED***

	if (fromParts.length) {
		var i = fromParts.length;
		while (i--) { fromParts[i] = '..'; ***REMOVED***
	***REMOVED***

	return fromParts.concat(toParts).join('/');
***REMOVED***

var toString = Object.prototype.toString;

function isObject(thing) {
	return toString.call(thing) === '[object Object]';
***REMOVED***

function getLocator(source) {
	var originalLines = source.split('\n');
	var lineOffsets = [];

	for (var i = 0, pos = 0; i < originalLines.length; i++) {
		lineOffsets.push(pos);
		pos += originalLines[i].length + 1;
	***REMOVED***

	return function locate(index) {
		var i = 0;
		var j = lineOffsets.length;
		while (i < j) {
			var m = (i + j) >> 1;
			if (index < lineOffsets[m]) {
				j = m;
			***REMOVED*** else {
				i = m + 1;
			***REMOVED***
		***REMOVED***
		var line = i - 1;
		var column = index - lineOffsets[line];
		return { line: line, column: column ***REMOVED***;
	***REMOVED***;
***REMOVED***

var Mappings = function Mappings(hires) {
	this.hires = hires;
	this.generatedCodeLine = 0;
	this.generatedCodeColumn = 0;
	this.raw = [];
	this.rawSegments = this.raw[this.generatedCodeLine] = [];
	this.pending = null;
***REMOVED***;

Mappings.prototype.addEdit = function addEdit (sourceIndex, content, loc, nameIndex) {
	if (content.length) {
		var segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];
		if (nameIndex >= 0) {
			segment.push(nameIndex);
		***REMOVED***
		this.rawSegments.push(segment);
	***REMOVED*** else if (this.pending) {
		this.rawSegments.push(this.pending);
	***REMOVED***

	this.advance(content);
	this.pending = null;
***REMOVED***;

Mappings.prototype.addUneditedChunk = function addUneditedChunk (sourceIndex, chunk, original, loc, sourcemapLocations) {
	var originalCharIndex = chunk.start;
	var first = true;

	while (originalCharIndex < chunk.end) {
		if (this.hires || first || sourcemapLocations.has(originalCharIndex)) {
			this.rawSegments.push([this.generatedCodeColumn, sourceIndex, loc.line, loc.column]);
		***REMOVED***

		if (original[originalCharIndex] === '\n') {
			loc.line += 1;
			loc.column = 0;
			this.generatedCodeLine += 1;
			this.raw[this.generatedCodeLine] = this.rawSegments = [];
			this.generatedCodeColumn = 0;
			first = true;
		***REMOVED*** else {
			loc.column += 1;
			this.generatedCodeColumn += 1;
			first = false;
		***REMOVED***

		originalCharIndex += 1;
	***REMOVED***

	this.pending = null;
***REMOVED***;

Mappings.prototype.advance = function advance (str) {
	if (!str) { return; ***REMOVED***

	var lines = str.split('\n');

	if (lines.length > 1) {
		for (var i = 0; i < lines.length - 1; i++) {
			this.generatedCodeLine++;
			this.raw[this.generatedCodeLine] = this.rawSegments = [];
		***REMOVED***
		this.generatedCodeColumn = 0;
	***REMOVED***

	this.generatedCodeColumn += lines[lines.length - 1].length;
***REMOVED***;

var n = '\n';

var warned = {
	insertLeft: false,
	insertRight: false,
	storeName: false,
***REMOVED***;

var MagicString = function MagicString(string, options) {
	if ( options === void 0 ) options = {***REMOVED***;

	var chunk = new Chunk(0, string.length, string);

	Object.defineProperties(this, {
		original: { writable: true, value: string ***REMOVED***,
		outro: { writable: true, value: '' ***REMOVED***,
		intro: { writable: true, value: '' ***REMOVED***,
		firstChunk: { writable: true, value: chunk ***REMOVED***,
		lastChunk: { writable: true, value: chunk ***REMOVED***,
		lastSearchedChunk: { writable: true, value: chunk ***REMOVED***,
		byStart: { writable: true, value: {***REMOVED*** ***REMOVED***,
		byEnd: { writable: true, value: {***REMOVED*** ***REMOVED***,
		filename: { writable: true, value: options.filename ***REMOVED***,
		indentExclusionRanges: { writable: true, value: options.indentExclusionRanges ***REMOVED***,
		sourcemapLocations: { writable: true, value: new BitSet() ***REMOVED***,
		storedNames: { writable: true, value: {***REMOVED*** ***REMOVED***,
		indentStr: { writable: true, value: guessIndent(string) ***REMOVED***,
	***REMOVED***);

	this.byStart[0] = chunk;
	this.byEnd[string.length] = chunk;
***REMOVED***;

MagicString.prototype.addSourcemapLocation = function addSourcemapLocation (char) {
	this.sourcemapLocations.add(char);
***REMOVED***;

MagicString.prototype.append = function append (content) {
	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); ***REMOVED***

	this.outro += content;
	return this;
***REMOVED***;

MagicString.prototype.appendLeft = function appendLeft (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); ***REMOVED***

	this._split(index);

	var chunk = this.byEnd[index];

	if (chunk) {
		chunk.appendLeft(content);
	***REMOVED*** else {
		this.intro += content;
	***REMOVED***
	return this;
***REMOVED***;

MagicString.prototype.appendRight = function appendRight (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); ***REMOVED***

	this._split(index);

	var chunk = this.byStart[index];

	if (chunk) {
		chunk.appendRight(content);
	***REMOVED*** else {
		this.outro += content;
	***REMOVED***
	return this;
***REMOVED***;

MagicString.prototype.clone = function clone () {
	var cloned = new MagicString(this.original, { filename: this.filename ***REMOVED***);

	var originalChunk = this.firstChunk;
	var clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());

	while (originalChunk) {
		cloned.byStart[clonedChunk.start] = clonedChunk;
		cloned.byEnd[clonedChunk.end] = clonedChunk;

		var nextOriginalChunk = originalChunk.next;
		var nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();

		if (nextClonedChunk) {
			clonedChunk.next = nextClonedChunk;
			nextClonedChunk.previous = clonedChunk;

			clonedChunk = nextClonedChunk;
		***REMOVED***

		originalChunk = nextOriginalChunk;
	***REMOVED***

	cloned.lastChunk = clonedChunk;

	if (this.indentExclusionRanges) {
		cloned.indentExclusionRanges = this.indentExclusionRanges.slice();
	***REMOVED***

	cloned.sourcemapLocations = new BitSet(this.sourcemapLocations);

	cloned.intro = this.intro;
	cloned.outro = this.outro;

	return cloned;
***REMOVED***;

MagicString.prototype.generateDecodedMap = function generateDecodedMap (options) {
		var this$1$1 = this;

	options = options || {***REMOVED***;

	var sourceIndex = 0;
	var names = Object.keys(this.storedNames);
	var mappings = new Mappings(options.hires);

	var locate = getLocator(this.original);

	if (this.intro) {
		mappings.advance(this.intro);
	***REMOVED***

	this.firstChunk.eachNext(function (chunk) {
		var loc = locate(chunk.start);

		if (chunk.intro.length) { mappings.advance(chunk.intro); ***REMOVED***

		if (chunk.edited) {
			mappings.addEdit(
				sourceIndex,
				chunk.content,
				loc,
				chunk.storeName ? names.indexOf(chunk.original) : -1
			);
		***REMOVED*** else {
			mappings.addUneditedChunk(sourceIndex, chunk, this$1$1.original, loc, this$1$1.sourcemapLocations);
		***REMOVED***

		if (chunk.outro.length) { mappings.advance(chunk.outro); ***REMOVED***
	***REMOVED***);

	return {
		file: options.file ? options.file.split(/[/\\]/).pop() : null,
		sources: [options.source ? getRelativePath(options.file || '', options.source) : null],
		sourcesContent: options.includeContent ? [this.original] : [null],
		names: names,
		mappings: mappings.raw,
	***REMOVED***;
***REMOVED***;

MagicString.prototype.generateMap = function generateMap (options) {
	return new SourceMap(this.generateDecodedMap(options));
***REMOVED***;

MagicString.prototype.getIndentString = function getIndentString () {
	return this.indentStr === null ? '\t' : this.indentStr;
***REMOVED***;

MagicString.prototype.indent = function indent (indentStr, options) {
	var pattern = /^[^\r\n]/gm;

	if (isObject(indentStr)) {
		options = indentStr;
		indentStr = undefined;
	***REMOVED***

	indentStr = indentStr !== undefined ? indentStr : this.indentStr || '\t';

	if (indentStr === '') { return this; ***REMOVED*** // noop

	options = options || {***REMOVED***;

	// Process exclusion ranges
	var isExcluded = {***REMOVED***;

	if (options.exclude) {
		var exclusions =
			typeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;
		exclusions.forEach(function (exclusion) {
			for (var i = exclusion[0]; i < exclusion[1]; i += 1) {
				isExcluded[i] = true;
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	var shouldIndentNextCharacter = options.indentStart !== false;
	var replacer = function (match) {
		if (shouldIndentNextCharacter) { return ("" + indentStr + match); ***REMOVED***
		shouldIndentNextCharacter = true;
		return match;
	***REMOVED***;

	this.intro = this.intro.replace(pattern, replacer);

	var charIndex = 0;
	var chunk = this.firstChunk;

	while (chunk) {
		var end = chunk.end;

		if (chunk.edited) {
			if (!isExcluded[charIndex]) {
				chunk.content = chunk.content.replace(pattern, replacer);

				if (chunk.content.length) {
					shouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\n';
				***REMOVED***
			***REMOVED***
		***REMOVED*** else {
			charIndex = chunk.start;

			while (charIndex < end) {
				if (!isExcluded[charIndex]) {
					var char = this.original[charIndex];

					if (char === '\n') {
						shouldIndentNextCharacter = true;
					***REMOVED*** else if (char !== '\r' && shouldIndentNextCharacter) {
						shouldIndentNextCharacter = false;

						if (charIndex === chunk.start) {
							chunk.prependRight(indentStr);
						***REMOVED*** else {
							this._splitChunk(chunk, charIndex);
							chunk = chunk.next;
							chunk.prependRight(indentStr);
						***REMOVED***
					***REMOVED***
				***REMOVED***

				charIndex += 1;
			***REMOVED***
		***REMOVED***

		charIndex = chunk.end;
		chunk = chunk.next;
	***REMOVED***

	this.outro = this.outro.replace(pattern, replacer);

	return this;
***REMOVED***;

MagicString.prototype.insert = function insert () {
	throw new Error(
		'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)'
	);
***REMOVED***;

MagicString.prototype.insertLeft = function insertLeft (index, content) {
	if (!warned.insertLeft) {
		console.warn(
			'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead'
		); // eslint-disable-line no-console
		warned.insertLeft = true;
	***REMOVED***

	return this.appendLeft(index, content);
***REMOVED***;

MagicString.prototype.insertRight = function insertRight (index, content) {
	if (!warned.insertRight) {
		console.warn(
			'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead'
		); // eslint-disable-line no-console
		warned.insertRight = true;
	***REMOVED***

	return this.prependRight(index, content);
***REMOVED***;

MagicString.prototype.move = function move (start, end, index) {
	if (index >= start && index <= end) { throw new Error('Cannot move a selection inside itself'); ***REMOVED***

	this._split(start);
	this._split(end);
	this._split(index);

	var first = this.byStart[start];
	var last = this.byEnd[end];

	var oldLeft = first.previous;
	var oldRight = last.next;

	var newRight = this.byStart[index];
	if (!newRight && last === this.lastChunk) { return this; ***REMOVED***
	var newLeft = newRight ? newRight.previous : this.lastChunk;

	if (oldLeft) { oldLeft.next = oldRight; ***REMOVED***
	if (oldRight) { oldRight.previous = oldLeft; ***REMOVED***

	if (newLeft) { newLeft.next = first; ***REMOVED***
	if (newRight) { newRight.previous = last; ***REMOVED***

	if (!first.previous) { this.firstChunk = last.next; ***REMOVED***
	if (!last.next) {
		this.lastChunk = first.previous;
		this.lastChunk.next = null;
	***REMOVED***

	first.previous = newLeft;
	last.next = newRight || null;

	if (!newLeft) { this.firstChunk = first; ***REMOVED***
	if (!newRight) { this.lastChunk = last; ***REMOVED***
	return this;
***REMOVED***;

MagicString.prototype.overwrite = function overwrite (start, end, content, options) {
	if (typeof content !== 'string') { throw new TypeError('replacement content must be a string'); ***REMOVED***

	while (start < 0) { start += this.original.length; ***REMOVED***
	while (end < 0) { end += this.original.length; ***REMOVED***

	if (end > this.original.length) { throw new Error('end is out of bounds'); ***REMOVED***
	if (start === end)
		{ throw new Error(
			'Cannot overwrite a zero-length range – use appendLeft or prependRight instead'
		); ***REMOVED***

	this._split(start);
	this._split(end);

	if (options === true) {
		if (!warned.storeName) {
			console.warn(
				'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string'
			); // eslint-disable-line no-console
			warned.storeName = true;
		***REMOVED***

		options = { storeName: true ***REMOVED***;
	***REMOVED***
	var storeName = options !== undefined ? options.storeName : false;
	var contentOnly = options !== undefined ? options.contentOnly : false;

	if (storeName) {
		var original = this.original.slice(start, end);
		Object.defineProperty(this.storedNames, original, { writable: true, value: true, enumerable: true ***REMOVED***);
	***REMOVED***

	var first = this.byStart[start];
	var last = this.byEnd[end];

	if (first) {
		var chunk = first;
		while (chunk !== last) {
			if (chunk.next !== this.byStart[chunk.end]) {
				throw new Error('Cannot overwrite across a split point');
			***REMOVED***
			chunk = chunk.next;
			chunk.edit('', false);
		***REMOVED***

		first.edit(content, storeName, contentOnly);
	***REMOVED*** else {
		// must be inserting at the end
		var newChunk = new Chunk(start, end, '').edit(content, storeName);

		// TODO last chunk in the array may not be the last chunk, if it's moved...
		last.next = newChunk;
		newChunk.previous = last;
	***REMOVED***
	return this;
***REMOVED***;

MagicString.prototype.prepend = function prepend (content) {
	if (typeof content !== 'string') { throw new TypeError('outro content must be a string'); ***REMOVED***

	this.intro = content + this.intro;
	return this;
***REMOVED***;

MagicString.prototype.prependLeft = function prependLeft (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); ***REMOVED***

	this._split(index);

	var chunk = this.byEnd[index];

	if (chunk) {
		chunk.prependLeft(content);
	***REMOVED*** else {
		this.intro = content + this.intro;
	***REMOVED***
	return this;
***REMOVED***;

MagicString.prototype.prependRight = function prependRight (index, content) {
	if (typeof content !== 'string') { throw new TypeError('inserted content must be a string'); ***REMOVED***

	this._split(index);

	var chunk = this.byStart[index];

	if (chunk) {
		chunk.prependRight(content);
	***REMOVED*** else {
		this.outro = content + this.outro;
	***REMOVED***
	return this;
***REMOVED***;

MagicString.prototype.remove = function remove (start, end) {
	while (start < 0) { start += this.original.length; ***REMOVED***
	while (end < 0) { end += this.original.length; ***REMOVED***

	if (start === end) { return this; ***REMOVED***

	if (start < 0 || end > this.original.length) { throw new Error('Character is out of bounds'); ***REMOVED***
	if (start > end) { throw new Error('end must be greater than start'); ***REMOVED***

	this._split(start);
	this._split(end);

	var chunk = this.byStart[start];

	while (chunk) {
		chunk.intro = '';
		chunk.outro = '';
		chunk.edit('');

		chunk = end > chunk.end ? this.byStart[chunk.end] : null;
	***REMOVED***
	return this;
***REMOVED***;

MagicString.prototype.lastChar = function lastChar () {
	if (this.outro.length) { return this.outro[this.outro.length - 1]; ***REMOVED***
	var chunk = this.lastChunk;
	do {
		if (chunk.outro.length) { return chunk.outro[chunk.outro.length - 1]; ***REMOVED***
		if (chunk.content.length) { return chunk.content[chunk.content.length - 1]; ***REMOVED***
		if (chunk.intro.length) { return chunk.intro[chunk.intro.length - 1]; ***REMOVED***
	***REMOVED*** while ((chunk = chunk.previous));
	if (this.intro.length) { return this.intro[this.intro.length - 1]; ***REMOVED***
	return '';
***REMOVED***;

MagicString.prototype.lastLine = function lastLine () {
	var lineIndex = this.outro.lastIndexOf(n);
	if (lineIndex !== -1) { return this.outro.substr(lineIndex + 1); ***REMOVED***
	var lineStr = this.outro;
	var chunk = this.lastChunk;
	do {
		if (chunk.outro.length > 0) {
			lineIndex = chunk.outro.lastIndexOf(n);
			if (lineIndex !== -1) { return chunk.outro.substr(lineIndex + 1) + lineStr; ***REMOVED***
			lineStr = chunk.outro + lineStr;
		***REMOVED***

		if (chunk.content.length > 0) {
			lineIndex = chunk.content.lastIndexOf(n);
			if (lineIndex !== -1) { return chunk.content.substr(lineIndex + 1) + lineStr; ***REMOVED***
			lineStr = chunk.content + lineStr;
		***REMOVED***

		if (chunk.intro.length > 0) {
			lineIndex = chunk.intro.lastIndexOf(n);
			if (lineIndex !== -1) { return chunk.intro.substr(lineIndex + 1) + lineStr; ***REMOVED***
			lineStr = chunk.intro + lineStr;
		***REMOVED***
	***REMOVED*** while ((chunk = chunk.previous));
	lineIndex = this.intro.lastIndexOf(n);
	if (lineIndex !== -1) { return this.intro.substr(lineIndex + 1) + lineStr; ***REMOVED***
	return this.intro + lineStr;
***REMOVED***;

MagicString.prototype.slice = function slice (start, end) {
		if ( start === void 0 ) start = 0;
		if ( end === void 0 ) end = this.original.length;

	while (start < 0) { start += this.original.length; ***REMOVED***
	while (end < 0) { end += this.original.length; ***REMOVED***

	var result = '';

	// find start chunk
	var chunk = this.firstChunk;
	while (chunk && (chunk.start > start || chunk.end <= start)) {
		// found end chunk before start
		if (chunk.start < end && chunk.end >= end) {
			return result;
		***REMOVED***

		chunk = chunk.next;
	***REMOVED***

	if (chunk && chunk.edited && chunk.start !== start)
		{ throw new Error(("Cannot use replaced character " + start + " as slice start anchor.")); ***REMOVED***

	var startChunk = chunk;
	while (chunk) {
		if (chunk.intro && (startChunk !== chunk || chunk.start === start)) {
			result += chunk.intro;
		***REMOVED***

		var containsEnd = chunk.start < end && chunk.end >= end;
		if (containsEnd && chunk.edited && chunk.end !== end)
			{ throw new Error(("Cannot use replaced character " + end + " as slice end anchor.")); ***REMOVED***

		var sliceStart = startChunk === chunk ? start - chunk.start : 0;
		var sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;

		result += chunk.content.slice(sliceStart, sliceEnd);

		if (chunk.outro && (!containsEnd || chunk.end === end)) {
			result += chunk.outro;
		***REMOVED***

		if (containsEnd) {
			break;
		***REMOVED***

		chunk = chunk.next;
	***REMOVED***

	return result;
***REMOVED***;

// TODO deprecate this? not really very useful
MagicString.prototype.snip = function snip (start, end) {
	var clone = this.clone();
	clone.remove(0, start);
	clone.remove(end, clone.original.length);

	return clone;
***REMOVED***;

MagicString.prototype._split = function _split (index) {
	if (this.byStart[index] || this.byEnd[index]) { return; ***REMOVED***

	var chunk = this.lastSearchedChunk;
	var searchForward = index > chunk.end;

	while (chunk) {
		if (chunk.contains(index)) { return this._splitChunk(chunk, index); ***REMOVED***

		chunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];
	***REMOVED***
***REMOVED***;

MagicString.prototype._splitChunk = function _splitChunk (chunk, index) {
	if (chunk.edited && chunk.content.length) {
		// zero-length edited chunks are a special case (overlapping replacements)
		var loc = getLocator(this.original)(index);
		throw new Error(
			("Cannot split a chunk that has already been edited (" + (loc.line) + ":" + (loc.column) + " – \"" + (chunk.original) + "\")")
		);
	***REMOVED***

	var newChunk = chunk.split(index);

	this.byEnd[index] = chunk;
	this.byStart[index] = newChunk;
	this.byEnd[newChunk.end] = newChunk;

	if (chunk === this.lastChunk) { this.lastChunk = newChunk; ***REMOVED***

	this.lastSearchedChunk = chunk;
	return true;
***REMOVED***;

MagicString.prototype.toString = function toString () {
	var str = this.intro;

	var chunk = this.firstChunk;
	while (chunk) {
		str += chunk.toString();
		chunk = chunk.next;
	***REMOVED***

	return str + this.outro;
***REMOVED***;

MagicString.prototype.isEmpty = function isEmpty () {
	var chunk = this.firstChunk;
	do {
		if (
			(chunk.intro.length && chunk.intro.trim()) ||
			(chunk.content.length && chunk.content.trim()) ||
			(chunk.outro.length && chunk.outro.trim())
		)
			{ return false; ***REMOVED***
	***REMOVED*** while ((chunk = chunk.next));
	return true;
***REMOVED***;

MagicString.prototype.length = function length () {
	var chunk = this.firstChunk;
	var length = 0;
	do {
		length += chunk.intro.length + chunk.content.length + chunk.outro.length;
	***REMOVED*** while ((chunk = chunk.next));
	return length;
***REMOVED***;

MagicString.prototype.trimLines = function trimLines () {
	return this.trim('[\\r\\n]');
***REMOVED***;

MagicString.prototype.trim = function trim (charType) {
	return this.trimStart(charType).trimEnd(charType);
***REMOVED***;

MagicString.prototype.trimEndAborted = function trimEndAborted (charType) {
	var rx = new RegExp((charType || '\\s') + '+$');

	this.outro = this.outro.replace(rx, '');
	if (this.outro.length) { return true; ***REMOVED***

	var chunk = this.lastChunk;

	do {
		var end = chunk.end;
		var aborted = chunk.trimEnd(rx);

		// if chunk was trimmed, we have a new lastChunk
		if (chunk.end !== end) {
			if (this.lastChunk === chunk) {
				this.lastChunk = chunk.next;
			***REMOVED***

			this.byEnd[chunk.end] = chunk;
			this.byStart[chunk.next.start] = chunk.next;
			this.byEnd[chunk.next.end] = chunk.next;
		***REMOVED***

		if (aborted) { return true; ***REMOVED***
		chunk = chunk.previous;
	***REMOVED*** while (chunk);

	return false;
***REMOVED***;

MagicString.prototype.trimEnd = function trimEnd (charType) {
	this.trimEndAborted(charType);
	return this;
***REMOVED***;
MagicString.prototype.trimStartAborted = function trimStartAborted (charType) {
	var rx = new RegExp('^' + (charType || '\\s') + '+');

	this.intro = this.intro.replace(rx, '');
	if (this.intro.length) { return true; ***REMOVED***

	var chunk = this.firstChunk;

	do {
		var end = chunk.end;
		var aborted = chunk.trimStart(rx);

		if (chunk.end !== end) {
			// special case...
			if (chunk === this.lastChunk) { this.lastChunk = chunk.next; ***REMOVED***

			this.byEnd[chunk.end] = chunk;
			this.byStart[chunk.next.start] = chunk.next;
			this.byEnd[chunk.next.end] = chunk.next;
		***REMOVED***

		if (aborted) { return true; ***REMOVED***
		chunk = chunk.next;
	***REMOVED*** while (chunk);

	return false;
***REMOVED***;

MagicString.prototype.trimStart = function trimStart (charType) {
	this.trimStartAborted(charType);
	return this;
***REMOVED***;

var hasOwnProp = Object.prototype.hasOwnProperty;

var Bundle = function Bundle(options) {
	if ( options === void 0 ) options = {***REMOVED***;

	this.intro = options.intro || '';
	this.separator = options.separator !== undefined ? options.separator : '\n';
	this.sources = [];
	this.uniqueSources = [];
	this.uniqueSourceIndexByFilename = {***REMOVED***;
***REMOVED***;

Bundle.prototype.addSource = function addSource (source) {
	if (source instanceof MagicString) {
		return this.addSource({
			content: source,
			filename: source.filename,
			separator: this.separator,
		***REMOVED***);
	***REMOVED***

	if (!isObject(source) || !source.content) {
		throw new Error(
			'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`'
		);
	***REMOVED***

	['filename', 'indentExclusionRanges', 'separator'].forEach(function (option) {
		if (!hasOwnProp.call(source, option)) { source[option] = source.content[option]; ***REMOVED***
	***REMOVED***);

	if (source.separator === undefined) {
		// TODO there's a bunch of this sort of thing, needs cleaning up
		source.separator = this.separator;
	***REMOVED***

	if (source.filename) {
		if (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {
			this.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;
			this.uniqueSources.push({ filename: source.filename, content: source.content.original ***REMOVED***);
		***REMOVED*** else {
			var uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];
			if (source.content.original !== uniqueSource.content) {
				throw new Error(("Illegal source: same filename (" + (source.filename) + "), different contents"));
			***REMOVED***
		***REMOVED***
	***REMOVED***

	this.sources.push(source);
	return this;
***REMOVED***;

Bundle.prototype.append = function append (str, options) {
	this.addSource({
		content: new MagicString(str),
		separator: (options && options.separator) || '',
	***REMOVED***);

	return this;
***REMOVED***;

Bundle.prototype.clone = function clone () {
	var bundle = new Bundle({
		intro: this.intro,
		separator: this.separator,
	***REMOVED***);

	this.sources.forEach(function (source) {
		bundle.addSource({
			filename: source.filename,
			content: source.content.clone(),
			separator: source.separator,
		***REMOVED***);
	***REMOVED***);

	return bundle;
***REMOVED***;

Bundle.prototype.generateDecodedMap = function generateDecodedMap (options) {
		var this$1$1 = this;
		if ( options === void 0 ) options = {***REMOVED***;

	var names = [];
	this.sources.forEach(function (source) {
		Object.keys(source.content.storedNames).forEach(function (name) {
			if (!~names.indexOf(name)) { names.push(name); ***REMOVED***
		***REMOVED***);
	***REMOVED***);

	var mappings = new Mappings(options.hires);

	if (this.intro) {
		mappings.advance(this.intro);
	***REMOVED***

	this.sources.forEach(function (source, i) {
		if (i > 0) {
			mappings.advance(this$1$1.separator);
		***REMOVED***

		var sourceIndex = source.filename ? this$1$1.uniqueSourceIndexByFilename[source.filename] : -1;
		var magicString = source.content;
		var locate = getLocator(magicString.original);

		if (magicString.intro) {
			mappings.advance(magicString.intro);
		***REMOVED***

		magicString.firstChunk.eachNext(function (chunk) {
			var loc = locate(chunk.start);

			if (chunk.intro.length) { mappings.advance(chunk.intro); ***REMOVED***

			if (source.filename) {
				if (chunk.edited) {
					mappings.addEdit(
						sourceIndex,
						chunk.content,
						loc,
						chunk.storeName ? names.indexOf(chunk.original) : -1
					);
				***REMOVED*** else {
					mappings.addUneditedChunk(
						sourceIndex,
						chunk,
						magicString.original,
						loc,
						magicString.sourcemapLocations
					);
				***REMOVED***
			***REMOVED*** else {
				mappings.advance(chunk.content);
			***REMOVED***

			if (chunk.outro.length) { mappings.advance(chunk.outro); ***REMOVED***
		***REMOVED***);

		if (magicString.outro) {
			mappings.advance(magicString.outro);
		***REMOVED***
	***REMOVED***);

	return {
		file: options.file ? options.file.split(/[/\\]/).pop() : null,
		sources: this.uniqueSources.map(function (source) {
			return options.file ? getRelativePath(options.file, source.filename) : source.filename;
		***REMOVED***),
		sourcesContent: this.uniqueSources.map(function (source) {
			return options.includeContent ? source.content : null;
		***REMOVED***),
		names: names,
		mappings: mappings.raw,
	***REMOVED***;
***REMOVED***;

Bundle.prototype.generateMap = function generateMap (options) {
	return new SourceMap(this.generateDecodedMap(options));
***REMOVED***;

Bundle.prototype.getIndentString = function getIndentString () {
	var indentStringCounts = {***REMOVED***;

	this.sources.forEach(function (source) {
		var indentStr = source.content.indentStr;

		if (indentStr === null) { return; ***REMOVED***

		if (!indentStringCounts[indentStr]) { indentStringCounts[indentStr] = 0; ***REMOVED***
		indentStringCounts[indentStr] += 1;
	***REMOVED***);

	return (
		Object.keys(indentStringCounts).sort(function (a, b) {
			return indentStringCounts[a] - indentStringCounts[b];
		***REMOVED***)[0] || '\t'
	);
***REMOVED***;

Bundle.prototype.indent = function indent (indentStr) {
		var this$1$1 = this;

	if (!arguments.length) {
		indentStr = this.getIndentString();
	***REMOVED***

	if (indentStr === '') { return this; ***REMOVED*** // noop

	var trailingNewline = !this.intro || this.intro.slice(-1) === '\n';

	this.sources.forEach(function (source, i) {
		var separator = source.separator !== undefined ? source.separator : this$1$1.separator;
		var indentStart = trailingNewline || (i > 0 && /\r?\n$/.test(separator));

		source.content.indent(indentStr, {
			exclude: source.indentExclusionRanges,
			indentStart: indentStart, //: trailingNewline || /\r?\n$/.test( separator )  //true///\r?\n/.test( separator )
		***REMOVED***);

		trailingNewline = source.content.lastChar() === '\n';
	***REMOVED***);

	if (this.intro) {
		this.intro =
			indentStr +
			this.intro.replace(/^[^\n]/gm, function (match, index) {
				return index > 0 ? indentStr + match : match;
			***REMOVED***);
	***REMOVED***

	return this;
***REMOVED***;

Bundle.prototype.prepend = function prepend (str) {
	this.intro = str + this.intro;
	return this;
***REMOVED***;

Bundle.prototype.toString = function toString () {
		var this$1$1 = this;

	var body = this.sources
		.map(function (source, i) {
			var separator = source.separator !== undefined ? source.separator : this$1$1.separator;
			var str = (i > 0 ? separator : '') + source.content.toString();

			return str;
		***REMOVED***)
		.join('');

	return this.intro + body;
***REMOVED***;

Bundle.prototype.isEmpty = function isEmpty () {
	if (this.intro.length && this.intro.trim()) { return false; ***REMOVED***
	if (this.sources.some(function (source) { return !source.content.isEmpty(); ***REMOVED***)) { return false; ***REMOVED***
	return true;
***REMOVED***;

Bundle.prototype.length = function length () {
	return this.sources.reduce(
		function (length, source) { return length + source.content.length(); ***REMOVED***,
		this.intro.length
	);
***REMOVED***;

Bundle.prototype.trimLines = function trimLines () {
	return this.trim('[\\r\\n]');
***REMOVED***;

Bundle.prototype.trim = function trim (charType) {
	return this.trimStart(charType).trimEnd(charType);
***REMOVED***;

Bundle.prototype.trimStart = function trimStart (charType) {
	var rx = new RegExp('^' + (charType || '\\s') + '+');
	this.intro = this.intro.replace(rx, '');

	if (!this.intro) {
		var source;
		var i = 0;

		do {
			source = this.sources[i++];
			if (!source) {
				break;
			***REMOVED***
		***REMOVED*** while (!source.content.trimStartAborted(charType));
	***REMOVED***

	return this;
***REMOVED***;

Bundle.prototype.trimEnd = function trimEnd (charType) {
	var rx = new RegExp((charType || '\\s') + '+$');

	var source;
	var i = this.sources.length - 1;

	do {
		source = this.sources[i--];
		if (!source) {
			this.intro = this.intro.replace(rx, '');
			break;
		***REMOVED***
	***REMOVED*** while (!source.content.trimEndAborted(charType));

	return this;
***REMOVED***;

MagicString.Bundle = Bundle;
MagicString.SourceMap = SourceMap;
MagicString.default = MagicString; // work around TypeScript bug https://github.com/Rich-Harris/magic-string/pull/121

module.exports = MagicString;
//# sourceMappingURL=magic-string.cjs.js.map
