/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { ConcatSource ***REMOVED*** = require("webpack-sources");
const ExternalModule = require("../ExternalModule");
const Template = require("../Template");
const AbstractLibraryPlugin = require("./AbstractLibraryPlugin");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../../declarations/WebpackOptions").LibraryOptions***REMOVED*** LibraryOptions */
/** @typedef {import("../../declarations/WebpackOptions").LibraryType***REMOVED*** LibraryType */
/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../Compilation").ChunkHashContext***REMOVED*** ChunkHashContext */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../javascript/JavascriptModulesPlugin").RenderContext***REMOVED*** RenderContext */
/** @typedef {import("../util/Hash")***REMOVED*** Hash */
/** @template T @typedef {import("./AbstractLibraryPlugin").LibraryContext<T>***REMOVED*** LibraryContext<T> */

/**
 * @typedef {object***REMOVED*** AmdLibraryPluginOptions
 * @property {LibraryType***REMOVED*** type
 * @property {boolean=***REMOVED*** requireAsWrapper
 */

/**
 * @typedef {object***REMOVED*** AmdLibraryPluginParsed
 * @property {string***REMOVED*** name
 * @property {string***REMOVED*** amdContainer
 */

/**
 * @typedef {AmdLibraryPluginParsed***REMOVED*** T
 * @extends {AbstractLibraryPlugin<AmdLibraryPluginParsed>***REMOVED***
 */
class AmdLibraryPlugin extends AbstractLibraryPlugin {
	/**
	 * @param {AmdLibraryPluginOptions***REMOVED*** options the plugin options
	 */
	constructor(options) {
		super({
			pluginName: "AmdLibraryPlugin",
			type: options.type
		***REMOVED***);
		this.requireAsWrapper = options.requireAsWrapper;
	***REMOVED***

	/**
	 * @param {LibraryOptions***REMOVED*** library normalized library option
	 * @returns {T | false***REMOVED*** preprocess as needed by overriding
	 */
	parseOptions(library) {
		const { name, amdContainer ***REMOVED*** = library;
		if (this.requireAsWrapper) {
			if (name) {
				throw new Error(
					`AMD library name must be unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE***REMOVED***`
				);
			***REMOVED***
		***REMOVED*** else if (name && typeof name !== "string") {
			throw new Error(
				`AMD library name must be a simple string or unset. ${AbstractLibraryPlugin.COMMON_LIBRARY_NAME_MESSAGE***REMOVED***`
			);
		***REMOVED***
		const _name = /** @type {string***REMOVED*** */ (name);
		const _amdContainer = /** @type {string***REMOVED*** */ (amdContainer);
		return { name: _name, amdContainer: _amdContainer ***REMOVED***;
	***REMOVED***

	/**
	 * @param {Source***REMOVED*** source source
	 * @param {RenderContext***REMOVED*** renderContext render context
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {Source***REMOVED*** source with library export
	 */
	render(
		source,
		{ chunkGraph, chunk, runtimeTemplate ***REMOVED***,
		{ options, compilation ***REMOVED***
	) {
		const modern = runtimeTemplate.supportsArrowFunction();
		const modules = chunkGraph
			.getChunkModules(chunk)
			.filter(
				m =>
					m instanceof ExternalModule &&
					(m.externalType === "amd" || m.externalType === "amd-require")
			);
		const externals = /** @type {ExternalModule[]***REMOVED*** */ (modules);
		const externalsDepsArray = JSON.stringify(
			externals.map(m =>
				typeof m.request === "object" && !Array.isArray(m.request)
					? m.request.amd
					: m.request
			)
		);
		const externalsArguments = externals
			.map(
				m =>
					`__WEBPACK_EXTERNAL_MODULE_${Template.toIdentifier(
						`${chunkGraph.getModuleId(m)***REMOVED***`
					)***REMOVED***__`
			)
			.join(", ");

		const iife = runtimeTemplate.isIIFE();
		const fnStart =
			(modern
				? `(${externalsArguments***REMOVED***) => {`
				: `function(${externalsArguments***REMOVED***) {`) +
			(iife || !chunk.hasRuntime() ? " return " : "\n");
		const fnEnd = iife ? ";\n***REMOVED***" : "\n***REMOVED***";

		let amdContainerPrefix = "";
		if (options.amdContainer) {
			amdContainerPrefix = `${options.amdContainer***REMOVED***.`;
		***REMOVED***

		if (this.requireAsWrapper) {
			return new ConcatSource(
				`${amdContainerPrefix***REMOVED***require(${externalsDepsArray***REMOVED***, ${fnStart***REMOVED***`,
				source,
				`${fnEnd***REMOVED***);`
			);
		***REMOVED*** else if (options.name) {
			const name = compilation.getPath(options.name, {
				chunk
			***REMOVED***);

			return new ConcatSource(
				`${amdContainerPrefix***REMOVED***define(${JSON.stringify(
					name
				)***REMOVED***, ${externalsDepsArray***REMOVED***, ${fnStart***REMOVED***`,
				source,
				`${fnEnd***REMOVED***);`
			);
		***REMOVED*** else if (externalsArguments) {
			return new ConcatSource(
				`${amdContainerPrefix***REMOVED***define(${externalsDepsArray***REMOVED***, ${fnStart***REMOVED***`,
				source,
				`${fnEnd***REMOVED***);`
			);
		***REMOVED***
		return new ConcatSource(
			`${amdContainerPrefix***REMOVED***define(${fnStart***REMOVED***`,
			source,
			`${fnEnd***REMOVED***);`
		);
	***REMOVED***

	/**
	 * @param {Chunk***REMOVED*** chunk the chunk
	 * @param {Hash***REMOVED*** hash hash
	 * @param {ChunkHashContext***REMOVED*** chunkHashContext chunk hash context
	 * @param {LibraryContext<T>***REMOVED*** libraryContext context
	 * @returns {void***REMOVED***
	 */
	chunkHash(chunk, hash, chunkHashContext, { options, compilation ***REMOVED***) {
		hash.update("AmdLibraryPlugin");
		if (this.requireAsWrapper) {
			hash.update("requireAsWrapper");
		***REMOVED*** else if (options.name) {
			hash.update("named");
			const name = compilation.getPath(options.name, {
				chunk
			***REMOVED***);
			hash.update(name);
		***REMOVED*** else if (options.amdContainer) {
			hash.update("amdContainer");
			hash.update(options.amdContainer);
		***REMOVED***
	***REMOVED***
***REMOVED***

module.exports = AmdLibraryPlugin;
