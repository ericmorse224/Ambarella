/**
 * @fileoverview Validate strings passed to the RegExp constructor
 * @author Michael Ficarra
 */
"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const RegExpValidator = require("@eslint-community/regexpp").RegExpValidator;
const validator = new RegExpValidator();
const validFlags = "dgimsuvy";
const undefined1 = void 0;

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		type: "problem",

		defaultOptions: [{***REMOVED***],

		docs: {
			description:
				"Disallow invalid regular expression strings in `RegExp` constructors",
			recommended: true,
			url: "https://eslint.org/docs/latest/rules/no-invalid-regexp",
		***REMOVED***,

		schema: [
			{
				type: "object",
				properties: {
					allowConstructorFlags: {
						type: "array",
						items: {
							type: "string",
						***REMOVED***,
					***REMOVED***,
				***REMOVED***,
				additionalProperties: false,
			***REMOVED***,
		],

		messages: {
			regexMessage: "{{message***REMOVED******REMOVED***.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const [{ allowConstructorFlags ***REMOVED***] = context.options;
		let allowedFlags = [];

		if (allowConstructorFlags) {
			const temp = allowConstructorFlags
				.join("")
				.replace(new RegExp(`[${validFlags***REMOVED***]`, "gu"), "");

			if (temp) {
				allowedFlags = [...new Set(temp)];
			***REMOVED***
		***REMOVED***

		/**
		 * Reports error with the provided message.
		 * @param {ASTNode***REMOVED*** node The node holding the invalid RegExp
		 * @param {string***REMOVED*** message The message to report.
		 * @returns {void***REMOVED***
		 */
		function report(node, message) {
			context.report({
				node,
				messageId: "regexMessage",
				data: { message ***REMOVED***,
			***REMOVED***);
		***REMOVED***

		/**
		 * Check if node is a string
		 * @param {ASTNode***REMOVED*** node node to evaluate
		 * @returns {boolean***REMOVED*** True if its a string
		 * @private
		 */
		function isString(node) {
			return (
				node &&
				node.type === "Literal" &&
				typeof node.value === "string"
			);
		***REMOVED***

		/**
		 * Gets flags of a regular expression created by the given `RegExp()` or `new RegExp()` call
		 * Examples:
		 *     new RegExp(".")         // => ""
		 *     new RegExp(".", "gu")   // => "gu"
		 *     new RegExp(".", flags)  // => null
		 * @param {ASTNode***REMOVED*** node `CallExpression` or `NewExpression` node
		 * @returns {string|null***REMOVED*** flags if they can be determined, `null` otherwise
		 * @private
		 */
		function getFlags(node) {
			if (node.arguments.length < 2) {
				return "";
			***REMOVED***

			if (isString(node.arguments[1])) {
				return node.arguments[1].value;
			***REMOVED***

			return null;
		***REMOVED***

		/**
		 * Check syntax error in a given pattern.
		 * @param {string***REMOVED*** pattern The RegExp pattern to validate.
		 * @param {Object***REMOVED*** flags The RegExp flags to validate.
		 * @param {boolean***REMOVED*** [flags.unicode] The Unicode flag.
		 * @param {boolean***REMOVED*** [flags.unicodeSets] The UnicodeSets flag.
		 * @returns {string|null***REMOVED*** The syntax error.
		 */
		function validateRegExpPattern(pattern, flags) {
			try {
				validator.validatePattern(
					pattern,
					undefined1,
					undefined1,
					flags,
				);
				return null;
			***REMOVED*** catch (err) {
				return err.message;
			***REMOVED***
		***REMOVED***

		/**
		 * Check syntax error in a given flags.
		 * @param {string|null***REMOVED*** flags The RegExp flags to validate.
		 * @param {string|null***REMOVED*** flagsToCheck The RegExp invalid flags.
		 * @param {string***REMOVED*** allFlags all valid and allowed flags.
		 * @returns {string|null***REMOVED*** The syntax error.
		 */
		function validateRegExpFlags(flags, flagsToCheck, allFlags) {
			const duplicateFlags = [];

			if (typeof flagsToCheck === "string") {
				for (const flag of flagsToCheck) {
					if (allFlags.includes(flag)) {
						duplicateFlags.push(flag);
					***REMOVED***
				***REMOVED***
			***REMOVED***

			/*
			 * `regexpp` checks the combination of `u` and `v` flags when parsing `Pattern` according to `ecma262`,
			 * but this rule may check only the flag when the pattern is unidentifiable, so check it here.
			 * https://tc39.es/ecma262/multipage/text-processing.html#sec-parsepattern
			 */
			if (flags && flags.includes("u") && flags.includes("v")) {
				return "Regex 'u' and 'v' flags cannot be used together";
			***REMOVED***

			if (duplicateFlags.length > 0) {
				return `Duplicate flags ('${duplicateFlags.join("")***REMOVED***') supplied to RegExp constructor`;
			***REMOVED***

			if (!flagsToCheck) {
				return null;
			***REMOVED***

			return `Invalid flags supplied to RegExp constructor '${flagsToCheck***REMOVED***'`;
		***REMOVED***

		return {
			"CallExpression, NewExpression"(node) {
				if (
					node.callee.type !== "Identifier" ||
					node.callee.name !== "RegExp"
				) {
					return;
				***REMOVED***

				const flags = getFlags(node);
				let flagsToCheck = flags;
				const allFlags =
					allowedFlags.length > 0
						? validFlags.split("").concat(allowedFlags)
						: validFlags.split("");

				if (flags) {
					allFlags.forEach(flag => {
						flagsToCheck = flagsToCheck.replace(flag, "");
					***REMOVED***);
				***REMOVED***

				let message = validateRegExpFlags(
					flags,
					flagsToCheck,
					allFlags,
				);

				if (message) {
					report(node, message);
					return;
				***REMOVED***

				if (!isString(node.arguments[0])) {
					return;
				***REMOVED***

				const pattern = node.arguments[0].value;

				message =
					// If flags are unknown, report the regex only if its pattern is invalid both with and without the "u" flag
					flags === null
						? validateRegExpPattern(pattern, {
								unicode: true,
								unicodeSets: false,
							***REMOVED***) &&
							validateRegExpPattern(pattern, {
								unicode: false,
								unicodeSets: true,
							***REMOVED***) &&
							validateRegExpPattern(pattern, {
								unicode: false,
								unicodeSets: false,
							***REMOVED***)
						: validateRegExpPattern(pattern, {
								unicode: flags.includes("u"),
								unicodeSets: flags.includes("v"),
							***REMOVED***);

				if (message) {
					report(node, message);
				***REMOVED***
			***REMOVED***,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
