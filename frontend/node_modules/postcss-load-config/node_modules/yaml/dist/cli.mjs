import { resolve ***REMOVED*** from 'node:path';
import { parseArgs ***REMOVED*** from 'node:util';
import { prettyToken ***REMOVED*** from './parse/cst.js';
import { Lexer ***REMOVED*** from './parse/lexer.js';
import { Parser ***REMOVED*** from './parse/parser.js';
import { Composer ***REMOVED*** from './compose/composer.js';
import { LineCounter ***REMOVED*** from './parse/line-counter.js';
import { prettifyError ***REMOVED*** from './errors.js';
import { visit ***REMOVED*** from './visit.js';

const help = `\
yaml: A command-line YAML processor and inspector

Reads stdin and writes output to stdout and errors & warnings to stderr.

Usage:
  yaml          Process a YAML stream, outputting it as YAML
  yaml cst      Parse the CST of a YAML stream
  yaml lex      Parse the lexical tokens of a YAML stream
  yaml valid    Validate a YAML stream, returning 0 on success

Options:
  --help, -h    Show this message.
  --json, -j    Output JSON.
  --indent 2    Output pretty-printed data, indented by the given number of spaces.

Additional options for bare "yaml" command:
  --doc, -d     Output pretty-printed JS Document objects.
  --single, -1  Require the input to consist of a single YAML document.
  --strict, -s  Stop on errors.
  --visit, -v   Apply a visitor to each document (requires a path to import)
  --yaml 1.1    Set the YAML version. (default: 1.2)`;
class UserError extends Error {
    constructor(code, message) {
        super(`Error: ${message***REMOVED***`);
        this.code = code;
    ***REMOVED***
***REMOVED***
UserError.ARGS = 2;
UserError.SINGLE = 3;
async function cli(stdin, done, argv) {
    let args;
    try {
        args = parseArgs({
            args: argv,
            allowPositionals: true,
            options: {
                doc: { type: 'boolean', short: 'd' ***REMOVED***,
                help: { type: 'boolean', short: 'h' ***REMOVED***,
                indent: { type: 'string', short: 'i' ***REMOVED***,
                json: { type: 'boolean', short: 'j' ***REMOVED***,
                single: { type: 'boolean', short: '1' ***REMOVED***,
                strict: { type: 'boolean', short: 's' ***REMOVED***,
                visit: { type: 'string', short: 'v' ***REMOVED***,
                yaml: { type: 'string', default: '1.2' ***REMOVED***
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***
    catch (error) {
        return done(new UserError(UserError.ARGS, error.message));
    ***REMOVED***
    const { positionals: [mode], values: opt ***REMOVED*** = args;
    let indent = Number(opt.indent);
    stdin.setEncoding('utf-8');
    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
    switch (opt.help || mode) {
        /* istanbul ignore next */
        case true: // --help
            console.log(help);
            break;
        case 'lex': {
            const lexer = new Lexer();
            const data = [];
            const add = (tok) => {
                if (opt.json)
                    data.push(tok);
                else
                    console.log(prettyToken(tok));
            ***REMOVED***;
            stdin.on('data', (chunk) => {
                for (const tok of lexer.lex(chunk, true))
                    add(tok);
            ***REMOVED***);
            stdin.on('end', () => {
                for (const tok of lexer.lex('', false))
                    add(tok);
                if (opt.json)
                    console.log(JSON.stringify(data, null, indent));
                done();
            ***REMOVED***);
            break;
        ***REMOVED***
        case 'cst': {
            const parser = new Parser();
            const data = [];
            const add = (tok) => {
                if (opt.json)
                    data.push(tok);
                else
                    console.dir(tok, { depth: null ***REMOVED***);
            ***REMOVED***;
            stdin.on('data', (chunk) => {
                for (const tok of parser.parse(chunk, true))
                    add(tok);
            ***REMOVED***);
            stdin.on('end', () => {
                for (const tok of parser.parse('', false))
                    add(tok);
                if (opt.json)
                    console.log(JSON.stringify(data, null, indent));
                done();
            ***REMOVED***);
            break;
        ***REMOVED***
        case undefined:
        case 'valid': {
            const lineCounter = new LineCounter();
            const parser = new Parser(lineCounter.addNewLine);
            // @ts-expect-error Version is validated at runtime
            const composer = new Composer({ version: opt.yaml ***REMOVED***);
            const visitor = opt.visit
                ? (await import(resolve(opt.visit))).default
                : null;
            let source = '';
            let hasDoc = false;
            let reqDocEnd = false;
            const data = [];
            const add = (doc) => {
                if (hasDoc && opt.single) {
                    return done(new UserError(UserError.SINGLE, 'Input stream contains multiple documents'));
                ***REMOVED***
                for (const error of doc.errors) {
                    prettifyError(source, lineCounter)(error);
                    if (opt.strict || mode === 'valid')
                        return done(error);
                    console.error(error);
                ***REMOVED***
                for (const warning of doc.warnings) {
                    prettifyError(source, lineCounter)(warning);
                    console.error(warning);
                ***REMOVED***
                if (visitor)
                    visit(doc, visitor);
                if (mode === 'valid')
                    doc.toJS();
                else if (opt.json)
                    data.push(doc);
                else if (opt.doc) {
                    Object.defineProperties(doc, {
                        options: { enumerable: false ***REMOVED***,
                        schema: { enumerable: false ***REMOVED***
                    ***REMOVED***);
                    console.dir(doc, { depth: null ***REMOVED***);
                ***REMOVED***
                else {
                    if (reqDocEnd)
                        console.log('...');
                    try {
                        indent || (indent = 2);
                        const str = doc.toString({ indent ***REMOVED***);
                        console.log(str.endsWith('\n') ? str.slice(0, -1) : str);
                    ***REMOVED***
                    catch (error) {
                        done(error);
                    ***REMOVED***
                ***REMOVED***
                hasDoc = true;
                reqDocEnd = !doc.directives?.docEnd;
            ***REMOVED***;
            stdin.on('data', (chunk) => {
                source += chunk;
                for (const tok of parser.parse(chunk, true)) {
                    for (const doc of composer.next(tok))
                        add(doc);
                ***REMOVED***
            ***REMOVED***);
            stdin.on('end', () => {
                for (const tok of parser.parse('', false)) {
                    for (const doc of composer.next(tok))
                        add(doc);
                ***REMOVED***
                for (const doc of composer.end(false))
                    add(doc);
                if (opt.single && !hasDoc) {
                    return done(new UserError(UserError.SINGLE, 'Input stream contained no documents'));
                ***REMOVED***
                if (mode !== 'valid' && opt.json) {
                    console.log(JSON.stringify(opt.single ? data[0] : data, null, indent));
                ***REMOVED***
                done();
            ***REMOVED***);
            break;
        ***REMOVED***
        default:
            done(new UserError(UserError.ARGS, `Unknown command: ${JSON.stringify(mode)***REMOVED***`));
    ***REMOVED***
***REMOVED***

export { UserError, cli, help ***REMOVED***;
