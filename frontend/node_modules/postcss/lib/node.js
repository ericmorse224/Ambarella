'use strict'

let CssSyntaxError = require('./css-syntax-error')
let Stringifier = require('./stringifier')
let stringify = require('./stringify')
let { isClean, my ***REMOVED*** = require('./symbols')

function cloneNode(obj, parent) {
  let cloned = new obj.constructor()

  for (let i in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, i)) {
      /* c8 ignore next 2 */
      continue
    ***REMOVED***
    if (i === 'proxyCache') continue
    let value = obj[i]
    let type = typeof value

    if (i === 'parent' && type === 'object') {
      if (parent) cloned[i] = parent
    ***REMOVED*** else if (i === 'source') {
      cloned[i] = value
    ***REMOVED*** else if (Array.isArray(value)) {
      cloned[i] = value.map(j => cloneNode(j, cloned))
    ***REMOVED*** else {
      if (type === 'object' && value !== null) value = cloneNode(value)
      cloned[i] = value
    ***REMOVED***
  ***REMOVED***

  return cloned
***REMOVED***

function sourceOffset(inputCSS, position) {
  // Not all custom syntaxes support `offset` in `source.start` and `source.end`
  if (
    position &&
    typeof position.offset !== 'undefined'
  ) {
    return position.offset;
  ***REMOVED***

  let column = 1
  let line = 1
  let offset = 0

  for (let i = 0; i < inputCSS.length; i++) {
    if (line === position.line && column === position.column) {
      offset = i
      break
    ***REMOVED***

    if (inputCSS[i] === '\n') {
      column = 1
      line += 1
    ***REMOVED*** else {
      column += 1
    ***REMOVED***
  ***REMOVED***

  return offset
***REMOVED***

class Node {
  get proxyOf() {
    return this
  ***REMOVED***

  constructor(defaults = {***REMOVED***) {
    this.raws = {***REMOVED***
    this[isClean] = false
    this[my] = true

    for (let name in defaults) {
      if (name === 'nodes') {
        this.nodes = []
        for (let node of defaults[name]) {
          if (typeof node.clone === 'function') {
            this.append(node.clone())
          ***REMOVED*** else {
            this.append(node)
          ***REMOVED***
        ***REMOVED***
      ***REMOVED*** else {
        this[name] = defaults[name]
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  addToError(error) {
    error.postcssNode = this
    if (error.stack && this.source && /\n\s{4***REMOVED***at /.test(error.stack)) {
      let s = this.source
      error.stack = error.stack.replace(
        /\n\s{4***REMOVED***at /,
        `$&${s.input.from***REMOVED***:${s.start.line***REMOVED***:${s.start.column***REMOVED***$&`
      )
    ***REMOVED***
    return error
  ***REMOVED***

  after(add) {
    this.parent.insertAfter(this, add)
    return this
  ***REMOVED***

  assign(overrides = {***REMOVED***) {
    for (let name in overrides) {
      this[name] = overrides[name]
    ***REMOVED***
    return this
  ***REMOVED***

  before(add) {
    this.parent.insertBefore(this, add)
    return this
  ***REMOVED***

  cleanRaws(keepBetween) {
    delete this.raws.before
    delete this.raws.after
    if (!keepBetween) delete this.raws.between
  ***REMOVED***

  clone(overrides = {***REMOVED***) {
    let cloned = cloneNode(this)
    for (let name in overrides) {
      cloned[name] = overrides[name]
    ***REMOVED***
    return cloned
  ***REMOVED***

  cloneAfter(overrides = {***REMOVED***) {
    let cloned = this.clone(overrides)
    this.parent.insertAfter(this, cloned)
    return cloned
  ***REMOVED***

  cloneBefore(overrides = {***REMOVED***) {
    let cloned = this.clone(overrides)
    this.parent.insertBefore(this, cloned)
    return cloned
  ***REMOVED***

  error(message, opts = {***REMOVED***) {
    if (this.source) {
      let { end, start ***REMOVED*** = this.rangeBy(opts)
      return this.source.input.error(
        message,
        { column: start.column, line: start.line ***REMOVED***,
        { column: end.column, line: end.line ***REMOVED***,
        opts
      )
    ***REMOVED***
    return new CssSyntaxError(message)
  ***REMOVED***

  getProxyProcessor() {
    return {
      get(node, prop) {
        if (prop === 'proxyOf') {
          return node
        ***REMOVED*** else if (prop === 'root') {
          return () => node.root().toProxy()
        ***REMOVED*** else {
          return node[prop]
        ***REMOVED***
      ***REMOVED***,

      set(node, prop, value) {
        if (node[prop] === value) return true
        node[prop] = value
        if (
          prop === 'prop' ||
          prop === 'value' ||
          prop === 'name' ||
          prop === 'params' ||
          prop === 'important' ||
          /* c8 ignore next */
          prop === 'text'
        ) {
          node.markDirty()
        ***REMOVED***
        return true
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  /* c8 ignore next 3 */
  markClean() {
    this[isClean] = true
  ***REMOVED***

  markDirty() {
    if (this[isClean]) {
      this[isClean] = false
      let next = this
      while ((next = next.parent)) {
        next[isClean] = false
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***

  next() {
    if (!this.parent) return undefined
    let index = this.parent.index(this)
    return this.parent.nodes[index + 1]
  ***REMOVED***

  positionBy(opts) {
    let pos = this.source.start
    if (opts.index) {
      pos = this.positionInside(opts.index)
    ***REMOVED*** else if (opts.word) {
      let inputString = ('document' in this.source.input)
        ? this.source.input.document
        : this.source.input.css
      let stringRepresentation = inputString.slice(
        sourceOffset(inputString, this.source.start),
        sourceOffset(inputString, this.source.end)
      )
      let index = stringRepresentation.indexOf(opts.word)
      if (index !== -1) pos = this.positionInside(index)
    ***REMOVED***
    return pos
  ***REMOVED***

  positionInside(index) {
    let column = this.source.start.column
    let line = this.source.start.line
    let inputString = ('document' in this.source.input)
      ? this.source.input.document
      : this.source.input.css
    let offset = sourceOffset(inputString, this.source.start)
    let end = offset + index

    for (let i = offset; i < end; i++) {
      if (inputString[i] === '\n') {
        column = 1
        line += 1
      ***REMOVED*** else {
        column += 1
      ***REMOVED***
    ***REMOVED***

    return { column, line ***REMOVED***
  ***REMOVED***

  prev() {
    if (!this.parent) return undefined
    let index = this.parent.index(this)
    return this.parent.nodes[index - 1]
  ***REMOVED***

  rangeBy(opts) {
    let start = {
      column: this.source.start.column,
      line: this.source.start.line
    ***REMOVED***
    let end = this.source.end
      ? {
          column: this.source.end.column + 1,
          line: this.source.end.line
        ***REMOVED***
      : {
          column: start.column + 1,
          line: start.line
        ***REMOVED***

    if (opts.word) {
      let inputString = ('document' in this.source.input)
        ? this.source.input.document
        : this.source.input.css
      let stringRepresentation = inputString.slice(
        sourceOffset(inputString, this.source.start),
        sourceOffset(inputString, this.source.end)
      )
      let index = stringRepresentation.indexOf(opts.word)
      if (index !== -1) {
        start = this.positionInside(index)
        end = this.positionInside(
          index + opts.word.length,
        )
      ***REMOVED***
    ***REMOVED*** else {
      if (opts.start) {
        start = {
          column: opts.start.column,
          line: opts.start.line
        ***REMOVED***
      ***REMOVED*** else if (opts.index) {
        start = this.positionInside(opts.index)
      ***REMOVED***

      if (opts.end) {
        end = {
          column: opts.end.column,
          line: opts.end.line
        ***REMOVED***
      ***REMOVED*** else if (typeof opts.endIndex === 'number') {
        end = this.positionInside(opts.endIndex)
      ***REMOVED*** else if (opts.index) {
        end = this.positionInside(opts.index + 1)
      ***REMOVED***
    ***REMOVED***

    if (
      end.line < start.line ||
      (end.line === start.line && end.column <= start.column)
    ) {
      end = { column: start.column + 1, line: start.line ***REMOVED***
    ***REMOVED***

    return { end, start ***REMOVED***
  ***REMOVED***

  raw(prop, defaultType) {
    let str = new Stringifier()
    return str.raw(this, prop, defaultType)
  ***REMOVED***

  remove() {
    if (this.parent) {
      this.parent.removeChild(this)
    ***REMOVED***
    this.parent = undefined
    return this
  ***REMOVED***

  replaceWith(...nodes) {
    if (this.parent) {
      let bookmark = this
      let foundSelf = false
      for (let node of nodes) {
        if (node === this) {
          foundSelf = true
        ***REMOVED*** else if (foundSelf) {
          this.parent.insertAfter(bookmark, node)
          bookmark = node
        ***REMOVED*** else {
          this.parent.insertBefore(bookmark, node)
        ***REMOVED***
      ***REMOVED***

      if (!foundSelf) {
        this.remove()
      ***REMOVED***
    ***REMOVED***

    return this
  ***REMOVED***

  root() {
    let result = this
    while (result.parent && result.parent.type !== 'document') {
      result = result.parent
    ***REMOVED***
    return result
  ***REMOVED***

  toJSON(_, inputs) {
    let fixed = {***REMOVED***
    let emitInputs = inputs == null
    inputs = inputs || new Map()
    let inputsNextIndex = 0

    for (let name in this) {
      if (!Object.prototype.hasOwnProperty.call(this, name)) {
        /* c8 ignore next 2 */
        continue
      ***REMOVED***
      if (name === 'parent' || name === 'proxyCache') continue
      let value = this[name]

      if (Array.isArray(value)) {
        fixed[name] = value.map(i => {
          if (typeof i === 'object' && i.toJSON) {
            return i.toJSON(null, inputs)
          ***REMOVED*** else {
            return i
          ***REMOVED***
        ***REMOVED***)
      ***REMOVED*** else if (typeof value === 'object' && value.toJSON) {
        fixed[name] = value.toJSON(null, inputs)
      ***REMOVED*** else if (name === 'source') {
        let inputId = inputs.get(value.input)
        if (inputId == null) {
          inputId = inputsNextIndex
          inputs.set(value.input, inputsNextIndex)
          inputsNextIndex++
        ***REMOVED***
        fixed[name] = {
          end: value.end,
          inputId,
          start: value.start
        ***REMOVED***
      ***REMOVED*** else {
        fixed[name] = value
      ***REMOVED***
    ***REMOVED***

    if (emitInputs) {
      fixed.inputs = [...inputs.keys()].map(input => input.toJSON())
    ***REMOVED***

    return fixed
  ***REMOVED***

  toProxy() {
    if (!this.proxyCache) {
      this.proxyCache = new Proxy(this, this.getProxyProcessor())
    ***REMOVED***
    return this.proxyCache
  ***REMOVED***

  toString(stringifier = stringify) {
    if (stringifier.stringify) stringifier = stringifier.stringify
    let result = ''
    stringifier(this, i => {
      result += i
    ***REMOVED***)
    return result
  ***REMOVED***

  warn(result, text, opts) {
    let data = { node: this ***REMOVED***
    for (let i in opts) data[i] = opts[i]
    return result.warn(text, data)
  ***REMOVED***
***REMOVED***

module.exports = Node
Node.default = Node
