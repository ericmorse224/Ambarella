/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const t = require("@webassemblyjs/ast");
const { moduleContextFromModuleAST ***REMOVED*** = require("@webassemblyjs/ast");
const { decode ***REMOVED*** = require("@webassemblyjs/wasm-parser");
const Parser = require("../Parser");
const StaticExportsDependency = require("../dependencies/StaticExportsDependency");
const WebAssemblyExportImportedDependency = require("../dependencies/WebAssemblyExportImportedDependency");
const WebAssemblyImportDependency = require("../dependencies/WebAssemblyImportDependency");

/** @typedef {import("@webassemblyjs/ast").ModuleImport***REMOVED*** ModuleImport */
/** @typedef {import("@webassemblyjs/ast").NumberLiteral***REMOVED*** NumberLiteral */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../Module").BuildInfo***REMOVED*** BuildInfo */
/** @typedef {import("../Module").BuildMeta***REMOVED*** BuildMeta */
/** @typedef {import("../Parser").ParserState***REMOVED*** ParserState */
/** @typedef {import("../Parser").PreparsedAst***REMOVED*** PreparsedAst */

const JS_COMPAT_TYPES = new Set(["i32", "i64", "f32", "f64", "externref"]);

/**
 * @param {t.Signature***REMOVED*** signature the func signature
 * @returns {null | string***REMOVED*** the type incompatible with js types
 */
const getJsIncompatibleType = signature => {
	for (const param of signature.params) {
		if (!JS_COMPAT_TYPES.has(param.valtype)) {
			return `${param.valtype***REMOVED*** as parameter`;
		***REMOVED***
	***REMOVED***
	for (const type of signature.results) {
		if (!JS_COMPAT_TYPES.has(type)) return `${type***REMOVED*** as result`;
	***REMOVED***
	return null;
***REMOVED***;

/**
 * TODO why are there two different Signature types?
 * @param {t.FuncSignature***REMOVED*** signature the func signature
 * @returns {null | string***REMOVED*** the type incompatible with js types
 */
const getJsIncompatibleTypeOfFuncSignature = signature => {
	for (const param of signature.args) {
		if (!JS_COMPAT_TYPES.has(param)) {
			return `${param***REMOVED*** as parameter`;
		***REMOVED***
	***REMOVED***
	for (const type of signature.result) {
		if (!JS_COMPAT_TYPES.has(type)) return `${type***REMOVED*** as result`;
	***REMOVED***
	return null;
***REMOVED***;

const decoderOpts = {
	ignoreCodeSection: true,
	ignoreDataSection: true,

	// this will avoid having to lookup with identifiers in the ModuleContext
	ignoreCustomNameSection: true
***REMOVED***;

class WebAssemblyParser extends Parser {
	/**
	 * @param {{***REMOVED***=***REMOVED*** options parser options
	 */
	constructor(options) {
		super();
		this.hooks = Object.freeze({***REMOVED***);
		this.options = options;
	***REMOVED***

	/**
	 * @param {string | Buffer | PreparsedAst***REMOVED*** source the source to parse
	 * @param {ParserState***REMOVED*** state the parser state
	 * @returns {ParserState***REMOVED*** the parser state
	 */
	parse(source, state) {
		if (!Buffer.isBuffer(source)) {
			throw new Error("WebAssemblyParser input must be a Buffer");
		***REMOVED***

		// flag it as ESM
		/** @type {BuildInfo***REMOVED*** */
		(state.module.buildInfo).strict = true;
		/** @type {BuildMeta***REMOVED*** */
		(state.module.buildMeta).exportsType = "namespace";

		// parse it
		const program = decode(source, decoderOpts);
		const module = program.body[0];

		const moduleContext = moduleContextFromModuleAST(module);

		// extract imports and exports
		/** @type {string[]***REMOVED*** */
		const exports = [];
		const buildMeta = /** @type {BuildMeta***REMOVED*** */ (state.module.buildMeta);
		/** @type {Record<string, string> | undefined***REMOVED*** */
		let jsIncompatibleExports = (buildMeta.jsIncompatibleExports = undefined);

		/** @type {(ModuleImport | null)[]***REMOVED*** */
		const importedGlobals = [];

		t.traverse(module, {
			ModuleExport({ node ***REMOVED***) {
				const descriptor = node.descr;

				if (descriptor.exportType === "Func") {
					const funcIdx = descriptor.id.value;

					/** @type {t.FuncSignature***REMOVED*** */
					const funcSignature = moduleContext.getFunction(funcIdx);

					const incompatibleType =
						getJsIncompatibleTypeOfFuncSignature(funcSignature);

					if (incompatibleType) {
						if (jsIncompatibleExports === undefined) {
							jsIncompatibleExports =
								/** @type {BuildMeta***REMOVED*** */
								(state.module.buildMeta).jsIncompatibleExports = {***REMOVED***;
						***REMOVED***
						jsIncompatibleExports[node.name] = incompatibleType;
					***REMOVED***
				***REMOVED***

				exports.push(node.name);

				if (node.descr && node.descr.exportType === "Global") {
					const refNode =
						importedGlobals[/** @type {NumberLiteral***REMOVED*** */ (node.descr.id).value];
					if (refNode) {
						const dep = new WebAssemblyExportImportedDependency(
							node.name,
							refNode.module,
							refNode.name,
							/** @type {string***REMOVED*** */
							(refNode.descr.valtype)
						);

						state.module.addDependency(dep);
					***REMOVED***
				***REMOVED***
			***REMOVED***,

			Global({ node ***REMOVED***) {
				const init = node.init[0];

				let importNode = null;

				if (init.id === "get_global") {
					const globalIdx = init.args[0].value;

					if (globalIdx < importedGlobals.length) {
						importNode = importedGlobals[globalIdx];
					***REMOVED***
				***REMOVED***

				importedGlobals.push(importNode);
			***REMOVED***,

			ModuleImport({ node ***REMOVED***) {
				/** @type {false | string***REMOVED*** */
				let onlyDirectImport = false;

				if (t.isMemory(node.descr) === true) {
					onlyDirectImport = "Memory";
				***REMOVED*** else if (t.isTable(node.descr) === true) {
					onlyDirectImport = "Table";
				***REMOVED*** else if (t.isFuncImportDescr(node.descr) === true) {
					const incompatibleType = getJsIncompatibleType(
						/** @type {t.Signature***REMOVED*** */
						(node.descr.signature)
					);
					if (incompatibleType) {
						onlyDirectImport = `Non-JS-compatible Func Signature (${incompatibleType***REMOVED***)`;
					***REMOVED***
				***REMOVED*** else if (t.isGlobalType(node.descr) === true) {
					const type = /** @type {string***REMOVED*** */ (node.descr.valtype);
					if (!JS_COMPAT_TYPES.has(type)) {
						onlyDirectImport = `Non-JS-compatible Global Type (${type***REMOVED***)`;
					***REMOVED***
				***REMOVED***

				const dep = new WebAssemblyImportDependency(
					node.module,
					node.name,
					node.descr,
					onlyDirectImport
				);

				state.module.addDependency(dep);

				if (t.isGlobalType(node.descr)) {
					importedGlobals.push(node);
				***REMOVED***
			***REMOVED***
		***REMOVED***);

		state.module.addDependency(new StaticExportsDependency(exports, false));

		return state;
	***REMOVED***
***REMOVED***

module.exports = WebAssemblyParser;
