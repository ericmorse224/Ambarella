"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
***REMOVED***);
exports.hoist = hoist;
var util = require("./util.js");
const hasOwn = Object.prototype.hasOwnProperty;
function hoist(funPath) {
  const t = util.getTypes();
  t.assertFunction(funPath.node);
  const vars = {***REMOVED***;
  function varDeclToExpr({
    node: vdec,
    scope
  ***REMOVED***, includeIdentifiers) {
    t.assertVariableDeclaration(vdec);
    const exprs = [];
    vdec.declarations.forEach(function (dec) {
      vars[dec.id.name] = t.identifier(dec.id.name);
      scope.removeBinding(dec.id.name);
      if (dec.init) {
        exprs.push(t.assignmentExpression("=", dec.id, dec.init));
      ***REMOVED*** else if (includeIdentifiers) {
        exprs.push(dec.id);
      ***REMOVED***
    ***REMOVED***);
    if (exprs.length === 0) return null;
    if (exprs.length === 1) return exprs[0];
    return t.sequenceExpression(exprs);
  ***REMOVED***
  funPath.get("body").traverse({
    VariableDeclaration: {
      exit: function (path) {
        const expr = varDeclToExpr(path, false);
        if (expr === null) {
          path.remove();
        ***REMOVED*** else {
          util.replaceWithOrRemove(path, t.expressionStatement(expr));
        ***REMOVED***
        path.skip();
      ***REMOVED***
    ***REMOVED***,
    ForStatement: function (path) {
      const init = path.get("init");
      if (init.isVariableDeclaration()) {
        util.replaceWithOrRemove(init, varDeclToExpr(init, false));
      ***REMOVED***
    ***REMOVED***,
    ForXStatement: function (path) {
      const left = path.get("left");
      if (left.isVariableDeclaration()) {
        util.replaceWithOrRemove(left, varDeclToExpr(left, true));
      ***REMOVED***
    ***REMOVED***,
    FunctionDeclaration: function (path) {
      const node = path.node;
      vars[node.id.name] = node.id;
      const assignment = t.expressionStatement(t.assignmentExpression("=", t.clone(node.id), t.functionExpression(path.scope.generateUidIdentifierBasedOnNode(node), node.params, node.body, node.generator, node.expression)));
      if (path.parentPath.isBlockStatement()) {
        path.parentPath.unshiftContainer("body", assignment);
        path.remove();
      ***REMOVED*** else {
        util.replaceWithOrRemove(path, assignment);
      ***REMOVED***
      path.scope.removeBinding(node.id.name);
      path.skip();
    ***REMOVED***,
    FunctionExpression: function (path) {
      path.skip();
    ***REMOVED***,
    ArrowFunctionExpression: function (path) {
      path.skip();
    ***REMOVED***
  ***REMOVED***);
  const paramNames = {***REMOVED***;
  funPath.get("params").forEach(function (paramPath) {
    const param = paramPath.node;
    if (t.isIdentifier(param)) {
      paramNames[param.name] = param;
    ***REMOVED*** else {***REMOVED***
  ***REMOVED***);
  const declarations = [];
  Object.keys(vars).forEach(function (name) {
    if (!hasOwn.call(paramNames, name)) {
      declarations.push(t.variableDeclarator(vars[name], null));
    ***REMOVED***
  ***REMOVED***);
  if (declarations.length === 0) {
    return null;
  ***REMOVED***
  return t.variableDeclaration("var", declarations);
***REMOVED***

//# sourceMappingURL=hoist.js.map
