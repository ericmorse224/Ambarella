"use strict";

const globalObject = require("@sinonjs/commons").global;

/**
 * @typedef {object***REMOVED*** IdleDeadline
 * @property {boolean***REMOVED*** didTimeout - whether or not the callback was called before reaching the optional timeout
 * @property {function():number***REMOVED*** timeRemaining - a floating-point value providing an estimate of the number of milliseconds remaining in the current idle period
 */

/**
 * Queues a function to be called during a browser's idle periods
 *
 * @callback RequestIdleCallback
 * @param {function(IdleDeadline)***REMOVED*** callback
 * @param {{timeout: number***REMOVED******REMOVED*** options - an options object
 * @returns {number***REMOVED*** the id
 */

/**
 * @callback NextTick
 * @param {VoidVarArgsFunc***REMOVED*** callback - the callback to run
 * @param {...****REMOVED*** arguments - optional arguments to call the callback with
 * @returns {void***REMOVED***
 */

/**
 * @callback SetImmediate
 * @param {VoidVarArgsFunc***REMOVED*** callback - the callback to run
 * @param {...****REMOVED*** arguments - optional arguments to call the callback with
 * @returns {NodeImmediate***REMOVED***
 */

/**
 * @callback VoidVarArgsFunc
 * @param {...****REMOVED*** callback - the callback to run
 * @returns {void***REMOVED***
 */

/**
 * @typedef RequestAnimationFrame
 * @property {function(number):void***REMOVED*** requestAnimationFrame
 * @returns {number***REMOVED*** - the id
 */

/**
 * @typedef Performance
 * @property {function(): number***REMOVED*** now
 */

/* eslint-disable jsdoc/require-property-description */
/**
 * @typedef {object***REMOVED*** Clock
 * @property {number***REMOVED*** now - the current time
 * @property {Date***REMOVED*** Date - the Date constructor
 * @property {number***REMOVED*** loopLimit - the maximum number of timers before assuming an infinite loop
 * @property {RequestIdleCallback***REMOVED*** requestIdleCallback
 * @property {function(number):void***REMOVED*** cancelIdleCallback
 * @property {setTimeout***REMOVED*** setTimeout
 * @property {clearTimeout***REMOVED*** clearTimeout
 * @property {NextTick***REMOVED*** nextTick
 * @property {queueMicrotask***REMOVED*** queueMicrotask
 * @property {setInterval***REMOVED*** setInterval
 * @property {clearInterval***REMOVED*** clearInterval
 * @property {SetImmediate***REMOVED*** setImmediate
 * @property {function(NodeImmediate):void***REMOVED*** clearImmediate
 * @property {function():number***REMOVED*** countTimers
 * @property {RequestAnimationFrame***REMOVED*** requestAnimationFrame
 * @property {function(number):void***REMOVED*** cancelAnimationFrame
 * @property {function():void***REMOVED*** runMicrotasks
 * @property {function(string | number): number***REMOVED*** tick
 * @property {function(string | number): Promise<number>***REMOVED*** tickAsync
 * @property {function(): number***REMOVED*** next
 * @property {function(): Promise<number>***REMOVED*** nextAsync
 * @property {function(): number***REMOVED*** runAll
 * @property {function(): number***REMOVED*** runToFrame
 * @property {function(): Promise<number>***REMOVED*** runAllAsync
 * @property {function(): number***REMOVED*** runToLast
 * @property {function(): Promise<number>***REMOVED*** runToLastAsync
 * @property {function(): void***REMOVED*** reset
 * @property {function(number | Date): void***REMOVED*** setSystemTime
 * @property {Performance***REMOVED*** performance
 * @property {function(number[]): number[]***REMOVED*** hrtime - process.hrtime (legacy)
 * @property {function(): void***REMOVED*** uninstall Uninstall the clock.
 * @property {Function[]***REMOVED*** methods - the methods that are faked
 * @property {boolean***REMOVED*** [shouldClearNativeTimers] inherited from config
 */
/* eslint-enable jsdoc/require-property-description */

/**
 * Configuration object for the `install` method.
 *
 * @typedef {object***REMOVED*** Config
 * @property {number|Date***REMOVED*** [now] a number (in milliseconds) or a Date object (default epoch)
 * @property {string[]***REMOVED*** [toFake] names of the methods that should be faked.
 * @property {number***REMOVED*** [loopLimit] the maximum number of timers that will be run when calling runAll()
 * @property {boolean***REMOVED*** [shouldAdvanceTime] tells FakeTimers to increment mocked time automatically (default false)
 * @property {number***REMOVED*** [advanceTimeDelta] increment mocked time every <<advanceTimeDelta>> ms (default: 20ms)
 * @property {boolean***REMOVED*** [shouldClearNativeTimers] forwards clear timer calls to native functions if they are not fakes (default: false)
 */

/* eslint-disable jsdoc/require-property-description */
/**
 * The internal structure to describe a scheduled fake timer
 *
 * @typedef {object***REMOVED*** Timer
 * @property {Function***REMOVED*** func
 * @property {*[]***REMOVED*** args
 * @property {number***REMOVED*** delay
 * @property {number***REMOVED*** callAt
 * @property {number***REMOVED*** createdAt
 * @property {boolean***REMOVED*** immediate
 * @property {number***REMOVED*** id
 * @property {Error***REMOVED*** [error]
 */

/**
 * A Node timer
 *
 * @typedef {object***REMOVED*** NodeImmediate
 * @property {function(): boolean***REMOVED*** hasRef
 * @property {function(): NodeImmediate***REMOVED*** ref
 * @property {function(): NodeImmediate***REMOVED*** unref
 */
/* eslint-enable jsdoc/require-property-description */

/* eslint-disable complexity */

/**
 * Mocks available features in the specified global namespace.
 *
 * @param {****REMOVED*** _global Namespace to mock (e.g. `window`)
 * @returns {FakeTimers***REMOVED***
 */
function withGlobal(_global) {
    const userAgent = _global.navigator && _global.navigator.userAgent;
    const isRunningInIE = userAgent && userAgent.indexOf("MSIE ") > -1;
    const maxTimeout = Math.pow(2, 31) - 1; //see https://heycam.github.io/webidl/#abstract-opdef-converttoint
    const idCounterStart = 1e12; // arbitrarily large number to avoid collisions with native timer IDs
    const NOOP = function () {
        return undefined;
    ***REMOVED***;
    const NOOP_ARRAY = function () {
        return [];
    ***REMOVED***;
    const timeoutResult = _global.setTimeout(NOOP, 0);
    const addTimerReturnsObject = typeof timeoutResult === "object";
    const hrtimePresent =
        _global.process && typeof _global.process.hrtime === "function";
    const hrtimeBigintPresent =
        hrtimePresent && typeof _global.process.hrtime.bigint === "function";
    const nextTickPresent =
        _global.process && typeof _global.process.nextTick === "function";
    const utilPromisify = _global.process && require("util").promisify;
    const performancePresent =
        _global.performance && typeof _global.performance.now === "function";
    const hasPerformancePrototype =
        _global.Performance &&
        (typeof _global.Performance).match(/^(function|object)$/);
    const queueMicrotaskPresent = _global.hasOwnProperty("queueMicrotask");
    const requestAnimationFramePresent =
        _global.requestAnimationFrame &&
        typeof _global.requestAnimationFrame === "function";
    const cancelAnimationFramePresent =
        _global.cancelAnimationFrame &&
        typeof _global.cancelAnimationFrame === "function";
    const requestIdleCallbackPresent =
        _global.requestIdleCallback &&
        typeof _global.requestIdleCallback === "function";
    const cancelIdleCallbackPresent =
        _global.cancelIdleCallback &&
        typeof _global.cancelIdleCallback === "function";
    const setImmediatePresent =
        _global.setImmediate && typeof _global.setImmediate === "function";

    // Make properties writable in IE, as per
    // https://www.adequatelygood.com/Replacing-setTimeout-Globally.html
    /* eslint-disable no-self-assign */
    if (isRunningInIE) {
        _global.setTimeout = _global.setTimeout;
        _global.clearTimeout = _global.clearTimeout;
        _global.setInterval = _global.setInterval;
        _global.clearInterval = _global.clearInterval;
        _global.Date = _global.Date;
    ***REMOVED***

    // setImmediate is not a standard function
    // avoid adding the prop to the window object if not present
    if (setImmediatePresent) {
        _global.setImmediate = _global.setImmediate;
        _global.clearImmediate = _global.clearImmediate;
    ***REMOVED***
    /* eslint-enable no-self-assign */

    _global.clearTimeout(timeoutResult);

    const NativeDate = _global.Date;
    let uniqueTimerId = idCounterStart;

    /**
     * @param {number***REMOVED*** num
     * @returns {boolean***REMOVED***
     */
    function isNumberFinite(num) {
        if (Number.isFinite) {
            return Number.isFinite(num);
        ***REMOVED***

        return isFinite(num);
    ***REMOVED***

    let isNearInfiniteLimit = false;

    /**
     * @param {Clock***REMOVED*** clock
     * @param {number***REMOVED*** i
     */
    function checkIsNearInfiniteLimit(clock, i) {
        if (clock.loopLimit && i === clock.loopLimit - 1) {
            isNearInfiniteLimit = true;
        ***REMOVED***
    ***REMOVED***

    /**
     *
     */
    function resetIsNearInfiniteLimit() {
        isNearInfiniteLimit = false;
    ***REMOVED***

    /**
     * Parse strings like "01:10:00" (meaning 1 hour, 10 minutes, 0 seconds) into
     * number of milliseconds. This is used to support human-readable strings passed
     * to clock.tick()
     *
     * @param {string***REMOVED*** str
     * @returns {number***REMOVED***
     */
    function parseTime(str) {
        if (!str) {
            return 0;
        ***REMOVED***

        const strings = str.split(":");
        const l = strings.length;
        let i = l;
        let ms = 0;
        let parsed;

        if (l > 3 || !/^(\d\d:){0,2***REMOVED***\d\d?$/.test(str)) {
            throw new Error(
                "tick only understands numbers, 'm:s' and 'h:m:s'. Each part must be two digits"
            );
        ***REMOVED***

        while (i--) {
            parsed = parseInt(strings[i], 10);

            if (parsed >= 60) {
                throw new Error(`Invalid time ${str***REMOVED***`);
            ***REMOVED***

            ms += parsed * Math.pow(60, l - i - 1);
        ***REMOVED***

        return ms * 1000;
    ***REMOVED***

    /**
     * Get the decimal part of the millisecond value as nanoseconds
     *
     * @param {number***REMOVED*** msFloat the number of milliseconds
     * @returns {number***REMOVED*** an integer number of nanoseconds in the range [0,1e6)
     *
     * Example: nanoRemainer(123.456789) -> 456789
     */
    function nanoRemainder(msFloat) {
        const modulo = 1e6;
        const remainder = (msFloat * 1e6) % modulo;
        const positiveRemainder =
            remainder < 0 ? remainder + modulo : remainder;

        return Math.floor(positiveRemainder);
    ***REMOVED***

    /**
     * Used to grok the `now` parameter to createClock.
     *
     * @param {Date|number***REMOVED*** epoch the system time
     * @returns {number***REMOVED***
     */
    function getEpoch(epoch) {
        if (!epoch) {
            return 0;
        ***REMOVED***
        if (typeof epoch.getTime === "function") {
            return epoch.getTime();
        ***REMOVED***
        if (typeof epoch === "number") {
            return epoch;
        ***REMOVED***
        throw new TypeError("now should be milliseconds since UNIX epoch");
    ***REMOVED***

    /**
     * @param {number***REMOVED*** from
     * @param {number***REMOVED*** to
     * @param {Timer***REMOVED*** timer
     * @returns {boolean***REMOVED***
     */
    function inRange(from, to, timer) {
        return timer && timer.callAt >= from && timer.callAt <= to;
    ***REMOVED***

    /**
     * @param {Clock***REMOVED*** clock
     * @param {Timer***REMOVED*** job
     */
    function getInfiniteLoopError(clock, job) {
        const infiniteLoopError = new Error(
            `Aborting after running ${clock.loopLimit***REMOVED*** timers, assuming an infinite loop!`
        );

        if (!job.error) {
            return infiniteLoopError;
        ***REMOVED***

        // pattern never matched in Node
        const computedTargetPattern = /target\.*[<|(|[].*?[>|\]|)]\s*/;
        let clockMethodPattern = new RegExp(
            String(Object.keys(clock).join("|"))
        );

        if (addTimerReturnsObject) {
            // node.js environment
            clockMethodPattern = new RegExp(
                `\\s+at (Object\\.)?(?:${Object.keys(clock).join("|")***REMOVED***)\\s+`
            );
        ***REMOVED***

        let matchedLineIndex = -1;
        job.error.stack.split("\n").some(function (line, i) {
            // If we've matched a computed target line (e.g. setTimeout) then we
            // don't need to look any further. Return true to stop iterating.
            const matchedComputedTarget = line.match(computedTargetPattern);
            /* istanbul ignore if */
            if (matchedComputedTarget) {
                matchedLineIndex = i;
                return true;
            ***REMOVED***

            // If we've matched a clock method line, then there may still be
            // others further down the trace. Return false to keep iterating.
            const matchedClockMethod = line.match(clockMethodPattern);
            if (matchedClockMethod) {
                matchedLineIndex = i;
                return false;
            ***REMOVED***

            // If we haven't matched anything on this line, but we matched
            // previously and set the matched line index, then we can stop.
            // If we haven't matched previously, then we should keep iterating.
            return matchedLineIndex >= 0;
        ***REMOVED***);

        const stack = `${infiniteLoopError***REMOVED***\n${job.type || "Microtask"***REMOVED*** - ${
            job.func.name || "anonymous"
        ***REMOVED***\n${job.error.stack
            .split("\n")
            .slice(matchedLineIndex + 1)
            .join("\n")***REMOVED***`;

        try {
            Object.defineProperty(infiniteLoopError, "stack", {
                value: stack,
            ***REMOVED***);
        ***REMOVED*** catch (e) {
            // noop
        ***REMOVED***

        return infiniteLoopError;
    ***REMOVED***

    /**
     * @param {Date***REMOVED*** target
     * @param {Date***REMOVED*** source
     * @returns {Date***REMOVED*** the target after modifications
     */
    function mirrorDateProperties(target, source) {
        let prop;
        for (prop in source) {
            if (source.hasOwnProperty(prop)) {
                target[prop] = source[prop];
            ***REMOVED***
        ***REMOVED***

        // set special now implementation
        if (source.now) {
            target.now = function now() {
                return target.clock.now;
            ***REMOVED***;
        ***REMOVED*** else {
            delete target.now;
        ***REMOVED***

        // set special toSource implementation
        if (source.toSource) {
            target.toSource = function toSource() {
                return source.toSource();
            ***REMOVED***;
        ***REMOVED*** else {
            delete target.toSource;
        ***REMOVED***

        // set special toString implementation
        target.toString = function toString() {
            return source.toString();
        ***REMOVED***;

        target.prototype = source.prototype;
        target.parse = source.parse;
        target.UTC = source.UTC;
        target.prototype.toUTCString = source.prototype.toUTCString;

        return target;
    ***REMOVED***

    //eslint-disable-next-line jsdoc/require-jsdoc
    function createDate() {
        /**
         * @param {number***REMOVED*** year
         * @param {number***REMOVED*** month
         * @param {number***REMOVED*** date
         * @param {number***REMOVED*** hour
         * @param {number***REMOVED*** minute
         * @param {number***REMOVED*** second
         * @param {number***REMOVED*** ms
         *
         * @returns {Date***REMOVED***
         */
        function ClockDate(year, month, date, hour, minute, second, ms) {
            // the Date constructor called as a function, ref Ecma-262 Edition 5.1, section 15.9.2.
            // This remains so in the 10th edition of 2019 as well.
            if (!(this instanceof ClockDate)) {
                return new NativeDate(ClockDate.clock.now).toString();
            ***REMOVED***

            // if Date is called as a constructor with 'new' keyword
            // Defensive and verbose to avoid potential harm in passing
            // explicit undefined when user does not pass argument
            switch (arguments.length) {
                case 0:
                    return new NativeDate(ClockDate.clock.now);
                case 1:
                    return new NativeDate(year);
                case 2:
                    return new NativeDate(year, month);
                case 3:
                    return new NativeDate(year, month, date);
                case 4:
                    return new NativeDate(year, month, date, hour);
                case 5:
                    return new NativeDate(year, month, date, hour, minute);
                case 6:
                    return new NativeDate(
                        year,
                        month,
                        date,
                        hour,
                        minute,
                        second
                    );
                default:
                    return new NativeDate(
                        year,
                        month,
                        date,
                        hour,
                        minute,
                        second,
                        ms
                    );
            ***REMOVED***
        ***REMOVED***

        return mirrorDateProperties(ClockDate, NativeDate);
    ***REMOVED***

    //eslint-disable-next-line jsdoc/require-jsdoc
    function enqueueJob(clock, job) {
        // enqueues a microtick-deferred task - ecma262/#sec-enqueuejob
        if (!clock.jobs) {
            clock.jobs = [];
        ***REMOVED***
        clock.jobs.push(job);
    ***REMOVED***

    //eslint-disable-next-line jsdoc/require-jsdoc
    function runJobs(clock) {
        // runs all microtick-deferred tasks - ecma262/#sec-runjobs
        if (!clock.jobs) {
            return;
        ***REMOVED***
        for (let i = 0; i < clock.jobs.length; i++) {
            const job = clock.jobs[i];
            job.func.apply(null, job.args);

            checkIsNearInfiniteLimit(clock, i);
            if (clock.loopLimit && i > clock.loopLimit) {
                throw getInfiniteLoopError(clock, job);
            ***REMOVED***
        ***REMOVED***
        resetIsNearInfiniteLimit();
        clock.jobs = [];
    ***REMOVED***

    /**
     * @param {Clock***REMOVED*** clock
     * @param {Timer***REMOVED*** timer
     * @returns {number***REMOVED*** id of the created timer
     */
    function addTimer(clock, timer) {
        if (timer.func === undefined) {
            throw new Error("Callback must be provided to timer calls");
        ***REMOVED***

        if (addTimerReturnsObject) {
            // Node.js environment
            if (typeof timer.func !== "function") {
                throw new TypeError(
                    `[ERR_INVALID_CALLBACK]: Callback must be a function. Received ${
                        timer.func
                    ***REMOVED*** of type ${typeof timer.func***REMOVED***`
                );
            ***REMOVED***
        ***REMOVED***

        if (isNearInfiniteLimit) {
            timer.error = new Error();
        ***REMOVED***

        timer.type = timer.immediate ? "Immediate" : "Timeout";

        if (timer.hasOwnProperty("delay")) {
            if (typeof timer.delay !== "number") {
                timer.delay = parseInt(timer.delay, 10);
            ***REMOVED***

            if (!isNumberFinite(timer.delay)) {
                timer.delay = 0;
            ***REMOVED***
            timer.delay = timer.delay > maxTimeout ? 1 : timer.delay;
            timer.delay = Math.max(0, timer.delay);
        ***REMOVED***

        if (timer.hasOwnProperty("interval")) {
            timer.type = "Interval";
            timer.interval = timer.interval > maxTimeout ? 1 : timer.interval;
        ***REMOVED***

        if (timer.hasOwnProperty("animation")) {
            timer.type = "AnimationFrame";
            timer.animation = true;
        ***REMOVED***

        if (timer.hasOwnProperty("idleCallback")) {
            timer.type = "IdleCallback";
            timer.idleCallback = true;
        ***REMOVED***

        if (!clock.timers) {
            clock.timers = {***REMOVED***;
        ***REMOVED***

        timer.id = uniqueTimerId++;
        timer.createdAt = clock.now;
        timer.callAt =
            clock.now + (parseInt(timer.delay) || (clock.duringTick ? 1 : 0));

        clock.timers[timer.id] = timer;

        if (addTimerReturnsObject) {
            const res = {
                ref: function () {
                    return res;
                ***REMOVED***,
                unref: function () {
                    return res;
                ***REMOVED***,
                refresh: function () {
                    clearTimeout(timer.id);
                    const args = [timer.func, timer.delay].concat(timer.args);
                    return setTimeout.apply(null, args);
                ***REMOVED***,
                [Symbol.toPrimitive]: function () {
                    return timer.id;
                ***REMOVED***,
            ***REMOVED***;
            return res;
        ***REMOVED***

        return timer.id;
    ***REMOVED***

    /* eslint consistent-return: "off" */
    /**
     * Timer comparitor
     *
     * @param {Timer***REMOVED*** a
     * @param {Timer***REMOVED*** b
     * @returns {number***REMOVED***
     */
    function compareTimers(a, b) {
        // Sort first by absolute timing
        if (a.callAt < b.callAt) {
            return -1;
        ***REMOVED***
        if (a.callAt > b.callAt) {
            return 1;
        ***REMOVED***

        // Sort next by immediate, immediate timers take precedence
        if (a.immediate && !b.immediate) {
            return -1;
        ***REMOVED***
        if (!a.immediate && b.immediate) {
            return 1;
        ***REMOVED***

        // Sort next by creation time, earlier-created timers take precedence
        if (a.createdAt < b.createdAt) {
            return -1;
        ***REMOVED***
        if (a.createdAt > b.createdAt) {
            return 1;
        ***REMOVED***

        // Sort next by id, lower-id timers take precedence
        if (a.id < b.id) {
            return -1;
        ***REMOVED***
        if (a.id > b.id) {
            return 1;
        ***REMOVED***

        // As timer ids are unique, no fallback `0` is necessary
    ***REMOVED***

    /**
     * @param {Clock***REMOVED*** clock
     * @param {number***REMOVED*** from
     * @param {number***REMOVED*** to
     *
     * @returns {Timer***REMOVED***
     */
    function firstTimerInRange(clock, from, to) {
        const timers = clock.timers;
        let timer = null;
        let id, isInRange;

        for (id in timers) {
            if (timers.hasOwnProperty(id)) {
                isInRange = inRange(from, to, timers[id]);

                if (
                    isInRange &&
                    (!timer || compareTimers(timer, timers[id]) === 1)
                ) {
                    timer = timers[id];
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        return timer;
    ***REMOVED***

    /**
     * @param {Clock***REMOVED*** clock
     * @returns {Timer***REMOVED***
     */
    function firstTimer(clock) {
        const timers = clock.timers;
        let timer = null;
        let id;

        for (id in timers) {
            if (timers.hasOwnProperty(id)) {
                if (!timer || compareTimers(timer, timers[id]) === 1) {
                    timer = timers[id];
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        return timer;
    ***REMOVED***

    /**
     * @param {Clock***REMOVED*** clock
     * @returns {Timer***REMOVED***
     */
    function lastTimer(clock) {
        const timers = clock.timers;
        let timer = null;
        let id;

        for (id in timers) {
            if (timers.hasOwnProperty(id)) {
                if (!timer || compareTimers(timer, timers[id]) === -1) {
                    timer = timers[id];
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        return timer;
    ***REMOVED***

    /**
     * @param {Clock***REMOVED*** clock
     * @param {Timer***REMOVED*** timer
     */
    function callTimer(clock, timer) {
        if (typeof timer.interval === "number") {
            clock.timers[timer.id].callAt += timer.interval;
        ***REMOVED*** else {
            delete clock.timers[timer.id];
        ***REMOVED***

        if (typeof timer.func === "function") {
            timer.func.apply(null, timer.args);
        ***REMOVED*** else {
            /* eslint no-eval: "off" */
            const eval2 = eval;
            (function () {
                eval2(timer.func);
            ***REMOVED***)();
        ***REMOVED***
    ***REMOVED***

    /**
     * Gets clear handler name for a given timer type
     * @param {string***REMOVED*** ttype
     */
    function getClearHandler(ttype) {
        if (ttype === "IdleCallback" || ttype === "AnimationFrame") {
            return `cancel${ttype***REMOVED***`;
        ***REMOVED***
        return `clear${ttype***REMOVED***`;
    ***REMOVED***

    /**
     * Gets schedule handler name for a given timer type
     * @param {string***REMOVED*** ttype
     */
    function getScheduleHandler(ttype) {
        if (ttype === "IdleCallback" || ttype === "AnimationFrame") {
            return `request${ttype***REMOVED***`;
        ***REMOVED***
        return `set${ttype***REMOVED***`;
    ***REMOVED***

    /**
     * Creates an anonymous function to warn only once
     */
    function createWarnOnce() {
        let calls = 0;
        return function (msg) {
            // eslint-disable-next-line
            !calls++ && console.warn(msg);
        ***REMOVED***;
    ***REMOVED***
    const warnOnce = createWarnOnce();

    /**
     * @param {Clock***REMOVED*** clock
     * @param {number***REMOVED*** timerId
     * @param {string***REMOVED*** ttype
     */
    function clearTimer(clock, timerId, ttype) {
        if (!timerId) {
            // null appears to be allowed in most browsers, and appears to be
            // relied upon by some libraries, like Bootstrap carousel
            return;
        ***REMOVED***

        if (!clock.timers) {
            clock.timers = {***REMOVED***;
        ***REMOVED***

        // in Node, the ID is stored as the primitive value for `Timeout` objects
        // for `Immediate` objects, no ID exists, so it gets coerced to NaN
        const id = Number(timerId);

        if (Number.isNaN(id) || id < idCounterStart) {
            const handlerName = getClearHandler(ttype);

            if (clock.shouldClearNativeTimers === true) {
                const nativeHandler = clock[`_${handlerName***REMOVED***`];
                return typeof nativeHandler === "function"
                    ? nativeHandler(timerId)
                    : undefined;
            ***REMOVED***
            warnOnce(
                `FakeTimers: ${handlerName***REMOVED*** was invoked to clear a native timer instead of one created by this library.` +
                    "\nTo automatically clean-up native timers, use `shouldClearNativeTimers`."
            );
        ***REMOVED***

        if (clock.timers.hasOwnProperty(id)) {
            // check that the ID matches a timer of the correct type
            const timer = clock.timers[id];
            if (
                timer.type === ttype ||
                (timer.type === "Timeout" && ttype === "Interval") ||
                (timer.type === "Interval" && ttype === "Timeout")
            ) {
                delete clock.timers[id];
            ***REMOVED*** else {
                const clear = getClearHandler(ttype);
                const schedule = getScheduleHandler(timer.type);
                throw new Error(
                    `Cannot clear timer: timer created with ${schedule***REMOVED***() but cleared with ${clear***REMOVED***()`
                );
            ***REMOVED***
        ***REMOVED***
    ***REMOVED***

    /**
     * @param {Clock***REMOVED*** clock
     * @param {Config***REMOVED*** config
     * @returns {Timer[]***REMOVED***
     */
    function uninstall(clock, config) {
        let method, i, l;
        const installedHrTime = "_hrtime";
        const installedNextTick = "_nextTick";

        for (i = 0, l = clock.methods.length; i < l; i++) {
            method = clock.methods[i];
            if (method === "hrtime" && _global.process) {
                _global.process.hrtime = clock[installedHrTime];
            ***REMOVED*** else if (method === "nextTick" && _global.process) {
                _global.process.nextTick = clock[installedNextTick];
            ***REMOVED*** else if (method === "performance") {
                const originalPerfDescriptor = Object.getOwnPropertyDescriptor(
                    clock,
                    `_${method***REMOVED***`
                );
                if (
                    originalPerfDescriptor &&
                    originalPerfDescriptor.get &&
                    !originalPerfDescriptor.set
                ) {
                    Object.defineProperty(
                        _global,
                        method,
                        originalPerfDescriptor
                    );
                ***REMOVED*** else if (originalPerfDescriptor.configurable) {
                    _global[method] = clock[`_${method***REMOVED***`];
                ***REMOVED***
            ***REMOVED*** else {
                if (_global[method] && _global[method].hadOwnProperty) {
                    _global[method] = clock[`_${method***REMOVED***`];
                ***REMOVED*** else {
                    try {
                        delete _global[method];
                    ***REMOVED*** catch (ignore) {
                        /* eslint no-empty: "off" */
                    ***REMOVED***
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***

        if (config.shouldAdvanceTime === true) {
            _global.clearInterval(clock.attachedInterval);
        ***REMOVED***

        // Prevent multiple executions which will completely remove these props
        clock.methods = [];

        // return pending timers, to enable checking what timers remained on uninstall
        if (!clock.timers) {
            return [];
        ***REMOVED***
        return Object.keys(clock.timers).map(function mapper(key) {
            return clock.timers[key];
        ***REMOVED***);
    ***REMOVED***

    /**
     * @param {object***REMOVED*** target the target containing the method to replace
     * @param {string***REMOVED*** method the keyname of the method on the target
     * @param {Clock***REMOVED*** clock
     */
    function hijackMethod(target, method, clock) {
        clock[method].hadOwnProperty = Object.prototype.hasOwnProperty.call(
            target,
            method
        );
        clock[`_${method***REMOVED***`] = target[method];

        if (method === "Date") {
            const date = mirrorDateProperties(clock[method], target[method]);
            target[method] = date;
        ***REMOVED*** else if (method === "performance") {
            const originalPerfDescriptor = Object.getOwnPropertyDescriptor(
                target,
                method
            );
            // JSDOM has a read only performance field so we have to save/copy it differently
            if (
                originalPerfDescriptor &&
                originalPerfDescriptor.get &&
                !originalPerfDescriptor.set
            ) {
                Object.defineProperty(
                    clock,
                    `_${method***REMOVED***`,
                    originalPerfDescriptor
                );

                const perfDescriptor = Object.getOwnPropertyDescriptor(
                    clock,
                    method
                );
                Object.defineProperty(target, method, perfDescriptor);
            ***REMOVED*** else {
                target[method] = clock[method];
            ***REMOVED***
        ***REMOVED*** else {
            target[method] = function () {
                return clock[method].apply(clock, arguments);
            ***REMOVED***;

            Object.defineProperties(
                target[method],
                Object.getOwnPropertyDescriptors(clock[method])
            );
        ***REMOVED***

        target[method].clock = clock;
    ***REMOVED***

    /**
     * @param {Clock***REMOVED*** clock
     * @param {number***REMOVED*** advanceTimeDelta
     */
    function doIntervalTick(clock, advanceTimeDelta) {
        clock.tick(advanceTimeDelta);
    ***REMOVED***

    /**
     * @typedef {object***REMOVED*** Timers
     * @property {setTimeout***REMOVED*** setTimeout
     * @property {clearTimeout***REMOVED*** clearTimeout
     * @property {setInterval***REMOVED*** setInterval
     * @property {clearInterval***REMOVED*** clearInterval
     * @property {Date***REMOVED*** Date
     * @property {SetImmediate=***REMOVED*** setImmediate
     * @property {function(NodeImmediate): void=***REMOVED*** clearImmediate
     * @property {function(number[]):number[]=***REMOVED*** hrtime
     * @property {NextTick=***REMOVED*** nextTick
     * @property {Performance=***REMOVED*** performance
     * @property {RequestAnimationFrame=***REMOVED*** requestAnimationFrame
     * @property {boolean=***REMOVED*** queueMicrotask
     * @property {function(number): void=***REMOVED*** cancelAnimationFrame
     * @property {RequestIdleCallback=***REMOVED*** requestIdleCallback
     * @property {function(number): void=***REMOVED*** cancelIdleCallback
     */

    /** @type {Timers***REMOVED*** */
    const timers = {
        setTimeout: _global.setTimeout,
        clearTimeout: _global.clearTimeout,
        setInterval: _global.setInterval,
        clearInterval: _global.clearInterval,
        Date: _global.Date,
    ***REMOVED***;

    if (setImmediatePresent) {
        timers.setImmediate = _global.setImmediate;
        timers.clearImmediate = _global.clearImmediate;
    ***REMOVED***

    if (hrtimePresent) {
        timers.hrtime = _global.process.hrtime;
    ***REMOVED***

    if (nextTickPresent) {
        timers.nextTick = _global.process.nextTick;
    ***REMOVED***

    if (performancePresent) {
        timers.performance = _global.performance;
    ***REMOVED***

    if (requestAnimationFramePresent) {
        timers.requestAnimationFrame = _global.requestAnimationFrame;
    ***REMOVED***

    if (queueMicrotaskPresent) {
        timers.queueMicrotask = true;
    ***REMOVED***

    if (cancelAnimationFramePresent) {
        timers.cancelAnimationFrame = _global.cancelAnimationFrame;
    ***REMOVED***

    if (requestIdleCallbackPresent) {
        timers.requestIdleCallback = _global.requestIdleCallback;
    ***REMOVED***

    if (cancelIdleCallbackPresent) {
        timers.cancelIdleCallback = _global.cancelIdleCallback;
    ***REMOVED***

    const originalSetTimeout = _global.setImmediate || _global.setTimeout;

    /**
     * @param {Date|number***REMOVED*** [start] the system time - non-integer values are floored
     * @param {number***REMOVED*** [loopLimit] maximum number of timers that will be run when calling runAll()
     * @returns {Clock***REMOVED***
     */
    function createClock(start, loopLimit) {
        // eslint-disable-next-line no-param-reassign
        start = Math.floor(getEpoch(start));
        // eslint-disable-next-line no-param-reassign
        loopLimit = loopLimit || 1000;
        let nanos = 0;
        const adjustedSystemTime = [0, 0]; // [millis, nanoremainder]

        if (NativeDate === undefined) {
            throw new Error(
                "The global scope doesn't have a `Date` object" +
                    " (see https://github.com/sinonjs/sinon/issues/1852#issuecomment-419622780)"
            );
        ***REMOVED***

        const clock = {
            now: start,
            Date: createDate(),
            loopLimit: loopLimit,
        ***REMOVED***;

        clock.Date.clock = clock;

        //eslint-disable-next-line jsdoc/require-jsdoc
        function getTimeToNextFrame() {
            return 16 - ((clock.now - start) % 16);
        ***REMOVED***

        //eslint-disable-next-line jsdoc/require-jsdoc
        function hrtime(prev) {
            const millisSinceStart = clock.now - adjustedSystemTime[0] - start;
            const secsSinceStart = Math.floor(millisSinceStart / 1000);
            const remainderInNanos =
                (millisSinceStart - secsSinceStart * 1e3) * 1e6 +
                nanos -
                adjustedSystemTime[1];

            if (Array.isArray(prev)) {
                if (prev[1] > 1e9) {
                    throw new TypeError(
                        "Number of nanoseconds can't exceed a billion"
                    );
                ***REMOVED***

                const oldSecs = prev[0];
                let nanoDiff = remainderInNanos - prev[1];
                let secDiff = secsSinceStart - oldSecs;

                if (nanoDiff < 0) {
                    nanoDiff += 1e9;
                    secDiff -= 1;
                ***REMOVED***

                return [secDiff, nanoDiff];
            ***REMOVED***
            return [secsSinceStart, remainderInNanos];
        ***REMOVED***

        if (hrtimeBigintPresent) {
            hrtime.bigint = function () {
                const parts = hrtime();
                return BigInt(parts[0]) * BigInt(1e9) + BigInt(parts[1]); // eslint-disable-line
            ***REMOVED***;
        ***REMOVED***

        clock.requestIdleCallback = function requestIdleCallback(
            func,
            timeout
        ) {
            let timeToNextIdlePeriod = 0;

            if (clock.countTimers() > 0) {
                timeToNextIdlePeriod = 50; // const for now
            ***REMOVED***

            const result = addTimer(clock, {
                func: func,
                args: Array.prototype.slice.call(arguments, 2),
                delay:
                    typeof timeout === "undefined"
                        ? timeToNextIdlePeriod
                        : Math.min(timeout, timeToNextIdlePeriod),
                idleCallback: true,
            ***REMOVED***);

            return Number(result);
        ***REMOVED***;

        clock.cancelIdleCallback = function cancelIdleCallback(timerId) {
            return clearTimer(clock, timerId, "IdleCallback");
        ***REMOVED***;

        clock.setTimeout = function setTimeout(func, timeout) {
            return addTimer(clock, {
                func: func,
                args: Array.prototype.slice.call(arguments, 2),
                delay: timeout,
            ***REMOVED***);
        ***REMOVED***;
        if (typeof _global.Promise !== "undefined" && utilPromisify) {
            clock.setTimeout[
                utilPromisify.custom
            ] = function promisifiedSetTimeout(timeout, arg) {
                return new _global.Promise(function setTimeoutExecutor(
                    resolve
                ) {
                    addTimer(clock, {
                        func: resolve,
                        args: [arg],
                        delay: timeout,
                    ***REMOVED***);
                ***REMOVED***);
            ***REMOVED***;
        ***REMOVED***

        clock.clearTimeout = function clearTimeout(timerId) {
            return clearTimer(clock, timerId, "Timeout");
        ***REMOVED***;

        clock.nextTick = function nextTick(func) {
            return enqueueJob(clock, {
                func: func,
                args: Array.prototype.slice.call(arguments, 1),
                error: isNearInfiniteLimit ? new Error() : null,
            ***REMOVED***);
        ***REMOVED***;

        clock.queueMicrotask = function queueMicrotask(func) {
            return clock.nextTick(func); // explicitly drop additional arguments
        ***REMOVED***;

        clock.setInterval = function setInterval(func, timeout) {
            // eslint-disable-next-line no-param-reassign
            timeout = parseInt(timeout, 10);
            return addTimer(clock, {
                func: func,
                args: Array.prototype.slice.call(arguments, 2),
                delay: timeout,
                interval: timeout,
            ***REMOVED***);
        ***REMOVED***;

        clock.clearInterval = function clearInterval(timerId) {
            return clearTimer(clock, timerId, "Interval");
        ***REMOVED***;

        if (setImmediatePresent) {
            clock.setImmediate = function setImmediate(func) {
                return addTimer(clock, {
                    func: func,
                    args: Array.prototype.slice.call(arguments, 1),
                    immediate: true,
                ***REMOVED***);
            ***REMOVED***;

            if (typeof _global.Promise !== "undefined" && utilPromisify) {
                clock.setImmediate[
                    utilPromisify.custom
                ] = function promisifiedSetImmediate(arg) {
                    return new _global.Promise(function setImmediateExecutor(
                        resolve
                    ) {
                        addTimer(clock, {
                            func: resolve,
                            args: [arg],
                            immediate: true,
                        ***REMOVED***);
                    ***REMOVED***);
                ***REMOVED***;
            ***REMOVED***

            clock.clearImmediate = function clearImmediate(timerId) {
                return clearTimer(clock, timerId, "Immediate");
            ***REMOVED***;
        ***REMOVED***

        clock.countTimers = function countTimers() {
            return (
                Object.keys(clock.timers || {***REMOVED***).length +
                (clock.jobs || []).length
            );
        ***REMOVED***;

        clock.requestAnimationFrame = function requestAnimationFrame(func) {
            const result = addTimer(clock, {
                func: func,
                delay: getTimeToNextFrame(),
                args: [clock.now + getTimeToNextFrame()],
                animation: true,
            ***REMOVED***);

            return Number(result);
        ***REMOVED***;

        clock.cancelAnimationFrame = function cancelAnimationFrame(timerId) {
            return clearTimer(clock, timerId, "AnimationFrame");
        ***REMOVED***;

        clock.runMicrotasks = function runMicrotasks() {
            runJobs(clock);
        ***REMOVED***;

        /**
         * @param {number|string***REMOVED*** tickValue milliseconds or a string parseable by parseTime
         * @param {boolean***REMOVED*** isAsync
         * @param {Function***REMOVED*** resolve
         * @param {Function***REMOVED*** reject
         * @returns {number|undefined***REMOVED*** will return the new `now` value or nothing for async
         */
        function doTick(tickValue, isAsync, resolve, reject) {
            const msFloat =
                typeof tickValue === "number"
                    ? tickValue
                    : parseTime(tickValue);
            const ms = Math.floor(msFloat);
            const remainder = nanoRemainder(msFloat);
            let nanosTotal = nanos + remainder;
            let tickTo = clock.now + ms;

            if (msFloat < 0) {
                throw new TypeError("Negative ticks are not supported");
            ***REMOVED***

            // adjust for positive overflow
            if (nanosTotal >= 1e6) {
                tickTo += 1;
                nanosTotal -= 1e6;
            ***REMOVED***

            nanos = nanosTotal;
            let tickFrom = clock.now;
            let previous = clock.now;
            // ESLint fails to detect this correctly
            /* eslint-disable prefer-const */
            let timer,
                firstException,
                oldNow,
                nextPromiseTick,
                compensationCheck,
                postTimerCall;
            /* eslint-enable prefer-const */

            clock.duringTick = true;

            // perform microtasks
            oldNow = clock.now;
            runJobs(clock);
            if (oldNow !== clock.now) {
                // compensate for any setSystemTime() call during microtask callback
                tickFrom += clock.now - oldNow;
                tickTo += clock.now - oldNow;
            ***REMOVED***

            //eslint-disable-next-line jsdoc/require-jsdoc
            function doTickInner() {
                // perform each timer in the requested range
                timer = firstTimerInRange(clock, tickFrom, tickTo);
                // eslint-disable-next-line no-unmodified-loop-condition
                while (timer && tickFrom <= tickTo) {
                    if (clock.timers[timer.id]) {
                        tickFrom = timer.callAt;
                        clock.now = timer.callAt;
                        oldNow = clock.now;
                        try {
                            runJobs(clock);
                            callTimer(clock, timer);
                        ***REMOVED*** catch (e) {
                            firstException = firstException || e;
                        ***REMOVED***

                        if (isAsync) {
                            // finish up after native setImmediate callback to allow
                            // all native es6 promises to process their callbacks after
                            // each timer fires.
                            originalSetTimeout(nextPromiseTick);
                            return;
                        ***REMOVED***

                        compensationCheck();
                    ***REMOVED***

                    postTimerCall();
                ***REMOVED***

                // perform process.nextTick()s again
                oldNow = clock.now;
                runJobs(clock);
                if (oldNow !== clock.now) {
                    // compensate for any setSystemTime() call during process.nextTick() callback
                    tickFrom += clock.now - oldNow;
                    tickTo += clock.now - oldNow;
                ***REMOVED***
                clock.duringTick = false;

                // corner case: during runJobs new timers were scheduled which could be in the range [clock.now, tickTo]
                timer = firstTimerInRange(clock, tickFrom, tickTo);
                if (timer) {
                    try {
                        clock.tick(tickTo - clock.now); // do it all again - for the remainder of the requested range
                    ***REMOVED*** catch (e) {
                        firstException = firstException || e;
                    ***REMOVED***
                ***REMOVED*** else {
                    // no timers remaining in the requested range: move the clock all the way to the end
                    clock.now = tickTo;

                    // update nanos
                    nanos = nanosTotal;
                ***REMOVED***
                if (firstException) {
                    throw firstException;
                ***REMOVED***

                if (isAsync) {
                    resolve(clock.now);
                ***REMOVED*** else {
                    return clock.now;
                ***REMOVED***
            ***REMOVED***

            nextPromiseTick =
                isAsync &&
                function () {
                    try {
                        compensationCheck();
                        postTimerCall();
                        doTickInner();
                    ***REMOVED*** catch (e) {
                        reject(e);
                    ***REMOVED***
                ***REMOVED***;

            compensationCheck = function () {
                // compensate for any setSystemTime() call during timer callback
                if (oldNow !== clock.now) {
                    tickFrom += clock.now - oldNow;
                    tickTo += clock.now - oldNow;
                    previous += clock.now - oldNow;
                ***REMOVED***
            ***REMOVED***;

            postTimerCall = function () {
                timer = firstTimerInRange(clock, previous, tickTo);
                previous = tickFrom;
            ***REMOVED***;

            return doTickInner();
        ***REMOVED***

        /**
         * @param {string|number***REMOVED*** tickValue number of milliseconds or a human-readable value like "01:11:15"
         * @returns {number***REMOVED*** will return the new `now` value
         */
        clock.tick = function tick(tickValue) {
            return doTick(tickValue, false);
        ***REMOVED***;

        if (typeof _global.Promise !== "undefined") {
            /**
             * @param {string|number***REMOVED*** tickValue number of milliseconds or a human-readable value like "01:11:15"
             * @returns {Promise***REMOVED***
             */
            clock.tickAsync = function tickAsync(tickValue) {
                return new _global.Promise(function (resolve, reject) {
                    originalSetTimeout(function () {
                        try {
                            doTick(tickValue, true, resolve, reject);
                        ***REMOVED*** catch (e) {
                            reject(e);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***);
            ***REMOVED***;
        ***REMOVED***

        clock.next = function next() {
            runJobs(clock);
            const timer = firstTimer(clock);
            if (!timer) {
                return clock.now;
            ***REMOVED***

            clock.duringTick = true;
            try {
                clock.now = timer.callAt;
                callTimer(clock, timer);
                runJobs(clock);
                return clock.now;
            ***REMOVED*** finally {
                clock.duringTick = false;
            ***REMOVED***
        ***REMOVED***;

        if (typeof _global.Promise !== "undefined") {
            clock.nextAsync = function nextAsync() {
                return new _global.Promise(function (resolve, reject) {
                    originalSetTimeout(function () {
                        try {
                            const timer = firstTimer(clock);
                            if (!timer) {
                                resolve(clock.now);
                                return;
                            ***REMOVED***

                            let err;
                            clock.duringTick = true;
                            clock.now = timer.callAt;
                            try {
                                callTimer(clock, timer);
                            ***REMOVED*** catch (e) {
                                err = e;
                            ***REMOVED***
                            clock.duringTick = false;

                            originalSetTimeout(function () {
                                if (err) {
                                    reject(err);
                                ***REMOVED*** else {
                                    resolve(clock.now);
                                ***REMOVED***
                            ***REMOVED***);
                        ***REMOVED*** catch (e) {
                            reject(e);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***);
            ***REMOVED***;
        ***REMOVED***

        clock.runAll = function runAll() {
            let numTimers, i;
            runJobs(clock);
            for (i = 0; i < clock.loopLimit; i++) {
                if (!clock.timers) {
                    resetIsNearInfiniteLimit();
                    return clock.now;
                ***REMOVED***

                numTimers = Object.keys(clock.timers).length;
                if (numTimers === 0) {
                    resetIsNearInfiniteLimit();
                    return clock.now;
                ***REMOVED***

                clock.next();
                checkIsNearInfiniteLimit(clock, i);
            ***REMOVED***

            const excessJob = firstTimer(clock);
            throw getInfiniteLoopError(clock, excessJob);
        ***REMOVED***;

        clock.runToFrame = function runToFrame() {
            return clock.tick(getTimeToNextFrame());
        ***REMOVED***;

        if (typeof _global.Promise !== "undefined") {
            clock.runAllAsync = function runAllAsync() {
                return new _global.Promise(function (resolve, reject) {
                    let i = 0;
                    /**
                     *
                     */
                    function doRun() {
                        originalSetTimeout(function () {
                            try {
                                let numTimers;
                                if (i < clock.loopLimit) {
                                    if (!clock.timers) {
                                        resetIsNearInfiniteLimit();
                                        resolve(clock.now);
                                        return;
                                    ***REMOVED***

                                    numTimers = Object.keys(clock.timers)
                                        .length;
                                    if (numTimers === 0) {
                                        resetIsNearInfiniteLimit();
                                        resolve(clock.now);
                                        return;
                                    ***REMOVED***

                                    clock.next();

                                    i++;

                                    doRun();
                                    checkIsNearInfiniteLimit(clock, i);
                                    return;
                                ***REMOVED***

                                const excessJob = firstTimer(clock);
                                reject(getInfiniteLoopError(clock, excessJob));
                            ***REMOVED*** catch (e) {
                                reject(e);
                            ***REMOVED***
                        ***REMOVED***);
                    ***REMOVED***
                    doRun();
                ***REMOVED***);
            ***REMOVED***;
        ***REMOVED***

        clock.runToLast = function runToLast() {
            const timer = lastTimer(clock);
            if (!timer) {
                runJobs(clock);
                return clock.now;
            ***REMOVED***

            return clock.tick(timer.callAt - clock.now);
        ***REMOVED***;

        if (typeof _global.Promise !== "undefined") {
            clock.runToLastAsync = function runToLastAsync() {
                return new _global.Promise(function (resolve, reject) {
                    originalSetTimeout(function () {
                        try {
                            const timer = lastTimer(clock);
                            if (!timer) {
                                resolve(clock.now);
                            ***REMOVED***

                            resolve(clock.tickAsync(timer.callAt));
                        ***REMOVED*** catch (e) {
                            reject(e);
                        ***REMOVED***
                    ***REMOVED***);
                ***REMOVED***);
            ***REMOVED***;
        ***REMOVED***

        clock.reset = function reset() {
            nanos = 0;
            clock.timers = {***REMOVED***;
            clock.jobs = [];
            clock.now = start;
        ***REMOVED***;

        clock.setSystemTime = function setSystemTime(systemTime) {
            // determine time difference
            const newNow = getEpoch(systemTime);
            const difference = newNow - clock.now;
            let id, timer;

            adjustedSystemTime[0] = adjustedSystemTime[0] + difference;
            adjustedSystemTime[1] = adjustedSystemTime[1] + nanos;
            // update 'system clock'
            clock.now = newNow;
            nanos = 0;

            // update timers and intervals to keep them stable
            for (id in clock.timers) {
                if (clock.timers.hasOwnProperty(id)) {
                    timer = clock.timers[id];
                    timer.createdAt += difference;
                    timer.callAt += difference;
                ***REMOVED***
            ***REMOVED***
        ***REMOVED***;

        if (performancePresent) {
            clock.performance = Object.create(null);

            if (hasPerformancePrototype) {
                const proto = _global.Performance.prototype;

                Object.getOwnPropertyNames(proto).forEach(function (name) {
                    if (name.indexOf("getEntries") === 0) {
                        // match expected return type for getEntries functions
                        clock.performance[name] = NOOP_ARRAY;
                    ***REMOVED*** else {
                        clock.performance[name] = NOOP;
                    ***REMOVED***
                ***REMOVED***);
            ***REMOVED***

            clock.performance.now = function FakeTimersNow() {
                const hrt = hrtime();
                const millis = hrt[0] * 1000 + hrt[1] / 1e6;
                return millis;
            ***REMOVED***;
        ***REMOVED***

        if (hrtimePresent) {
            clock.hrtime = hrtime;
        ***REMOVED***

        return clock;
    ***REMOVED***

    /* eslint-disable complexity */

    /**
     * @param {Config=***REMOVED*** [config] Optional config
     * @returns {Clock***REMOVED***
     */
    function install(config) {
        if (
            arguments.length > 1 ||
            config instanceof Date ||
            Array.isArray(config) ||
            typeof config === "number"
        ) {
            throw new TypeError(
                `FakeTimers.install called with ${String(
                    config
                )***REMOVED*** install requires an object parameter`
            );
        ***REMOVED***

        // eslint-disable-next-line no-param-reassign
        config = typeof config !== "undefined" ? config : {***REMOVED***;
        config.shouldAdvanceTime = config.shouldAdvanceTime || false;
        config.advanceTimeDelta = config.advanceTimeDelta || 20;
        config.shouldClearNativeTimers =
            config.shouldClearNativeTimers || false;

        if (config.target) {
            throw new TypeError(
                "config.target is no longer supported. Use `withGlobal(target)` instead."
            );
        ***REMOVED***

        let i, l;
        const clock = createClock(config.now, config.loopLimit);
        clock.shouldClearNativeTimers = config.shouldClearNativeTimers;

        clock.uninstall = function () {
            return uninstall(clock, config);
        ***REMOVED***;

        clock.methods = config.toFake || [];

        if (clock.methods.length === 0) {
            // do not fake nextTick by default - GitHub#126
            clock.methods = Object.keys(timers).filter(function (key) {
                return key !== "nextTick" && key !== "queueMicrotask";
            ***REMOVED***);
        ***REMOVED***

        if (config.shouldAdvanceTime === true) {
            const intervalTick = doIntervalTick.bind(
                null,
                clock,
                config.advanceTimeDelta
            );
            const intervalId = _global.setInterval(
                intervalTick,
                config.advanceTimeDelta
            );
            clock.attachedInterval = intervalId;
        ***REMOVED***

        for (i = 0, l = clock.methods.length; i < l; i++) {
            const nameOfMethodToReplace = clock.methods[i];
            if (nameOfMethodToReplace === "hrtime") {
                if (
                    _global.process &&
                    typeof _global.process.hrtime === "function"
                ) {
                    hijackMethod(_global.process, nameOfMethodToReplace, clock);
                ***REMOVED***
            ***REMOVED*** else if (nameOfMethodToReplace === "nextTick") {
                if (
                    _global.process &&
                    typeof _global.process.nextTick === "function"
                ) {
                    hijackMethod(_global.process, nameOfMethodToReplace, clock);
                ***REMOVED***
            ***REMOVED*** else {
                hijackMethod(_global, nameOfMethodToReplace, clock);
            ***REMOVED***
        ***REMOVED***

        return clock;
    ***REMOVED***

    /* eslint-enable complexity */

    return {
        timers: timers,
        createClock: createClock,
        install: install,
        withGlobal: withGlobal,
    ***REMOVED***;
***REMOVED***

/**
 * @typedef {object***REMOVED*** FakeTimers
 * @property {Timers***REMOVED*** timers
 * @property {createClock***REMOVED*** createClock
 * @property {Function***REMOVED*** install
 * @property {withGlobal***REMOVED*** withGlobal
 */

/* eslint-enable complexity */

/** @type {FakeTimers***REMOVED*** */
const defaultImplementation = withGlobal(globalObject);

exports.timers = defaultImplementation.timers;
exports.createClock = defaultImplementation.createClock;
exports.install = defaultImplementation.install;
exports.withGlobal = withGlobal;
