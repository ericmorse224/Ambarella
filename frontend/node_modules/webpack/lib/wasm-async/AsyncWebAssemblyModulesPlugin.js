/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { SyncWaterfallHook ***REMOVED*** = require("tapable");
const Compilation = require("../Compilation");
const Generator = require("../Generator");
const { tryRunOrWebpackError ***REMOVED*** = require("../HookWebpackError");
const { WEBASSEMBLY_MODULE_TYPE_ASYNC ***REMOVED*** = require("../ModuleTypeConstants");
const WebAssemblyImportDependency = require("../dependencies/WebAssemblyImportDependency");
const { compareModulesByIdOrIdentifier ***REMOVED*** = require("../util/comparators");
const memoize = require("../util/memoize");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../../declarations/WebpackOptions").OutputNormalized***REMOVED*** OutputOptions */
/** @typedef {import("../Chunk")***REMOVED*** Chunk */
/** @typedef {import("../ChunkGraph")***REMOVED*** ChunkGraph */
/** @typedef {import("../CodeGenerationResults")***REMOVED*** CodeGenerationResults */
/** @typedef {import("../Compiler")***REMOVED*** Compiler */
/** @typedef {import("../DependencyTemplates")***REMOVED*** DependencyTemplates */
/** @typedef {import("../Module")***REMOVED*** Module */
/** @typedef {import("../ModuleGraph")***REMOVED*** ModuleGraph */
/** @typedef {import("../RuntimeTemplate")***REMOVED*** RuntimeTemplate */
/** @typedef {import("../Template").RenderManifestEntry***REMOVED*** RenderManifestEntry */
/** @typedef {import("../Template").RenderManifestOptions***REMOVED*** RenderManifestOptions */
/** @typedef {import("../WebpackError")***REMOVED*** WebpackError */

const getAsyncWebAssemblyGenerator = memoize(() =>
	require("./AsyncWebAssemblyGenerator")
);
const getAsyncWebAssemblyJavascriptGenerator = memoize(() =>
	require("./AsyncWebAssemblyJavascriptGenerator")
);
const getAsyncWebAssemblyParser = memoize(() =>
	require("./AsyncWebAssemblyParser")
);

/**
 * @typedef {object***REMOVED*** WebAssemblyRenderContext
 * @property {Chunk***REMOVED*** chunk the chunk
 * @property {DependencyTemplates***REMOVED*** dependencyTemplates the dependency templates
 * @property {RuntimeTemplate***REMOVED*** runtimeTemplate the runtime template
 * @property {ModuleGraph***REMOVED*** moduleGraph the module graph
 * @property {ChunkGraph***REMOVED*** chunkGraph the chunk graph
 * @property {CodeGenerationResults***REMOVED*** codeGenerationResults results of code generation
 */

/**
 * @typedef {object***REMOVED*** CompilationHooks
 * @property {SyncWaterfallHook<[Source, Module, WebAssemblyRenderContext]>***REMOVED*** renderModuleContent
 */

/**
 * @typedef {object***REMOVED*** AsyncWebAssemblyModulesPluginOptions
 * @property {boolean=***REMOVED*** mangleImports mangle imports
 */

/** @type {WeakMap<Compilation, CompilationHooks>***REMOVED*** */
const compilationHooksMap = new WeakMap();

const PLUGIN_NAME = "AsyncWebAssemblyModulesPlugin";

class AsyncWebAssemblyModulesPlugin {
	/**
	 * @param {Compilation***REMOVED*** compilation the compilation
	 * @returns {CompilationHooks***REMOVED*** the attached hooks
	 */
	static getCompilationHooks(compilation) {
		if (!(compilation instanceof Compilation)) {
			throw new TypeError(
				"The 'compilation' argument must be an instance of Compilation"
			);
		***REMOVED***
		let hooks = compilationHooksMap.get(compilation);
		if (hooks === undefined) {
			hooks = {
				renderModuleContent: new SyncWaterfallHook([
					"source",
					"module",
					"renderContext"
				])
			***REMOVED***;
			compilationHooksMap.set(compilation, hooks);
		***REMOVED***
		return hooks;
	***REMOVED***

	/**
	 * @param {AsyncWebAssemblyModulesPluginOptions***REMOVED*** options options
	 */
	constructor(options) {
		this.options = options;
	***REMOVED***

	/**
	 * Apply the plugin
	 * @param {Compiler***REMOVED*** compiler the compiler instance
	 * @returns {void***REMOVED***
	 */
	apply(compiler) {
		compiler.hooks.compilation.tap(
			PLUGIN_NAME,
			(compilation, { normalModuleFactory ***REMOVED***) => {
				const hooks =
					AsyncWebAssemblyModulesPlugin.getCompilationHooks(compilation);
				compilation.dependencyFactories.set(
					WebAssemblyImportDependency,
					normalModuleFactory
				);

				normalModuleFactory.hooks.createParser
					.for(WEBASSEMBLY_MODULE_TYPE_ASYNC)
					.tap(PLUGIN_NAME, () => {
						const AsyncWebAssemblyParser = getAsyncWebAssemblyParser();

						return new AsyncWebAssemblyParser();
					***REMOVED***);
				normalModuleFactory.hooks.createGenerator
					.for(WEBASSEMBLY_MODULE_TYPE_ASYNC)
					.tap(PLUGIN_NAME, () => {
						const AsyncWebAssemblyJavascriptGenerator =
							getAsyncWebAssemblyJavascriptGenerator();
						const AsyncWebAssemblyGenerator = getAsyncWebAssemblyGenerator();

						return Generator.byType({
							javascript: new AsyncWebAssemblyJavascriptGenerator(
								compilation.outputOptions.webassemblyModuleFilename
							),
							webassembly: new AsyncWebAssemblyGenerator(this.options)
						***REMOVED***);
					***REMOVED***);

				compilation.hooks.renderManifest.tap(
					"WebAssemblyModulesPlugin",
					(result, options) => {
						const { moduleGraph, chunkGraph, runtimeTemplate ***REMOVED*** = compilation;
						const {
							chunk,
							outputOptions,
							dependencyTemplates,
							codeGenerationResults
						***REMOVED*** = options;

						for (const module of chunkGraph.getOrderedChunkModulesIterable(
							chunk,
							compareModulesByIdOrIdentifier(chunkGraph)
						)) {
							if (module.type === WEBASSEMBLY_MODULE_TYPE_ASYNC) {
								const filenameTemplate =
									/** @type {NonNullable<OutputOptions["webassemblyModuleFilename"]>***REMOVED*** */
									(outputOptions.webassemblyModuleFilename);

								result.push({
									render: () =>
										this.renderModule(
											module,
											{
												chunk,
												dependencyTemplates,
												runtimeTemplate,
												moduleGraph,
												chunkGraph,
												codeGenerationResults
											***REMOVED***,
											hooks
										),
									filenameTemplate,
									pathOptions: {
										module,
										runtime: chunk.runtime,
										chunkGraph
									***REMOVED***,
									auxiliary: true,
									identifier: `webassemblyAsyncModule${chunkGraph.getModuleId(
										module
									)***REMOVED***`,
									hash: chunkGraph.getModuleHash(module, chunk.runtime)
								***REMOVED***);
							***REMOVED***
						***REMOVED***

						return result;
					***REMOVED***
				);
			***REMOVED***
		);
	***REMOVED***

	/**
	 * @param {Module***REMOVED*** module the rendered module
	 * @param {WebAssemblyRenderContext***REMOVED*** renderContext options object
	 * @param {CompilationHooks***REMOVED*** hooks hooks
	 * @returns {Source***REMOVED*** the newly generated source from rendering
	 */
	renderModule(module, renderContext, hooks) {
		const { codeGenerationResults, chunk ***REMOVED*** = renderContext;
		try {
			const moduleSource = codeGenerationResults.getSource(
				module,
				chunk.runtime,
				"webassembly"
			);
			return tryRunOrWebpackError(
				() =>
					hooks.renderModuleContent.call(moduleSource, module, renderContext),
				"AsyncWebAssemblyModulesPlugin.getCompilationHooks().renderModuleContent"
			);
		***REMOVED*** catch (err) {
			/** @type {WebpackError***REMOVED*** */ (err).module = module;
			throw err;
		***REMOVED***
	***REMOVED***
***REMOVED***

module.exports = AsyncWebAssemblyModulesPlugin;
