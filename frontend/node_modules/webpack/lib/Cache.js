/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { AsyncParallelHook, AsyncSeriesBailHook, SyncHook ***REMOVED*** = require("tapable");
const {
	makeWebpackError,
	makeWebpackErrorCallback
***REMOVED*** = require("./HookWebpackError");

/** @typedef {import("./WebpackError")***REMOVED*** WebpackError */

/**
 * @typedef {object***REMOVED*** Etag
 * @property {() => string***REMOVED*** toString
 */

/**
 * @template T
 * @callback CallbackCache
 * @param {WebpackError | null***REMOVED*** err
 * @param {T=***REMOVED*** result
 * @returns {void***REMOVED***
 */

/** @typedef {EXPECTED_ANY***REMOVED*** Data */

/**
 * @callback GotHandler
 * @param {TODO***REMOVED*** result
 * @param {(err?: Error) => void***REMOVED*** callback
 * @returns {void***REMOVED***
 */

/**
 * @param {number***REMOVED*** times times
 * @param {(err?: Error) => void***REMOVED*** callback callback
 * @returns {(err?: Error) => void***REMOVED*** callback
 */
const needCalls = (times, callback) => err => {
	if (--times === 0) {
		return callback(err);
	***REMOVED***
	if (err && times > 0) {
		times = 0;
		return callback(err);
	***REMOVED***
***REMOVED***;

class Cache {
	constructor() {
		this.hooks = {
			/** @type {AsyncSeriesBailHook<[string, Etag | null, GotHandler[]], Data>***REMOVED*** */
			get: new AsyncSeriesBailHook(["identifier", "etag", "gotHandlers"]),
			/** @type {AsyncParallelHook<[string, Etag | null, Data]>***REMOVED*** */
			store: new AsyncParallelHook(["identifier", "etag", "data"]),
			/** @type {AsyncParallelHook<[Iterable<string>]>***REMOVED*** */
			storeBuildDependencies: new AsyncParallelHook(["dependencies"]),
			/** @type {SyncHook<[]>***REMOVED*** */
			beginIdle: new SyncHook([]),
			/** @type {AsyncParallelHook<[]>***REMOVED*** */
			endIdle: new AsyncParallelHook([]),
			/** @type {AsyncParallelHook<[]>***REMOVED*** */
			shutdown: new AsyncParallelHook([])
		***REMOVED***;
	***REMOVED***

	/**
	 * @template T
	 * @param {string***REMOVED*** identifier the cache identifier
	 * @param {Etag | null***REMOVED*** etag the etag
	 * @param {CallbackCache<T>***REMOVED*** callback signals when the value is retrieved
	 * @returns {void***REMOVED***
	 */
	get(identifier, etag, callback) {
		/** @type {GotHandler[]***REMOVED*** */
		const gotHandlers = [];
		this.hooks.get.callAsync(identifier, etag, gotHandlers, (err, result) => {
			if (err) {
				callback(makeWebpackError(err, "Cache.hooks.get"));
				return;
			***REMOVED***
			if (result === null) {
				result = undefined;
			***REMOVED***
			if (gotHandlers.length > 1) {
				const innerCallback = needCalls(gotHandlers.length, () =>
					callback(null, result)
				);
				for (const gotHandler of gotHandlers) {
					gotHandler(result, innerCallback);
				***REMOVED***
			***REMOVED*** else if (gotHandlers.length === 1) {
				gotHandlers[0](result, () => callback(null, result));
			***REMOVED*** else {
				callback(null, result);
			***REMOVED***
		***REMOVED***);
	***REMOVED***

	/**
	 * @template T
	 * @param {string***REMOVED*** identifier the cache identifier
	 * @param {Etag | null***REMOVED*** etag the etag
	 * @param {T***REMOVED*** data the value to store
	 * @param {CallbackCache<void>***REMOVED*** callback signals when the value is stored
	 * @returns {void***REMOVED***
	 */
	store(identifier, etag, data, callback) {
		this.hooks.store.callAsync(
			identifier,
			etag,
			data,
			makeWebpackErrorCallback(callback, "Cache.hooks.store")
		);
	***REMOVED***

	/**
	 * After this method has succeeded the cache can only be restored when build dependencies are
	 * @param {Iterable<string>***REMOVED*** dependencies list of all build dependencies
	 * @param {CallbackCache<void>***REMOVED*** callback signals when the dependencies are stored
	 * @returns {void***REMOVED***
	 */
	storeBuildDependencies(dependencies, callback) {
		this.hooks.storeBuildDependencies.callAsync(
			dependencies,
			makeWebpackErrorCallback(callback, "Cache.hooks.storeBuildDependencies")
		);
	***REMOVED***

	/**
	 * @returns {void***REMOVED***
	 */
	beginIdle() {
		this.hooks.beginIdle.call();
	***REMOVED***

	/**
	 * @param {CallbackCache<void>***REMOVED*** callback signals when the call finishes
	 * @returns {void***REMOVED***
	 */
	endIdle(callback) {
		this.hooks.endIdle.callAsync(
			makeWebpackErrorCallback(callback, "Cache.hooks.endIdle")
		);
	***REMOVED***

	/**
	 * @param {CallbackCache<void>***REMOVED*** callback signals when the call finishes
	 * @returns {void***REMOVED***
	 */
	shutdown(callback) {
		this.hooks.shutdown.callAsync(
			makeWebpackErrorCallback(callback, "Cache.hooks.shutdown")
		);
	***REMOVED***
***REMOVED***

Cache.STAGE_MEMORY = -10;
Cache.STAGE_DEFAULT = 0;
Cache.STAGE_DISK = 10;
Cache.STAGE_NETWORK = 20;

module.exports = Cache;
