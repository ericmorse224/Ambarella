/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const { parseResource ***REMOVED*** = require("../util/identifier");

/** @typedef {import("estree").Expression***REMOVED*** Expression */
/** @typedef {import("../../declarations/WebpackOptions").JavascriptParserOptions***REMOVED*** JavascriptParserOptions */
/** @typedef {import("../../declarations/WebpackOptions").ModuleOptionsNormalized***REMOVED*** ModuleOptions */
/** @typedef {import("../Dependency").DependencyLocation***REMOVED*** DependencyLocation */
/** @typedef {import("../javascript/BasicEvaluatedExpression")***REMOVED*** BasicEvaluatedExpression */
/** @typedef {import("../javascript/JavascriptParser")***REMOVED*** JavascriptParser */
/** @typedef {import("../javascript/JavascriptParser").Range***REMOVED*** Range */
/** @typedef {import("./ContextDependency")***REMOVED*** ContextDependency */
/** @typedef {import("./ContextDependency").ContextDependencyOptions***REMOVED*** ContextDependencyOptions */

/**
 * Escapes regular expression metacharacters
 * @param {string***REMOVED*** str String to quote
 * @returns {string***REMOVED*** Escaped string
 */
const quoteMeta = str => str.replace(/[-[\]\\/{***REMOVED***()*+?.^$|]/g, "\\$&");

/**
 * @param {string***REMOVED*** prefix prefix
 * @returns {{prefix: string, context: string***REMOVED******REMOVED*** result
 */
const splitContextFromPrefix = prefix => {
	const idx = prefix.lastIndexOf("/");
	let context = ".";
	if (idx >= 0) {
		context = prefix.slice(0, idx);
		prefix = `.${prefix.slice(idx)***REMOVED***`;
	***REMOVED***
	return {
		context,
		prefix
	***REMOVED***;
***REMOVED***;

/** @typedef {Partial<Omit<ContextDependencyOptions, "resource">>***REMOVED*** PartialContextDependencyOptions */
/** @typedef {{ new(options: ContextDependencyOptions, range: Range, valueRange: Range, ...args: any[]): ContextDependency ***REMOVED******REMOVED*** ContextDependencyConstructor */

/**
 * @param {ContextDependencyConstructor***REMOVED*** Dep the Dependency class
 * @param {Range***REMOVED*** range source range
 * @param {BasicEvaluatedExpression***REMOVED*** param context param
 * @param {Expression***REMOVED*** expr expr
 * @param {Pick<JavascriptParserOptions, `${"expr"|"wrapped"***REMOVED***Context${"Critical"|"Recursive"|"RegExp"***REMOVED***` | "exprContextRequest">***REMOVED*** options options for context creation
 * @param {PartialContextDependencyOptions***REMOVED*** contextOptions options for the ContextModule
 * @param {JavascriptParser***REMOVED*** parser the parser
 * @param {...EXPECTED_ANY***REMOVED*** depArgs depArgs
 * @returns {ContextDependency***REMOVED*** the created Dependency
 */
module.exports.create = (
	Dep,
	range,
	param,
	expr,
	options,
	contextOptions,
	parser,
	...depArgs
) => {
	if (param.isTemplateString()) {
		const quasis = /** @type {BasicEvaluatedExpression[]***REMOVED*** */ (param.quasis);
		const prefixRaw = /** @type {string***REMOVED*** */ (quasis[0].string);
		const postfixRaw =
			/** @type {string***REMOVED*** */
			(quasis.length > 1 ? quasis[quasis.length - 1].string : "");

		const valueRange = /** @type {Range***REMOVED*** */ (param.range);
		const { context, prefix ***REMOVED*** = splitContextFromPrefix(prefixRaw);
		const {
			path: postfix,
			query,
			fragment
		***REMOVED*** = parseResource(postfixRaw, parser);

		// When there are more than two quasis, the generated RegExp can be more precise
		// We join the quasis with the expression regexp
		const innerQuasis = quasis.slice(1, -1);
		const innerRegExp =
			/** @type {RegExp***REMOVED*** */ (options.wrappedContextRegExp).source +
			innerQuasis
				.map(
					q =>
						quoteMeta(/** @type {string***REMOVED*** */ (q.string)) +
						/** @type {RegExp***REMOVED*** */ (options.wrappedContextRegExp).source
				)
				.join("");

		// Example: `./context/pre${e***REMOVED***inner${e***REMOVED***inner2${e***REMOVED***post?query#frag`
		// context: "./context"
		// prefix: "./pre"
		// innerQuasis: [BEE("inner"), BEE("inner2")]
		// (BEE = BasicEvaluatedExpression)
		// postfix: "post"
		// query: "?query"
		// fragment: "#frag"
		// regExp: /^\.\/pre.*inner.*inner2.*post$/
		const regExp = new RegExp(
			`^${quoteMeta(prefix)***REMOVED***${innerRegExp***REMOVED***${quoteMeta(postfix)***REMOVED***$`
		);
		const dep = new Dep(
			{
				request: context + query + fragment,
				recursive: /** @type {boolean***REMOVED*** */ (options.wrappedContextRecursive),
				regExp,
				mode: "sync",
				...contextOptions
			***REMOVED***,
			range,
			valueRange,
			...depArgs
		);
		dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expr.loc);

		/** @type {{ value: string, range: Range ***REMOVED***[]***REMOVED*** */
		const replaces = [];
		const parts = /** @type {BasicEvaluatedExpression[]***REMOVED*** */ (param.parts);

		for (const [i, part] of parts.entries()) {
			if (i % 2 === 0) {
				// Quasis or merged quasi
				let range = /** @type {Range***REMOVED*** */ (part.range);
				let value = /** @type {string***REMOVED*** */ (part.string);
				if (param.templateStringKind === "cooked") {
					value = JSON.stringify(value);
					value = value.slice(1, -1);
				***REMOVED***
				if (i === 0) {
					// prefix
					value = prefix;
					range = [
						/** @type {Range***REMOVED*** */ (param.range)[0],
						/** @type {Range***REMOVED*** */ (part.range)[1]
					];
					value =
						(param.templateStringKind === "cooked" ? "`" : "String.raw`") +
						value;
				***REMOVED*** else if (i === parts.length - 1) {
					// postfix
					value = postfix;
					range = [
						/** @type {Range***REMOVED*** */ (part.range)[0],
						/** @type {Range***REMOVED*** */ (param.range)[1]
					];
					value = `${value***REMOVED***\``;
				***REMOVED*** else if (
					part.expression &&
					part.expression.type === "TemplateElement" &&
					part.expression.value.raw === value
				) {
					// Shortcut when it's a single quasi and doesn't need to be replaced
					continue;
				***REMOVED***
				replaces.push({
					range,
					value
				***REMOVED***);
			***REMOVED*** else {
				// Expression
				parser.walkExpression(
					/** @type {Expression***REMOVED*** */
					(part.expression)
				);
			***REMOVED***
		***REMOVED***

		dep.replaces = replaces;
		dep.critical =
			options.wrappedContextCritical &&
			"a part of the request of a dependency is an expression";
		return dep;
	***REMOVED*** else if (
		param.isWrapped() &&
		((param.prefix && param.prefix.isString()) ||
			(param.postfix && param.postfix.isString()))
	) {
		const prefixRaw =
			/** @type {string***REMOVED*** */
			(param.prefix && param.prefix.isString() ? param.prefix.string : "");
		const postfixRaw =
			/** @type {string***REMOVED*** */
			(param.postfix && param.postfix.isString() ? param.postfix.string : "");
		const prefixRange =
			param.prefix && param.prefix.isString() ? param.prefix.range : null;
		const postfixRange =
			param.postfix && param.postfix.isString() ? param.postfix.range : null;
		const valueRange = /** @type {Range***REMOVED*** */ (param.range);
		const { context, prefix ***REMOVED*** = splitContextFromPrefix(prefixRaw);
		const {
			path: postfix,
			query,
			fragment
		***REMOVED*** = parseResource(postfixRaw, parser);
		const regExp = new RegExp(
			`^${quoteMeta(prefix)***REMOVED***${
				/** @type {RegExp***REMOVED*** */ (options.wrappedContextRegExp).source
			***REMOVED***${quoteMeta(postfix)***REMOVED***$`
		);
		const dep = new Dep(
			{
				request: context + query + fragment,
				recursive: /** @type {boolean***REMOVED*** */ (options.wrappedContextRecursive),
				regExp,
				mode: "sync",
				...contextOptions
			***REMOVED***,
			range,
			valueRange,
			...depArgs
		);
		dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expr.loc);
		const replaces = [];
		if (prefixRange) {
			replaces.push({
				range: prefixRange,
				value: JSON.stringify(prefix)
			***REMOVED***);
		***REMOVED***
		if (postfixRange) {
			replaces.push({
				range: postfixRange,
				value: JSON.stringify(postfix)
			***REMOVED***);
		***REMOVED***
		dep.replaces = replaces;
		dep.critical =
			options.wrappedContextCritical &&
			"a part of the request of a dependency is an expression";

		if (parser && param.wrappedInnerExpressions) {
			for (const part of param.wrappedInnerExpressions) {
				if (part.expression)
					parser.walkExpression(
						/** @type {Expression***REMOVED*** */
						(part.expression)
					);
			***REMOVED***
		***REMOVED***

		return dep;
	***REMOVED***
	const dep = new Dep(
		{
			request: /** @type {string***REMOVED*** */ (options.exprContextRequest),
			recursive: /** @type {boolean***REMOVED*** */ (options.exprContextRecursive),
			regExp: /** @type {RegExp***REMOVED*** */ (options.exprContextRegExp),
			mode: "sync",
			...contextOptions
		***REMOVED***,
		range,
		/** @type {Range***REMOVED*** */ (param.range),
		...depArgs
	);
	dep.loc = /** @type {DependencyLocation***REMOVED*** */ (expr.loc);
	dep.critical =
		options.exprContextCritical &&
		"the request of a dependency is an expression";

	parser.walkExpression(/** @type {Expression***REMOVED*** */ (param.expression));

	return dep;
***REMOVED***;
