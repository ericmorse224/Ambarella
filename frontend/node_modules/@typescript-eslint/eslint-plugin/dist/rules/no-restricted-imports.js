"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod ***REMOVED***;
***REMOVED***;
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const ignore_1 = __importDefault(require("ignore"));
const util_1 = require("../util");
const getESLintCoreRule_1 = require("../util/getESLintCoreRule");
const baseRule = (0, getESLintCoreRule_1.getESLintCoreRule)('no-restricted-imports');
const allowTypeImportsOptionSchema = {
    allowTypeImports: {
        type: 'boolean',
        default: false,
    ***REMOVED***,
***REMOVED***;
const schemaForMergeArrayOfStringsOrObjects = {
    items: {
        anyOf: [
            {***REMOVED***,
            {
                properties: allowTypeImportsOptionSchema,
            ***REMOVED***,
        ],
    ***REMOVED***,
***REMOVED***;
const schemaForMergeArrayOfStringsOrObjectPatterns = {
    anyOf: [
        {***REMOVED***,
        {
            items: {
                properties: allowTypeImportsOptionSchema,
            ***REMOVED***,
        ***REMOVED***,
    ],
***REMOVED***;
const schema = (0, util_1.deepMerge)(Object.assign({***REMOVED***, baseRule.meta.schema), {
    anyOf: [
        schemaForMergeArrayOfStringsOrObjects,
        {
            items: {
                properties: {
                    paths: schemaForMergeArrayOfStringsOrObjects,
                    patterns: schemaForMergeArrayOfStringsOrObjectPatterns,
                ***REMOVED***,
            ***REMOVED***,
        ***REMOVED***,
    ],
***REMOVED***);
function isObjectOfPaths(obj) {
    return Object.prototype.hasOwnProperty.call(obj, 'paths');
***REMOVED***
function isObjectOfPatterns(obj) {
    return Object.prototype.hasOwnProperty.call(obj, 'patterns');
***REMOVED***
function isOptionsArrayOfStringOrObject(options) {
    if (isObjectOfPaths(options[0])) {
        return false;
    ***REMOVED***
    if (isObjectOfPatterns(options[0])) {
        return false;
    ***REMOVED***
    return true;
***REMOVED***
function getRestrictedPaths(options) {
    if (isOptionsArrayOfStringOrObject(options)) {
        return options;
    ***REMOVED***
    if (isObjectOfPaths(options[0])) {
        return options[0].paths;
    ***REMOVED***
    return [];
***REMOVED***
function getRestrictedPatterns(options) {
    if (isObjectOfPatterns(options[0])) {
        return options[0].patterns;
    ***REMOVED***
    return [];
***REMOVED***
exports.default = (0, util_1.createRule)({
    name: 'no-restricted-imports',
    meta: {
        type: 'suggestion',
        docs: {
            description: 'Disallow specified modules when loaded by `import`',
            recommended: false,
            extendsBaseRule: true,
        ***REMOVED***,
        messages: baseRule.meta.messages,
        fixable: baseRule.meta.fixable,
        schema,
    ***REMOVED***,
    defaultOptions: [],
    create(context) {
        const rules = baseRule.create(context);
        const { options ***REMOVED*** = context;
        if (options.length === 0) {
            return {***REMOVED***;
        ***REMOVED***
        const restrictedPaths = getRestrictedPaths(options);
        const allowedTypeImportPathNameSet = new Set();
        for (const restrictedPath of restrictedPaths) {
            if (typeof restrictedPath === 'object' &&
                restrictedPath.allowTypeImports) {
                allowedTypeImportPathNameSet.add(restrictedPath.name);
            ***REMOVED***
        ***REMOVED***
        function isAllowedTypeImportPath(importSource) {
            return allowedTypeImportPathNameSet.has(importSource);
        ***REMOVED***
        const restrictedPatterns = getRestrictedPatterns(options);
        const allowedImportTypeMatchers = [];
        for (const restrictedPattern of restrictedPatterns) {
            if (typeof restrictedPattern === 'object' &&
                restrictedPattern.allowTypeImports) {
                // Following how ignore is configured in the base rule
                allowedImportTypeMatchers.push((0, ignore_1.default)({
                    allowRelativePaths: true,
                    ignoreCase: !restrictedPattern.caseSensitive,
                ***REMOVED***).add(restrictedPattern.group));
            ***REMOVED***
        ***REMOVED***
        function isAllowedTypeImportPattern(importSource) {
            return (
            // As long as there's one matching pattern that allows type import
            allowedImportTypeMatchers.some(matcher => matcher.ignores(importSource)));
        ***REMOVED***
        return {
            ImportDeclaration(node) {
                if (node.importKind === 'type') {
                    const importSource = node.source.value.trim();
                    if (!isAllowedTypeImportPath(importSource) &&
                        !isAllowedTypeImportPattern(importSource)) {
                        return rules.ImportDeclaration(node);
                    ***REMOVED***
                ***REMOVED***
                else {
                    return rules.ImportDeclaration(node);
                ***REMOVED***
            ***REMOVED***,
            'ExportNamedDeclaration[source]'(node) {
                if (node.exportKind === 'type') {
                    const importSource = node.source.value.trim();
                    if (!isAllowedTypeImportPath(importSource) &&
                        !isAllowedTypeImportPattern(importSource)) {
                        return rules.ExportNamedDeclaration(node);
                    ***REMOVED***
                ***REMOVED***
                else {
                    return rules.ExportNamedDeclaration(node);
                ***REMOVED***
            ***REMOVED***,
            ExportAllDeclaration: rules.ExportAllDeclaration,
        ***REMOVED***;
    ***REMOVED***,
***REMOVED***);
//# sourceMappingURL=no-restricted-imports.js.map