'use strict'

let { nanoid ***REMOVED*** = require('nanoid/non-secure')
let { isAbsolute, resolve ***REMOVED*** = require('path')
let { SourceMapConsumer, SourceMapGenerator ***REMOVED*** = require('source-map-js')
let { fileURLToPath, pathToFileURL ***REMOVED*** = require('url')

let CssSyntaxError = require('./css-syntax-error')
let PreviousMap = require('./previous-map')
let terminalHighlight = require('./terminal-highlight')

let fromOffsetCache = Symbol('fromOffsetCache')

let sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator)
let pathAvailable = Boolean(resolve && isAbsolute)

class Input {
  get from() {
    return this.file || this.id
  ***REMOVED***

  constructor(css, opts = {***REMOVED***) {
    if (
      css === null ||
      typeof css === 'undefined' ||
      (typeof css === 'object' && !css.toString)
    ) {
      throw new Error(`PostCSS received ${css***REMOVED*** instead of CSS string`)
    ***REMOVED***

    this.css = css.toString()

    if (this.css[0] === '\uFEFF' || this.css[0] === '\uFFFE') {
      this.hasBOM = true
      this.css = this.css.slice(1)
    ***REMOVED*** else {
      this.hasBOM = false
    ***REMOVED***

    this.document = this.css
    if (opts.document) this.document = opts.document.toString()

    if (opts.from) {
      if (
        !pathAvailable ||
        /^\w+:\/\//.test(opts.from) ||
        isAbsolute(opts.from)
      ) {
        this.file = opts.from
      ***REMOVED*** else {
        this.file = resolve(opts.from)
      ***REMOVED***
    ***REMOVED***

    if (pathAvailable && sourceMapAvailable) {
      let map = new PreviousMap(this.css, opts)
      if (map.text) {
        this.map = map
        let file = map.consumer().file
        if (!this.file && file) this.file = this.mapResolve(file)
      ***REMOVED***
    ***REMOVED***

    if (!this.file) {
      this.id = '<input css ' + nanoid(6) + '>'
    ***REMOVED***
    if (this.map) this.map.file = this.from
  ***REMOVED***

  error(message, line, column, opts = {***REMOVED***) {
    let endColumn, endLine, result

    if (line && typeof line === 'object') {
      let start = line
      let end = column
      if (typeof start.offset === 'number') {
        let pos = this.fromOffset(start.offset)
        line = pos.line
        column = pos.col
      ***REMOVED*** else {
        line = start.line
        column = start.column
      ***REMOVED***
      if (typeof end.offset === 'number') {
        let pos = this.fromOffset(end.offset)
        endLine = pos.line
        endColumn = pos.col
      ***REMOVED*** else {
        endLine = end.line
        endColumn = end.column
      ***REMOVED***
    ***REMOVED*** else if (!column) {
      let pos = this.fromOffset(line)
      line = pos.line
      column = pos.col
    ***REMOVED***

    let origin = this.origin(line, column, endLine, endColumn)
    if (origin) {
      result = new CssSyntaxError(
        message,
        origin.endLine === undefined
          ? origin.line
          : { column: origin.column, line: origin.line ***REMOVED***,
        origin.endLine === undefined
          ? origin.column
          : { column: origin.endColumn, line: origin.endLine ***REMOVED***,
        origin.source,
        origin.file,
        opts.plugin
      )
    ***REMOVED*** else {
      result = new CssSyntaxError(
        message,
        endLine === undefined ? line : { column, line ***REMOVED***,
        endLine === undefined ? column : { column: endColumn, line: endLine ***REMOVED***,
        this.css,
        this.file,
        opts.plugin
      )
    ***REMOVED***

    result.input = { column, endColumn, endLine, line, source: this.css ***REMOVED***
    if (this.file) {
      if (pathToFileURL) {
        result.input.url = pathToFileURL(this.file).toString()
      ***REMOVED***
      result.input.file = this.file
    ***REMOVED***

    return result
  ***REMOVED***

  fromOffset(offset) {
    let lastLine, lineToIndex
    if (!this[fromOffsetCache]) {
      let lines = this.css.split('\n')
      lineToIndex = new Array(lines.length)
      let prevIndex = 0

      for (let i = 0, l = lines.length; i < l; i++) {
        lineToIndex[i] = prevIndex
        prevIndex += lines[i].length + 1
      ***REMOVED***

      this[fromOffsetCache] = lineToIndex
    ***REMOVED*** else {
      lineToIndex = this[fromOffsetCache]
    ***REMOVED***
    lastLine = lineToIndex[lineToIndex.length - 1]

    let min = 0
    if (offset >= lastLine) {
      min = lineToIndex.length - 1
    ***REMOVED*** else {
      let max = lineToIndex.length - 2
      let mid
      while (min < max) {
        mid = min + ((max - min) >> 1)
        if (offset < lineToIndex[mid]) {
          max = mid - 1
        ***REMOVED*** else if (offset >= lineToIndex[mid + 1]) {
          min = mid + 1
        ***REMOVED*** else {
          min = mid
          break
        ***REMOVED***
      ***REMOVED***
    ***REMOVED***
    return {
      col: offset - lineToIndex[min] + 1,
      line: min + 1
    ***REMOVED***
  ***REMOVED***

  mapResolve(file) {
    if (/^\w+:\/\//.test(file)) {
      return file
    ***REMOVED***
    return resolve(this.map.consumer().sourceRoot || this.map.root || '.', file)
  ***REMOVED***

  origin(line, column, endLine, endColumn) {
    if (!this.map) return false
    let consumer = this.map.consumer()

    let from = consumer.originalPositionFor({ column, line ***REMOVED***)
    if (!from.source) return false

    let to
    if (typeof endLine === 'number') {
      to = consumer.originalPositionFor({ column: endColumn, line: endLine ***REMOVED***)
    ***REMOVED***

    let fromUrl

    if (isAbsolute(from.source)) {
      fromUrl = pathToFileURL(from.source)
    ***REMOVED*** else {
      fromUrl = new URL(
        from.source,
        this.map.consumer().sourceRoot || pathToFileURL(this.map.mapFile)
      )
    ***REMOVED***

    let result = {
      column: from.column,
      endColumn: to && to.column,
      endLine: to && to.line,
      line: from.line,
      url: fromUrl.toString()
    ***REMOVED***

    if (fromUrl.protocol === 'file:') {
      if (fileURLToPath) {
        result.file = fileURLToPath(fromUrl)
      ***REMOVED*** else {
        /* c8 ignore next 2 */
        throw new Error(`file: protocol is not available in this PostCSS build`)
      ***REMOVED***
    ***REMOVED***

    let source = consumer.sourceContentFor(from.source)
    if (source) result.source = source

    return result
  ***REMOVED***

  toJSON() {
    let json = {***REMOVED***
    for (let name of ['hasBOM', 'css', 'file', 'id']) {
      if (this[name] != null) {
        json[name] = this[name]
      ***REMOVED***
    ***REMOVED***
    if (this.map) {
      json.map = { ...this.map ***REMOVED***
      if (json.map.consumerCache) {
        json.map.consumerCache = undefined
      ***REMOVED***
    ***REMOVED***
    return json
  ***REMOVED***
***REMOVED***

module.exports = Input
Input.default = Input

if (terminalHighlight && terminalHighlight.registerInput) {
  terminalHighlight.registerInput(Input)
***REMOVED***
