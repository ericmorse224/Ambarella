import type {AnySchema, AnySchemaObject, UriResolver***REMOVED*** from "../types"
import type Ajv from "../ajv"
import type {URIComponent***REMOVED*** from "fast-uri"
import {eachItem***REMOVED*** from "./util"
import * as equal from "fast-deep-equal"
import * as traverse from "json-schema-traverse"

// the hash of local references inside the schema (created by getSchemaRefs), used for inline resolution
export type LocalRefs = {[Ref in string]?: AnySchemaObject***REMOVED***

// TODO refactor to use keyword definitions
const SIMPLE_INLINED = new Set([
  "type",
  "format",
  "pattern",
  "maxLength",
  "minLength",
  "maxProperties",
  "minProperties",
  "maxItems",
  "minItems",
  "maximum",
  "minimum",
  "uniqueItems",
  "multipleOf",
  "required",
  "enum",
  "const",
])

export function inlineRef(schema: AnySchema, limit: boolean | number = true): boolean {
  if (typeof schema == "boolean") return true
  if (limit === true) return !hasRef(schema)
  if (!limit) return false
  return countKeys(schema) <= limit
***REMOVED***

const REF_KEYWORDS = new Set([
  "$ref",
  "$recursiveRef",
  "$recursiveAnchor",
  "$dynamicRef",
  "$dynamicAnchor",
])

function hasRef(schema: AnySchemaObject): boolean {
  for (const key in schema) {
    if (REF_KEYWORDS.has(key)) return true
    const sch = schema[key]
    if (Array.isArray(sch) && sch.some(hasRef)) return true
    if (typeof sch == "object" && hasRef(sch)) return true
  ***REMOVED***
  return false
***REMOVED***

function countKeys(schema: AnySchemaObject): number {
  let count = 0
  for (const key in schema) {
    if (key === "$ref") return Infinity
    count++
    if (SIMPLE_INLINED.has(key)) continue
    if (typeof schema[key] == "object") {
      eachItem(schema[key], (sch) => (count += countKeys(sch)))
    ***REMOVED***
    if (count === Infinity) return Infinity
  ***REMOVED***
  return count
***REMOVED***

export function getFullPath(resolver: UriResolver, id = "", normalize?: boolean): string {
  if (normalize !== false) id = normalizeId(id)
  const p = resolver.parse(id)
  return _getFullPath(resolver, p)
***REMOVED***

export function _getFullPath(resolver: UriResolver, p: URIComponent): string {
  const serialized = resolver.serialize(p)
  return serialized.split("#")[0] + "#"
***REMOVED***

const TRAILING_SLASH_HASH = /#\/?$/
export function normalizeId(id: string | undefined): string {
  return id ? id.replace(TRAILING_SLASH_HASH, "") : ""
***REMOVED***

export function resolveUrl(resolver: UriResolver, baseId: string, id: string): string {
  id = normalizeId(id)
  return resolver.resolve(baseId, id)
***REMOVED***

const ANCHOR = /^[a-z_][-a-z0-9._]*$/i

export function getSchemaRefs(this: Ajv, schema: AnySchema, baseId: string): LocalRefs {
  if (typeof schema == "boolean") return {***REMOVED***
  const {schemaId, uriResolver***REMOVED*** = this.opts
  const schId = normalizeId(schema[schemaId] || baseId)
  const baseIds: {[JsonPtr in string]?: string***REMOVED*** = {"": schId***REMOVED***
  const pathPrefix = getFullPath(uriResolver, schId, false)
  const localRefs: LocalRefs = {***REMOVED***
  const schemaRefs: Set<string> = new Set()

  traverse(schema, {allKeys: true***REMOVED***, (sch, jsonPtr, _, parentJsonPtr) => {
    if (parentJsonPtr === undefined) return
    const fullPath = pathPrefix + jsonPtr
    let innerBaseId = baseIds[parentJsonPtr]
    if (typeof sch[schemaId] == "string") innerBaseId = addRef.call(this, sch[schemaId])
    addAnchor.call(this, sch.$anchor)
    addAnchor.call(this, sch.$dynamicAnchor)
    baseIds[jsonPtr] = innerBaseId

    function addRef(this: Ajv, ref: string): string {
      // eslint-disable-next-line @typescript-eslint/unbound-method
      const _resolve = this.opts.uriResolver.resolve
      ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref)
      if (schemaRefs.has(ref)) throw ambiguos(ref)
      schemaRefs.add(ref)
      let schOrRef = this.refs[ref]
      if (typeof schOrRef == "string") schOrRef = this.refs[schOrRef]
      if (typeof schOrRef == "object") {
        checkAmbiguosRef(sch, schOrRef.schema, ref)
      ***REMOVED*** else if (ref !== normalizeId(fullPath)) {
        if (ref[0] === "#") {
          checkAmbiguosRef(sch, localRefs[ref], ref)
          localRefs[ref] = sch
        ***REMOVED*** else {
          this.refs[ref] = fullPath
        ***REMOVED***
      ***REMOVED***
      return ref
    ***REMOVED***

    function addAnchor(this: Ajv, anchor: unknown): void {
      if (typeof anchor == "string") {
        if (!ANCHOR.test(anchor)) throw new Error(`invalid anchor "${anchor***REMOVED***"`)
        addRef.call(this, `#${anchor***REMOVED***`)
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***)

  return localRefs

  function checkAmbiguosRef(sch1: AnySchema, sch2: AnySchema | undefined, ref: string): void {
    if (sch2 !== undefined && !equal(sch1, sch2)) throw ambiguos(ref)
  ***REMOVED***

  function ambiguos(ref: string): Error {
    return new Error(`reference "${ref***REMOVED***" resolves to more than one schema`)
  ***REMOVED***
***REMOVED***
