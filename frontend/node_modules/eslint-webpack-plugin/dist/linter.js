"use strict";

const {
  dirname,
  isAbsolute,
  join
***REMOVED*** = require('path');

const ESLintError = require('./ESLintError');

const {
  getESLint
***REMOVED*** = require('./getESLint');
/** @typedef {import('eslint').ESLint***REMOVED*** ESLint */

/** @typedef {import('eslint').ESLint.Formatter***REMOVED*** Formatter */

/** @typedef {import('eslint').ESLint.LintResult***REMOVED*** LintResult */

/** @typedef {import('webpack').Compiler***REMOVED*** Compiler */

/** @typedef {import('webpack').Compilation***REMOVED*** Compilation */

/** @typedef {import('./options').Options***REMOVED*** Options */

/** @typedef {import('./options').FormatterFunction***REMOVED*** FormatterFunction */

/** @typedef {(compilation: Compilation) => Promise<void>***REMOVED*** GenerateReport */

/** @typedef {{errors?: ESLintError, warnings?: ESLintError, generateReportAsset?: GenerateReport***REMOVED******REMOVED*** Report */

/** @typedef {() => Promise<Report>***REMOVED*** Reporter */

/** @typedef {(files: string|string[]) => void***REMOVED*** Linter */

/** @typedef {{[files: string]: LintResult***REMOVED******REMOVED*** LintResultMap */

/** @type {WeakMap<Compiler, LintResultMap>***REMOVED*** */


const resultStorage = new WeakMap();
/**
 * @param {string|undefined***REMOVED*** key
 * @param {Options***REMOVED*** options
 * @param {Compilation***REMOVED*** compilation
 * @returns {{lint: Linter, report: Reporter, threads: number***REMOVED******REMOVED***
 */

function linter(key, options, compilation) {
  /** @type {ESLint***REMOVED*** */
  let eslint;
  /** @type {(files: string|string[]) => Promise<LintResult[]>***REMOVED*** */

  let lintFiles;
  /** @type {() => Promise<void>***REMOVED*** */

  let cleanup;
  /** @type number */

  let threads;
  /** @type {Promise<LintResult[]>[]***REMOVED*** */

  const rawResults = [];
  const crossRunResultStorage = getResultStorage(compilation);

  try {
    ({
      eslint,
      lintFiles,
      cleanup,
      threads
    ***REMOVED*** = getESLint(key, options));
  ***REMOVED*** catch (e) {
    throw new ESLintError(e.message);
  ***REMOVED***

  return {
    lint,
    report,
    threads
  ***REMOVED***;
  /**
   * @param {string | string[]***REMOVED*** files
   */

  function lint(files) {
    for (const file of asList(files)) {
      delete crossRunResultStorage[file];
    ***REMOVED***

    rawResults.push(lintFiles(files).catch(e => {
      // @ts-ignore
      compilation.errors.push(new ESLintError(e.message));
      return [];
    ***REMOVED***));
  ***REMOVED***

  async function report() {
    // Filter out ignored files.
    let results = await removeIgnoredWarnings(eslint, // Get the current results, resetting the rawResults to empty
    await flatten(rawResults.splice(0, rawResults.length)));
    await cleanup();

    for (const result of results) {
      crossRunResultStorage[result.filePath] = result;
    ***REMOVED***

    results = Object.values(crossRunResultStorage); // do not analyze if there are no results or eslint config

    if (!results || results.length < 1) {
      return {***REMOVED***;
    ***REMOVED***

    const formatter = await loadFormatter(eslint, options.formatter);
    const {
      errors,
      warnings
    ***REMOVED*** = await formatResults(formatter, parseResults(options, results));
    return {
      errors,
      warnings,
      generateReportAsset
    ***REMOVED***;
    /**
     * @param {Compilation***REMOVED*** compilation
     * @returns {Promise<void>***REMOVED***
     */

    async function generateReportAsset({
      compiler
    ***REMOVED***) {
      const {
        outputReport
      ***REMOVED*** = options;
      /**
       * @param {string***REMOVED*** name
       * @param {string | Buffer***REMOVED*** content
       */

      const save = (name, content) =>
      /** @type {Promise<void>***REMOVED*** */
      new Promise((finish, bail) => {
        const {
          mkdir,
          writeFile
        ***REMOVED*** = compiler.outputFileSystem; // ensure directory exists
        // @ts-ignore - the types for `outputFileSystem` are missing the 3 arg overload

        mkdir(dirname(name), {
          recursive: true
        ***REMOVED***, err => {
          /* istanbul ignore if */
          if (err) bail(err);else writeFile(name, content, err2 => {
            /* istanbul ignore if */
            if (err2) bail(err2);else finish();
          ***REMOVED***);
        ***REMOVED***);
      ***REMOVED***);

      if (!outputReport || !outputReport.filePath) {
        return;
      ***REMOVED***

      const content = await (outputReport.formatter ? (await loadFormatter(eslint, outputReport.formatter)).format(results) : formatter.format(results));
      let {
        filePath
      ***REMOVED*** = outputReport;

      if (!isAbsolute(filePath)) {
        filePath = join(compiler.outputPath, filePath);
      ***REMOVED***

      await save(filePath, content);
    ***REMOVED***
  ***REMOVED***
***REMOVED***
/**
 * @param {Formatter***REMOVED*** formatter
 * @param {{ errors: LintResult[]; warnings: LintResult[]; ***REMOVED******REMOVED*** results
 * @returns {Promise<{errors?: ESLintError, warnings?: ESLintError***REMOVED***>***REMOVED***
 */


async function formatResults(formatter, results) {
  let errors;
  let warnings;

  if (results.warnings.length > 0) {
    warnings = new ESLintError(await formatter.format(results.warnings));
  ***REMOVED***

  if (results.errors.length > 0) {
    errors = new ESLintError(await formatter.format(results.errors));
  ***REMOVED***

  return {
    errors,
    warnings
  ***REMOVED***;
***REMOVED***
/**
 * @param {Options***REMOVED*** options
 * @param {LintResult[]***REMOVED*** results
 * @returns {{errors: LintResult[], warnings: LintResult[]***REMOVED******REMOVED***
 */


function parseResults(options, results) {
  /** @type {LintResult[]***REMOVED*** */
  const errors = [];
  /** @type {LintResult[]***REMOVED*** */

  const warnings = [];
  results.forEach(file => {
    if (fileHasErrors(file)) {
      const messages = file.messages.filter(message => options.emitError && message.severity === 2);

      if (messages.length > 0) {
        errors.push({ ...file,
          messages
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***

    if (fileHasWarnings(file)) {
      const messages = file.messages.filter(message => options.emitWarning && message.severity === 1);

      if (messages.length > 0) {
        warnings.push({ ...file,
          messages
        ***REMOVED***);
      ***REMOVED***
    ***REMOVED***
  ***REMOVED***);
  return {
    errors,
    warnings
  ***REMOVED***;
***REMOVED***
/**
 * @param {LintResult***REMOVED*** file
 * @returns {boolean***REMOVED***
 */


function fileHasErrors(file) {
  return file.errorCount > 0;
***REMOVED***
/**
 * @param {LintResult***REMOVED*** file
 * @returns {boolean***REMOVED***
 */


function fileHasWarnings(file) {
  return file.warningCount > 0;
***REMOVED***
/**
 * @param {ESLint***REMOVED*** eslint
 * @param {string|FormatterFunction=***REMOVED*** formatter
 * @returns {Promise<Formatter>***REMOVED***
 */


async function loadFormatter(eslint, formatter) {
  if (typeof formatter === 'function') {
    return {
      format: formatter
    ***REMOVED***;
  ***REMOVED***

  if (typeof formatter === 'string') {
    try {
      return eslint.loadFormatter(formatter);
    ***REMOVED*** catch (_) {// Load the default formatter.
    ***REMOVED***
  ***REMOVED***

  return eslint.loadFormatter();
***REMOVED***
/**
 * @param {ESLint***REMOVED*** eslint
 * @param {LintResult[]***REMOVED*** results
 * @returns {Promise<LintResult[]>***REMOVED***
 */


async function removeIgnoredWarnings(eslint, results) {
  const filterPromises = results.map(async result => {
    // Short circuit the call to isPathIgnored.
    //   fatal is false for ignored file warnings.
    //   ruleId is unset for internal ESLint errors.
    //   line is unset for warnings not involving file contents.
    const ignored = result.messages.length === 0 || result.warningCount === 1 && result.errorCount === 0 && !result.messages[0].fatal && !result.messages[0].ruleId && !result.messages[0].line && (await eslint.isPathIgnored(result.filePath));
    return ignored ? false : result;
  ***REMOVED***); // @ts-ignore

  return (await Promise.all(filterPromises)).filter(result => !!result);
***REMOVED***
/**
 * @param {Promise<LintResult[]>[]***REMOVED*** results
 * @returns {Promise<LintResult[]>***REMOVED***
 */


async function flatten(results) {
  /**
   * @param {LintResult[]***REMOVED*** acc
   * @param {LintResult[]***REMOVED*** list
   */
  const flat = (acc, list) => [...acc, ...list];

  return (await Promise.all(results)).reduce(flat, []);
***REMOVED***
/**
 * @param {Compilation***REMOVED*** compilation
 * @returns {LintResultMap***REMOVED***
 */


function getResultStorage({
  compiler
***REMOVED***) {
  let storage = resultStorage.get(compiler);

  if (!storage) {
    resultStorage.set(compiler, storage = {***REMOVED***);
  ***REMOVED***

  return storage;
***REMOVED***
/**
 * @param {string | string[]***REMOVED*** x
 */


function asList(x) {
  /* istanbul ignore next */
  return Array.isArray(x) ? x : [x];
***REMOVED***

module.exports = linter;