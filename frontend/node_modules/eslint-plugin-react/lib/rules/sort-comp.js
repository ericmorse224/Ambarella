/**
 * @fileoverview Enforce component methods order
 * @author Yannick Croissant
 */

'use strict';

const has = require('hasown');
const entries = require('object.entries');
const values = require('object.values');
const arrayIncludes = require('array-includes');

const Components = require('../util/Components');
const astUtil = require('../util/ast');
const docsUrl = require('../util/docsUrl');
const report = require('../util/report');

const defaultConfig = {
  order: [
    'static-methods',
    'lifecycle',
    'everything-else',
    'render',
  ],
  groups: {
    lifecycle: [
      'displayName',
      'propTypes',
      'contextTypes',
      'childContextTypes',
      'mixins',
      'statics',
      'defaultProps',
      'constructor',
      'getDefaultProps',
      'state',
      'getInitialState',
      'getChildContext',
      'getDerivedStateFromProps',
      'componentWillMount',
      'UNSAFE_componentWillMount',
      'componentDidMount',
      'componentWillReceiveProps',
      'UNSAFE_componentWillReceiveProps',
      'shouldComponentUpdate',
      'componentWillUpdate',
      'UNSAFE_componentWillUpdate',
      'getSnapshotBeforeUpdate',
      'componentDidUpdate',
      'componentDidCatch',
      'componentWillUnmount',
    ],
  ***REMOVED***,
***REMOVED***;

/**
 * Get the methods order from the default config and the user config
 * @param {Object***REMOVED*** userConfig The user configuration.
 * @returns {Array***REMOVED*** Methods order
 */
function getMethodsOrder(userConfig) {
  userConfig = userConfig || {***REMOVED***;

  const groups = Object.assign({***REMOVED***, defaultConfig.groups, userConfig.groups);
  const order = userConfig.order || defaultConfig.order;

  let config = [];
  let entry;
  for (let i = 0, j = order.length; i < j; i++) {
    entry = order[i];
    if (has(groups, entry)) {
      config = config.concat(groups[entry]);
    ***REMOVED*** else {
      config.push(entry);
    ***REMOVED***
  ***REMOVED***

  return config;
***REMOVED***

// ------------------------------------------------------------------------------
// Rule Definition
// ------------------------------------------------------------------------------

const messages = {
  unsortedProps: '{{propA***REMOVED******REMOVED*** should be placed {{position***REMOVED******REMOVED*** {{propB***REMOVED******REMOVED***',
***REMOVED***;

/** @type {import('eslint').Rule.RuleModule***REMOVED*** */
module.exports = {
  meta: {
    docs: {
      description: 'Enforce component methods order',
      category: 'Stylistic Issues',
      recommended: false,
      url: docsUrl('sort-comp'),
    ***REMOVED***,

    messages,

    schema: [{
      type: 'object',
      properties: {
        order: {
          type: 'array',
          items: {
            type: 'string',
          ***REMOVED***,
        ***REMOVED***,
        groups: {
          type: 'object',
          patternProperties: {
            '^.*$': {
              type: 'array',
              items: {
                type: 'string',
              ***REMOVED***,
            ***REMOVED***,
          ***REMOVED***,
        ***REMOVED***,
      ***REMOVED***,
      additionalProperties: false,
    ***REMOVED***],
  ***REMOVED***,

  create: Components.detect((context, components) => {
    /** @satisfies {Record<string, { node: ASTNode, score: number, closest: { distance: number, ref: { node: null | ASTNode, index: number ***REMOVED*** ***REMOVED*** ***REMOVED***>***REMOVED*** */
    const errors = {***REMOVED***;
    const methodsOrder = getMethodsOrder(context.options[0]);

    // --------------------------------------------------------------------------
    // Public
    // --------------------------------------------------------------------------

    const regExpRegExp = /\/(.*)\/([gimsuy]*)/;

    /**
     * Get indexes of the matching patterns in methods order configuration
     * @param {Object***REMOVED*** method - Method metadata.
     * @returns {Array***REMOVED*** The matching patterns indexes. Return [Infinity] if there is no match.
     */
    function getRefPropIndexes(method) {
      const methodGroupIndexes = [];

      methodsOrder.forEach((currentGroup, groupIndex) => {
        if (currentGroup === 'getters') {
          if (method.getter) {
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED*** else if (currentGroup === 'setters') {
          if (method.setter) {
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED*** else if (currentGroup === 'type-annotations') {
          if (method.typeAnnotation) {
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED*** else if (currentGroup === 'static-variables') {
          if (method.staticVariable) {
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED*** else if (currentGroup === 'static-methods') {
          if (method.staticMethod) {
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED*** else if (currentGroup === 'instance-variables') {
          if (method.instanceVariable) {
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED*** else if (currentGroup === 'instance-methods') {
          if (method.instanceMethod) {
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED*** else if (arrayIncludes([
          'displayName',
          'propTypes',
          'contextTypes',
          'childContextTypes',
          'mixins',
          'statics',
          'defaultProps',
          'constructor',
          'getDefaultProps',
          'state',
          'getInitialState',
          'getChildContext',
          'getDerivedStateFromProps',
          'componentWillMount',
          'UNSAFE_componentWillMount',
          'componentDidMount',
          'componentWillReceiveProps',
          'UNSAFE_componentWillReceiveProps',
          'shouldComponentUpdate',
          'componentWillUpdate',
          'UNSAFE_componentWillUpdate',
          'getSnapshotBeforeUpdate',
          'componentDidUpdate',
          'componentDidCatch',
          'componentWillUnmount',
          'render',
        ], currentGroup)) {
          if (currentGroup === method.name) {
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED*** else {
          // Is the group a regex?
          const isRegExp = currentGroup.match(regExpRegExp);
          if (isRegExp) {
            const isMatching = new RegExp(isRegExp[1], isRegExp[2]).test(method.name);
            if (isMatching) {
              methodGroupIndexes.push(groupIndex);
            ***REMOVED***
          ***REMOVED*** else if (currentGroup === method.name) {
            methodGroupIndexes.push(groupIndex);
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***);

      // No matching pattern, return 'everything-else' index
      if (methodGroupIndexes.length === 0) {
        const everythingElseIndex = methodsOrder.indexOf('everything-else');

        if (everythingElseIndex !== -1) {
          methodGroupIndexes.push(everythingElseIndex);
        ***REMOVED*** else {
          // No matching pattern and no 'everything-else' group
          methodGroupIndexes.push(Infinity);
        ***REMOVED***
      ***REMOVED***

      return methodGroupIndexes;
    ***REMOVED***

    /**
     * Get properties name
     * @param {Object***REMOVED*** node - Property.
     * @returns {string***REMOVED*** Property name.
     */
    function getPropertyName(node) {
      if (node.kind === 'get') {
        return 'getter functions';
      ***REMOVED***

      if (node.kind === 'set') {
        return 'setter functions';
      ***REMOVED***

      return astUtil.getPropertyName(node);
    ***REMOVED***

    /**
     * Store a new error in the error list
     * @param {Object***REMOVED*** propA - Mispositioned property.
     * @param {Object***REMOVED*** propB - Reference property.
     */
    function storeError(propA, propB) {
      // Initialize the error object if needed
      if (!errors[propA.index]) {
        errors[propA.index] = {
          node: propA.node,
          score: 0,
          closest: {
            distance: Infinity,
            ref: {
              node: null,
              index: 0,
            ***REMOVED***,
          ***REMOVED***,
        ***REMOVED***;
      ***REMOVED***
      // Increment the prop score
      errors[propA.index].score += 1;
      // Stop here if we already have pushed another node at this position
      if (getPropertyName(errors[propA.index].node) !== getPropertyName(propA.node)) {
        return;
      ***REMOVED***
      // Stop here if we already have a closer reference
      if (Math.abs(propA.index - propB.index) > errors[propA.index].closest.distance) {
        return;
      ***REMOVED***
      // Update the closest reference
      errors[propA.index].closest.distance = Math.abs(propA.index - propB.index);
      errors[propA.index].closest.ref.node = propB.node;
      errors[propA.index].closest.ref.index = propB.index;
    ***REMOVED***

    /**
     * Dedupe errors, only keep the ones with the highest score and delete the others
     */
    function dedupeErrors() {
      entries(errors).forEach((entry) => {
        const i = entry[0];
        const error = entry[1];

        const index = error.closest.ref.index;
        if (errors[index]) {
          if (error.score > errors[index].score) {
            delete errors[index];
          ***REMOVED*** else {
            delete errors[i];
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***);
    ***REMOVED***

    /**
     * Report errors
     */
    function reportErrors() {
      dedupeErrors();

      entries(errors).forEach((entry) => {
        const nodeA = entry[1].node;
        const nodeB = entry[1].closest.ref.node;
        const indexA = entry[0];
        const indexB = entry[1].closest.ref.index;

        report(context, messages.unsortedProps, 'unsortedProps', {
          node: nodeA,
          data: {
            propA: getPropertyName(nodeA),
            propB: getPropertyName(nodeB),
            position: indexA < indexB ? 'before' : 'after',
          ***REMOVED***,
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***

    /**
     * Compare two properties and find out if they are in the right order
     * @param {Array***REMOVED*** propertiesInfos Array containing all the properties metadata.
     * @param {Object***REMOVED*** propA First property name and metadata
     * @param {Object***REMOVED*** propB Second property name.
     * @returns {Object***REMOVED*** Object containing a correct true/false flag and the correct indexes for the two properties.
     */
    function comparePropsOrder(propertiesInfos, propA, propB) {
      let i;
      let j;
      let k;
      let l;
      let refIndexA;
      let refIndexB;

      // Get references indexes (the correct position) for given properties
      const refIndexesA = getRefPropIndexes(propA);
      const refIndexesB = getRefPropIndexes(propB);

      // Get current indexes for given properties
      const classIndexA = propertiesInfos.indexOf(propA);
      const classIndexB = propertiesInfos.indexOf(propB);

      // Loop around the references indexes for the 1st property
      for (i = 0, j = refIndexesA.length; i < j; i++) {
        refIndexA = refIndexesA[i];

        // Loop around the properties for the 2nd property (for comparison)
        for (k = 0, l = refIndexesB.length; k < l; k++) {
          refIndexB = refIndexesB[k];

          if (
            // Comparing the same properties
            refIndexA === refIndexB
            // 1st property is placed before the 2nd one in reference and in current component
            || ((refIndexA < refIndexB) && (classIndexA < classIndexB))
            // 1st property is placed after the 2nd one in reference and in current component
            || ((refIndexA > refIndexB) && (classIndexA > classIndexB))
          ) {
            return {
              correct: true,
              indexA: classIndexA,
              indexB: classIndexB,
            ***REMOVED***;
          ***REMOVED***
        ***REMOVED***
      ***REMOVED***

      // We did not find any correct match between reference and current component
      return {
        correct: false,
        indexA: refIndexA,
        indexB: refIndexB,
      ***REMOVED***;
    ***REMOVED***

    /**
     * Check properties order from a properties list and store the eventual errors
     * @param {Array***REMOVED*** properties Array containing all the properties.
     */
    function checkPropsOrder(properties) {
      const propertiesInfos = properties.map((node) => ({
        name: getPropertyName(node),
        getter: node.kind === 'get',
        setter: node.kind === 'set',
        staticVariable: node.static
          && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition')
          && (!node.value || !astUtil.isFunctionLikeExpression(node.value)),
        staticMethod: node.static
          && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition' || node.type === 'MethodDefinition')
          && node.value
          && (astUtil.isFunctionLikeExpression(node.value)),
        instanceVariable: !node.static
          && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition')
          && (!node.value || !astUtil.isFunctionLikeExpression(node.value)),
        instanceMethod: !node.static
          && (node.type === 'ClassProperty' || node.type === 'PropertyDefinition')
          && node.value
          && (astUtil.isFunctionLikeExpression(node.value)),
        typeAnnotation: !!node.typeAnnotation && node.value === null,
      ***REMOVED***));

      // Loop around the properties
      propertiesInfos.forEach((propA, i) => {
        // Loop around the properties a second time (for comparison)
        propertiesInfos.forEach((propB, k) => {
          if (i === k) {
            return;
          ***REMOVED***

          // Compare the properties order
          const order = comparePropsOrder(propertiesInfos, propA, propB);

          if (!order.correct) {
            // Store an error if the order is incorrect
            storeError({
              node: properties[i],
              index: order.indexA,
            ***REMOVED***, {
              node: properties[k],
              index: order.indexB,
            ***REMOVED***);
          ***REMOVED***
        ***REMOVED***);
      ***REMOVED***);
    ***REMOVED***

    return {
      'Program:exit'() {
        values(components.list()).forEach((component) => {
          const properties = astUtil.getComponentProperties(component.node);
          checkPropsOrder(properties);
        ***REMOVED***);

        reportErrors();
      ***REMOVED***,
    ***REMOVED***;
  ***REMOVED***),

  defaultConfig,
***REMOVED***;
