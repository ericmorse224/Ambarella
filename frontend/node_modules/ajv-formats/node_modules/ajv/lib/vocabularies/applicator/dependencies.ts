import type {
  CodeKeywordDefinition,
  ErrorObject,
  KeywordErrorDefinition,
  SchemaMap,
  AnySchema,
***REMOVED*** from "../../types"
import type {KeywordCxt***REMOVED*** from "../../compile/validate"
import {_, str***REMOVED*** from "../../compile/codegen"
import {alwaysValidSchema***REMOVED*** from "../../compile/util"
import {checkReportMissingProp, checkMissingProp, reportMissingProp, propertyInData***REMOVED*** from "../code"

export type PropertyDependencies = {[K in string]?: string[]***REMOVED***

export interface DependenciesErrorParams {
  property: string
  missingProperty: string
  depsCount: number
  deps: string // TODO change to string[]
***REMOVED***

type SchemaDependencies = SchemaMap

export type DependenciesError = ErrorObject<
  "dependencies",
  DependenciesErrorParams,
  {[K in string]?: string[] | AnySchema***REMOVED***
>

export const error: KeywordErrorDefinition = {
  message: ({params: {property, depsCount, deps***REMOVED******REMOVED***) => {
    const property_ies = depsCount === 1 ? "property" : "properties"
    return str`must have ${property_ies***REMOVED*** ${deps***REMOVED*** when property ${property***REMOVED*** is present`
  ***REMOVED***,
  params: ({params: {property, depsCount, deps, missingProperty***REMOVED******REMOVED***) =>
    _`{property: ${property***REMOVED***,
    missingProperty: ${missingProperty***REMOVED***,
    depsCount: ${depsCount***REMOVED***,
    deps: ${deps***REMOVED******REMOVED***`, // TODO change to reference
***REMOVED***

const def: CodeKeywordDefinition = {
  keyword: "dependencies",
  type: "object",
  schemaType: "object",
  error,
  code(cxt: KeywordCxt) {
    const [propDeps, schDeps] = splitDependencies(cxt)
    validatePropertyDeps(cxt, propDeps)
    validateSchemaDeps(cxt, schDeps)
  ***REMOVED***,
***REMOVED***

function splitDependencies({schema***REMOVED***: KeywordCxt): [PropertyDependencies, SchemaDependencies] {
  const propertyDeps: PropertyDependencies = {***REMOVED***
  const schemaDeps: SchemaDependencies = {***REMOVED***
  for (const key in schema) {
    if (key === "__proto__") continue
    const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps
    deps[key] = schema[key]
  ***REMOVED***
  return [propertyDeps, schemaDeps]
***REMOVED***

export function validatePropertyDeps(
  cxt: KeywordCxt,
  propertyDeps: {[K in string]?: string[]***REMOVED*** = cxt.schema
): void {
  const {gen, data, it***REMOVED*** = cxt
  if (Object.keys(propertyDeps).length === 0) return
  const missing = gen.let("missing")
  for (const prop in propertyDeps) {
    const deps = propertyDeps[prop] as string[]
    if (deps.length === 0) continue
    const hasProperty = propertyInData(gen, data, prop, it.opts.ownProperties)
    cxt.setParams({
      property: prop,
      depsCount: deps.length,
      deps: deps.join(", "),
    ***REMOVED***)
    if (it.allErrors) {
      gen.if(hasProperty, () => {
        for (const depProp of deps) {
          checkReportMissingProp(cxt, depProp)
        ***REMOVED***
      ***REMOVED***)
    ***REMOVED*** else {
      gen.if(_`${hasProperty***REMOVED*** && (${checkMissingProp(cxt, deps, missing)***REMOVED***)`)
      reportMissingProp(cxt, missing)
      gen.else()
    ***REMOVED***
  ***REMOVED***
***REMOVED***

export function validateSchemaDeps(cxt: KeywordCxt, schemaDeps: SchemaMap = cxt.schema): void {
  const {gen, data, keyword, it***REMOVED*** = cxt
  const valid = gen.name("valid")
  for (const prop in schemaDeps) {
    if (alwaysValidSchema(it, schemaDeps[prop] as AnySchema)) continue
    gen.if(
      propertyInData(gen, data, prop, it.opts.ownProperties),
      () => {
        const schCxt = cxt.subschema({keyword, schemaProp: prop***REMOVED***, valid)
        cxt.mergeValidEvaluated(schCxt, valid)
      ***REMOVED***,
      () => gen.var(valid, true) // TODO var
    )
    cxt.ok(valid)
  ***REMOVED***
***REMOVED***

export default def
