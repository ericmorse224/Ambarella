/* eslint-env mocha */
import assert from 'assert';
import entries from 'object.entries';
import fromEntries from 'object.fromentries';
import { getOpeningElement, setParserName, fallbackToBabylon ***REMOVED*** from '../helper';
import getProp from '../../src/getProp';

const literal = {
  source: '<div {...{ id: "foo" ***REMOVED******REMOVED*** />',
  target: '<div id="foo" />',
  offset: { keyOffset: -6, valueOffset: -7 ***REMOVED***,
***REMOVED***;

const expression1 = {
  source: '<div {...{ id ***REMOVED******REMOVED*** />',
  target: '<div id={id***REMOVED*** />',
  offset: { keyOffset: -6, valueOffset: -2 ***REMOVED***,
***REMOVED***;

const expression2 = {
  source: '<div {...{ id: `foo${bar***REMOVED***baz` ***REMOVED******REMOVED*** />', // eslint-disable-line no-template-curly-in-string
  target: '<div id={`foo${bar***REMOVED***baz`***REMOVED*** />', // eslint-disable-line no-template-curly-in-string
  offset: { keyOffset: -6, valueOffset: -6 ***REMOVED***,
***REMOVED***;

describe('getProp', () => {
  it('should create the correct AST for literal with flow parser', () => {
    actualTest('flow', literal);
  ***REMOVED***);
  it('should create the correct AST for literal with babel parser', () => {
    actualTest('babel', literal);
  ***REMOVED***);
  it('should create the correct AST for expression with flow parser (1)', () => {
    actualTest('flow', expression1);
  ***REMOVED***);
  it('should create the correct AST for expression with babel parser (1)', () => {
    actualTest('babel', expression1);
  ***REMOVED***);
  it('should create the correct AST for expression with flow parser (2)', () => {
    actualTest('flow', expression2);
  ***REMOVED***);
  it('should create the correct AST for expression with babel parser (2)', () => {
    actualTest('babel', expression2);
  ***REMOVED***);
***REMOVED***);

function actualTest(parserName, test) {
  setParserName(parserName);
  const { source, target, offset ***REMOVED*** = test;
  const sourceProps = stripConstructors(getOpeningElement(source).attributes);
  const targetProps = stripConstructors(getOpeningElement(target).attributes);
  const prop = 'id';
  const sourceResult = getProp(sourceProps, prop);
  const targetResult = getProp(targetProps, prop);

  if (fallbackToBabylon && parserName === 'babel' && test === literal) {
    // Babylon (node < 6) adds an `extra: null` prop to a literal if it is parsed from a
    // JSXAttribute, other literals don't get this.
    sourceResult.value.extra = null;
  ***REMOVED***

  assert.deepStrictEqual(
    adjustLocations(sourceResult, offset),
    adjustRange(targetResult),
  );
***REMOVED***

function adjustRange({ name, value: { expression, ...value ***REMOVED***, ...node ***REMOVED***) {
  return {
    ...adjustNodeRange(node),
    name: adjustNodeRange(name),
    value: {
      ...adjustNodeRange(value),
      ...(expression ? { expression: adjustNodeRangeRecursively(expression) ***REMOVED*** : {***REMOVED***),
    ***REMOVED***,
  ***REMOVED***;
***REMOVED***

function adjustNodeRange(node) {
  if (!node.loc) {
    return node;
  ***REMOVED***

  const [start, end] = node.range || [node.start, node.end];
  return {
    ...node,
    end: undefined,
    range: [start, end],
    start: undefined,
  ***REMOVED***;
***REMOVED***

function adjustNodeRangeRecursively(node) {
  if (Array.isArray(node)) {
    return node.map(adjustNodeRangeRecursively);
  ***REMOVED***

  if (node && typeof node === 'object') {
    return adjustNodeRange(mapValues(node, adjustNodeRangeRecursively));
  ***REMOVED***

  return node;
***REMOVED***

function stripConstructors(value) {
  return JSON.parse(JSON.stringify(value));
***REMOVED***

function adjustLocations(node, { keyOffset, valueOffset ***REMOVED***) {
  const hasExpression = !!node.value.expression;
  return {
    ...adjustNodeLocations(node, {
      startOffset: keyOffset,
      endOffset: valueOffset + (hasExpression ? 1 : 0),
    ***REMOVED***),
    name: adjustNodeLocations(node.name, { startOffset: keyOffset, endOffset: keyOffset ***REMOVED***),
    value: {
      ...adjustNodeLocations(node.value, {
        startOffset: valueOffset - (hasExpression ? 1 : 0),
        endOffset: valueOffset + (hasExpression ? 1 : 0),
      ***REMOVED***),
      ...(hasExpression
        ? {
          expression: adjustLocationsRecursively(
            node.value.expression,
            { startOffset: valueOffset, endOffset: valueOffset ***REMOVED***,
          ),
        ***REMOVED***
        : {***REMOVED***
      ),
    ***REMOVED***,
  ***REMOVED***;
***REMOVED***

function adjustNodeLocations(node, { startOffset, endOffset ***REMOVED***) {
  if (!node.loc) {
    return node;
  ***REMOVED***

  const [start, end] = node.range || [];
  return {
    ...node,
    end: undefined,
    loc: {
      ...node.loc,
      start: {
        ...node.loc.start,
        column: node.loc.start.column + startOffset,
      ***REMOVED***,
      end: {
        ...node.loc.end,
        column: node.loc.end.column + endOffset,
      ***REMOVED***,
    ***REMOVED***,
    range: [start + startOffset, end + endOffset],
    start: undefined,
  ***REMOVED***;
***REMOVED***

function adjustLocationsRecursively(node, { startOffset, endOffset ***REMOVED***) {
  if (Array.isArray(node)) {
    return node.map((x) => adjustLocationsRecursively(x, { startOffset, endOffset ***REMOVED***));
  ***REMOVED***
  if (node && typeof node === 'object') {
    return adjustNodeLocations(
      mapValues(node, (x) => adjustLocationsRecursively(x, { startOffset, endOffset ***REMOVED***)),
      { startOffset, endOffset ***REMOVED***,
    );
  ***REMOVED***

  return node;
***REMOVED***

function mapValues(o, f) {
  return fromEntries(entries(o).map(([k, v]) => [k, f(v)]));
***REMOVED***
