this.workbox=this.workbox||{***REMOVED***,this.workbox.precaching=function(t,e,s,n,i,c,r,o){"use strict";try{self["workbox:precaching:6.5.4"]&&_()***REMOVED***catch(t){***REMOVED***function a(t){if(!t)throw new s.WorkboxError("add-to-cache-list-unexpected-type",{entry:t***REMOVED***);if("string"==typeof t){const e=new URL(t,location.href);return{cacheKey:e.href,url:e.href***REMOVED******REMOVED***const{revision:e,url:n***REMOVED***=t;if(!n)throw new s.WorkboxError("add-to-cache-list-unexpected-type",{entry:t***REMOVED***);if(!e){const t=new URL(n,location.href);return{cacheKey:t.href,url:t.href***REMOVED******REMOVED***const i=new URL(n,location.href),c=new URL(n,location.href);return i.searchParams.set("__WB_REVISION__",e),{cacheKey:i.href,url:c.href***REMOVED******REMOVED***class h{constructor(){this.updatedURLs=[],this.notUpdatedURLs=[],this.handlerWillStart=async({request:t,state:e***REMOVED***)=>{e&&(e.originalRequest=t)***REMOVED***,this.cachedResponseWillBeUsed=async({event:t,state:e,cachedResponse:s***REMOVED***)=>{if("install"===t.type&&e&&e.originalRequest&&e.originalRequest instanceof Request){const t=e.originalRequest.url;s?this.notUpdatedURLs.push(t):this.updatedURLs.push(t)***REMOVED***return s***REMOVED******REMOVED******REMOVED***class l{constructor({precacheController:t***REMOVED***){this.cacheKeyWillBeUsed=async({request:t,params:e***REMOVED***)=>{const s=(null==e?void 0:e.cacheKey)||this.tt.getCacheKeyForURL(t.url);return s?new Request(s,{headers:t.headers***REMOVED***):t***REMOVED***,this.tt=t***REMOVED******REMOVED***class u extends c.Strategy{constructor(t={***REMOVED***){t.cacheName=e.cacheNames.getPrecacheName(t.cacheName),super(t),this.et=!1!==t.fallbackToNetwork,this.plugins.push(u.copyRedirectedCacheableResponsesPlugin)***REMOVED***async _handle(t,e){const s=await e.cacheMatch(t);return s||(e.event&&"install"===e.event.type?await this.st(t,e):await this.nt(t,e))***REMOVED***async nt(t,e){let n;const i=e.params||{***REMOVED***;if(!this.et)throw new s.WorkboxError("missing-precache-entry",{cacheName:this.cacheName,url:t.url***REMOVED***);{const s=i.integrity,c=t.integrity,r=!c||c===s;n=await e.fetch(new Request(t,{integrity:"no-cors"!==t.mode?c||s:void 0***REMOVED***)),s&&r&&"no-cors"!==t.mode&&(this.it(),await e.cachePut(t,n.clone()))***REMOVED***return n***REMOVED***async st(t,e){this.it();const n=await e.fetch(t);if(!await e.cachePut(t,n.clone()))throw new s.WorkboxError("bad-precaching-response",{url:t.url,status:n.status***REMOVED***);return n***REMOVED***it(){let t=null,e=0;for(const[s,n]of this.plugins.entries())n!==u.copyRedirectedCacheableResponsesPlugin&&(n===u.defaultPrecacheCacheabilityPlugin&&(t=s),n.cacheWillUpdate&&e++);0===e?this.plugins.push(u.defaultPrecacheCacheabilityPlugin):e>1&&null!==t&&this.plugins.splice(t,1)***REMOVED******REMOVED***u.defaultPrecacheCacheabilityPlugin={cacheWillUpdate:async({response:t***REMOVED***)=>!t||t.status>=400?null:t***REMOVED***,u.copyRedirectedCacheableResponsesPlugin={cacheWillUpdate:async({response:t***REMOVED***)=>t.redirected?await i.copyResponse(t):t***REMOVED***;class f{constructor({cacheName:t,plugins:s=[],fallbackToNetwork:n=!0***REMOVED***={***REMOVED***){this.ct=new Map,this.rt=new Map,this.ot=new Map,this.ht=new u({cacheName:e.cacheNames.getPrecacheName(t),plugins:[...s,new l({precacheController:this***REMOVED***)],fallbackToNetwork:n***REMOVED***),this.install=this.install.bind(this),this.activate=this.activate.bind(this)***REMOVED***get strategy(){return this.ht***REMOVED***precache(t){this.addToCacheList(t),this.lt||(self.addEventListener("install",this.install),self.addEventListener("activate",this.activate),this.lt=!0)***REMOVED***addToCacheList(t){const e=[];for(const n of t){"string"==typeof n?e.push(n):n&&void 0===n.revision&&e.push(n.url);const{cacheKey:t,url:i***REMOVED***=a(n),c="string"!=typeof n&&n.revision?"reload":"default";if(this.ct.has(i)&&this.ct.get(i)!==t)throw new s.WorkboxError("add-to-cache-list-conflicting-entries",{firstEntry:this.ct.get(i),secondEntry:t***REMOVED***);if("string"!=typeof n&&n.integrity){if(this.ot.has(t)&&this.ot.get(t)!==n.integrity)throw new s.WorkboxError("add-to-cache-list-conflicting-integrities",{url:i***REMOVED***);this.ot.set(t,n.integrity)***REMOVED***if(this.ct.set(i,t),this.rt.set(i,c),e.length>0){const t=`Workbox is precaching URLs without revision info: ${e.join(", ")***REMOVED***\nThis is generally NOT safe. Learn more at https://bit.ly/wb-precache`;console.warn(t)***REMOVED******REMOVED******REMOVED***install(t){return n.waitUntil(t,(async()=>{const e=new h;this.strategy.plugins.push(e);for(const[e,s]of this.ct){const n=this.ot.get(s),i=this.rt.get(e),c=new Request(e,{integrity:n,cache:i,credentials:"same-origin"***REMOVED***);await Promise.all(this.strategy.handleAll({params:{cacheKey:s***REMOVED***,request:c,event:t***REMOVED***))***REMOVED***const{updatedURLs:s,notUpdatedURLs:n***REMOVED***=e;return{updatedURLs:s,notUpdatedURLs:n***REMOVED******REMOVED***))***REMOVED***activate(t){return n.waitUntil(t,(async()=>{const t=await self.caches.open(this.strategy.cacheName),e=await t.keys(),s=new Set(this.ct.values()),n=[];for(const i of e)s.has(i.url)||(await t.delete(i),n.push(i.url));return{deletedURLs:n***REMOVED******REMOVED***))***REMOVED***getURLsToCacheKeys(){return this.ct***REMOVED***getCachedURLs(){return[...this.ct.keys()]***REMOVED***getCacheKeyForURL(t){const e=new URL(t,location.href);return this.ct.get(e.href)***REMOVED***getIntegrityForCacheKey(t){return this.ot.get(t)***REMOVED***async matchPrecache(t){const e=t instanceof Request?t.url:t,s=this.getCacheKeyForURL(e);if(s){return(await self.caches.open(this.strategy.cacheName)).match(s)***REMOVED******REMOVED***createHandlerBoundToURL(t){const e=this.getCacheKeyForURL(t);if(!e)throw new s.WorkboxError("non-precached-url",{url:t***REMOVED***);return s=>(s.request=new Request(t),s.params=Object.assign({cacheKey:e***REMOVED***,s.params),this.strategy.handle(s))***REMOVED******REMOVED***let w;const d=()=>(w||(w=new f),w);class y extends o.Route{constructor(t,e){super((({request:s***REMOVED***)=>{const n=t.getURLsToCacheKeys();for(const i of function*(t,{ignoreURLParametersMatching:e=[/^utm_/,/^fbclid$/],directoryIndex:s="index.html",cleanURLs:n=!0,urlManipulation:i***REMOVED***={***REMOVED***){const c=new URL(t,location.href);c.hash="",yield c.href;const r=function(t,e=[]){for(const s of[...t.searchParams.keys()])e.some((t=>t.test(s)))&&t.searchParams.delete(s);return t***REMOVED***(c,e);if(yield r.href,s&&r.pathname.endsWith("/")){const t=new URL(r.href);t.pathname+=s,yield t.href***REMOVED***if(n){const t=new URL(r.href);t.pathname+=".html",yield t.href***REMOVED***if(i){const t=i({url:c***REMOVED***);for(const e of t)yield e.href***REMOVED******REMOVED***(s.url,e)){const e=n.get(i);if(e){return{cacheKey:e,integrity:t.getIntegrityForCacheKey(e)***REMOVED******REMOVED******REMOVED******REMOVED***),t.strategy)***REMOVED******REMOVED***function p(t){const e=d(),s=new y(e,t);r.registerRoute(s)***REMOVED***function R(t){d().precache(t)***REMOVED***return t.PrecacheController=f,t.PrecacheFallbackPlugin=class{constructor({fallbackURL:t,precacheController:e***REMOVED***){this.handlerDidError=()=>this.tt.matchPrecache(this.ut),this.ut=t,this.tt=e||d()***REMOVED******REMOVED***,t.PrecacheRoute=y,t.PrecacheStrategy=u,t.addPlugins=function(t){d().strategy.plugins.push(...t)***REMOVED***,t.addRoute=p,t.cleanupOutdatedCaches=function(){self.addEventListener("activate",(t=>{const s=e.cacheNames.getPrecacheName();t.waitUntil((async(t,e="-precache-")=>{const s=(await self.caches.keys()).filter((s=>s.includes(e)&&s.includes(self.registration.scope)&&s!==t));return await Promise.all(s.map((t=>self.caches.delete(t)))),s***REMOVED***)(s).then((t=>{***REMOVED***)))***REMOVED***))***REMOVED***,t.createHandlerBoundToURL=function(t){return d().createHandlerBoundToURL(t)***REMOVED***,t.getCacheKeyForURL=function(t){return d().getCacheKeyForURL(t)***REMOVED***,t.matchPrecache=function(t){return d().matchPrecache(t)***REMOVED***,t.precache=R,t.precacheAndRoute=function(t,e){R(t),p(e)***REMOVED***,t***REMOVED***({***REMOVED***,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core,workbox.strategies,workbox.routing,workbox.routing);
//# sourceMappingURL=workbox-precaching.prod.js.map
