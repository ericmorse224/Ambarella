/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
"use strict";

const fs = require("fs");
const path = require("path");
const { EventEmitter ***REMOVED*** = require("events");
const reducePlan = require("./reducePlan");

const IS_OSX = require("os").platform() === "darwin";
const IS_WIN = require("os").platform() === "win32";
const SUPPORTS_RECURSIVE_WATCHING = IS_OSX || IS_WIN;

const watcherLimit =
	+process.env.WATCHPACK_WATCHER_LIMIT || (IS_OSX ? 2000 : 10000);

const recursiveWatcherLogging = !!process.env
	.WATCHPACK_RECURSIVE_WATCHER_LOGGING;

let isBatch = false;
let watcherCount = 0;

/** @type {Map<Watcher, string>***REMOVED*** */
const pendingWatchers = new Map();

/** @type {Map<string, RecursiveWatcher>***REMOVED*** */
const recursiveWatchers = new Map();

/** @type {Map<string, DirectWatcher>***REMOVED*** */
const directWatchers = new Map();

/** @type {Map<Watcher, RecursiveWatcher | DirectWatcher>***REMOVED*** */
const underlyingWatcher = new Map();

class DirectWatcher {
	constructor(filePath) {
		this.filePath = filePath;
		this.watchers = new Set();
		this.watcher = undefined;
		try {
			const watcher = fs.watch(filePath);
			this.watcher = watcher;
			watcher.on("change", (type, filename) => {
				for (const w of this.watchers) {
					w.emit("change", type, filename);
				***REMOVED***
			***REMOVED***);
			watcher.on("error", error => {
				for (const w of this.watchers) {
					w.emit("error", error);
				***REMOVED***
			***REMOVED***);
		***REMOVED*** catch (err) {
			process.nextTick(() => {
				for (const w of this.watchers) {
					w.emit("error", err);
				***REMOVED***
			***REMOVED***);
		***REMOVED***
		watcherCount++;
	***REMOVED***

	add(watcher) {
		underlyingWatcher.set(watcher, this);
		this.watchers.add(watcher);
	***REMOVED***

	remove(watcher) {
		this.watchers.delete(watcher);
		if (this.watchers.size === 0) {
			directWatchers.delete(this.filePath);
			watcherCount--;
			if (this.watcher) this.watcher.close();
		***REMOVED***
	***REMOVED***

	getWatchers() {
		return this.watchers;
	***REMOVED***
***REMOVED***

class RecursiveWatcher {
	constructor(rootPath) {
		this.rootPath = rootPath;
		/** @type {Map<Watcher, string>***REMOVED*** */
		this.mapWatcherToPath = new Map();
		/** @type {Map<string, Set<Watcher>>***REMOVED*** */
		this.mapPathToWatchers = new Map();
		this.watcher = undefined;
		try {
			const watcher = fs.watch(rootPath, {
				recursive: true
			***REMOVED***);
			this.watcher = watcher;
			watcher.on("change", (type, filename) => {
				if (!filename) {
					if (recursiveWatcherLogging) {
						process.stderr.write(
							`[watchpack] dispatch ${type***REMOVED*** event in recursive watcher (${this.rootPath***REMOVED***) to all watchers\n`
						);
					***REMOVED***
					for (const w of this.mapWatcherToPath.keys()) {
						w.emit("change", type);
					***REMOVED***
				***REMOVED*** else {
					const dir = path.dirname(filename);
					const watchers = this.mapPathToWatchers.get(dir);
					if (recursiveWatcherLogging) {
						process.stderr.write(
							`[watchpack] dispatch ${type***REMOVED*** event in recursive watcher (${
								this.rootPath
							***REMOVED***) for '${filename***REMOVED***' to ${
								watchers ? watchers.size : 0
							***REMOVED*** watchers\n`
						);
					***REMOVED***
					if (watchers === undefined) return;
					for (const w of watchers) {
						w.emit("change", type, path.basename(filename));
					***REMOVED***
				***REMOVED***
			***REMOVED***);
			watcher.on("error", error => {
				for (const w of this.mapWatcherToPath.keys()) {
					w.emit("error", error);
				***REMOVED***
			***REMOVED***);
		***REMOVED*** catch (err) {
			process.nextTick(() => {
				for (const w of this.mapWatcherToPath.keys()) {
					w.emit("error", err);
				***REMOVED***
			***REMOVED***);
		***REMOVED***
		watcherCount++;
		if (recursiveWatcherLogging) {
			process.stderr.write(
				`[watchpack] created recursive watcher at ${rootPath***REMOVED***\n`
			);
		***REMOVED***
	***REMOVED***

	add(filePath, watcher) {
		underlyingWatcher.set(watcher, this);
		const subpath = filePath.slice(this.rootPath.length + 1) || ".";
		this.mapWatcherToPath.set(watcher, subpath);
		const set = this.mapPathToWatchers.get(subpath);
		if (set === undefined) {
			const newSet = new Set();
			newSet.add(watcher);
			this.mapPathToWatchers.set(subpath, newSet);
		***REMOVED*** else {
			set.add(watcher);
		***REMOVED***
	***REMOVED***

	remove(watcher) {
		const subpath = this.mapWatcherToPath.get(watcher);
		if (!subpath) return;
		this.mapWatcherToPath.delete(watcher);
		const set = this.mapPathToWatchers.get(subpath);
		set.delete(watcher);
		if (set.size === 0) {
			this.mapPathToWatchers.delete(subpath);
		***REMOVED***
		if (this.mapWatcherToPath.size === 0) {
			recursiveWatchers.delete(this.rootPath);
			watcherCount--;
			if (this.watcher) this.watcher.close();
			if (recursiveWatcherLogging) {
				process.stderr.write(
					`[watchpack] closed recursive watcher at ${this.rootPath***REMOVED***\n`
				);
			***REMOVED***
		***REMOVED***
	***REMOVED***

	getWatchers() {
		return this.mapWatcherToPath;
	***REMOVED***
***REMOVED***

class Watcher extends EventEmitter {
	close() {
		if (pendingWatchers.has(this)) {
			pendingWatchers.delete(this);
			return;
		***REMOVED***
		const watcher = underlyingWatcher.get(this);
		watcher.remove(this);
		underlyingWatcher.delete(this);
	***REMOVED***
***REMOVED***

const createDirectWatcher = filePath => {
	const existing = directWatchers.get(filePath);
	if (existing !== undefined) return existing;
	const w = new DirectWatcher(filePath);
	directWatchers.set(filePath, w);
	return w;
***REMOVED***;

const createRecursiveWatcher = rootPath => {
	const existing = recursiveWatchers.get(rootPath);
	if (existing !== undefined) return existing;
	const w = new RecursiveWatcher(rootPath);
	recursiveWatchers.set(rootPath, w);
	return w;
***REMOVED***;

const execute = () => {
	/** @type {Map<string, Watcher[] | Watcher>***REMOVED*** */
	const map = new Map();
	const addWatcher = (watcher, filePath) => {
		const entry = map.get(filePath);
		if (entry === undefined) {
			map.set(filePath, watcher);
		***REMOVED*** else if (Array.isArray(entry)) {
			entry.push(watcher);
		***REMOVED*** else {
			map.set(filePath, [entry, watcher]);
		***REMOVED***
	***REMOVED***;
	for (const [watcher, filePath] of pendingWatchers) {
		addWatcher(watcher, filePath);
	***REMOVED***
	pendingWatchers.clear();

	// Fast case when we are not reaching the limit
	if (!SUPPORTS_RECURSIVE_WATCHING || watcherLimit - watcherCount >= map.size) {
		// Create watchers for all entries in the map
		for (const [filePath, entry] of map) {
			const w = createDirectWatcher(filePath);
			if (Array.isArray(entry)) {
				for (const item of entry) w.add(item);
			***REMOVED*** else {
				w.add(entry);
			***REMOVED***
		***REMOVED***
		return;
	***REMOVED***

	// Reconsider existing watchers to improving watch plan
	for (const watcher of recursiveWatchers.values()) {
		for (const [w, subpath] of watcher.getWatchers()) {
			addWatcher(w, path.join(watcher.rootPath, subpath));
		***REMOVED***
	***REMOVED***
	for (const watcher of directWatchers.values()) {
		for (const w of watcher.getWatchers()) {
			addWatcher(w, watcher.filePath);
		***REMOVED***
	***REMOVED***

	// Merge map entries to keep watcher limit
	// Create a 10% buffer to be able to enter fast case more often
	const plan = reducePlan(map, watcherLimit * 0.9);

	// Update watchers for all entries in the map
	for (const [filePath, entry] of plan) {
		if (entry.size === 1) {
			for (const [watcher, filePath] of entry) {
				const w = createDirectWatcher(filePath);
				const old = underlyingWatcher.get(watcher);
				if (old === w) continue;
				w.add(watcher);
				if (old !== undefined) old.remove(watcher);
			***REMOVED***
		***REMOVED*** else {
			const filePaths = new Set(entry.values());
			if (filePaths.size > 1) {
				const w = createRecursiveWatcher(filePath);
				for (const [watcher, watcherPath] of entry) {
					const old = underlyingWatcher.get(watcher);
					if (old === w) continue;
					w.add(watcherPath, watcher);
					if (old !== undefined) old.remove(watcher);
				***REMOVED***
			***REMOVED*** else {
				for (const filePath of filePaths) {
					const w = createDirectWatcher(filePath);
					for (const watcher of entry.keys()) {
						const old = underlyingWatcher.get(watcher);
						if (old === w) continue;
						w.add(watcher);
						if (old !== undefined) old.remove(watcher);
					***REMOVED***
				***REMOVED***
			***REMOVED***
		***REMOVED***
	***REMOVED***
***REMOVED***;

exports.watch = filePath => {
	const watcher = new Watcher();
	// Find an existing watcher
	const directWatcher = directWatchers.get(filePath);
	if (directWatcher !== undefined) {
		directWatcher.add(watcher);
		return watcher;
	***REMOVED***
	let current = filePath;
	for (;;) {
		const recursiveWatcher = recursiveWatchers.get(current);
		if (recursiveWatcher !== undefined) {
			recursiveWatcher.add(filePath, watcher);
			return watcher;
		***REMOVED***
		const parent = path.dirname(current);
		if (parent === current) break;
		current = parent;
	***REMOVED***
	// Queue up watcher for creation
	pendingWatchers.set(watcher, filePath);
	if (!isBatch) execute();
	return watcher;
***REMOVED***;

exports.batch = fn => {
	isBatch = true;
	try {
		fn();
	***REMOVED*** finally {
		isBatch = false;
		execute();
	***REMOVED***
***REMOVED***;

exports.getNumberOfWatchers = () => {
	return watcherCount;
***REMOVED***;
