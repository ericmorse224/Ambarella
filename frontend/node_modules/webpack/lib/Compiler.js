/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const parseJson = require("json-parse-even-better-errors");
const asyncLib = require("neo-async");
const {
	SyncHook,
	SyncBailHook,
	AsyncParallelHook,
	AsyncSeriesHook
***REMOVED*** = require("tapable");
const { SizeOnlySource ***REMOVED*** = require("webpack-sources");
const webpack = require(".");
const Cache = require("./Cache");
const CacheFacade = require("./CacheFacade");
const ChunkGraph = require("./ChunkGraph");
const Compilation = require("./Compilation");
const ConcurrentCompilationError = require("./ConcurrentCompilationError");
const ContextModuleFactory = require("./ContextModuleFactory");
const ModuleGraph = require("./ModuleGraph");
const NormalModuleFactory = require("./NormalModuleFactory");
const RequestShortener = require("./RequestShortener");
const ResolverFactory = require("./ResolverFactory");
const Stats = require("./Stats");
const Watching = require("./Watching");
const WebpackError = require("./WebpackError");
const { Logger ***REMOVED*** = require("./logging/Logger");
const { join, dirname, mkdirp ***REMOVED*** = require("./util/fs");
const { makePathsRelative ***REMOVED*** = require("./util/identifier");
const { isSourceEqual ***REMOVED*** = require("./util/source");

/** @typedef {import("webpack-sources").Source***REMOVED*** Source */
/** @typedef {import("../declarations/WebpackOptions").EntryNormalized***REMOVED*** Entry */
/** @typedef {import("../declarations/WebpackOptions").OutputNormalized***REMOVED*** OutputOptions */
/** @typedef {import("../declarations/WebpackOptions").WatchOptions***REMOVED*** WatchOptions */
/** @typedef {import("../declarations/WebpackOptions").WebpackOptionsNormalized***REMOVED*** WebpackOptions */
/** @typedef {import("../declarations/WebpackOptions").WebpackPluginInstance***REMOVED*** WebpackPluginInstance */
/** @typedef {import("./Chunk")***REMOVED*** Chunk */
/** @typedef {import("./ChunkGraph").ModuleId***REMOVED*** ModuleId */
/** @typedef {import("./Dependency")***REMOVED*** Dependency */
/** @typedef {import("./Module")***REMOVED*** Module */
/** @typedef {import("./Module").BuildInfo***REMOVED*** BuildInfo */
/** @typedef {import("./config/target").PlatformTargetProperties***REMOVED*** PlatformTargetProperties */
/** @typedef {import("./logging/createConsoleLogger").LoggingFunction***REMOVED*** LoggingFunction */
/** @typedef {import("./util/fs").IStats***REMOVED*** IStats */
/** @typedef {import("./util/fs").InputFileSystem***REMOVED*** InputFileSystem */
/** @typedef {import("./util/fs").IntermediateFileSystem***REMOVED*** IntermediateFileSystem */
/** @typedef {import("./util/fs").OutputFileSystem***REMOVED*** OutputFileSystem */
/** @typedef {import("./util/fs").TimeInfoEntries***REMOVED*** TimeInfoEntries */
/** @typedef {import("./util/fs").WatchFileSystem***REMOVED*** WatchFileSystem */

/**
 * @typedef {object***REMOVED*** CompilationParams
 * @property {NormalModuleFactory***REMOVED*** normalModuleFactory
 * @property {ContextModuleFactory***REMOVED*** contextModuleFactory
 */

/**
 * @template T
 * @callback RunCallback
 * @param {Error | null***REMOVED*** err
 * @param {T=***REMOVED*** result
 */

/**
 * @template T
 * @callback Callback
 * @param {(Error | null)=***REMOVED*** err
 * @param {T=***REMOVED*** result
 */

/**
 * @callback RunAsChildCallback
 * @param {Error | null***REMOVED*** err
 * @param {Chunk[]=***REMOVED*** entries
 * @param {Compilation=***REMOVED*** compilation
 */

/**
 * @typedef {object***REMOVED*** AssetEmittedInfo
 * @property {Buffer***REMOVED*** content
 * @property {Source***REMOVED*** source
 * @property {Compilation***REMOVED*** compilation
 * @property {string***REMOVED*** outputPath
 * @property {string***REMOVED*** targetPath
 */

/** @typedef {{ sizeOnlySource: SizeOnlySource | undefined, writtenTo: Map<string, number> ***REMOVED******REMOVED*** CacheEntry */
/** @typedef {{ path: string, source: Source, size: number | undefined, waiting: ({ cacheEntry: CacheEntry, file: string ***REMOVED***[] | undefined) ***REMOVED******REMOVED*** SimilarEntry */

/** @typedef {WeakMap<Dependency, Module>***REMOVED*** WeakReferences */
/** @typedef {import("./util/WeakTupleMap")<EXPECTED_ANY[], EXPECTED_ANY>***REMOVED*** MemCache */
/** @typedef {{ buildInfo: BuildInfo, references: WeakReferences | undefined, memCache: MemCache ***REMOVED******REMOVED*** ModuleMemCachesItem */

/**
 * @param {string[]***REMOVED*** array an array
 * @returns {boolean***REMOVED*** true, if the array is sorted
 */
const isSorted = array => {
	for (let i = 1; i < array.length; i++) {
		if (array[i - 1] > array[i]) return false;
	***REMOVED***
	return true;
***REMOVED***;

/**
 * @template {object***REMOVED*** T
 * @param {T***REMOVED*** obj an object
 * @param {(keyof T)[]***REMOVED*** keys the keys of the object
 * @returns {T***REMOVED*** the object with properties sorted by property name
 */
const sortObject = (obj, keys) => {
	const o = /** @type {T***REMOVED*** */ ({***REMOVED***);
	for (const k of keys.sort()) {
		o[k] = obj[k];
	***REMOVED***
	return o;
***REMOVED***;

/**
 * @param {string***REMOVED*** filename filename
 * @param {string | string[] | undefined***REMOVED*** hashes list of hashes
 * @returns {boolean***REMOVED*** true, if the filename contains any hash
 */
const includesHash = (filename, hashes) => {
	if (!hashes) return false;
	if (Array.isArray(hashes)) {
		return hashes.some(hash => filename.includes(hash));
	***REMOVED***
	return filename.includes(hashes);
***REMOVED***;

class Compiler {
	/**
	 * @param {string***REMOVED*** context the compilation path
	 * @param {WebpackOptions***REMOVED*** options options
	 */
	constructor(context, options = /** @type {WebpackOptions***REMOVED*** */ ({***REMOVED***)) {
		this.hooks = Object.freeze({
			/** @type {SyncHook<[]>***REMOVED*** */
			initialize: new SyncHook([]),

			/** @type {SyncBailHook<[Compilation], boolean | void>***REMOVED*** */
			shouldEmit: new SyncBailHook(["compilation"]),
			/** @type {AsyncSeriesHook<[Stats]>***REMOVED*** */
			done: new AsyncSeriesHook(["stats"]),
			/** @type {SyncHook<[Stats]>***REMOVED*** */
			afterDone: new SyncHook(["stats"]),
			/** @type {AsyncSeriesHook<[]>***REMOVED*** */
			additionalPass: new AsyncSeriesHook([]),
			/** @type {AsyncSeriesHook<[Compiler]>***REMOVED*** */
			beforeRun: new AsyncSeriesHook(["compiler"]),
			/** @type {AsyncSeriesHook<[Compiler]>***REMOVED*** */
			run: new AsyncSeriesHook(["compiler"]),
			/** @type {AsyncSeriesHook<[Compilation]>***REMOVED*** */
			emit: new AsyncSeriesHook(["compilation"]),
			/** @type {AsyncSeriesHook<[string, AssetEmittedInfo]>***REMOVED*** */
			assetEmitted: new AsyncSeriesHook(["file", "info"]),
			/** @type {AsyncSeriesHook<[Compilation]>***REMOVED*** */
			afterEmit: new AsyncSeriesHook(["compilation"]),

			/** @type {SyncHook<[Compilation, CompilationParams]>***REMOVED*** */
			thisCompilation: new SyncHook(["compilation", "params"]),
			/** @type {SyncHook<[Compilation, CompilationParams]>***REMOVED*** */
			compilation: new SyncHook(["compilation", "params"]),
			/** @type {SyncHook<[NormalModuleFactory]>***REMOVED*** */
			normalModuleFactory: new SyncHook(["normalModuleFactory"]),
			/** @type {SyncHook<[ContextModuleFactory]>***REMOVED***  */
			contextModuleFactory: new SyncHook(["contextModuleFactory"]),

			/** @type {AsyncSeriesHook<[CompilationParams]>***REMOVED*** */
			beforeCompile: new AsyncSeriesHook(["params"]),
			/** @type {SyncHook<[CompilationParams]>***REMOVED*** */
			compile: new SyncHook(["params"]),
			/** @type {AsyncParallelHook<[Compilation]>***REMOVED*** */
			make: new AsyncParallelHook(["compilation"]),
			/** @type {AsyncParallelHook<[Compilation]>***REMOVED*** */
			finishMake: new AsyncSeriesHook(["compilation"]),
			/** @type {AsyncSeriesHook<[Compilation]>***REMOVED*** */
			afterCompile: new AsyncSeriesHook(["compilation"]),

			/** @type {AsyncSeriesHook<[]>***REMOVED*** */
			readRecords: new AsyncSeriesHook([]),
			/** @type {AsyncSeriesHook<[]>***REMOVED*** */
			emitRecords: new AsyncSeriesHook([]),

			/** @type {AsyncSeriesHook<[Compiler]>***REMOVED*** */
			watchRun: new AsyncSeriesHook(["compiler"]),
			/** @type {SyncHook<[Error]>***REMOVED*** */
			failed: new SyncHook(["error"]),
			/** @type {SyncHook<[string | null, number]>***REMOVED*** */
			invalid: new SyncHook(["filename", "changeTime"]),
			/** @type {SyncHook<[]>***REMOVED*** */
			watchClose: new SyncHook([]),
			/** @type {AsyncSeriesHook<[]>***REMOVED*** */
			shutdown: new AsyncSeriesHook([]),

			/** @type {SyncBailHook<[string, string, EXPECTED_ANY[] | undefined], true | void>***REMOVED*** */
			infrastructureLog: new SyncBailHook(["origin", "type", "args"]),

			// TODO the following hooks are weirdly located here
			// TODO move them for webpack 5
			/** @type {SyncHook<[]>***REMOVED*** */
			environment: new SyncHook([]),
			/** @type {SyncHook<[]>***REMOVED*** */
			afterEnvironment: new SyncHook([]),
			/** @type {SyncHook<[Compiler]>***REMOVED*** */
			afterPlugins: new SyncHook(["compiler"]),
			/** @type {SyncHook<[Compiler]>***REMOVED*** */
			afterResolvers: new SyncHook(["compiler"]),
			/** @type {SyncBailHook<[string, Entry], boolean | void>***REMOVED*** */
			entryOption: new SyncBailHook(["context", "entry"])
		***REMOVED***);

		this.webpack = webpack;

		/** @type {string | undefined***REMOVED*** */
		this.name = undefined;
		/** @type {Compilation | undefined***REMOVED*** */
		this.parentCompilation = undefined;
		/** @type {Compiler***REMOVED*** */
		this.root = this;
		/** @type {string***REMOVED*** */
		this.outputPath = "";
		/** @type {Watching | undefined***REMOVED*** */
		this.watching = undefined;

		/** @type {OutputFileSystem | null***REMOVED*** */
		this.outputFileSystem = null;
		/** @type {IntermediateFileSystem | null***REMOVED*** */
		this.intermediateFileSystem = null;
		/** @type {InputFileSystem | null***REMOVED*** */
		this.inputFileSystem = null;
		/** @type {WatchFileSystem | null***REMOVED*** */
		this.watchFileSystem = null;

		/** @type {string|null***REMOVED*** */
		this.recordsInputPath = null;
		/** @type {string|null***REMOVED*** */
		this.recordsOutputPath = null;
		/** @type {Record<string, TODO>***REMOVED*** */
		this.records = {***REMOVED***;
		/** @type {Set<string | RegExp>***REMOVED*** */
		this.managedPaths = new Set();
		/** @type {Set<string | RegExp>***REMOVED*** */
		this.unmanagedPaths = new Set();
		/** @type {Set<string | RegExp>***REMOVED*** */
		this.immutablePaths = new Set();

		/** @type {ReadonlySet<string> | undefined***REMOVED*** */
		this.modifiedFiles = undefined;
		/** @type {ReadonlySet<string> | undefined***REMOVED*** */
		this.removedFiles = undefined;
		/** @type {TimeInfoEntries | undefined***REMOVED*** */
		this.fileTimestamps = undefined;
		/** @type {TimeInfoEntries | undefined***REMOVED*** */
		this.contextTimestamps = undefined;
		/** @type {number | undefined***REMOVED*** */
		this.fsStartTime = undefined;

		/** @type {ResolverFactory***REMOVED*** */
		this.resolverFactory = new ResolverFactory();

		/** @type {LoggingFunction | undefined***REMOVED*** */
		this.infrastructureLogger = undefined;

		/** @type {Readonly<PlatformTargetProperties>***REMOVED*** */
		this.platform = {
			web: null,
			browser: null,
			webworker: null,
			node: null,
			nwjs: null,
			electron: null
		***REMOVED***;

		this.options = options;

		this.context = context;

		this.requestShortener = new RequestShortener(context, this.root);

		this.cache = new Cache();

		/** @type {Map<Module, ModuleMemCachesItem> | undefined***REMOVED*** */
		this.moduleMemCaches = undefined;

		this.compilerPath = "";

		/** @type {boolean***REMOVED*** */
		this.running = false;

		/** @type {boolean***REMOVED*** */
		this.idle = false;

		/** @type {boolean***REMOVED*** */
		this.watchMode = false;

		this._backCompat = this.options.experiments.backCompat !== false;

		/** @type {Compilation | undefined***REMOVED*** */
		this._lastCompilation = undefined;
		/** @type {NormalModuleFactory | undefined***REMOVED*** */
		this._lastNormalModuleFactory = undefined;

		/**
		 * @private
		 * @type {WeakMap<Source, CacheEntry>***REMOVED***
		 */
		this._assetEmittingSourceCache = new WeakMap();
		/**
		 * @private
		 * @type {Map<string, number>***REMOVED***
		 */
		this._assetEmittingWrittenFiles = new Map();
		/**
		 * @private
		 * @type {Set<string>***REMOVED***
		 */
		this._assetEmittingPreviousFiles = new Set();
	***REMOVED***

	/**
	 * @param {string***REMOVED*** name cache name
	 * @returns {CacheFacade***REMOVED*** the cache facade instance
	 */
	getCache(name) {
		return new CacheFacade(
			this.cache,
			`${this.compilerPath***REMOVED***${name***REMOVED***`,
			this.options.output.hashFunction
		);
	***REMOVED***

	/**
	 * @param {string | (() => string)***REMOVED*** name name of the logger, or function called once to get the logger name
	 * @returns {Logger***REMOVED*** a logger with that name
	 */
	getInfrastructureLogger(name) {
		if (!name) {
			throw new TypeError(
				"Compiler.getInfrastructureLogger(name) called without a name"
			);
		***REMOVED***
		return new Logger(
			(type, args) => {
				if (typeof name === "function") {
					name = name();
					if (!name) {
						throw new TypeError(
							"Compiler.getInfrastructureLogger(name) called with a function not returning a name"
						);
					***REMOVED***
				***REMOVED***
				if (
					this.hooks.infrastructureLog.call(name, type, args) === undefined &&
					this.infrastructureLogger !== undefined
				) {
					this.infrastructureLogger(name, type, args);
				***REMOVED***
			***REMOVED***,
			childName => {
				if (typeof name === "function") {
					if (typeof childName === "function") {
						return this.getInfrastructureLogger(() => {
							if (typeof name === "function") {
								name = name();
								if (!name) {
									throw new TypeError(
										"Compiler.getInfrastructureLogger(name) called with a function not returning a name"
									);
								***REMOVED***
							***REMOVED***
							if (typeof childName === "function") {
								childName = childName();
								if (!childName) {
									throw new TypeError(
										"Logger.getChildLogger(name) called with a function not returning a name"
									);
								***REMOVED***
							***REMOVED***
							return `${name***REMOVED***/${childName***REMOVED***`;
						***REMOVED***);
					***REMOVED***
					return this.getInfrastructureLogger(() => {
						if (typeof name === "function") {
							name = name();
							if (!name) {
								throw new TypeError(
									"Compiler.getInfrastructureLogger(name) called with a function not returning a name"
								);
							***REMOVED***
						***REMOVED***
						return `${name***REMOVED***/${childName***REMOVED***`;
					***REMOVED***);
				***REMOVED***
				if (typeof childName === "function") {
					return this.getInfrastructureLogger(() => {
						if (typeof childName === "function") {
							childName = childName();
							if (!childName) {
								throw new TypeError(
									"Logger.getChildLogger(name) called with a function not returning a name"
								);
							***REMOVED***
						***REMOVED***
						return `${name***REMOVED***/${childName***REMOVED***`;
					***REMOVED***);
				***REMOVED***
				return this.getInfrastructureLogger(`${name***REMOVED***/${childName***REMOVED***`);
			***REMOVED***
		);
	***REMOVED***

	// TODO webpack 6: solve this in a better way
	// e.g. move compilation specific info from Modules into ModuleGraph
	_cleanupLastCompilation() {
		if (this._lastCompilation !== undefined) {
			for (const childCompilation of this._lastCompilation.children) {
				for (const module of childCompilation.modules) {
					ChunkGraph.clearChunkGraphForModule(module);
					ModuleGraph.clearModuleGraphForModule(module);
					module.cleanupForCache();
				***REMOVED***
				for (const chunk of childCompilation.chunks) {
					ChunkGraph.clearChunkGraphForChunk(chunk);
				***REMOVED***
			***REMOVED***

			for (const module of this._lastCompilation.modules) {
				ChunkGraph.clearChunkGraphForModule(module);
				ModuleGraph.clearModuleGraphForModule(module);
				module.cleanupForCache();
			***REMOVED***
			for (const chunk of this._lastCompilation.chunks) {
				ChunkGraph.clearChunkGraphForChunk(chunk);
			***REMOVED***
			this._lastCompilation = undefined;
		***REMOVED***
	***REMOVED***

	// TODO webpack 6: solve this in a better way
	_cleanupLastNormalModuleFactory() {
		if (this._lastNormalModuleFactory !== undefined) {
			this._lastNormalModuleFactory.cleanupForCache();
			this._lastNormalModuleFactory = undefined;
		***REMOVED***
	***REMOVED***

	/**
	 * @param {WatchOptions***REMOVED*** watchOptions the watcher's options
	 * @param {RunCallback<Stats>***REMOVED*** handler signals when the call finishes
	 * @returns {Watching***REMOVED*** a compiler watcher
	 */
	watch(watchOptions, handler) {
		if (this.running) {
			return handler(new ConcurrentCompilationError());
		***REMOVED***

		this.running = true;
		this.watchMode = true;
		this.watching = new Watching(this, watchOptions, handler);
		return this.watching;
	***REMOVED***

	/**
	 * @param {RunCallback<Stats>***REMOVED*** callback signals when the call finishes
	 * @returns {void***REMOVED***
	 */
	run(callback) {
		if (this.running) {
			return callback(new ConcurrentCompilationError());
		***REMOVED***

		/** @type {Logger | undefined***REMOVED*** */
		let logger;

		/**
		 * @param {Error | null***REMOVED*** err error
		 * @param {Stats=***REMOVED*** stats stats
		 */
		const finalCallback = (err, stats) => {
			if (logger) logger.time("beginIdle");
			this.idle = true;
			this.cache.beginIdle();
			this.idle = true;
			if (logger) logger.timeEnd("beginIdle");
			this.running = false;
			if (err) {
				this.hooks.failed.call(err);
			***REMOVED***
			if (callback !== undefined) callback(err, stats);
			this.hooks.afterDone.call(/** @type {Stats***REMOVED*** */ (stats));
		***REMOVED***;

		const startTime = Date.now();

		this.running = true;

		/**
		 * @param {Error | null***REMOVED*** err error
		 * @param {Compilation=***REMOVED*** _compilation compilation
		 * @returns {void***REMOVED***
		 */
		const onCompiled = (err, _compilation) => {
			if (err) return finalCallback(err);

			const compilation = /** @type {Compilation***REMOVED*** */ (_compilation);

			if (this.hooks.shouldEmit.call(compilation) === false) {
				compilation.startTime = startTime;
				compilation.endTime = Date.now();
				const stats = new Stats(compilation);
				this.hooks.done.callAsync(stats, err => {
					if (err) return finalCallback(err);
					return finalCallback(null, stats);
				***REMOVED***);
				return;
			***REMOVED***

			process.nextTick(() => {
				logger = compilation.getLogger("webpack.Compiler");
				logger.time("emitAssets");
				this.emitAssets(compilation, err => {
					/** @type {Logger***REMOVED*** */
					(logger).timeEnd("emitAssets");
					if (err) return finalCallback(err);

					if (compilation.hooks.needAdditionalPass.call()) {
						compilation.needAdditionalPass = true;

						compilation.startTime = startTime;
						compilation.endTime = Date.now();
						/** @type {Logger***REMOVED*** */
						(logger).time("done hook");
						const stats = new Stats(compilation);
						this.hooks.done.callAsync(stats, err => {
							/** @type {Logger***REMOVED*** */
							(logger).timeEnd("done hook");
							if (err) return finalCallback(err);

							this.hooks.additionalPass.callAsync(err => {
								if (err) return finalCallback(err);
								this.compile(onCompiled);
							***REMOVED***);
						***REMOVED***);
						return;
					***REMOVED***

					/** @type {Logger***REMOVED*** */
					(logger).time("emitRecords");
					this.emitRecords(err => {
						/** @type {Logger***REMOVED*** */
						(logger).timeEnd("emitRecords");
						if (err) return finalCallback(err);

						compilation.startTime = startTime;
						compilation.endTime = Date.now();
						/** @type {Logger***REMOVED*** */
						(logger).time("done hook");
						const stats = new Stats(compilation);
						this.hooks.done.callAsync(stats, err => {
							/** @type {Logger***REMOVED*** */
							(logger).timeEnd("done hook");
							if (err) return finalCallback(err);
							this.cache.storeBuildDependencies(
								compilation.buildDependencies,
								err => {
									if (err) return finalCallback(err);
									return finalCallback(null, stats);
								***REMOVED***
							);
						***REMOVED***);
					***REMOVED***);
				***REMOVED***);
			***REMOVED***);
		***REMOVED***;

		const run = () => {
			this.hooks.beforeRun.callAsync(this, err => {
				if (err) return finalCallback(err);

				this.hooks.run.callAsync(this, err => {
					if (err) return finalCallback(err);

					this.readRecords(err => {
						if (err) return finalCallback(err);

						this.compile(onCompiled);
					***REMOVED***);
				***REMOVED***);
			***REMOVED***);
		***REMOVED***;

		if (this.idle) {
			this.cache.endIdle(err => {
				if (err) return finalCallback(err);

				this.idle = false;
				run();
			***REMOVED***);
		***REMOVED*** else {
			run();
		***REMOVED***
	***REMOVED***

	/**
	 * @param {RunAsChildCallback***REMOVED*** callback signals when the call finishes
	 * @returns {void***REMOVED***
	 */
	runAsChild(callback) {
		const startTime = Date.now();

		/**
		 * @param {Error | null***REMOVED*** err error
		 * @param {Chunk[]=***REMOVED*** entries entries
		 * @param {Compilation=***REMOVED*** compilation compilation
		 */
		const finalCallback = (err, entries, compilation) => {
			try {
				callback(err, entries, compilation);
			***REMOVED*** catch (runAsChildErr) {
				const err = new WebpackError(
					`compiler.runAsChild callback error: ${runAsChildErr***REMOVED***`,
					{ cause: runAsChildErr ***REMOVED***
				);
				err.details = /** @type {Error***REMOVED*** */ (runAsChildErr).stack;
				/** @type {Compilation***REMOVED*** */
				(this.parentCompilation).errors.push(err);
			***REMOVED***
		***REMOVED***;

		this.compile((err, _compilation) => {
			if (err) return finalCallback(err);

			const compilation = /** @type {Compilation***REMOVED*** */ (_compilation);
			const parentCompilation = /** @type {Compilation***REMOVED*** */ (
				this.parentCompilation
			);

			parentCompilation.children.push(compilation);

			for (const { name, source, info ***REMOVED*** of compilation.getAssets()) {
				parentCompilation.emitAsset(name, source, info);
			***REMOVED***

			/** @type {Chunk[]***REMOVED*** */
			const entries = [];

			for (const ep of compilation.entrypoints.values()) {
				entries.push(...ep.chunks);
			***REMOVED***

			compilation.startTime = startTime;
			compilation.endTime = Date.now();

			return finalCallback(null, entries, compilation);
		***REMOVED***);
	***REMOVED***

	purgeInputFileSystem() {
		if (this.inputFileSystem && this.inputFileSystem.purge) {
			this.inputFileSystem.purge();
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Compilation***REMOVED*** compilation the compilation
	 * @param {Callback<void>***REMOVED*** callback signals when the assets are emitted
	 * @returns {void***REMOVED***
	 */
	emitAssets(compilation, callback) {
		/** @type {string***REMOVED*** */
		let outputPath;

		/**
		 * @param {Error=***REMOVED*** err error
		 * @returns {void***REMOVED***
		 */
		const emitFiles = err => {
			if (err) return callback(err);

			const assets = compilation.getAssets();
			compilation.assets = { ...compilation.assets ***REMOVED***;
			/** @type {Map<string, SimilarEntry>***REMOVED*** */
			const caseInsensitiveMap = new Map();
			/** @type {Set<string>***REMOVED*** */
			const allTargetPaths = new Set();
			asyncLib.forEachLimit(
				assets,
				15,
				({ name: file, source, info ***REMOVED***, callback) => {
					let targetFile = file;
					let immutable = info.immutable;
					const queryStringIdx = targetFile.indexOf("?");
					if (queryStringIdx >= 0) {
						targetFile = targetFile.slice(0, queryStringIdx);
						// We may remove the hash, which is in the query string
						// So we recheck if the file is immutable
						// This doesn't cover all cases, but immutable is only a performance optimization anyway
						immutable =
							immutable &&
							(includesHash(targetFile, info.contenthash) ||
								includesHash(targetFile, info.chunkhash) ||
								includesHash(targetFile, info.modulehash) ||
								includesHash(targetFile, info.fullhash));
					***REMOVED***

					/**
					 * @param {Error=***REMOVED*** err error
					 * @returns {void***REMOVED***
					 */
					const writeOut = err => {
						if (err) return callback(err);
						const targetPath = join(
							/** @type {OutputFileSystem***REMOVED*** */
							(this.outputFileSystem),
							outputPath,
							targetFile
						);
						allTargetPaths.add(targetPath);

						// check if the target file has already been written by this Compiler
						const targetFileGeneration =
							this._assetEmittingWrittenFiles.get(targetPath);

						// create an cache entry for this Source if not already existing
						let cacheEntry = this._assetEmittingSourceCache.get(source);
						if (cacheEntry === undefined) {
							cacheEntry = {
								sizeOnlySource: undefined,
								writtenTo: new Map()
							***REMOVED***;
							this._assetEmittingSourceCache.set(source, cacheEntry);
						***REMOVED***

						/** @type {SimilarEntry | undefined***REMOVED*** */
						let similarEntry;

						const checkSimilarFile = () => {
							const caseInsensitiveTargetPath = targetPath.toLowerCase();
							similarEntry = caseInsensitiveMap.get(caseInsensitiveTargetPath);
							if (similarEntry !== undefined) {
								const { path: other, source: otherSource ***REMOVED*** = similarEntry;
								if (isSourceEqual(otherSource, source)) {
									// Size may or may not be available at this point.
									// If it's not available add to "waiting" list and it will be updated once available
									if (similarEntry.size !== undefined) {
										updateWithReplacementSource(similarEntry.size);
									***REMOVED*** else {
										if (!similarEntry.waiting) similarEntry.waiting = [];
										similarEntry.waiting.push({ file, cacheEntry ***REMOVED***);
									***REMOVED***
									alreadyWritten();
								***REMOVED*** else {
									const err =
										new WebpackError(`Prevent writing to file that only differs in casing or query string from already written file.
This will lead to a race-condition and corrupted files on case-insensitive file systems.
${targetPath***REMOVED***
${other***REMOVED***`);
									err.file = file;
									callback(err);
								***REMOVED***
								return true;
							***REMOVED***
							caseInsensitiveMap.set(
								caseInsensitiveTargetPath,
								(similarEntry = /** @type {SimilarEntry***REMOVED*** */ ({
									path: targetPath,
									source,
									size: undefined,
									waiting: undefined
								***REMOVED***))
							);
							return false;
						***REMOVED***;

						/**
						 * get the binary (Buffer) content from the Source
						 * @returns {Buffer***REMOVED*** content for the source
						 */
						const getContent = () => {
							if (typeof source.buffer === "function") {
								return source.buffer();
							***REMOVED***
							const bufferOrString = source.source();
							if (Buffer.isBuffer(bufferOrString)) {
								return bufferOrString;
							***REMOVED***
							return Buffer.from(bufferOrString, "utf8");
						***REMOVED***;

						const alreadyWritten = () => {
							// cache the information that the Source has been already been written to that location
							if (targetFileGeneration === undefined) {
								const newGeneration = 1;
								this._assetEmittingWrittenFiles.set(targetPath, newGeneration);
								/** @type {CacheEntry***REMOVED*** */
								(cacheEntry).writtenTo.set(targetPath, newGeneration);
							***REMOVED*** else {
								/** @type {CacheEntry***REMOVED*** */
								(cacheEntry).writtenTo.set(targetPath, targetFileGeneration);
							***REMOVED***
							callback();
						***REMOVED***;

						/**
						 * Write the file to output file system
						 * @param {Buffer***REMOVED*** content content to be written
						 * @returns {void***REMOVED***
						 */
						const doWrite = content => {
							/** @type {OutputFileSystem***REMOVED*** */
							(this.outputFileSystem).writeFile(targetPath, content, err => {
								if (err) return callback(err);

								// information marker that the asset has been emitted
								compilation.emittedAssets.add(file);

								// cache the information that the Source has been written to that location
								const newGeneration =
									targetFileGeneration === undefined
										? 1
										: targetFileGeneration + 1;
								/** @type {CacheEntry***REMOVED*** */
								(cacheEntry).writtenTo.set(targetPath, newGeneration);
								this._assetEmittingWrittenFiles.set(targetPath, newGeneration);
								this.hooks.assetEmitted.callAsync(
									file,
									{
										content,
										source,
										outputPath,
										compilation,
										targetPath
									***REMOVED***,
									callback
								);
							***REMOVED***);
						***REMOVED***;

						/**
						 * @param {number***REMOVED*** size size
						 */
						const updateWithReplacementSource = size => {
							updateFileWithReplacementSource(
								file,
								/** @type {CacheEntry***REMOVED*** */ (cacheEntry),
								size
							);
							/** @type {SimilarEntry***REMOVED*** */
							(similarEntry).size = size;
							if (
								/** @type {SimilarEntry***REMOVED*** */ (similarEntry).waiting !== undefined
							) {
								for (const { file, cacheEntry ***REMOVED*** of /** @type {SimilarEntry***REMOVED*** */ (
									similarEntry
								).waiting) {
									updateFileWithReplacementSource(file, cacheEntry, size);
								***REMOVED***
							***REMOVED***
						***REMOVED***;

						/**
						 * @param {string***REMOVED*** file file
						 * @param {CacheEntry***REMOVED*** cacheEntry cache entry
						 * @param {number***REMOVED*** size size
						 */
						const updateFileWithReplacementSource = (
							file,
							cacheEntry,
							size
						) => {
							// Create a replacement resource which only allows to ask for size
							// This allows to GC all memory allocated by the Source
							// (expect when the Source is stored in any other cache)
							if (!cacheEntry.sizeOnlySource) {
								cacheEntry.sizeOnlySource = new SizeOnlySource(size);
							***REMOVED***
							compilation.updateAsset(file, cacheEntry.sizeOnlySource, {
								size
							***REMOVED***);
						***REMOVED***;

						/**
						 * @param {IStats***REMOVED*** stats stats
						 * @returns {void***REMOVED***
						 */
						const processExistingFile = stats => {
							// skip emitting if it's already there and an immutable file
							if (immutable) {
								updateWithReplacementSource(/** @type {number***REMOVED*** */ (stats.size));
								return alreadyWritten();
							***REMOVED***

							const content = getContent();

							updateWithReplacementSource(content.length);

							// if it exists and content on disk matches content
							// skip writing the same content again
							// (to keep mtime and don't trigger watchers)
							// for a fast negative match file size is compared first
							if (content.length === stats.size) {
								compilation.comparedForEmitAssets.add(file);
								return /** @type {OutputFileSystem***REMOVED*** */ (
									this.outputFileSystem
								).readFile(targetPath, (err, existingContent) => {
									if (
										err ||
										!content.equals(/** @type {Buffer***REMOVED*** */ (existingContent))
									) {
										return doWrite(content);
									***REMOVED***
									return alreadyWritten();
								***REMOVED***);
							***REMOVED***

							return doWrite(content);
						***REMOVED***;

						const processMissingFile = () => {
							const content = getContent();

							updateWithReplacementSource(content.length);

							return doWrite(content);
						***REMOVED***;

						// if the target file has already been written
						if (targetFileGeneration !== undefined) {
							// check if the Source has been written to this target file
							const writtenGeneration = /** @type {CacheEntry***REMOVED*** */ (
								cacheEntry
							).writtenTo.get(targetPath);
							if (writtenGeneration === targetFileGeneration) {
								// if yes, we may skip writing the file
								// if it's already there
								// (we assume one doesn't modify files while the Compiler is running, other then removing them)

								if (this._assetEmittingPreviousFiles.has(targetPath)) {
									const sizeOnlySource = /** @type {SizeOnlySource***REMOVED*** */ (
										/** @type {CacheEntry***REMOVED*** */ (cacheEntry).sizeOnlySource
									);

									// We assume that assets from the last compilation say intact on disk (they are not removed)
									compilation.updateAsset(file, sizeOnlySource, {
										size: sizeOnlySource.size()
									***REMOVED***);

									return callback();
								***REMOVED***
								// Settings immutable will make it accept file content without comparing when file exist
								immutable = true;
							***REMOVED*** else if (!immutable) {
								if (checkSimilarFile()) return;
								// We wrote to this file before which has very likely a different content
								// skip comparing and assume content is different for performance
								// This case happens often during watch mode.
								return processMissingFile();
							***REMOVED***
						***REMOVED***

						if (checkSimilarFile()) return;
						if (this.options.output.compareBeforeEmit) {
							/** @type {OutputFileSystem***REMOVED*** */
							(this.outputFileSystem).stat(targetPath, (err, stats) => {
								const exists = !err && /** @type {IStats***REMOVED*** */ (stats).isFile();

								if (exists) {
									processExistingFile(/** @type {IStats***REMOVED*** */ (stats));
								***REMOVED*** else {
									processMissingFile();
								***REMOVED***
							***REMOVED***);
						***REMOVED*** else {
							processMissingFile();
						***REMOVED***
					***REMOVED***;

					if (/\/|\\/.test(targetFile)) {
						const fs = /** @type {OutputFileSystem***REMOVED*** */ (this.outputFileSystem);
						const dir = dirname(fs, join(fs, outputPath, targetFile));
						mkdirp(fs, dir, writeOut);
					***REMOVED*** else {
						writeOut();
					***REMOVED***
				***REMOVED***,
				err => {
					// Clear map to free up memory
					caseInsensitiveMap.clear();
					if (err) {
						this._assetEmittingPreviousFiles.clear();
						return callback(err);
					***REMOVED***

					this._assetEmittingPreviousFiles = allTargetPaths;

					this.hooks.afterEmit.callAsync(compilation, err => {
						if (err) return callback(err);

						return callback();
					***REMOVED***);
				***REMOVED***
			);
		***REMOVED***;

		this.hooks.emit.callAsync(compilation, err => {
			if (err) return callback(err);
			outputPath = compilation.getPath(this.outputPath, {***REMOVED***);
			mkdirp(
				/** @type {OutputFileSystem***REMOVED*** */ (this.outputFileSystem),
				outputPath,
				emitFiles
			);
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {Callback<void>***REMOVED*** callback signals when the call finishes
	 * @returns {void***REMOVED***
	 */
	emitRecords(callback) {
		if (this.hooks.emitRecords.isUsed()) {
			if (this.recordsOutputPath) {
				asyncLib.parallel(
					[
						cb => this.hooks.emitRecords.callAsync(cb),
						this._emitRecords.bind(this)
					],
					err => callback(err)
				);
			***REMOVED*** else {
				this.hooks.emitRecords.callAsync(callback);
			***REMOVED***
		***REMOVED*** else if (this.recordsOutputPath) {
			this._emitRecords(callback);
		***REMOVED*** else {
			callback();
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Callback<void>***REMOVED*** callback signals when the call finishes
	 * @returns {void***REMOVED***
	 */
	_emitRecords(callback) {
		const writeFile = () => {
			/** @type {OutputFileSystem***REMOVED*** */
			(this.outputFileSystem).writeFile(
				/** @type {string***REMOVED*** */ (this.recordsOutputPath),
				JSON.stringify(
					this.records,
					(n, value) => {
						if (
							typeof value === "object" &&
							value !== null &&
							!Array.isArray(value)
						) {
							const keys = Object.keys(value);
							if (!isSorted(keys)) {
								return sortObject(value, keys);
							***REMOVED***
						***REMOVED***
						return value;
					***REMOVED***,
					2
				),
				callback
			);
		***REMOVED***;

		const recordsOutputPathDirectory = dirname(
			/** @type {OutputFileSystem***REMOVED*** */ (this.outputFileSystem),
			/** @type {string***REMOVED*** */ (this.recordsOutputPath)
		);
		if (!recordsOutputPathDirectory) {
			return writeFile();
		***REMOVED***
		mkdirp(
			/** @type {OutputFileSystem***REMOVED*** */ (this.outputFileSystem),
			recordsOutputPathDirectory,
			err => {
				if (err) return callback(err);
				writeFile();
			***REMOVED***
		);
	***REMOVED***

	/**
	 * @param {Callback<void>***REMOVED*** callback signals when the call finishes
	 * @returns {void***REMOVED***
	 */
	readRecords(callback) {
		if (this.hooks.readRecords.isUsed()) {
			if (this.recordsInputPath) {
				asyncLib.parallel(
					[
						cb => this.hooks.readRecords.callAsync(cb),
						this._readRecords.bind(this)
					],
					err => callback(err)
				);
			***REMOVED*** else {
				this.records = {***REMOVED***;
				this.hooks.readRecords.callAsync(callback);
			***REMOVED***
		***REMOVED*** else if (this.recordsInputPath) {
			this._readRecords(callback);
		***REMOVED*** else {
			this.records = {***REMOVED***;
			callback();
		***REMOVED***
	***REMOVED***

	/**
	 * @param {Callback<void>***REMOVED*** callback signals when the call finishes
	 * @returns {void***REMOVED***
	 */
	_readRecords(callback) {
		if (!this.recordsInputPath) {
			this.records = {***REMOVED***;
			return callback();
		***REMOVED***
		/** @type {InputFileSystem***REMOVED*** */
		(this.inputFileSystem).stat(this.recordsInputPath, err => {
			// It doesn't exist
			// We can ignore this.
			if (err) return callback();

			/** @type {InputFileSystem***REMOVED*** */
			(this.inputFileSystem).readFile(
				/** @type {string***REMOVED*** */ (this.recordsInputPath),
				(err, content) => {
					if (err) return callback(err);

					try {
						this.records = parseJson(
							/** @type {Buffer***REMOVED*** */ (content).toString("utf-8")
						);
					***REMOVED*** catch (parseErr) {
						return callback(
							new Error(
								`Cannot parse records: ${/** @type {Error***REMOVED*** */ (parseErr).message***REMOVED***`
							)
						);
					***REMOVED***

					return callback();
				***REMOVED***
			);
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {Compilation***REMOVED*** compilation the compilation
	 * @param {string***REMOVED*** compilerName the compiler's name
	 * @param {number***REMOVED*** compilerIndex the compiler's index
	 * @param {Partial<OutputOptions>=***REMOVED*** outputOptions the output options
	 * @param {WebpackPluginInstance[]=***REMOVED*** plugins the plugins to apply
	 * @returns {Compiler***REMOVED*** a child compiler
	 */
	createChildCompiler(
		compilation,
		compilerName,
		compilerIndex,
		outputOptions,
		plugins
	) {
		const childCompiler = new Compiler(this.context, {
			...this.options,
			output: {
				...this.options.output,
				...outputOptions
			***REMOVED***
		***REMOVED***);
		childCompiler.name = compilerName;
		childCompiler.outputPath = this.outputPath;
		childCompiler.inputFileSystem = this.inputFileSystem;
		childCompiler.outputFileSystem = null;
		childCompiler.resolverFactory = this.resolverFactory;
		childCompiler.modifiedFiles = this.modifiedFiles;
		childCompiler.removedFiles = this.removedFiles;
		childCompiler.fileTimestamps = this.fileTimestamps;
		childCompiler.contextTimestamps = this.contextTimestamps;
		childCompiler.fsStartTime = this.fsStartTime;
		childCompiler.cache = this.cache;
		childCompiler.compilerPath = `${this.compilerPath***REMOVED***${compilerName***REMOVED***|${compilerIndex***REMOVED***|`;
		childCompiler._backCompat = this._backCompat;

		const relativeCompilerName = makePathsRelative(
			this.context,
			compilerName,
			this.root
		);
		if (!this.records[relativeCompilerName]) {
			this.records[relativeCompilerName] = [];
		***REMOVED***
		if (this.records[relativeCompilerName][compilerIndex]) {
			childCompiler.records = this.records[relativeCompilerName][compilerIndex];
		***REMOVED*** else {
			this.records[relativeCompilerName].push((childCompiler.records = {***REMOVED***));
		***REMOVED***

		childCompiler.parentCompilation = compilation;
		childCompiler.root = this.root;
		if (Array.isArray(plugins)) {
			for (const plugin of plugins) {
				if (plugin) {
					plugin.apply(childCompiler);
				***REMOVED***
			***REMOVED***
		***REMOVED***
		for (const name in this.hooks) {
			if (
				![
					"make",
					"compile",
					"emit",
					"afterEmit",
					"invalid",
					"done",
					"thisCompilation"
				].includes(name) &&
				childCompiler.hooks[/** @type {keyof Compiler["hooks"]***REMOVED*** */ (name)]
			) {
				childCompiler.hooks[
					/** @type {keyof Compiler["hooks"]***REMOVED*** */
					(name)
				].taps =
					this.hooks[
						/** @type {keyof Compiler["hooks"]***REMOVED*** */
						(name)
					].taps.slice();
			***REMOVED***
		***REMOVED***

		compilation.hooks.childCompiler.call(
			childCompiler,
			compilerName,
			compilerIndex
		);

		return childCompiler;
	***REMOVED***

	isChild() {
		return Boolean(this.parentCompilation);
	***REMOVED***

	/**
	 * @param {CompilationParams***REMOVED*** params the compilation parameters
	 * @returns {Compilation***REMOVED*** compilation
	 */
	createCompilation(params) {
		this._cleanupLastCompilation();
		return (this._lastCompilation = new Compilation(this, params));
	***REMOVED***

	/**
	 * @param {CompilationParams***REMOVED*** params the compilation parameters
	 * @returns {Compilation***REMOVED*** the created compilation
	 */
	newCompilation(params) {
		const compilation = this.createCompilation(params);
		compilation.name = this.name;
		compilation.records = this.records;
		this.hooks.thisCompilation.call(compilation, params);
		this.hooks.compilation.call(compilation, params);
		return compilation;
	***REMOVED***

	createNormalModuleFactory() {
		this._cleanupLastNormalModuleFactory();
		const normalModuleFactory = new NormalModuleFactory({
			context: this.options.context,
			fs: /** @type {InputFileSystem***REMOVED*** */ (this.inputFileSystem),
			resolverFactory: this.resolverFactory,
			options: this.options.module,
			associatedObjectForCache: this.root,
			layers: this.options.experiments.layers
		***REMOVED***);
		this._lastNormalModuleFactory = normalModuleFactory;
		this.hooks.normalModuleFactory.call(normalModuleFactory);
		return normalModuleFactory;
	***REMOVED***

	createContextModuleFactory() {
		const contextModuleFactory = new ContextModuleFactory(this.resolverFactory);
		this.hooks.contextModuleFactory.call(contextModuleFactory);
		return contextModuleFactory;
	***REMOVED***

	newCompilationParams() {
		const params = {
			normalModuleFactory: this.createNormalModuleFactory(),
			contextModuleFactory: this.createContextModuleFactory()
		***REMOVED***;
		return params;
	***REMOVED***

	/**
	 * @param {RunCallback<Compilation>***REMOVED*** callback signals when the compilation finishes
	 * @returns {void***REMOVED***
	 */
	compile(callback) {
		const params = this.newCompilationParams();
		this.hooks.beforeCompile.callAsync(params, err => {
			if (err) return callback(err);

			this.hooks.compile.call(params);

			const compilation = this.newCompilation(params);

			const logger = compilation.getLogger("webpack.Compiler");

			logger.time("make hook");
			this.hooks.make.callAsync(compilation, err => {
				logger.timeEnd("make hook");
				if (err) return callback(err);

				logger.time("finish make hook");
				this.hooks.finishMake.callAsync(compilation, err => {
					logger.timeEnd("finish make hook");
					if (err) return callback(err);

					process.nextTick(() => {
						logger.time("finish compilation");
						compilation.finish(err => {
							logger.timeEnd("finish compilation");
							if (err) return callback(err);

							logger.time("seal compilation");
							compilation.seal(err => {
								logger.timeEnd("seal compilation");
								if (err) return callback(err);

								logger.time("afterCompile hook");
								this.hooks.afterCompile.callAsync(compilation, err => {
									logger.timeEnd("afterCompile hook");
									if (err) return callback(err);

									return callback(null, compilation);
								***REMOVED***);
							***REMOVED***);
						***REMOVED***);
					***REMOVED***);
				***REMOVED***);
			***REMOVED***);
		***REMOVED***);
	***REMOVED***

	/**
	 * @param {RunCallback<void>***REMOVED*** callback signals when the compiler closes
	 * @returns {void***REMOVED***
	 */
	close(callback) {
		if (this.watching) {
			// When there is still an active watching, close this first
			this.watching.close(err => {
				this.close(callback);
			***REMOVED***);
			return;
		***REMOVED***
		this.hooks.shutdown.callAsync(err => {
			if (err) return callback(err);
			// Get rid of reference to last compilation to avoid leaking memory
			// We can't run this._cleanupLastCompilation() as the Stats to this compilation
			// might be still in use. We try to get rid of the reference to the cache instead.
			this._lastCompilation = undefined;
			this._lastNormalModuleFactory = undefined;
			this.cache.shutdown(callback);
		***REMOVED***);
	***REMOVED***
***REMOVED***

module.exports = Compiler;
