'use strict';

var cssSelect = require('css-select');

var svgoCssSelectAdapter = require('./css-select-adapter');
var cssSelectOpts = {
  xmlMode: true,
  adapter: svgoCssSelectAdapter
***REMOVED***;

var JSAPI = module.exports = function(data, parentNode) {
    Object.assign(this, data);
    if (parentNode) {
        Object.defineProperty(this, 'parentNode', {
            writable: true,
            value: parentNode
        ***REMOVED***);
    ***REMOVED***
***REMOVED***;

/**
 * Perform a deep clone of this node.
 *
 * @return {Object***REMOVED*** element
 */
JSAPI.prototype.clone = function() {
    var node = this;
    var nodeData = {***REMOVED***;

    Object.keys(node).forEach(function(key) {
        if (key !== 'class' && key !== 'style' && key !== 'content') {
            nodeData[key] = node[key];
        ***REMOVED***
    ***REMOVED***);

    // Deep-clone node data.
    nodeData = JSON.parse(JSON.stringify(nodeData));

    // parentNode gets set to a proper object by the parent clone,
    // but it needs to be true/false now to do the right thing
    // in the constructor.
    var clonedNode = new JSAPI(nodeData, !!node.parentNode);

    if (node.class) {
        clonedNode.class = node.class.clone(clonedNode);
    ***REMOVED***
    if (node.style) {
        clonedNode.style = node.style.clone(clonedNode);
    ***REMOVED***
    if (node.content) {
        clonedNode.content = node.content.map(function(childNode) {
            var clonedChild = childNode.clone();
            clonedChild.parentNode = clonedNode;
            return clonedChild;
        ***REMOVED***);
    ***REMOVED***

    return clonedNode;
***REMOVED***;

/**
 * Determine if item is an element
 * (any, with a specific name or in a names array).
 *
 * @param {String|Array***REMOVED*** [param] element name or names arrays
 * @return {Boolean***REMOVED***
 */
JSAPI.prototype.isElem = function(param) {

    if (!param) return !!this.elem;

    if (Array.isArray(param)) return !!this.elem && (param.indexOf(this.elem) > -1);

    return !!this.elem && this.elem === param;

***REMOVED***;

/**
 * Renames an element
 *
 * @param {String***REMOVED*** name new element name
 * @return {Object***REMOVED*** element
 */
JSAPI.prototype.renameElem = function(name) {

    if (name && typeof name === 'string')
        this.elem = this.local = name;

    return this;

***REMOVED***;

/**
 * Determine if element is empty.
 *
 * @return {Boolean***REMOVED***
 */
 JSAPI.prototype.isEmpty = function() {

    return !this.content || !this.content.length;

***REMOVED***;

/**
 * Find the closest ancestor of the current element.
 * @param elemName
 *
 * @return {?Object***REMOVED***
 */
 JSAPI.prototype.closestElem = function(elemName) {
    var elem = this;

    while ((elem = elem.parentNode) && !elem.isElem(elemName));

    return elem;
***REMOVED***;

/**
 * Changes content by removing elements and/or adding new elements.
 *
 * @param {Number***REMOVED*** start Index at which to start changing the content.
 * @param {Number***REMOVED*** n Number of elements to remove.
 * @param {Array|Object***REMOVED*** [insertion] Elements to add to the content.
 * @return {Array***REMOVED*** Removed elements.
 */
 JSAPI.prototype.spliceContent = function(start, n, insertion) {

    if (arguments.length < 2) return [];

    if (!Array.isArray(insertion))
        insertion = Array.apply(null, arguments).slice(2);

    insertion.forEach(function(inner) { inner.parentNode = this ***REMOVED***, this);

    return this.content.splice.apply(this.content, [start, n].concat(insertion));


***REMOVED***;

/**
 * Determine if element has an attribute
 * (any, or by name or by name + value).
 *
 * @param {String***REMOVED*** [name] attribute name
 * @param {String***REMOVED*** [val] attribute value (will be toString()'ed)
 * @return {Boolean***REMOVED***
 */
 JSAPI.prototype.hasAttr = function(name, val) {

    if (!this.attrs || !Object.keys(this.attrs).length) return false;

    if (!arguments.length) return !!this.attrs;

    if (val !== undefined) return !!this.attrs[name] && this.attrs[name].value === val.toString();

    return !!this.attrs[name];

***REMOVED***;

/**
 * Determine if element has an attribute by local name
 * (any, or by name or by name + value).
 *
 * @param {String***REMOVED*** [localName] local attribute name
 * @param {Number|String|RegExp|Function***REMOVED*** [val] attribute value (will be toString()'ed or executed, otherwise ignored)
 * @return {Boolean***REMOVED***
 */
 JSAPI.prototype.hasAttrLocal = function(localName, val) {

    if (!this.attrs || !Object.keys(this.attrs).length) return false;

    if (!arguments.length) return !!this.attrs;

    var callback;

    switch (val != null && val.constructor && val.constructor.name) {
        case 'Number':   // same as String
        case 'String':   callback = stringValueTest; break;
        case 'RegExp':   callback = regexpValueTest; break;
        case 'Function': callback = funcValueTest; break;
        default:         callback = nameTest;
    ***REMOVED***
    return this.someAttr(callback);

    function nameTest(attr) {
        return attr.local === localName;
    ***REMOVED***

    function stringValueTest(attr) {
        return attr.local === localName && val == attr.value;
    ***REMOVED***

    function regexpValueTest(attr) {
        return attr.local === localName && val.test(attr.value);
    ***REMOVED***

    function funcValueTest(attr) {
        return attr.local === localName && val(attr.value);
    ***REMOVED***

***REMOVED***;

/**
 * Get a specific attribute from an element
 * (by name or name + value).
 *
 * @param {String***REMOVED*** name attribute name
 * @param {String***REMOVED*** [val] attribute value (will be toString()'ed)
 * @return {Object|Undefined***REMOVED***
 */
 JSAPI.prototype.attr = function(name, val) {

    if (!this.hasAttr() || !arguments.length) return undefined;

    if (val !== undefined) return this.hasAttr(name, val) ? this.attrs[name] : undefined;

    return this.attrs[name];

***REMOVED***;

/**
 * Get computed attribute value from an element
 *
 * @param {String***REMOVED*** name attribute name
 * @return {Object|Undefined***REMOVED***
 */
 JSAPI.prototype.computedAttr = function(name, val) {
    /* jshint eqnull: true */
    if (!arguments.length) return;

    for (var elem = this; elem && (!elem.hasAttr(name) || !elem.attr(name).value); elem = elem.parentNode);

    if (val != null) {
        return elem ? elem.hasAttr(name, val) : false;
    ***REMOVED*** else if (elem && elem.hasAttr(name)) {
        return elem.attrs[name].value;
    ***REMOVED***

***REMOVED***;

/**
 * Remove a specific attribute.
 *
 * @param {String|Array***REMOVED*** name attribute name
 * @param {String***REMOVED*** [val] attribute value
 * @return {Boolean***REMOVED***
 */
 JSAPI.prototype.removeAttr = function(name, val, recursive) {

    if (!arguments.length) return false;

    if (Array.isArray(name)) {
        name.forEach(this.removeAttr, this);
        return false;
    ***REMOVED***

    if (!this.hasAttr(name)) return false;

    if (!recursive && val && this.attrs[name].value !== val) return false;

    delete this.attrs[name];

    if (!Object.keys(this.attrs).length) delete this.attrs;

    return true;

***REMOVED***;

/**
 * Add attribute.
 *
 * @param {Object***REMOVED*** [attr={***REMOVED***] attribute object
 * @return {Object|Boolean***REMOVED*** created attribute or false if no attr was passed in
 */
 JSAPI.prototype.addAttr = function(attr) {
    attr = attr || {***REMOVED***;

    if (attr.name === undefined ||
        attr.prefix === undefined ||
        attr.local === undefined
    ) return false;

    this.attrs = this.attrs || {***REMOVED***;
    this.attrs[attr.name] = attr;

    if(attr.name === 'class') { // newly added class attribute
        this.class.hasClass();
    ***REMOVED***

    if(attr.name === 'style') { // newly added style attribute
        this.style.hasStyle();
    ***REMOVED***

    return this.attrs[attr.name];

***REMOVED***;

/**
 * Iterates over all attributes.
 *
 * @param {Function***REMOVED*** callback callback
 * @param {Object***REMOVED*** [context] callback context
 * @return {Boolean***REMOVED*** false if there are no any attributes
 */
 JSAPI.prototype.eachAttr = function(callback, context) {

    if (!this.hasAttr()) return false;

    for (var name in this.attrs) {
        callback.call(context, this.attrs[name]);
    ***REMOVED***

    return true;

***REMOVED***;

/**
 * Tests whether some attribute passes the test.
 *
 * @param {Function***REMOVED*** callback callback
 * @param {Object***REMOVED*** [context] callback context
 * @return {Boolean***REMOVED*** false if there are no any attributes
 */
 JSAPI.prototype.someAttr = function(callback, context) {

    if (!this.hasAttr()) return false;

    for (var name in this.attrs) {
        if (callback.call(context, this.attrs[name])) return true;
    ***REMOVED***

    return false;

***REMOVED***;

/**
 * Evaluate a string of CSS selectors against the element and returns matched elements.
 *
 * @param {String***REMOVED*** selectors CSS selector(s) string
 * @return {Array***REMOVED*** null if no elements matched
 */
 JSAPI.prototype.querySelectorAll = function(selectors) {

   var matchedEls = cssSelect(selectors, this, cssSelectOpts);

   return matchedEls.length > 0 ? matchedEls : null;

***REMOVED***;

/**
 * Evaluate a string of CSS selectors against the element and returns only the first matched element.
 *
 * @param {String***REMOVED*** selectors CSS selector(s) string
 * @return {Array***REMOVED*** null if no element matched
 */
 JSAPI.prototype.querySelector = function(selectors) {

   return cssSelect.selectOne(selectors, this, cssSelectOpts);

***REMOVED***;

/**
 * Test if a selector matches a given element.
 *
 * @param {String***REMOVED*** selector CSS selector string
 * @return {Boolean***REMOVED*** true if element would be selected by selector string, false if it does not
 */
 JSAPI.prototype.matches = function(selector) {

   return cssSelect.is(this, selector, cssSelectOpts);

***REMOVED***;
