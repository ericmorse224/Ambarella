/*
 Copyright 2012-2015, Yahoo Inc.
 Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
'use strict';

const { FileCoverage ***REMOVED*** = require('./file-coverage');
const { CoverageSummary ***REMOVED*** = require('./coverage-summary');

function maybeConstruct(obj, klass) {
    if (obj instanceof klass) {
        return obj;
    ***REMOVED***

    return new klass(obj);
***REMOVED***

function loadMap(source) {
    const data = Object.create(null);
    if (!source) {
        return data;
    ***REMOVED***

    Object.entries(source).forEach(([k, cov]) => {
        data[k] = maybeConstruct(cov, FileCoverage);
    ***REMOVED***);

    return data;
***REMOVED***

/** CoverageMap is a map of `FileCoverage` objects keyed by file paths. */
class CoverageMap {
    /**
     * @constructor
     * @param {Object***REMOVED*** [obj=undefined] obj A coverage map from which to initialize this
     * map's contents. This can be the raw global coverage object.
     */
    constructor(obj) {
        if (obj instanceof CoverageMap) {
            this.data = obj.data;
        ***REMOVED*** else {
            this.data = loadMap(obj);
        ***REMOVED***
    ***REMOVED***

    /**
     * merges a second coverage map into this one
     * @param {CoverageMap***REMOVED*** obj - a CoverageMap or its raw data. Coverage is merged
     *  correctly for the same files and additional file coverage keys are created
     *  as needed.
     */
    merge(obj) {
        const other = maybeConstruct(obj, CoverageMap);
        Object.values(other.data).forEach(fc => {
            this.addFileCoverage(fc);
        ***REMOVED***);
    ***REMOVED***

    /**
     * filter the coveragemap based on the callback provided
     * @param {Function (filename)***REMOVED*** callback - Returns true if the path
     *  should be included in the coveragemap. False if it should be
     *  removed.
     */
    filter(callback) {
        Object.keys(this.data).forEach(k => {
            if (!callback(k)) {
                delete this.data[k];
            ***REMOVED***
        ***REMOVED***);
    ***REMOVED***

    /**
     * returns a JSON-serializable POJO for this coverage map
     * @returns {Object***REMOVED***
     */
    toJSON() {
        return this.data;
    ***REMOVED***

    /**
     * returns an array for file paths for which this map has coverage
     * @returns {Array{string***REMOVED******REMOVED*** - array of files
     */
    files() {
        return Object.keys(this.data);
    ***REMOVED***

    /**
     * returns the file coverage for the specified file.
     * @param {String***REMOVED*** file
     * @returns {FileCoverage***REMOVED***
     */
    fileCoverageFor(file) {
        const fc = this.data[file];
        if (!fc) {
            throw new Error(`No file coverage available for: ${file***REMOVED***`);
        ***REMOVED***
        return fc;
    ***REMOVED***

    /**
     * adds a file coverage object to this map. If the path for the object,
     * already exists in the map, it is merged with the existing coverage
     * otherwise a new key is added to the map.
     * @param {FileCoverage***REMOVED*** fc the file coverage to add
     */
    addFileCoverage(fc) {
        const cov = new FileCoverage(fc);
        const { path ***REMOVED*** = cov;
        if (this.data[path]) {
            this.data[path].merge(cov);
        ***REMOVED*** else {
            this.data[path] = cov;
        ***REMOVED***
    ***REMOVED***

    /**
     * returns the coverage summary for all the file coverage objects in this map.
     * @returns {CoverageSummary***REMOVED***
     */
    getCoverageSummary() {
        const ret = new CoverageSummary();
        Object.values(this.data).forEach(fc => {
            ret.merge(fc.toSummary());
        ***REMOVED***);

        return ret;
    ***REMOVED***
***REMOVED***

module.exports = {
    CoverageMap
***REMOVED***;
