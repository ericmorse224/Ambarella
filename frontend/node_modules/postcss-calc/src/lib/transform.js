'use strict';
const selectorParser = require('postcss-selector-parser');
const valueParser = require('postcss-value-parser');

const { parser ***REMOVED*** = require('../parser.js');

const reducer = require('./reducer.js');
const stringifier = require('./stringifier.js');

const MATCH_CALC = /((?:-(moz|webkit)-)?calc)/i;

/**
 * @param {string***REMOVED*** value
 * @param {{precision: number, warnWhenCannotResolve: boolean***REMOVED******REMOVED*** options
 * @param {import("postcss").Result***REMOVED*** result
 * @param {import("postcss").ChildNode***REMOVED*** item
 */
function transformValue(value, options, result, item) {
  return valueParser(value)
    .walk((node) => {
      // skip anything which isn't a calc() function
      if (node.type !== 'function' || !MATCH_CALC.test(node.value)) {
        return;
      ***REMOVED***

      // stringify calc expression and produce an AST
      const contents = valueParser.stringify(node.nodes);
      const ast = parser.parse(contents);

      // reduce AST to its simplest form, that is, either to a single value
      // or a simplified calc expression
      const reducedAst = reducer(ast, options.precision);

      // stringify AST and write it back
      /** @type {valueParser.Node***REMOVED*** */ (node).type = 'word';
      node.value = stringifier(
        node.value,
        reducedAst,
        value,
        options,
        result,
        item
      );

      return false;
    ***REMOVED***)
    .toString();
***REMOVED***
/**
 * @param {import("postcss-selector-parser").Selectors***REMOVED*** value
 * @param {{precision: number, warnWhenCannotResolve: boolean***REMOVED******REMOVED*** options
 * @param {import("postcss").Result***REMOVED*** result
 * @param {import("postcss").ChildNode***REMOVED*** item
 */
function transformSelector(value, options, result, item) {
  return selectorParser((selectors) => {
    selectors.walk((node) => {
      // attribute value
      // e.g. the "calc(3*3)" part of "div[data-size="calc(3*3)"]"
      if (node.type === 'attribute' && node.value) {
        node.setValue(transformValue(node.value, options, result, item));
      ***REMOVED***

      // tag value
      // e.g. the "calc(3*3)" part of "div:nth-child(2n + calc(3*3))"
      if (node.type === 'tag') {
        node.value = transformValue(node.value, options, result, item);
      ***REMOVED***

      return;
    ***REMOVED***);
  ***REMOVED***).processSync(value);
***REMOVED***

/**
 * @param {any***REMOVED*** node
 * @param {{precision: number, preserve: boolean, warnWhenCannotResolve: boolean***REMOVED******REMOVED*** options
 * @param {'value'|'params'|'selector'***REMOVED*** property
 * @param {import("postcss").Result***REMOVED*** result
 */
module.exports = (node, property, options, result) => {
  let value = node[property];

  try {
    value =
      property === 'selector'
        ? transformSelector(node[property], options, result, node)
        : transformValue(node[property], options, result, node);
  ***REMOVED*** catch (error) {
    if (error instanceof Error) {
      result.warn(error.message, { node ***REMOVED***);
    ***REMOVED*** else {
      result.warn('Error', { node ***REMOVED***);
    ***REMOVED***
    return;
  ***REMOVED***

  // if the preserve option is enabled and the value has changed, write the
  // transformed value into a cloned node which is inserted before the current
  // node, preserving the original value. Otherwise, overwrite the original
  // value.
  if (options.preserve && node[property] !== value) {
    const clone = node.clone();
    clone[property] = value;
    node.parent.insertBefore(node, clone);
  ***REMOVED*** else {
    node[property] = value;
  ***REMOVED***
***REMOVED***;
