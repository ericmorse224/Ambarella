import { isCollection, isNode, isScalar, isSeq ***REMOVED*** from '../nodes/identity.js';
import { Scalar ***REMOVED*** from '../nodes/Scalar.js';
import { stringify ***REMOVED*** from './stringify.js';
import { lineComment, indentComment ***REMOVED*** from './stringifyComment.js';

function stringifyPair({ key, value ***REMOVED***, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys ***REMOVED*** ***REMOVED*** = ctx;
    let keyComment = (isNode(key) && key.comment) || null;
    if (simpleKeys) {
        if (keyComment) {
            throw new Error('With simple keys, key nodes cannot have comments');
        ***REMOVED***
        if (isCollection(key) || (!isNode(key) && typeof key === 'object')) {
            const msg = 'With simple keys, collection cannot be used as a key value';
            throw new Error(msg);
        ***REMOVED***
    ***REMOVED***
    let explicitKey = !simpleKeys &&
        (!key ||
            (keyComment && value == null && !ctx.inFlow) ||
            isCollection(key) ||
            (isScalar(key)
                ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL
                : typeof key === 'object'));
    ctx = Object.assign({***REMOVED***, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
    ***REMOVED***);
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
        explicitKey = true;
    ***REMOVED***
    if (ctx.inFlow) {
        if (allNullValues || value == null) {
            if (keyCommentDone && onComment)
                onComment();
            return str === '' ? '?' : explicitKey ? `? ${str***REMOVED***` : str;
        ***REMOVED***
    ***REMOVED***
    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {
        str = `? ${str***REMOVED***`;
        if (keyComment && !keyCommentDone) {
            str += lineComment(str, ctx.indent, commentString(keyComment));
        ***REMOVED***
        else if (chompKeep && onChompKeep)
            onChompKeep();
        return str;
    ***REMOVED***
    if (keyCommentDone)
        keyComment = null;
    if (explicitKey) {
        if (keyComment)
            str += lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str***REMOVED***\n${indent***REMOVED***:`;
    ***REMOVED***
    else {
        str = `${str***REMOVED***:`;
        if (keyComment)
            str += lineComment(str, ctx.indent, commentString(keyComment));
    ***REMOVED***
    let vsb, vcb, valueComment;
    if (isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
    ***REMOVED***
    else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === 'object')
            value = doc.createNode(value);
    ***REMOVED***
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && isScalar(value))
        ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq &&
        indentStep.length >= 2 &&
        !ctx.inFlow &&
        !explicitKey &&
        isSeq(value) &&
        !value.flow &&
        !value.tag &&
        !value.anchor) {
        // If indentSeq === false, consider '- ' as part of indentation where possible
        ctx.indent = ctx.indent.substring(2);
    ***REMOVED***
    let valueCommentDone = false;
    const valueStr = stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));
    let ws = ' ';
    if (keyComment || vsb || vcb) {
        ws = vsb ? '\n' : '';
        if (vcb) {
            const cs = commentString(vcb);
            ws += `\n${indentComment(cs, ctx.indent)***REMOVED***`;
        ***REMOVED***
        if (valueStr === '' && !ctx.inFlow) {
            if (ws === '\n')
                ws = '\n\n';
        ***REMOVED***
        else {
            ws += `\n${ctx.indent***REMOVED***`;
        ***REMOVED***
    ***REMOVED***
    else if (!explicitKey && isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf('\n');
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
            let hasPropsLine = false;
            if (hasNewline && (vs0 === '&' || vs0 === '!')) {
                let sp0 = valueStr.indexOf(' ');
                if (vs0 === '&' &&
                    sp0 !== -1 &&
                    sp0 < nl0 &&
                    valueStr[sp0 + 1] === '!') {
                    sp0 = valueStr.indexOf(' ', sp0 + 1);
                ***REMOVED***
                if (sp0 === -1 || nl0 < sp0)
                    hasPropsLine = true;
            ***REMOVED***
            if (!hasPropsLine)
                ws = `\n${ctx.indent***REMOVED***`;
        ***REMOVED***
    ***REMOVED***
    else if (valueStr === '' || valueStr[0] === '\n') {
        ws = '';
    ***REMOVED***
    str += ws + valueStr;
    if (ctx.inFlow) {
        if (valueCommentDone && onComment)
            onComment();
    ***REMOVED***
    else if (valueComment && !valueCommentDone) {
        str += lineComment(str, ctx.indent, commentString(valueComment));
    ***REMOVED***
    else if (chompKeep && onChompKeep) {
        onChompKeep();
    ***REMOVED***
    return str;
***REMOVED***

export { stringifyPair ***REMOVED***;
