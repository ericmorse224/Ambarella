/**
 * @fileoverview Common propTypes sorting functionality.
 */

'use strict';

const toSorted = require('array.prototype.tosorted');

const astUtil = require('./ast');
const eslintUtil = require('./eslint');

const getSourceCode = eslintUtil.getSourceCode;
const getText = eslintUtil.getText;

/**
 * Returns the value name of a node.
 *
 * @param {ASTNode***REMOVED*** node the node to check.
 * @returns {string***REMOVED*** The name of the node.
 */
function getValueName(node) {
  return node.type === 'Property'
    && node.value.property
    && node.value.property.name;
***REMOVED***

/**
 * Checks if the prop is required or not.
 *
 * @param {ASTNode***REMOVED*** node the prop to check.
 * @returns {boolean***REMOVED*** true if the prop is required.
 */
function isRequiredProp(node) {
  return getValueName(node) === 'isRequired';
***REMOVED***

/**
 * Checks if the proptype is a callback by checking if it starts with 'on'.
 *
 * @param {string***REMOVED*** propName the name of the proptype to check.
 * @returns {boolean***REMOVED*** true if the proptype is a callback.
 */
function isCallbackPropName(propName) {
  return /^on[A-Z]/.test(propName);
***REMOVED***

/**
 * Checks if the prop is PropTypes.shape.
 *
 * @param {ASTNode***REMOVED*** node the prop to check.
 * @returns {boolean***REMOVED*** true if the prop is PropTypes.shape.
 */
function isShapeProp(node) {
  return !!(
    node
    && node.callee
    && node.callee.property
    && node.callee.property.name === 'shape'
  );
***REMOVED***

/**
 * Returns the properties of a PropTypes.shape.
 *
 * @param {ASTNode***REMOVED*** node the prop to check.
 * @returns {Array***REMOVED*** the properties of the PropTypes.shape node.
 */
function getShapeProperties(node) {
  return node.arguments
    && node.arguments[0]
    && node.arguments[0].properties;
***REMOVED***

/**
 * Compares two elements.
 *
 * @param {ASTNode***REMOVED*** a the first element to compare.
 * @param {ASTNode***REMOVED*** b the second element to compare.
 * @param {Context***REMOVED*** context The context of the two nodes.
 * @param {boolean=***REMOVED*** ignoreCase whether or not to ignore case when comparing the two elements.
 * @param {boolean=***REMOVED*** requiredFirst whether or not to sort required elements first.
 * @param {boolean=***REMOVED*** callbacksLast whether or not to sort callbacks after everything else.
 * @param {boolean=***REMOVED*** noSortAlphabetically whether or not to disable alphabetical sorting of the elements.
 * @returns {number***REMOVED*** the sort order of the two elements.
 */
function sorter(a, b, context, ignoreCase, requiredFirst, callbacksLast, noSortAlphabetically) {
  const aKey = String(astUtil.getKeyValue(context, a));
  const bKey = String(astUtil.getKeyValue(context, b));

  if (requiredFirst) {
    if (isRequiredProp(a) && !isRequiredProp(b)) {
      return -1;
    ***REMOVED***
    if (!isRequiredProp(a) && isRequiredProp(b)) {
      return 1;
    ***REMOVED***
  ***REMOVED***

  if (callbacksLast) {
    if (isCallbackPropName(aKey) && !isCallbackPropName(bKey)) {
      return 1;
    ***REMOVED***
    if (!isCallbackPropName(aKey) && isCallbackPropName(bKey)) {
      return -1;
    ***REMOVED***
  ***REMOVED***

  if (!noSortAlphabetically) {
    if (ignoreCase) {
      return aKey.localeCompare(bKey);
    ***REMOVED***

    if (aKey < bKey) {
      return -1;
    ***REMOVED***
    if (aKey > bKey) {
      return 1;
    ***REMOVED***
  ***REMOVED***
  return 0;
***REMOVED***

const commentnodeMap = new WeakMap(); // all nodes reference WeakMap for start and end range

/**
 * Fixes sort order of prop types.
 *
 * @param {Context***REMOVED*** context the second element to compare.
 * @param {Fixer***REMOVED*** fixer the first element to compare.
 * @param {Array***REMOVED*** declarations The context of the two nodes.
 * @param {boolean=***REMOVED*** ignoreCase whether or not to ignore case when comparing the two elements.
 * @param {boolean=***REMOVED*** requiredFirst whether or not to sort required elements first.
 * @param {boolean=***REMOVED*** callbacksLast whether or not to sort callbacks after everything else.
 * @param {boolean=***REMOVED*** noSortAlphabetically whether or not to disable alphabetical sorting of the elements.
 * @param {boolean=***REMOVED*** sortShapeProp whether or not to sort propTypes defined in PropTypes.shape.
 * @param {boolean=***REMOVED*** checkTypes whether or not sorting of prop type definitions are checked.
 * @returns {Object|*|{range, text***REMOVED******REMOVED*** the sort order of the two elements.
 */
function fixPropTypesSort(
  context,
  fixer,
  declarations,
  ignoreCase,
  requiredFirst,
  callbacksLast,
  noSortAlphabetically,
  sortShapeProp,
  checkTypes
) {
  function sortInSource(allNodes, source) {
    const originalSource = source;
    const sourceCode = getSourceCode(context);
    for (let i = 0; i < allNodes.length; i++) {
      const node = allNodes[i];
      let commentAfter = [];
      let commentBefore = [];
      let newStart = 0;
      let newEnd = 0;
      try {
        commentBefore = sourceCode.getCommentsBefore(node);
        commentAfter = sourceCode.getCommentsAfter(node);
      ***REMOVED*** catch (e) { /**/ ***REMOVED***

      if (commentAfter.length === 0 || commentBefore.length === 0) {
        newStart = node.range[0];
        newEnd = node.range[1];
      ***REMOVED***

      const firstCommentBefore = commentBefore[0];
      if (commentBefore.length >= 1) {
        newStart = firstCommentBefore.range[0];
      ***REMOVED***
      const lastCommentAfter = commentAfter[commentAfter.length - 1];
      if (commentAfter.length >= 1) {
        newEnd = lastCommentAfter.range[1];
      ***REMOVED***
      commentnodeMap.set(node, { start: newStart, end: newEnd, hasComment: true ***REMOVED***);
    ***REMOVED***
    const nodeGroups = allNodes.reduce((acc, curr) => {
      if (curr.type === 'ExperimentalSpreadProperty' || curr.type === 'SpreadElement') {
        acc.push([]);
      ***REMOVED*** else {
        acc[acc.length - 1].push(curr);
      ***REMOVED***
      return acc;
    ***REMOVED***, [[]]);

    nodeGroups.forEach((nodes) => {
      const sortedAttributes = toSorted(
        nodes,
        (a, b) => sorter(a, b, context, ignoreCase, requiredFirst, callbacksLast, noSortAlphabetically)
      );

      const sourceCodeText = getText(context);
      let separator = '';
      source = nodes.reduceRight((acc, attr, index) => {
        const sortedAttr = sortedAttributes[index];
        const commentNode = commentnodeMap.get(sortedAttr);
        let sortedAttrText = sourceCodeText.slice(commentNode.start, commentNode.end);
        const sortedAttrTextLastChar = sortedAttrText[sortedAttrText.length - 1];
        if (!separator && [';', ','].some((allowedSep) => sortedAttrTextLastChar === allowedSep)) {
          separator = sortedAttrTextLastChar;
        ***REMOVED***
        if (sortShapeProp && isShapeProp(sortedAttr.value)) {
          const shape = getShapeProperties(sortedAttr.value);
          if (shape) {
            const attrSource = sortInSource(
              shape,
              originalSource
            );
            sortedAttrText = attrSource.slice(sortedAttr.range[0], sortedAttr.range[1]);
          ***REMOVED***
        ***REMOVED***
        const sortedAttrTextVal = checkTypes && !sortedAttrText.endsWith(separator) ? `${sortedAttrText***REMOVED***${separator***REMOVED***` : sortedAttrText;
        return `${acc.slice(0, commentnodeMap.get(attr).start)***REMOVED***${sortedAttrTextVal***REMOVED***${acc.slice(commentnodeMap.get(attr).end)***REMOVED***`;
      ***REMOVED***, source);
    ***REMOVED***);
    return source;
  ***REMOVED***

  const source = sortInSource(declarations, getText(context));

  const rangeStart = commentnodeMap.get(declarations[0]).start;
  const rangeEnd = commentnodeMap.get(declarations[declarations.length - 1]).end;
  return fixer.replaceTextRange([rangeStart, rangeEnd], source.slice(rangeStart, rangeEnd));
***REMOVED***

module.exports = {
  fixPropTypesSort,
  isCallbackPropName,
  isRequiredProp,
  isShapeProp,
***REMOVED***;
