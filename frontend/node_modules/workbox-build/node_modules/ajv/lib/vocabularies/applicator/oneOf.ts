import type {
  CodeKeywordDefinition,
  ErrorObject,
  KeywordErrorDefinition,
  AnySchema,
***REMOVED*** from "../../types"
import type {KeywordCxt***REMOVED*** from "../../compile/validate"
import {_, Name***REMOVED*** from "../../compile/codegen"
import {alwaysValidSchema***REMOVED*** from "../../compile/util"
import {SchemaCxt***REMOVED*** from "../../compile"

export type OneOfError = ErrorObject<
  "oneOf",
  {passingSchemas: [number, number] | null***REMOVED***,
  AnySchema[]
>

const error: KeywordErrorDefinition = {
  message: "must match exactly one schema in oneOf",
  params: ({params***REMOVED***) => _`{passingSchemas: ${params.passing***REMOVED******REMOVED***`,
***REMOVED***

const def: CodeKeywordDefinition = {
  keyword: "oneOf",
  schemaType: "array",
  trackErrors: true,
  error,
  code(cxt: KeywordCxt) {
    const {gen, schema, parentSchema, it***REMOVED*** = cxt
    /* istanbul ignore if */
    if (!Array.isArray(schema)) throw new Error("ajv implementation error")
    if (it.opts.discriminator && parentSchema.discriminator) return
    const schArr: AnySchema[] = schema
    const valid = gen.let("valid", false)
    const passing = gen.let("passing", null)
    const schValid = gen.name("_valid")
    cxt.setParams({passing***REMOVED***)
    // TODO possibly fail straight away (with warning or exception) if there are two empty always valid schemas

    gen.block(validateOneOf)

    cxt.result(
      valid,
      () => cxt.reset(),
      () => cxt.error(true)
    )

    function validateOneOf(): void {
      schArr.forEach((sch: AnySchema, i: number) => {
        let schCxt: SchemaCxt | undefined
        if (alwaysValidSchema(it, sch)) {
          gen.var(schValid, true)
        ***REMOVED*** else {
          schCxt = cxt.subschema(
            {
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: true,
            ***REMOVED***,
            schValid
          )
        ***REMOVED***

        if (i > 0) {
          gen
            .if(_`${schValid***REMOVED*** && ${valid***REMOVED***`)
            .assign(valid, false)
            .assign(passing, _`[${passing***REMOVED***, ${i***REMOVED***]`)
            .else()
        ***REMOVED***

        gen.if(schValid, () => {
          gen.assign(valid, true)
          gen.assign(passing, i)
          if (schCxt) cxt.mergeEvaluated(schCxt, Name)
        ***REMOVED***)
      ***REMOVED***)
    ***REMOVED***
  ***REMOVED***,
***REMOVED***

export default def
