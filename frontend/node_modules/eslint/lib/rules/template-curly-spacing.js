/**
 * @fileoverview Rule to enforce spacing around embedded expressions of template strings
 * @author Toru Nagashima
 * @deprecated in ESLint v8.53.0
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		deprecated: {
			message: "Formatting rules are being moved out of ESLint core.",
			url: "https://eslint.org/blog/2023/10/deprecating-formatting-rules/",
			deprecatedSince: "8.53.0",
			availableUntil: "10.0.0",
			replacedBy: [
				{
					message:
						"ESLint Stylistic now maintains deprecated stylistic core rules.",
					url: "https://eslint.style/guide/migration",
					plugin: {
						name: "@stylistic/eslint-plugin-js",
						url: "https://eslint.style/packages/js",
					***REMOVED***,
					rule: {
						name: "template-curly-spacing",
						url: "https://eslint.style/rules/js/template-curly-spacing",
					***REMOVED***,
				***REMOVED***,
			],
		***REMOVED***,
		type: "layout",

		docs: {
			description:
				"Require or disallow spacing around embedded expressions of template strings",
			recommended: false,
			url: "https://eslint.org/docs/latest/rules/template-curly-spacing",
		***REMOVED***,

		fixable: "whitespace",

		schema: [{ enum: ["always", "never"] ***REMOVED***],
		messages: {
			expectedBefore: "Expected space(s) before '***REMOVED***'.",
			expectedAfter: "Expected space(s) after '${'.",
			unexpectedBefore: "Unexpected space(s) before '***REMOVED***'.",
			unexpectedAfter: "Unexpected space(s) after '${'.",
		***REMOVED***,
	***REMOVED***,

	create(context) {
		const sourceCode = context.sourceCode;
		const always = context.options[0] === "always";

		/**
		 * Checks spacing before `***REMOVED***` of a given token.
		 * @param {Token***REMOVED*** token A token to check. This is a Template token.
		 * @returns {void***REMOVED***
		 */
		function checkSpacingBefore(token) {
			if (!token.value.startsWith("***REMOVED***")) {
				return; // starts with a backtick, this is the first template element in the template literal
			***REMOVED***

			const prevToken = sourceCode.getTokenBefore(token, {
					includeComments: true,
				***REMOVED***),
				hasSpace = sourceCode.isSpaceBetween(prevToken, token);

			if (!astUtils.isTokenOnSameLine(prevToken, token)) {
				return;
			***REMOVED***

			if (always && !hasSpace) {
				context.report({
					loc: {
						start: token.loc.start,
						end: {
							line: token.loc.start.line,
							column: token.loc.start.column + 1,
						***REMOVED***,
					***REMOVED***,
					messageId: "expectedBefore",
					fix: fixer => fixer.insertTextBefore(token, " "),
				***REMOVED***);
			***REMOVED***

			if (!always && hasSpace) {
				context.report({
					loc: {
						start: prevToken.loc.end,
						end: token.loc.start,
					***REMOVED***,
					messageId: "unexpectedBefore",
					fix: fixer =>
						fixer.removeRange([prevToken.range[1], token.range[0]]),
				***REMOVED***);
			***REMOVED***
		***REMOVED***

		/**
		 * Checks spacing after `${` of a given token.
		 * @param {Token***REMOVED*** token A token to check. This is a Template token.
		 * @returns {void***REMOVED***
		 */
		function checkSpacingAfter(token) {
			if (!token.value.endsWith("${")) {
				return; // ends with a backtick, this is the last template element in the template literal
			***REMOVED***

			const nextToken = sourceCode.getTokenAfter(token, {
					includeComments: true,
				***REMOVED***),
				hasSpace = sourceCode.isSpaceBetween(token, nextToken);

			if (!astUtils.isTokenOnSameLine(token, nextToken)) {
				return;
			***REMOVED***

			if (always && !hasSpace) {
				context.report({
					loc: {
						start: {
							line: token.loc.end.line,
							column: token.loc.end.column - 2,
						***REMOVED***,
						end: token.loc.end,
					***REMOVED***,
					messageId: "expectedAfter",
					fix: fixer => fixer.insertTextAfter(token, " "),
				***REMOVED***);
			***REMOVED***

			if (!always && hasSpace) {
				context.report({
					loc: {
						start: token.loc.end,
						end: nextToken.loc.start,
					***REMOVED***,
					messageId: "unexpectedAfter",
					fix: fixer =>
						fixer.removeRange([token.range[1], nextToken.range[0]]),
				***REMOVED***);
			***REMOVED***
		***REMOVED***

		return {
			TemplateElement(node) {
				const token = sourceCode.getFirstToken(node);

				checkSpacingBefore(token);
				checkSpacingAfter(token);
			***REMOVED***,
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
