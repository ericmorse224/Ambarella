/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

/**
 * @template T
 * @typedef {Record<string, string | string[] | T>***REMOVED*** Item
 */

/**
 * @template T
 * @typedef {(string | Item<T>)[] | Item<T>***REMOVED*** ContainerOptionsFormat
 */

/**
 * @template T
 * @template N
 * @param {ContainerOptionsFormat<T>***REMOVED*** options options passed by the user
 * @param {(item: string | string[], itemOrKey: string) => N***REMOVED*** normalizeSimple normalize a simple item
 * @param {(value: T, key: string) => N***REMOVED*** normalizeOptions normalize a complex item
 * @param {(item: string, normalized: N) => void***REMOVED*** fn processing function
 * @returns {void***REMOVED***
 */
const process = (options, normalizeSimple, normalizeOptions, fn) => {
	/**
	 * @param {(string | Item<T>)[]***REMOVED*** items items
	 */
	const array = items => {
		for (const item of items) {
			if (typeof item === "string") {
				fn(item, normalizeSimple(item, item));
			***REMOVED*** else if (item && typeof item === "object") {
				object(item);
			***REMOVED*** else {
				throw new Error("Unexpected options format");
			***REMOVED***
		***REMOVED***
	***REMOVED***;
	/**
	 * @param {Item<T>***REMOVED*** obj an object
	 */
	const object = obj => {
		for (const [key, value] of Object.entries(obj)) {
			if (typeof value === "string" || Array.isArray(value)) {
				fn(key, normalizeSimple(value, key));
			***REMOVED*** else {
				fn(key, normalizeOptions(value, key));
			***REMOVED***
		***REMOVED***
	***REMOVED***;
	if (!options) {
		// Do nothing
	***REMOVED*** else if (Array.isArray(options)) {
		array(options);
	***REMOVED*** else if (typeof options === "object") {
		object(options);
	***REMOVED*** else {
		throw new Error("Unexpected options format");
	***REMOVED***
***REMOVED***;

/**
 * @template T
 * @template R
 * @param {ContainerOptionsFormat<T>***REMOVED*** options options passed by the user
 * @param {(item: string | string[], itemOrKey: string) => R***REMOVED*** normalizeSimple normalize a simple item
 * @param {(value: T, key: string) => R***REMOVED*** normalizeOptions normalize a complex item
 * @returns {[string, R][]***REMOVED*** parsed options
 */
const parseOptions = (options, normalizeSimple, normalizeOptions) => {
	/** @type {[string, R][]***REMOVED*** */
	const items = [];
	process(options, normalizeSimple, normalizeOptions, (key, value) => {
		items.push([key, value]);
	***REMOVED***);
	return items;
***REMOVED***;

/**
 * @template T
 * @param {string***REMOVED*** scope scope name
 * @param {ContainerOptionsFormat<T>***REMOVED*** options options passed by the user
 * @returns {Record<string, string | string[] | T>***REMOVED*** options to spread or pass
 */
const scope = (scope, options) => {
	/** @type {Record<string, string | string[] | T>***REMOVED*** */
	const obj = {***REMOVED***;
	process(
		options,
		item => /** @type {string | string[] | T***REMOVED*** */ (item),
		item => /** @type {string | string[] | T***REMOVED*** */ (item),
		(key, value) => {
			obj[
				key.startsWith("./") ? `${scope***REMOVED***${key.slice(1)***REMOVED***` : `${scope***REMOVED***/${key***REMOVED***`
			] = value;
		***REMOVED***
	);
	return obj;
***REMOVED***;

module.exports.parseOptions = parseOptions;
module.exports.scope = scope;
