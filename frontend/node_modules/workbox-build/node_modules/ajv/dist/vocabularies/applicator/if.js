"use strict";
Object.defineProperty(exports, "__esModule", { value: true ***REMOVED***);
const codegen_1 = require("../../compile/codegen");
const util_1 = require("../../compile/util");
const error = {
    message: ({ params ***REMOVED***) => (0, codegen_1.str) `must match "${params.ifClause***REMOVED***" schema`,
    params: ({ params ***REMOVED***) => (0, codegen_1._) `{failingKeyword: ${params.ifClause***REMOVED******REMOVED***`,
***REMOVED***;
const def = {
    keyword: "if",
    schemaType: ["object", "boolean"],
    trackErrors: true,
    error,
    code(cxt) {
        const { gen, parentSchema, it ***REMOVED*** = cxt;
        if (parentSchema.then === undefined && parentSchema.else === undefined) {
            (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        ***REMOVED***
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
            return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
            const ifClause = gen.let("ifClause");
            cxt.setParams({ ifClause ***REMOVED***);
            gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        ***REMOVED***
        else if (hasThen) {
            gen.if(schValid, validateClause("then"));
        ***REMOVED***
        else {
            gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        ***REMOVED***
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
            const schCxt = cxt.subschema({
                keyword: "if",
                compositeRule: true,
                createErrors: false,
                allErrors: false,
            ***REMOVED***, schValid);
            cxt.mergeEvaluated(schCxt);
        ***REMOVED***
        function validateClause(keyword, ifClause) {
            return () => {
                const schCxt = cxt.subschema({ keyword ***REMOVED***, schValid);
                gen.assign(valid, schValid);
                cxt.mergeValidEvaluated(schCxt, valid);
                if (ifClause)
                    gen.assign(ifClause, (0, codegen_1._) `${keyword***REMOVED***`);
                else
                    cxt.setParams({ ifClause: keyword ***REMOVED***);
            ***REMOVED***;
        ***REMOVED***
    ***REMOVED***,
***REMOVED***;
function hasSchema(it, keyword) {
    const schema = it.schema[keyword];
    return schema !== undefined && !(0, util_1.alwaysValidSchema)(it, schema);
***REMOVED***
exports.default = def;
//# sourceMappingURL=if.js.map