/**
 * @fileoverview Rule to enforce that all class methods use 'this'.
 * @author Patrick Williams
 */

"use strict";

//------------------------------------------------------------------------------
// Requirements
//------------------------------------------------------------------------------

const astUtils = require("./utils/ast-utils");

//------------------------------------------------------------------------------
// Rule Definition
//------------------------------------------------------------------------------

/** @type {import('../types').Rule.RuleModule***REMOVED*** */
module.exports = {
	meta: {
		dialects: ["javascript", "typescript"],
		language: "javascript",
		type: "suggestion",

		defaultOptions: [
			{
				enforceForClassFields: true,
				exceptMethods: [],
				ignoreOverrideMethods: false,
			***REMOVED***,
		],

		docs: {
			description: "Enforce that class methods utilize `this`",
			recommended: false,
			url: "https://eslint.org/docs/latest/rules/class-methods-use-this",
		***REMOVED***,

		schema: [
			{
				type: "object",
				properties: {
					exceptMethods: {
						type: "array",
						items: {
							type: "string",
						***REMOVED***,
					***REMOVED***,
					enforceForClassFields: {
						type: "boolean",
					***REMOVED***,
					ignoreOverrideMethods: {
						type: "boolean",
					***REMOVED***,
					ignoreClassesWithImplements: {
						enum: ["all", "public-fields"],
					***REMOVED***,
				***REMOVED***,
				additionalProperties: false,
			***REMOVED***,
		],

		messages: {
			missingThis: "Expected 'this' to be used by class {{name***REMOVED******REMOVED***.",
		***REMOVED***,
	***REMOVED***,
	create(context) {
		const [options] = context.options;
		const {
			enforceForClassFields,
			ignoreOverrideMethods,
			ignoreClassesWithImplements,
		***REMOVED*** = options;
		const exceptMethods = new Set(options.exceptMethods);

		const stack = [];

		/**
		 * Push `this` used flag initialized with `false` onto the stack.
		 * @returns {void***REMOVED***
		 */
		function pushContext() {
			stack.push(false);
		***REMOVED***

		/**
		 * Pop `this` used flag from the stack.
		 * @returns {boolean | undefined***REMOVED*** `this` used flag
		 */
		function popContext() {
			return stack.pop();
		***REMOVED***

		/**
		 * Initializes the current context to false and pushes it onto the stack.
		 * These booleans represent whether 'this' has been used in the context.
		 * @returns {void***REMOVED***
		 * @private
		 */
		function enterFunction() {
			pushContext();
		***REMOVED***

		/**
		 * Check if the node is an instance method
		 * @param {ASTNode***REMOVED*** node node to check
		 * @returns {boolean***REMOVED*** True if its an instance method
		 * @private
		 */
		function isInstanceMethod(node) {
			switch (node.type) {
				case "MethodDefinition":
					return !node.static && node.kind !== "constructor";
				case "PropertyDefinition":
					return !node.static && enforceForClassFields;
				default:
					return false;
			***REMOVED***
		***REMOVED***

		/**
		 * Check if the node's parent class implements any interfaces
		 * @param {ASTNode***REMOVED*** node node to check
		 * @returns {boolean***REMOVED*** True if parent class implements interfaces
		 * @private
		 */
		function hasImplements(node) {
			const classNode = node.parent.parent;
			return (
				classNode?.type === "ClassDeclaration" &&
				classNode.implements?.length > 0
			);
		***REMOVED***

		/**
		 * Check if the node is an instance method not excluded by config
		 * @param {ASTNode***REMOVED*** node node to check
		 * @returns {boolean***REMOVED*** True if it is an instance method, and not excluded by config
		 * @private
		 */
		function isIncludedInstanceMethod(node) {
			if (isInstanceMethod(node)) {
				if (node.computed) {
					return true;
				***REMOVED***

				if (ignoreOverrideMethods && node.override) {
					return false;
				***REMOVED***

				if (ignoreClassesWithImplements) {
					const implementsInterfaces = hasImplements(node);
					if (implementsInterfaces) {
						if (
							ignoreClassesWithImplements === "all" ||
							(ignoreClassesWithImplements === "public-fields" &&
								node.key.type !== "PrivateIdentifier" &&
								(!node.accessibility ||
									node.accessibility === "public"))
						) {
							return false;
						***REMOVED***
					***REMOVED***
				***REMOVED***

				const hashIfNeeded =
					node.key.type === "PrivateIdentifier" ? "#" : "";
				const name =
					node.key.type === "Literal"
						? astUtils.getStaticStringValue(node.key)
						: node.key.name || "";

				return !exceptMethods.has(hashIfNeeded + name);
			***REMOVED***
			return false;
		***REMOVED***

		/**
		 * Checks if we are leaving a function that is a method, and reports if 'this' has not been used.
		 * Static methods and the constructor are exempt.
		 * Then pops the context off the stack.
		 * @param {ASTNode***REMOVED*** node A function node that was entered.
		 * @returns {void***REMOVED***
		 * @private
		 */
		function exitFunction(node) {
			const methodUsesThis = popContext();

			if (isIncludedInstanceMethod(node.parent) && !methodUsesThis) {
				context.report({
					node,
					loc: astUtils.getFunctionHeadLoc(node, context.sourceCode),
					messageId: "missingThis",
					data: {
						name: astUtils.getFunctionNameWithKind(node),
					***REMOVED***,
				***REMOVED***);
			***REMOVED***
		***REMOVED***

		/**
		 * Mark the current context as having used 'this'.
		 * @returns {void***REMOVED***
		 * @private
		 */
		function markThisUsed() {
			if (stack.length) {
				stack[stack.length - 1] = true;
			***REMOVED***
		***REMOVED***

		return {
			FunctionDeclaration: enterFunction,
			"FunctionDeclaration:exit": exitFunction,
			FunctionExpression: enterFunction,
			"FunctionExpression:exit": exitFunction,

			/*
			 * Class field value are implicit functions.
			 */
			"PropertyDefinition > *.key:exit": pushContext,
			"PropertyDefinition:exit": popContext,

			/*
			 * Class static blocks are implicit functions. They aren't required to use `this`,
			 * but we have to push context so that it captures any use of `this` in the static block
			 * separately from enclosing contexts, because static blocks have their own `this` and it
			 * shouldn't count as used `this` in enclosing contexts.
			 */
			StaticBlock: pushContext,
			"StaticBlock:exit": popContext,

			ThisExpression: markThisUsed,
			Super: markThisUsed,
			...(enforceForClassFields && {
				"PropertyDefinition > ArrowFunctionExpression.value":
					enterFunction,
				"PropertyDefinition > ArrowFunctionExpression.value:exit":
					exitFunction,
			***REMOVED***),
		***REMOVED***;
	***REMOVED***,
***REMOVED***;
