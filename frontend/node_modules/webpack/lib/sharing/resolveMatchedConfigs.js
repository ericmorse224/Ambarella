/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

"use strict";

const ModuleNotFoundError = require("../ModuleNotFoundError");
const LazySet = require("../util/LazySet");

/** @typedef {import("../Compilation")***REMOVED*** Compilation */
/** @typedef {import("../ResolverFactory").ResolveOptionsWithDependencyType***REMOVED*** ResolveOptionsWithDependencyType */

/**
 * @template T
 * @typedef {object***REMOVED*** MatchedConfigs
 * @property {Map<string, T>***REMOVED*** resolved
 * @property {Map<string, T>***REMOVED*** unresolved
 * @property {Map<string, T>***REMOVED*** prefixed
 */

/** @type {ResolveOptionsWithDependencyType***REMOVED*** */
const RESOLVE_OPTIONS = { dependencyType: "esm" ***REMOVED***;

/**
 * @template T
 * @param {Compilation***REMOVED*** compilation the compilation
 * @param {[string, T][]***REMOVED*** configs to be processed configs
 * @returns {Promise<MatchedConfigs<T>>***REMOVED*** resolved matchers
 */
module.exports.resolveMatchedConfigs = (compilation, configs) => {
	/** @type {Map<string, T>***REMOVED*** */
	const resolved = new Map();
	/** @type {Map<string, T>***REMOVED*** */
	const unresolved = new Map();
	/** @type {Map<string, T>***REMOVED*** */
	const prefixed = new Map();
	const resolveContext = {
		/** @type {LazySet<string>***REMOVED*** */
		fileDependencies: new LazySet(),
		/** @type {LazySet<string>***REMOVED*** */
		contextDependencies: new LazySet(),
		/** @type {LazySet<string>***REMOVED*** */
		missingDependencies: new LazySet()
	***REMOVED***;
	const resolver = compilation.resolverFactory.get("normal", RESOLVE_OPTIONS);
	const context = compilation.compiler.context;

	return Promise.all(
		// eslint-disable-next-line array-callback-return
		configs.map(([request, config]) => {
			if (/^\.\.?(\/|$)/.test(request)) {
				// relative request
				return new Promise(resolve => {
					resolver.resolve(
						{***REMOVED***,
						context,
						request,
						resolveContext,
						(err, result) => {
							if (err || result === false) {
								err = err || new Error(`Can't resolve ${request***REMOVED***`);
								compilation.errors.push(
									new ModuleNotFoundError(null, err, {
										name: `shared module ${request***REMOVED***`
									***REMOVED***)
								);
								return resolve(null);
							***REMOVED***
							resolved.set(/** @type {string***REMOVED*** */ (result), config);
							resolve(null);
						***REMOVED***
					);
				***REMOVED***);
			***REMOVED*** else if (/^(\/|[A-Za-z]:\\|\\\\)/.test(request)) {
				// absolute path
				resolved.set(request, config);
			***REMOVED*** else if (request.endsWith("/")) {
				// module request prefix
				prefixed.set(request, config);
			***REMOVED*** else {
				// module request
				unresolved.set(request, config);
			***REMOVED***
		***REMOVED***)
	).then(() => {
		compilation.contextDependencies.addAll(resolveContext.contextDependencies);
		compilation.fileDependencies.addAll(resolveContext.fileDependencies);
		compilation.missingDependencies.addAll(resolveContext.missingDependencies);
		return { resolved, unresolved, prefixed ***REMOVED***;
	***REMOVED***);
***REMOVED***;
